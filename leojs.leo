<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20201209145256.1"><vh>Startup</vh>
<v t="ekr.20201214084854.1"><vh>@file scripts.txt</vh></v>
</v>
<v t="felix.20201208214250.2"><vh>Documentation</vh>
<v t="felix.20201208214319.1"><vh>@clean README.md</vh></v>
<v t="felix.20201208214506.1"><vh>@clean CHANGELOG.md</vh></v>
<v t="felix.20201208224703.1"><vh>@clean CONTRIBUTING.md</vh></v>
</v>
<v t="ekr.20201209145358.1"><vh>VSCode extension</vh>
<v t="felix.20211007213344.1"><vh>@clean src/config.ts</vh>
<v t="felix.20211007213344.2"><vh>class Config</vh>
<v t="felix.20211007213344.3"><vh>getConfig</vh></v>
<v t="felix.20211007213344.4"><vh>getFontConfig</vh></v>
<v t="felix.20211007213344.5"><vh>setLeojsSettings</vh></v>
<v t="felix.20211007213344.6"><vh>setFontConfig</vh></v>
<v t="felix.20211007213344.7"><vh>setEnablePreview</vh></v>
<v t="felix.20211007213344.8"><vh>clearCloseEmptyGroups</vh></v>
<v t="felix.20211007213344.10"><vh>checkEnablePreview</vh></v>
<v t="felix.20211007213344.11"><vh>checkCloseEmptyGroups</vh></v>
<v t="felix.20211007213344.13"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20201214151326.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20201214151326.2"><vh>class Constants</vh>
<v t="felix.20201214151326.3"><vh>general constants</vh></v>
<v t="felix.20201214151326.4"><vh>workbench interface panels</vh></v>
<v t="felix.20201214151326.5"><vh>user messages</vh></v>
<v t="felix.20211008004139.1"><vh>find panel ids</vh></v>
<v t="felix.20201214151326.6"><vh>at-buttons strings</vh></v>
<v t="felix.20211007214102.1"><vh>configuration keys</vh></v>
<v t="felix.20211007214110.1"><vh>config defaults</vh></v>
<v t="felix.20201214151326.7"><vh>ask/save buttons</vh></v>
<v t="felix.20201214151326.8"><vh>context flags</vh></v>
<v t="felix.20201214151326.9"><vh>vscode commands</vh></v>
<v t="felix.20220923003944.1"><vh>body language code strings</vh></v>
<v t="felix.20201214151326.10"><vh>commands strings</vh></v>
<v t="felix.20201214151326.11"><vh>leo commands</vh></v>
<v t="felix.20221009233703.1"><vh>keep-selection old position offsets</vh></v>
<v t="felix.20220103222715.1"><vh>minibuffer overridden names</vh></v>
<v t="felix.20211208011642.1"><vh>minibuffer overridden commands</vh></v>
</v>
</v>
<v t="felix.20201208214322.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20201214150149.1"><vh>activate</vh></v>
<v t="felix.20221005002719.1"><vh>setStartupDoneContext</vh></v>
<v t="felix.20220523151725.1"><vh>setScheme</vh></v>
<v t="felix.20220523140004.1"><vh>runLeo</vh></v>
<v t="felix.20201208215619.1"><vh>deactivate</vh></v>
<v t="felix.20221002011858.1"><vh>closeLeoTextEditors</vh></v>
<v t="felix.20221002011903.1"><vh>showWelcomeIfNewer</vh></v>
</v>
<v t="felix.20211010192923.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20211010192923.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20211010192923.3"><vh>setBodyTime</vh></v>
<v t="felix.20221130233817.1"><vh>setOpenedBodyTime</vh></v>
<v t="felix.20211010192923.4"><vh>fireRefreshFile</vh></v>
<v t="felix.20211010192923.5"><vh>refreshPossibleGnxList</vh></v>
<v t="felix.20211010192923.6"><vh>watch</vh></v>
<v t="felix.20211010192923.7"><vh>stat</vh></v>
<v t="felix.20211010192923.8"><vh>readFile</vh></v>
<v t="felix.20211010192923.9"><vh>readDirectory</vh></v>
<v t="felix.20211010192923.10"><vh>createDirectory</vh></v>
<v t="felix.20211010192923.11"><vh>writeFile</vh></v>
<v t="felix.20211010192923.12"><vh>rename</vh></v>
<v t="felix.20211010192923.13"><vh>delete</vh></v>
<v t="felix.20211010192923.14"><vh>copy</vh></v>
<v t="felix.20211010192923.15"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20201208223553.1"><vh>@clean src/leoOutline.ts</vh>
<v t="felix.20201209011931.1"><vh>class LeoOutlineProvider</vh>
<v t="felix.20201209011931.2"><vh>constructor</vh></v>
<v t="felix.20201209011931.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20211003223641.1"><vh>buildId</vh></v>
<v t="felix.20211003233639.1"><vh>incTreeId</vh></v>
<v t="felix.20201209011931.4"><vh>getTreeItem</vh></v>
<v t="felix.20201209011931.5"><vh>getChildren</vh></v>
<v t="felix.20201209011931.6"><vh>getParent</vh></v>
<v t="felix.20220519232002.1"><vh>resolveTreeItem</vh></v>
</v>
<v t="felix.20211201001847.1"><vh>class LeoNode</vh></v>
</v>
<v t="felix.20201214194144.1"><vh>@clean src/leoUI.ts</vh>
<v t="felix.20201214195752.1"><vh>class LeoUI</vh>
<v t="felix.20201214194144.2"><vh>Constructor</vh></v>
<v t="felix.20220201235548.1"><vh>Finish Startup</vh></v>
<v t="felix.20220417215549.1"><vh>makeAllBindings</vh></v>
<v t="felix.20221113002623.1"><vh>showSettings</vh></v>
<v t="felix.20220920001018.1"><vh>Log Pane</vh>
<v t="felix.20220920001018.2"><vh>addLogPaneEntry</vh></v>
<v t="felix.20220920001018.3"><vh>showLogPane</vh></v>
<v t="felix.20220920001202.1"><vh>hideLogPane</vh></v>
</v>
<v t="felix.20201214194144.3"><vh>Document States</vh>
<v t="felix.20201214202058.1"><vh>_triggerGetStates</vh></v>
<v t="felix.20201227230901.1"><vh>_setupNoOpenedLeoDocument</vh></v>
<v t="felix.20201227230912.1"><vh>_setupOpenedLeoDocument</vh></v>
</v>
<v t="felix.20201214194144.5"><vh>UI Change Events</vh>
<v t="felix.20200719025231.24"><vh>_onChangeConfiguration</vh></v>
<v t="felix.20220930212953.1"><vh>_onDidOpenTextDocument</vh></v>
<v t="felix.20201214202625.1"><vh>_onChangeCollapsedState</vh></v>
<v t="felix.20201214202627.1"><vh>_onTreeViewVisibilityChanged</vh></v>
<v t="felix.20201214202631.1"><vh>_onDocTreeViewVisibilityChanged</vh></v>
<v t="felix.20201214202634.1"><vh>_onButtonsTreeViewVisibilityChanged</vh></v>
<v t="felix.20220930214434.1"><vh>_onGotoTreeViewVisibilityChanged</vh></v>
<v t="felix.20211122230343.1"><vh>_onUndosTreeViewVisibilityChanged</vh></v>
<v t="felix.20220930214530.1"><vh>_onFindViewVisibilityChanged</vh></v>
<v t="felix.20220930214929.1"><vh>_onActiveEditorChanged</vh></v>
<v t="felix.20220930214943.1"><vh>_changedTextEditorViewColumn</vh></v>
<v t="felix.20220930214948.1"><vh>_changedVisibleTextEditors</vh></v>
<v t="felix.20220930214953.1"><vh>_changedWindowState</vh></v>
<v t="felix.20220930214959.1"><vh>_onChangeEditorSelection</vh></v>
<v t="felix.20220930215005.1"><vh>_onChangeEditorScroll</vh></v>
<v t="felix.20220930215012.1"><vh>_onDocumentChanged</vh></v>
<v t="felix.20220930215020.1"><vh>setFindPanel</vh></v>
<v t="felix.20221101220727.1"><vh>refreshDesc</vh></v>
</v>
<v t="felix.20211204144931.1"><vh>Body Editing</vh>
<v t="felix.20211204144931.2"><vh>triggerBodySave</vh></v>
<v t="felix.20211204144931.3"><vh>_bodySaveSelection</vh></v>
<v t="felix.20211204144931.4"><vh>_bodySaveDocument</vh></v>
<v t="felix.20211204144931.5"><vh>_bodySaveDeactivate</vh></v>
</v>
<v t="felix.20201214194144.4"><vh>Refresh UI</vh>
<v t="felix.20220725004247.1"><vh>_setTreeViewTitle</vh></v>
<v t="felix.20201214202118.1"><vh>showOutline</vh></v>
<v t="felix.20211007232334.1"><vh>configTreeRefresh</vh></v>
<v t="felix.20201227155008.1"><vh>_setupRefresh</vh></v>
<v t="felix.20201227014627.1"><vh>_launchRefresh</vh></v>
<v t="felix.20220923001725.1"><vh>fullRefresh</vh></v>
<v t="felix.20220923001235.1"><vh>isTsStillValid</vh></v>
<v t="felix.20201222013904.1"><vh>_refreshOutline</vh></v>
<v t="felix.20220922235942.1"><vh>_revealNode</vh></v>
<v t="felix.20201229025520.1"><vh>gotSelectedNode</vh></v>
<v t="felix.20201214202123.1"><vh>_refreshDocumentsPane</vh></v>
<v t="felix.20221001002338.1"><vh>_refreshButtonsPane</vh></v>
<v t="felix.20221113221607.1"><vh>_refreshGotoPane</vh></v>
<v t="felix.20211124223735.1"><vh>_refreshUndoPane</vh></v>
</v>
<v t="felix.20220922000450.1"><vh>Body Pane Management</vh>
<v t="felix.20220922000450.2"><vh>_tryApplyNodeToBody</vh></v>
<v t="felix.20220922000450.3"><vh>_switchBody</vh></v>
<v t="felix.20220922000450.4"><vh>_locateOpenedBody</vh></v>
<v t="felix.20220922000450.5"><vh>_isBodyVisible</vh></v>
<v t="felix.20220922000450.6"><vh>_isBodyPreview</vh></v>
<v t="felix.20220922000450.7"><vh>isOutlineVisible</vh></v>
<v t="felix.20220922000450.8"><vh>_hideDeleteBody</vh></v>
<v t="felix.20220922000450.9"><vh>_checkPreviewMode</vh></v>
<v t="felix.20220922000450.10"><vh>closeBody</vh></v>
<v t="felix.20220922000450.11"><vh>cleanupBody</vh></v>
<v t="felix.20220922000450.12"><vh>showBody</vh></v>
<v t="felix.20220922000450.13"><vh>_setBodyLanguage</vh></v>
<v t="felix.20220922000450.14"><vh>refreshBodyStates</vh></v>
<v t="felix.20220922000450.15"><vh>debouncedRefreshBodyStates</vh></v>
</v>
<v t="felix.20201214194144.6"><vh>Commands</vh>
<v t="felix.20201214202749.1"><vh>selectTreeNode</vh></v>
<v t="felix.20201214202755.1"><vh>command</vh></v>
<v t="felix.20201214202757.1"><vh>minibuffer</vh></v>
<v t="felix.20221002124249.1"><vh>minibufferHistory</vh></v>
<v t="felix.20221002124535.1"><vh>_doMinibufferCommand</vh></v>
<v t="felix.20201214202759.1"><vh>editHeadline</vh></v>
<v t="felix.20201214202800.1"><vh>insertNode</vh></v>
<v t="felix.20211204181418.1"><vh>_insertAndSetHeadline</vh></v>
<v t="felix.20221108224707.1"><vh>chapterMain</vh></v>
<v t="felix.20221108224716.1"><vh>chapterSelect</vh></v>
</v>
<v t="felix.20211024012536.1"><vh>Clipboard</vh>
<v t="felix.20211212205241.1"><vh>replaceClipboardWith</vh></v>
<v t="felix.20220103203600.1"><vh>asyncGetTextFromClipboard</vh></v>
<v t="felix.20211024012523.1"><vh>getTextFromClipboard</vh></v>
</v>
<v t="felix.20220505215916.1"><vh>Nav</vh>
<v t="felix.20221206201231.1"><vh>goAnywhere</vh></v>
<v t="felix.20220505215916.2"><vh>findQuick</vh></v>
<v t="felix.20220505215916.3"><vh>findQuickSelected</vh></v>
<v t="felix.20220505215916.4"><vh>findQuickTimeline</vh></v>
<v t="felix.20220505215916.5"><vh>findQuickChanged</vh></v>
<v t="felix.20220505215916.6"><vh>findQuickHistory</vh></v>
<v t="felix.20220505215916.7"><vh>findQuick_marked</vh></v>
<v t="felix.20220505215916.8"><vh>showGotoPane</vh></v>
<v t="felix.20220505215916.9"><vh>gotoNavEntry</vh></v>
<v t="felix.20221027155905.1"><vh>navigateNavEntry</vh></v>
</v>
<v t="felix.20220505215924.1"><vh>Search</vh>
<v t="felix.20220505215924.2"><vh>navEnter</vh></v>
<v t="felix.20220505215924.3"><vh>navTextChange</vh></v>
<v t="felix.20220505215924.4"><vh>startSearch</vh></v>
<v t="felix.20220930222931.1"><vh>checkForceFindFocus</vh></v>
<v t="felix.20220505215924.6"><vh>_inputFindPattern</vh></v>
<v t="felix.20220505215924.7"><vh>find</vh></v>
<v t="felix.20220505215924.8"><vh>findSymbol</vh></v>
<v t="felix.20220505215924.9"><vh>replace &amp; replaceThenFind</vh></v>
<v t="felix.20220505215924.10"><vh>findAll &amp; replaceAll</vh></v>
<v t="felix.20220505215924.11"><vh>cloneFind</vh></v>
<v t="felix.20220505215924.12"><vh>setSearchOption</vh></v>
<v t="felix.20220505215924.13"><vh>loadSearchSettings</vh></v>
<v t="felix.20220505215924.14"><vh>saveSearchSettings</vh></v>
<v t="felix.20220505215924.15"><vh>gotoGlobalLine</vh></v>
<v t="felix.20220505215924.16"><vh>tagChildren</vh></v>
<v t="felix.20220505215924.17"><vh>tag_node</vh></v>
<v t="felix.20220505215924.18"><vh>remove_tag</vh></v>
<v t="felix.20220505215924.19"><vh>remove_tags</vh></v>
<v t="felix.20220505215924.20"><vh>cloneFindTag</vh></v>
</v>
<v t="felix.20201214194144.8"><vh>Leo Documents</vh>
<v t="felix.20220930215434.1"><vh>setDocumentSelection</vh></v>
<v t="felix.20220517002104.1"><vh>newLeoFile</vh></v>
<v t="felix.20201214211830.1"><vh>closeLeoFile</vh></v>
<v t="felix.20201214211832.1"><vh>openLeoFile</vh></v>
<v t="felix.20201214211834.1"><vh>showRecentLeoFiles</vh></v>
<v t="felix.20201214211835.1"><vh>saveAsLeoFile</vh></v>
<v t="felix.20211012233514.1"><vh>saveAsLeoJsFile</vh></v>
<v t="felix.20201214211836.1"><vh>saveLeoFile</vh></v>
<v t="felix.20201214211837.1"><vh>switchLeoFile</vh></v>
<v t="felix.20201214211839.1"><vh>selectOpenedLeoDocument</vh></v>
</v>
<v t="felix.20221114222048.1"><vh>Export/Import Commands</vh>
<v t="felix.20221114222048.2"><vh>importFile</vh></v>
<v t="felix.20221114222048.3"><vh>exportHeadlines</vh></v>
<v t="felix.20221114222048.4"><vh>flattenOutline</vh></v>
<v t="felix.20221114222048.5"><vh>outlineToCweb</vh></v>
<v t="felix.20221114222048.6"><vh>outlineToNoweb</vh></v>
<v t="felix.20221114222048.7"><vh>removeSentinels</vh></v>
<v t="felix.20221114222048.8"><vh>weave</vh></v>
<v t="felix.20221114222048.9"><vh>writeFileFromNode</vh></v>
<v t="felix.20221114222048.10"><vh>readFileIntoNode</vh></v>
</v>
<v t="felix.20201214194144.7"><vh>At Buttons</vh>
<v t="felix.20201214211742.1"><vh>clickAtButton</vh></v>
<v t="felix.20220517212706.1"><vh>_handleRClicks</vh></v>
<v t="felix.20220517212718.1"><vh>gotoScript</vh></v>
<v t="felix.20201214211744.1"><vh>removeAtButton</vh></v>
</v>
<v t="felix.20220930215533.1"><vh>Undos</vh>
<v t="felix.20220930215747.1"><vh>revertToUndo</vh></v>
<v t="felix.20220930215540.1"><vh>_setUndoSelection</vh></v>
</v>
<v t="felix.20211030165058.1"><vh>GUI Wrappers &amp; Helpers</vh>
<v t="felix.20220201230041.1"><vh>showLeoIDMessage</vh></v>
<v t="felix.20221106230554.1"><vh>show_find_success</vh></v>
<v t="felix.20220201225503.1"><vh>LeoGui.ensure_commander_visible</vh></v>
<v t="felix.20220201194319.1"><vh>setLeoIDCommand</vh></v>
<v t="felix.20220131235418.1"><vh>getIdFromSetting</vh></v>
<v t="felix.20220131234257.1"><vh>setIdSetting</vh></v>
<v t="felix.20221027153815.1"><vh>widget_name</vh></v>
<v t="felix.20221026222034.1"><vh>set_focus</vh></v>
<v t="felix.20221026222040.1"><vh>get_focus</vh></v>
<v t="felix.20221115230034.1"><vh>get1Arg</vh></v>
<v t="felix.20220613164517.1"><vh>runAboutLeoDialog</vh></v>
<v t="felix.20220108211750.1"><vh>runAskOkDialog</vh></v>
<v t="felix.20220109220155.1"><vh>runAskYesNoDialog</vh></v>
<v t="felix.20220516005841.1"><vh>runAskYesNoDialog</vh></v>
<v t="felix.20220107223824.1"><vh>runOpenFileDialog</vh></v>
<v t="felix.20220108211806.1"><vh>runSaveFileDialog</vh></v>
</v>
</v>
</v>
<v t="felix.20201214151419.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20201214151419.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20201214151419.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20201214151419.4"><vh>getTreeItem</vh></v>
<v t="felix.20201214151419.5"><vh>getChildren</vh></v>
<v t="felix.20201214151419.6"><vh>getParent</vh></v>
</v>
<v t="felix.20201214151425.2"><vh>class LeoButtonNode</vh>
<v t="felix.20201214151425.3"><vh>iconPath</vh></v>
<v t="felix.20201214151425.4"><vh>id</vh></v>
<v t="felix.20201214151425.5"><vh>tooltip</vh></v>
<v t="felix.20201214151425.6"><vh>description</vh></v>
</v>
</v>
<v t="felix.20201214151429.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20201214151429.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20201214151429.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20201214151429.4"><vh>getTreeItem</vh></v>
<v t="felix.20201214151429.5"><vh>getChildren</vh></v>
<v t="felix.20201214151429.6"><vh>getParent</vh></v>
</v>
<v t="felix.20201214151434.2"><vh>class LeoDocumentNode</vh></v>
</v>
<v t="felix.20220505221929.1"><vh>@clean src/leoGoto.ts</vh>
<v t="felix.20220505222045.1"><vh>class LeoGotoProvider</vh></v>
<v t="felix.20220505222101.1"><vh>class LeoGotoNode</vh></v>
</v>
<v t="felix.20211122205011.1"><vh>@clean src/leoUndos.ts</vh>
<v t="felix.20211122205031.1"><vh>class LeoUndosProvider</vh>
<v t="felix.20211122213012.1"><vh>refreshTreeRoot</vh></v>
<v t="felix.20211122213023.1"><vh>getTreeItem</vh></v>
<v t="felix.20211122214230.1"><vh>getChildren</vh></v>
<v t="felix.20211122213037.1"><vh>getParent</vh></v>
<v t="felix.20220520011951.1"><vh>resolveTreeItem</vh></v>
</v>
<v t="felix.20211122212823.1"><vh>class LeoUndoNode</vh></v>
</v>
<v t="felix.20201214151447.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20201214151447.2"><vh>class LeoStates</vh>
<v t="felix.20201214151447.3"><vh>General State Flags</vh>
<v t="felix.20221004234249.1"><vh>leojsStartupDone &amp; helper</vh></v>
<v t="felix.20201214233119.1"><vh>leoReady &amp; helper</vh></v>
<v t="felix.20201214151447.4"><vh>fileOpenedReady &amp; helper</vh></v>
<v t="felix.20201214151447.5"><vh>leoOpenedFileName</vh></v>
<v t="felix.20201214151447.6"><vh>leoChanged &amp; helper</vh></v>
<v t="felix.20201214151447.7"><vh>leoCanUndo &amp; helper</vh></v>
<v t="felix.20201214151447.8"><vh>leoCanRedo &amp; helper</vh></v>
<v t="felix.20220508201944.1"><vh>leoCanGoBack &amp; helper</vh></v>
<v t="felix.20220508201944.2"><vh>leoCanGoNext &amp; helper</vh></v>
<v t="felix.20201214151447.9"><vh>leoCanDemote &amp; helper</vh></v>
<v t="felix.20201214151447.10"><vh>leoCanPromote &amp; helper</vh></v>
<v t="felix.20201214151447.11"><vh>leoCanDehoist &amp; helper</vh></v>
</v>
<v t="felix.20201214151447.12"><vh>Selected Node Flags</vh>
<v t="felix.20201214151447.13"><vh>leoMarked</vh></v>
<v t="felix.20201214151447.14"><vh>leoCloned</vh></v>
<v t="felix.20201214151447.15"><vh>leoDirty</vh></v>
<v t="felix.20201214151447.16"><vh>leoEmpty</vh></v>
<v t="felix.20201214151447.17"><vh>leoChild</vh></v>
<v t="felix.20201214151447.18"><vh>leoAtFile</vh></v>
<v t="felix.20201214151447.19"><vh>leoRoot</vh></v>
</v>
<v t="felix.20201214151447.20"><vh>constructor</vh></v>
<v t="felix.20201214151447.21"><vh>selectedNodeFlags</vh></v>
<v t="felix.20201214151447.22"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20201214151451.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20201214151451.2"><vh>class LeoStatusBar</vh>
<v t="felix.20201214151451.3"><vh>show</vh></v>
<v t="felix.20201214151451.4"><vh>hide</vh></v>
<v t="felix.20201214151451.5"><vh>setString</vh></v>
<v t="felix.20201214151451.6"><vh>update</vh></v>
<v t="felix.20201214151451.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20201214151451.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20201214154816.1"><vh>@clean src/types.d.ts</vh>
<v t="felix.20211007213900.1"><vh>ConfigMembers</vh></v>
<v t="felix.20211007213909.1"><vh>ConfigSetting</vh></v>
<v t="felix.20211007213915.1"><vh>FontSettings</vh></v>
<v t="felix.20220922215553.1"><vh>Focus</vh></v>
<v t="felix.20201214154816.3"><vh>RevealType</vh></v>
<v t="felix.20201214154816.4"><vh>ReqRefresh</vh></v>
<v t="felix.20221009011653.1"><vh>CommandOptions</vh></v>
<v t="felix.20211010221959.1"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201214154816.6"><vh>ShowBodyParam</vh></v>
<v t="felix.20201214154816.7"><vh>LeoPackageStates</vh></v>
<v t="felix.20201214154816.8"><vh>LeoDocument</vh></v>
<v t="felix.20201214154816.9"><vh>LeoButton</vh></v>
<v t="felix.20220505220527.1"><vh>TGotoTypes</vh></v>
<v t="felix.20220505220532.1"><vh>LeoGoto</vh></v>
<v t="felix.20221027155442.1"><vh>LeoGotoNavKey</vh></v>
<v t="felix.20220505220537.1"><vh>LeoSearchScope</vh></v>
<v t="felix.20220505220544.1"><vh>LeoSearchSettings</vh></v>
<v t="felix.20220505220550.1"><vh>LeoGuiFindTabManagerSettings</vh></v>
<v t="felix.20201214154816.10"><vh>Icon</vh></v>
<v t="felix.20220505220619.1"><vh>BodyTimeInfo</vh></v>
<v t="felix.20220505220626.1"><vh>BodyPosition</vh></v>
<v t="felix.20220505220630.1"><vh>BodySelectionInfo</vh></v>
<v t="felix.20201214154816.11"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20201214154816.12"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20201214154816.13"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20201214154816.14"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20201214154816.15"><vh>AskMessageItem</vh></v>
<v t="felix.20201214154816.16"><vh>ChooseDocumentItem</vh></v>
<v t="felix.20220505220706.1"><vh>ChooseRClickItem</vh></v>
<v t="felix.20220505220722.1"><vh>RClick</vh></v>
<v t="felix.20201214154816.17"><vh>MinibufferCommand</vh></v>
</v>
<v t="felix.20210110210346.1"><vh>@clean src/declarations.d.ts</vh></v>
<v t="felix.20201208224407.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20220929001102.1"><vh>performanceNow</vh></v>
<v t="felix.20220505225030.1"><vh>uniqueId</vh></v>
<v t="felix.20220505225023.1"><vh>getUniqueId</vh></v>
<v t="felix.20201208224407.2"><vh>padNumber2</vh></v>
<v t="felix.20201208224407.4"><vh>addFileToGlobal</vh></v>
<v t="felix.20201208224407.5"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20201208224407.6"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20201208224407.7"><vh>buildDocumentIconPaths</vh></v>
<v t="felix.20221027230322.1"><vh>buildUndoIconPaths</vh></v>
<v t="felix.20201208224407.8"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20220505225236.1"><vh>buildGotoIconPaths</vh></v>
<v t="felix.20220109180351.1"><vh>convertLeoFiletypes</vh></v>
<v t="felix.20201208224407.10"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20201208224407.11"><vh>getFileFromPath</vh></v>
<v t="felix.20220417151556.1"><vh>getIdFromDialog</vh></v>
<v t="felix.20220201195806.1"><vh>isAlphaNumeric</vh></v>
<v t="felix.20201208224407.12"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20211007214455.1"><vh>isHexColor</vh></v>
<v t="felix.20201208224407.14"><vh>strToLeoUri</vh></v>
<v t="felix.20201208224407.15"><vh>leoUriToStr</vh></v>
<v t="felix.20201208224407.16"><vh>setContext</vh></v>
</v>
<v t="felix.20220417155704.1"><vh>@clean src/commandBindings.ts</vh>
<v t="felix.20220417155732.1"><vh>makeAllBindings</vh>
<v t="felix.20201214150149.2"><vh>&lt;&lt; Define entries for all commands &gt;&gt;</vh>
<v t="felix.20201214150149.15"><vh>Show UI panes</vh></v>
<v t="felix.20201214150149.3"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20201214150149.4"><vh>Leo File Documents</vh></v>
<v t="felix.20221114220040.1"><vh>Import Export Files</vh></v>
<v t="felix.20201214150149.5"><vh>Headline Editing</vh></v>
<v t="felix.20201214150149.6"><vh>Node Editing</vh></v>
<v t="felix.20201214150149.7"><vh>Tree View Interaction</vh></v>
<v t="felix.20201214150149.8"><vh>Goto Nodes</vh></v>
<v t="felix.20201214150149.9"><vh>Hoisting</vh></v>
<v t="felix.20201214150149.10"><vh>Outline Editing</vh></v>
<v t="felix.20201214150149.11"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214150149.12"><vh>Body Editing</vh></v>
<v t="felix.20201214150149.13"><vh>Move Nodes</vh></v>
<v t="felix.20201214150149.14"><vh>Undo</vh></v>
<v t="felix.20201214150149.16"><vh>Marked Nodes Commands</vh></v>
<v t="felix.20201214150149.17"><vh>Clone Find Commands</vh></v>
<v t="felix.20220917013425.1"><vh>Config Set Recommended</vh></v>
</v>
</v>
</v>
<v t="felix.20201214205159.1"><vh>@clean package.json</vh>
<v t="felix.20201214205159.2"><vh>&lt;&lt; contributes &gt;&gt;</vh>
<v t="felix.20211006225245.1"><vh>configuration</vh></v>
<v t="felix.20201214205159.3"><vh>viewsContainers</vh></v>
<v t="felix.20201214205159.4"><vh>views</vh></v>
<v t="felix.20220918234128.1"><vh>languages</vh></v>
<v t="felix.20220918234147.1"><vh>grammars</vh></v>
<v t="felix.20220918234152.1"><vh>snippets</vh></v>
<v t="felix.20201214205159.5"><vh>viewsWelcome</vh></v>
<v t="felix.20201214205159.6"><vh>commands</vh>
<v t="felix.20201214205159.9"><vh>Show UI Panes</vh></v>
<v t="felix.20201214205159.8"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20201214205159.10"><vh>Leo File Documents</vh></v>
<v t="felix.20221114213948.1"><vh>Import Export Files</vh></v>
<v t="felix.20201214205159.11"><vh>Tree View</vh></v>
<v t="felix.20201214205159.12"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.13"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.14"><vh>Node Editing</vh></v>
<v t="felix.20201214205159.15"><vh>Body Editing</vh></v>
<v t="felix.20201214205159.16"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.17"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.18"><vh>Goto Nodes</vh></v>
<v t="felix.20221108222157.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20201214205159.20"><vh>Undo/Redo</vh></v>
<v t="felix.20221113232048.1"><vh>Search</vh></v>
<v t="felix.20221113232519.1"><vh>Tags</vh></v>
<v t="felix.20221113232103.1"><vh>Nav</vh></v>
</v>
<v t="felix.20201214205159.23"><vh>menus</vh>
<v t="felix.20201214205159.24"><vh>commandPalette</vh>
<v t="felix.20201214205159.42"><vh>Scripting &amp; @Buttons</vh></v>
<v t="felix.20201214205159.44"><vh>Leo File Documents</vh></v>
<v t="felix.20201214205159.45"><vh>Tree View</vh></v>
<v t="felix.20201214205159.46"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.47"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.48"><vh>Node Editing</vh></v>
<v t="felix.20201214205159.49"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.50"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.51"><vh>Goto Nodes</vh></v>
<v t="felix.20201214205159.52"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20221115220743.1"><vh>Search</vh></v>
<v t="felix.20201214205159.53"><vh>Undo/Redo</vh></v>
</v>
<v t="felix.20201214205159.54"><vh>explorer/context</vh></v>
<v t="felix.20221112230919.1"><vh>editor/title</vh></v>
<v t="felix.20221113165005.1"><vh>editor/context</vh></v>
<v t="felix.20201214205159.55"><vh>view/title</vh></v>
<v t="felix.20201214205159.56"><vh>view/item/context</vh>
<v t="felix.20220517202245.1"><vh>leo documents commands</vh></v>
<v t="felix.20201214205159.57"><vh>Headline Editing Hover Icon</vh></v>
<v t="felix.20201214205159.58"><vh>Insert Node Hover Icon</vh></v>
<v t="felix.20201214205159.60"><vh>Outline Editing Hover Icon</vh></v>
<v t="felix.20201214205159.61"><vh>Mark/Unmark Hover Icon</vh></v>
<v t="felix.20201214205159.62"><vh>Tree View Interaction Context Menu</vh></v>
<v t="felix.20201214205159.63"><vh>Hoisting Context Menu</vh></v>
<v t="felix.20201214205159.64"><vh>Leo File Documents Context Menu</vh></v>
<v t="felix.20201214205159.65"><vh>Mark/Unmark Context Menu</vh></v>
<v t="felix.20201214205159.66"><vh>Outline Editing Context Menu</vh></v>
<v t="felix.20220517203332.1"><vh>at buttons</vh></v>
</v>
</v>
<v t="felix.20201214205159.67"><vh>keybindings</vh>
<v t="felix.20201214205159.68"><vh>Scripting &amp; @Buttons</vh></v>
<v t="felix.20201214205159.69"><vh>Show UI Panes</vh></v>
<v t="felix.20201214205159.70"><vh>Leo File Documents</vh></v>
<v t="felix.20201214205159.71"><vh>Tree View Interaction</vh></v>
<v t="felix.20201214205159.72"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.73"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.74"><vh>Body Editing</vh></v>
<v t="felix.20201214205159.75"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.76"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.77"><vh>Node Editing</vh></v>
<v t="felix.20211117232843.1"><vh>Undo/Redo</vh></v>
<v t="felix.20221115214948.1"><vh>Search</vh></v>
<v t="felix.20201214205159.78"><vh>Goto Nodes</vh></v>
<v t="felix.20221207231723.1"><vh>VSCode Commands</vh></v>
</v>
<v t="felix.20211119001637.1"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="felix.20201214205159.79"><vh>&lt;&lt; scripts &gt;&gt;</vh></v>
<v t="felix.20201214205159.80"><vh>&lt;&lt; devDependencies &gt;&gt;</vh></v>
<v t="felix.20201214205159.81"><vh>&lt;&lt; dependencies &gt;&gt;</vh></v>
</v>
</v>
<v t="felix.20210102000055.1"><vh>Leo</vh>
<v t="felix.20210102000100.1"><vh>Core classes</vh>
<v t="felix.20211018202009.1"><vh>@file src/core/decorators.ts</vh></v>
<v t="felix.20221109235435.1"><vh>@file src/core/findTabManager.ts</vh></v>
<v t="felix.20210102012334.1"><vh>@file src/core/leoApp.ts</vh></v>
<v t="felix.20211211234842.1"><vh>@file src/core/leoAtFile.ts</vh></v>
<v t="felix.20220429005433.1"><vh>@file src/core/leoChapters.ts</vh></v>
<v t="felix.20210110222544.1"><vh>@file src/core/leoCommands.ts</vh></v>
<v t="felix.20211031230132.1"><vh>@file src/core/leoConfig.ts</vh></v>
<v t="felix.20211212162008.1"><vh>@file src/core/leoExternalFiles.ts</vh></v>
<v t="felix.20210220181245.1"><vh>@file src/core/leoFileCommands.ts</vh></v>
<v t="felix.20210102012410.1"><vh>@file src/core/leoGlobals.ts</vh></v>
<v t="felix.20211021231651.1"><vh>@file src/core/leoHistory.ts</vh></v>
<v t="felix.20220105221256.1"><vh>@file src/core/leoImport.ts</vh></v>
<v t="felix.20210102012632.1"><vh>@file src/core/leoNodes.ts</vh></v>
<v t="felix.20211212162359.1"><vh>@file src/core/leoShadow.ts</vh></v>
<v t="felix.20211026230613.1"><vh>@file src/core/leoUndo.ts</vh></v>
<v t="felix.20221019001448.1"><vh>@file src/core/nodeTags.ts</vh></v>
<v t="felix.20221105221426.1"><vh>@file src/core/quicksearch.ts</vh></v>
</v>
<v t="felix.20211002194716.1"><vh>Command classes</vh>
<v t="felix.20220414231314.1"><vh>@file src/commands/commanderEditCommands.ts</vh></v>
<v t="felix.20211017230407.1"><vh>@file src/commands/commanderFileCommands.ts</vh></v>
<v t="felix.20220612234816.1"><vh>@file src/commands/commanderHelpCommands.ts</vh></v>
<v t="felix.20211002221425.1"><vh>@file src/commands/commanderOutlineCommands.ts</vh></v>
<v t="felix.20211212162627.1"><vh>@file src/commands/editFileCommands.ts</vh></v>
<v t="felix.20220503003653.1"><vh>@file src/commands/editCommands.ts</vh></v>
<v t="felix.20220503003725.1"><vh>@file src/commands/gotoCommands.ts</vh></v>
</v>
<v t="felix.20221119204248.1"><vh>Gui base classes</vh>
<v t="felix.20211212000140.1"><vh>@file src/core/leoFind.ts</vh></v>
<v t="felix.20220512205042.1"><vh>@file src/core/leoFrame.ts</vh></v>
<v t="felix.20221119204422.1"><vh>@file src/core/leoGui.ts</vh></v>
</v>
<v t="felix.20220128232146.1"><vh>unittests</vh>
<v t="felix.20220130224933.1"><vh>@file src/test/leoTest2.ts</vh></v>
<v t="felix.20220129002501.1"><vh>@file src/test/extension.test.ts</vh></v>
<v t="felix.20220129200448.1"><vh>@file src/test/leoApp.test.ts</vh></v>
<v t="felix.20220129003133.1"><vh>@file src/test/leoAtFile.test.ts</vh></v>
<v t="felix.20220129002752.1"><vh>@file src/test/leoCommands.test.ts</vh></v>
<v t="felix.20220129003431.1"><vh>@file src/test/leoConfig.test.ts</vh></v>
<v t="felix.20220129003154.1"><vh>@file src/test/leoExternalFiles.test.ts</vh></v>
<v t="felix.20220129003044.1"><vh>@file src/test/leoFileCommands.test.ts</vh></v>
<v t="felix.20220129003458.1"><vh>@file src/test/leoFind.test.ts</vh></v>
<v t="felix.20220129002458.1"><vh>@file src/test/leoGlobals.test.ts</vh></v>
<v t="felix.20220129003526.1"><vh>@file src/test/leoImport.test.ts</vh></v>
<v t="felix.20220129002948.1"><vh>@file src/test/leoNodes.test.ts</vh></v>
<v t="felix.20220129003553.1"><vh>@file src/test/leoShadow.test.ts</vh></v>
<v t="felix.20220129003013.1"><vh>@file src/test/leoUndo.test.ts</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20201209145256.1"></t>
<t tx="ekr.20201209145358.1"></t>
<t tx="felix.20200719025231.24">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {
    if (p_event.affectsConfiguration(Constants.CONFIG_NAME)) {
        this.config.buildFromSavedSettings(); // If the config setting started with 'leojs'
    }
    // also check if workbench.editor.enablePreview
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // Check For specific vscode settings needed for leojs
    // Leave small delay for multiple possible forced changes at startup
    setTimeout(() =&gt; {
        this.config.checkEnablePreview();
        this.config.checkCloseEmptyGroups();
    }, 150);
}

</t>
<t tx="felix.20201208214250.2"></t>
<t tx="felix.20201208214319.1"># leojs

## ![LeoEditor](https://raw.githubusercontent.com/boltex/leojs/master/resources/leoapp.png) Literate Editor with Outline _in Typescript_ ![Typescript](https://raw.githubusercontent.com/boltex/leojs/master/resources/typescript.png)

### Literate Programming with _Directed Acyclic Graphs_ ([dag](https://en.wikipedia.org/wiki/Directed_acyclic_graph))

LeoJS is [LeoInteg](https://github.com/boltex/leointeg#-leo-editor-integration-with-visual-studio-code)'s younger sibling project : a vsCode extension, currently in early alpha.

Inspired by &lt;https://github.com/leo-editor/leo-editor/issues/1025&gt;.

See Leo, the Literate Editor with Outline, at [leoeditor.com](https://leoeditor.com/)
or on [github](https://github.com/leo-editor/leo-editor), and vscode at [code.visualstudio.com](https://code.visualstudio.com/).

![Screenshot](https://raw.githubusercontent.com/boltex/leojs/master/resources/animated-screenshot.gif)

## Development Version Installation

Make sure you have Node.js and Git installed, then clone the sources and run `npm install` in a terminal to install the remaining development dependencies.

![run extension](https://raw.githubusercontent.com/boltex/leojs/master/resources/run-extension.png)

You can then run the **Run Extension** target, as shown above, in the **Debug View**.

## Web extension version
Will be available _'soon'_ when a first beta version is submitted to the Extension Market. (See [VSCode for the web](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for usage example)

**In the meantime**, see 'Running Development version as a web extension' below to try out with development version.

## Running Development version as a web extension

To try out running as a web extension on vscode.dev, use the following commands:

1. From the development folder, open a terminal and start an HTTP server by running `npx serve --cors -l 5000`

2. Open another terminal and run `npx localtunnel -p 5000`

3. Click on the generated URL and select the _Click-to-Continue_ button. (Copy the URL to your clipboard.)

4. Finally, open vscode.dev pointing to a github repo, similar to: `https://vscode.dev/github/boltex/practice-leo-phys` and run **Developer: Install Web Extension...** from the Command Palette and paste the generated URL.

## Features done so far

-   The commands and menus icons for outline editing
-   Undo and navigation history commands
-   The minibuffer Command-Palette
-   Panels for Outline, Undo history, Leo documents (no find, goto or @buttons panes yet)
-   Basic 'New', 'Open' and 'Save' operations (no external @files/@clean... support yet)

## Keybindings

| Outline Commands           |     |                    |                  |
| :------------------------- | :-- | :----------------- | :--------------- |
| `Ctrl + Z`                 |     | `Ctrl + Shift + Z` | Undo / Redo      |
| `Ctrl + I`                 | or  | `Shift + Insert`   | Insert Node      |
| `Ctrl + Insert`            |     |                    | Insert Child     |
| `Ctrl + H`                 |     |                    | Edit Headline    |
| `Ctrl + M`                 |     |                    | Mark / Unmark    |
| `Ctrl + Shift + C`         |     |                    | Copy Node        |
| `Ctrl + Shift + X`         |     |                    | Cut Node         |
| `Ctrl + Shift + V`         |     |                    | Paste Node       |
| `Ctrl + Shift + Backspace` | or  | `Delete`           | Delete Node      |
| `Ctrl + Backquote`         |     |                    | Clone Node       |
| `Ctrl + {`                 | and | `Ctrl + }`         | Promote / Demote |

| Moving Outline Nodes |     |                         |                    |
| :------------------- | :-- | :---------------------- | :----------------- |
| `Ctrl + U`           | or  | `Shift [+ Alt] + Up`    | Move Outline Up    |
| `Ctrl + D`           | or  | `Shift [+ Alt] + Down`  | Move Outline Down  |
| `Ctrl + L`           | or  | `Shift [+ Alt] + Left`  | Move Outline Left  |
| `Ctrl + R`           | or  | `Shift [+ Alt] + Right` | Move Outline Right |

_Move Outline commands need the 'Alt' key modifier only when focus is on body pane._

| Common Operations  |            |           |     |            |                     |
| :----------------- | :--------- | :-------- | :-- | :--------- | :------------------ | 
| `Ctrl + T`         |            |           |     |            | Toggle Outline/Body |
| `Tab` or `Enter`   | or         | `Alt + D` | or  | `Ctrl + G` | Focus on Body       |
| `Alt + T`          |            |           |     |            | Focus on Outline    |
| `Alt + -`          |            |           |     |            | Contract All        |
| `Ctrl + Shift + D` |            |           |     |            | Extract             |
| `Ctrl + Shift + N` |            |           |     |            | Extract Names       |
| `Alt + A`          |            |           |     |            | Sort Siblings       |
| `Alt + X`          |            |           |     |            | Minibuffer Palette  |

 &lt;!--               | `Ctrl + B` |           |     |            |                     | Execute Script | --&gt; 
 &lt;!--               | `Ctrl + F` |           |     |            |                     | Start Search   | --&gt; 
 &lt;!--               | `F3`       |           |     |            |                     | Find Next      | --&gt; 
 &lt;!--               | `F2`       |           |     |            |                     | Find Previous  | --&gt; 

| Tree Navigation    |           |                 |                          |
| :----------------- | :-------- | :-------------- | :----------------------- |
| `Alt + Home`       | or        | `Home` \*       | Go To First Visible Node |
|                    |           | `End` \*        | Go To Last Visible Node  |
| `PgUp / pgDn`      |           |                 | Tree page up/down        |
| `Alt + End`        |           |                 | Go To Last Sibling       |
| `Alt + N`          |           |                 | Go To Next Clone         |
| `Alt + Arrow Keys` | or        | `Arrow Keys` \* | Browse Tree              |

&lt;!--               | `Alt + G` |                 |                          | Go To Global Line | --&gt; 

\* _With the **'Leo Tree Browsing'** setting enabled by default, all arrows and numeric keypad keys change the outline's selection directly_

| File Commands      |     |     |                   |
| :----------------- | :-- | :-- | :---------------- |
| `Ctrl + S`         |     |     | Save Leo Document |
| `Ctrl + N`         |     |     | New Leo Document  |
| `Ctrl + O`         |     |     | Open Leo Document |
| `Ctrl + Shift + W` |     |     | Write File Nodes  |
| `Ctrl + Shift + Q` |     |     | Write Dirty Files |

**Enjoy!**
</t>
<t tx="felix.20201208214322.1">import * as vscode from 'vscode';
import { Constants } from './constants';
import * as path from 'path';
import * as utils from "./utils";
import * as g from './core/leoGlobals';
import { LeoApp } from './core/leoApp';
import { LoadManager } from "./core/leoApp";
process.hrtime = require('browser-process-hrtime'); // Overwrite 'hrtime' of process

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20201208214506.1"># Change Log

## 0.1.0 12.9.2020.

- Initial state

## 0.1.1 12.31.2021.

- Outline, undos and commands.

## 0.1.2 24.01.2022.

- Support web extension compilation for vscode.dev
</t>
<t tx="felix.20201208215619.1">// this method is called when your extension is deactivated
export function deactivate() { }

</t>
<t tx="felix.20201208223553.1">import * as vscode from 'vscode';
import { Constants } from "./constants";
import { Icon } from './types';
import { LeoUI } from './leoUI';
import * as g from './core/leoGlobals';
import { Position } from './core/leoNodes';

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20201208224407.1">import * as vscode from "vscode";
import { Utils as uriUtils } from "vscode-uri";
import { Constants } from "./constants";
import { Icon } from "./types";
import { LeoOutlineNode } from "./leoOutline";
import { Position } from "./core/leoNodes";

// String and other types/structures helper functions, along with common vscode API calls

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208224407.10">/**
 * * Returns milliseconds between the p_start process.hrtime tuple and p_end (or current call to process.hrtime)
 * @param p_start starting process.hrtime to subtract from p_end or current immediate time
 * @param p_end optional end process.hrtime (or immediate time)
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number], p_end?: [number, number]): number {
    if (!p_end) {
        p_end = process.hrtime(p_start);
    }
    const [w_secs, w_nanosecs] = p_end;
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201208224407.11">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20201208224407.12">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: Position, p_newHasBody: boolean): boolean {
    // hasBody can be undefined so force boolean.
    if (!p_node.isDirty() || (!!p_node.bodyString().length === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20201208224407.14">/**
* Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
* @param p_str leo node gnx strings are used to build Uri
* @returns A vscode 'Uri' object
*/
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20201208224407.15">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substr(1);
}

</t>
<t tx="felix.20201208224407.16">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'leoReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20201208224407.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20201208224407.4">/**
 * * Performs the actual addition into globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
 */
export function addFileToGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.globalState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.globalState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.globalState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.globalState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201208224407.5">/**
 * * Removes file entry from globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
  */
export function removeFileFromGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.globalState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.globalState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.globalState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201208224407.6">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {

            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
        };
    });
}

</t>
<t tx="felix.20201208224407.7">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20201208224407.8">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON_RCLICK),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON_RCLICK)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="felix.20201208224703.1">@language rest
@wrap

# How to install and run the development version

Thanks for trying out the development version of Leojs! :sunglasses: Contributions and pull requests are more than welcome!

## Introduction

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

</t>
<t tx="felix.20201209011931.1">export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;Position&gt; {
    private _onDidChangeTreeData: vscode.EventEmitter&lt;Position | undefined&gt; = new vscode.EventEmitter&lt;Position | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;Position | undefined&gt; = this._onDidChangeTreeData.event;

    public treeId: number = 0; // Starting salt for generated tree node Ids

    @others
}

</t>
<t tx="felix.20201209011931.2">constructor(
    private _icons: Icon[],
    private _leoUI: LeoUI
) {
}

</t>
<t tx="felix.20201209011931.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201209011931.4">public getTreeItem(element: Position): Thenable&lt;LeoOutlineNode&gt; | LeoOutlineNode {

    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (element.hasChildren()) {
        w_collapse = element.isExpanded() ? vscode.TreeItemCollapsibleState.Expanded : vscode.TreeItemCollapsibleState.Collapsed;
    }
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (element.isMarked()) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (element.isAnyAtFileNode()) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (element.isCloned()) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (element._isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    const w_icon: number =
        (+element.isDirty() &lt;&lt; 3) |
        (+element.isCloned() &lt;&lt; 2) |
        (+element.isMarked() &lt;&lt; 1) |
        +element.v.hasBody();

    const w_u = (element.v.u &amp;&amp; Object.keys(element.v.u).length) ? element.v.u : false;
    let desc: string = "";
    // * some smaller grayed-out text accompanying the main label
    if (w_u) {

        const w_uLength = Object.keys(w_u).length;
        if (w_uLength) {
            desc = "\u{1F4CE} (" + w_uLength + ")";
            if (w_u.__node_tags) {
                if (w_uLength === 1) {
                    // was only tag, so reset it
                    desc = "";
                } else {
                    desc = desc + " "; // add space
                }
                desc = desc + "\u{1F3F7} (" + Object.keys(w_u.__node_tags).length + ")";
            }
        }

    } else {
        // desc = "id:" + this.id; // ! debug test
        // desc = "gnx:" + this.gnx; // ! debug test
    }

    const w_leoNode = new LeoOutlineNode(
        element.h,
        w_collapse,
        element, // Position
        desc,
        this._icons[w_icon],
        this._buildId(element, w_collapse),
        w_contextValue
    );
    // Check if its the selected node and call signal it to the UI
    if (element.__eq__(g.app.windowList[this._leoUI.frameIndex].c.p)) {
        this._leoUI.gotSelectedNode(element);
    }
    // Build a LeoNode (a vscode tree node) from the Position
    return w_leoNode;
}

</t>
<t tx="felix.20201209011931.5">public getChildren(element?: Position): Position[] {
    if (!this._leoUI.leoStates.fileOpenedReady) {
        return [];
    }
    if (element) {
        return [...element.children()];
    } else {
        if (g.app.windowList[this._leoUI.frameIndex]) {
            // Currently Selected Document's Commander
            const w_c = g.app.windowList[this._leoUI.frameIndex].c;
            if (w_c.hoistStack.length) {
                // HOISTED: Topmost hoisted node starts the outline as single root 'child'
                const w_rootPosition = w_c.hoistStack[w_c.hoistStack.length - 1].p;
                w_rootPosition._isRoot = true;
                return [w_rootPosition];
            } else {
                // NOT HOISTED: Normal list of root nodes
                const w_rootNodes = [...w_c.all_Root_Children()];
                if (w_rootNodes.length === 1) {
                    // Exactly one: prevent hoisting on SINGLE top node
                    w_rootNodes[0]._isRoot = true;
                }
                return w_rootNodes;
            }
        } else {
            return []; // Attempted to access un-existent frame
        }
    }
}

</t>
<t tx="felix.20201209011931.6">public getParent(element: Position): vscode.ProviderResult&lt;Position&gt; {
    if (element) {
        const p_parent = element.parent();
        if (p_parent.v) {
            return p_parent;
        } else {
            return undefined;
        }
    }
    return undefined;
}

</t>
<t tx="felix.20201214150149.1">/**
 * Entry point for Leo in Javascript.
 */
export function activate(p_context: vscode.ExtensionContext) {

    if (p_context.extensionUri) {
        console.log('context.extensionUri', p_context.extensionUri.fsPath, p_context.extensionUri.scheme, p_context.extensionUri.toJSON(),);
    }
    console.log('g.osBrowser', g.isBrowser);
    console.log('test path.sep: ', path.sep);
    console.log('env scheme', vscode.env.uriScheme);
    console.log('env appHost', vscode.env.appHost);

    // * Close remaining leojs Bodies restored by vscode from last session.
    // TODO : USE TABGROUPS
    // vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
    //     if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
    //         if (p_textEditor.hide) {
    //             p_textEditor.hide();
    //         }
    //     }
    // });

    const w_leojsExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leojsVersion = w_leojsExtension.packageJSON.version;

    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);

    // * Close remaining Leo Bodies restored by vscode from last session.
    closeLeoTextEditors();

    // * Show a welcome screen on version updates, then start the actual extension.
    showWelcomeIfNewer(w_leojsVersion, w_previousVersion)
        .then(() =&gt; {

            p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leojsVersion);

        });

    if (!g.app) {
        (g.app as LeoApp) = new LeoApp();
    } else {
        vscode.window.showWarningMessage("g.app leojs application instance already exists!");
    }

    p_context.subscriptions.push(
        vscode.workspace.onDidChangeWorkspaceFolders((p_event =&gt; setScheme(p_event, p_context)))
    );

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders.length) {
        g.app.vscodeWorkspaceUri = vscode.workspace.workspaceFolders[0].uri;
        g.app.vscodeUriScheme = vscode.workspace.workspaceFolders[0].uri.scheme;
        g.app.vscodeUriAuthority = vscode.workspace.workspaceFolders[0].uri.authority;
        g.app.vscodeUriPath = vscode.workspace.workspaceFolders[0].uri.path;
    }

    if (!g.isBrowser) {
        // Regular NodeJs Extension: Dont wait for workspace being opened
        if (!g.app.vscodeUriScheme) {
            // Only setting if undefined, because regular vscode can still work on remote github virtual filesystem
            g.app.vscodeUriScheme = 'file';
        }
        runLeo(p_context);
    } else {
        // Web Browser Extension: CHeck for type of workspace opened first
        if (g.app.vscodeUriScheme) {

            if (!vscode.workspace.fs.isWritableFileSystem(g.app.vscodeUriScheme)) {
                vscode.window.showInformationMessage("Non-writable filesystem scheme: " + g.app.vscodeUriScheme, "More Info").then(selection =&gt; {
                    if (selection === "More Info") {
                        vscode.env.openExternal(
                            vscode.Uri.parse(
                                'https://code.visualstudio.com/docs/editor/vscode-web#_current-limitations'
                            )
                        );
                    }
                });
                console.log('NOT started because not writable workspace');
                setStartupDoneContext(true);
                return;
            }

            // Check if not file scheme : only virtual workspaces are suported if g.isBrowser is true.
            if (g.app.vscodeUriScheme !== 'file') {
                runLeo(p_context);
            } else {
                // Is local filesystem
                vscode.window.showInformationMessage("LeoJS in browser supports remote virtual filesystems: Local Filesystem requires desktop VSCode application: ", "More Info").then(selection =&gt; {
                    if (selection === "More Info") {
                        vscode.env.openExternal(vscode.Uri.parse(
                            'https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project'));
                    }
                });
                console.log('NOT started because no remote workspace yet');
                setStartupDoneContext(true);
                return;
            }
        } else {
            console.log('NOT started because no remote workspace yet');
            setStartupDoneContext(true);
        }

    }

}

</t>
<t tx="felix.20201214150149.10">[CMD.INSERT, (p_node: Position) =&gt; p_leoUI.insertNode(p_node, true, false, false)],
[CMD.INSERT_SELECTION, () =&gt; p_leoUI.insertNode(U, false, false, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; p_leoUI.insertNode(U, true, false, false)],
// Special command for when inserting rapidly more than one node without
// even specifying a headline label, e.g. spamming CTRL+I rapidly.
[CMD.INSERT_SELECTION_INTERRUPT, () =&gt; p_leoUI.insertNode(U, false, true, false)],

[CMD.INSERT_CHILD, (p_node: Position) =&gt; p_leoUI.insertNode(p_node, true, false, true)],
[CMD.INSERT_CHILD_SELECTION, () =&gt; p_leoUI.insertNode(U, false, false, true)],
[CMD.INSERT_CHILD_SELECTION_FO, () =&gt; p_leoUI.insertNode(U, true, false, true)],
// Special command for when inserting rapidly more than one node without
// even specifying a headline label, e.g. spamming CTRL+I rapidly.
[CMD.INSERT_CHILD_SELECTION_INTERRUPT, () =&gt; p_leoUI.insertNode(U, false, true, true)],

[CMD.CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.PROMOTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PROMOTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.PROMOTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.DEMOTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.DEMOTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.DEMOTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.SORT_CHILDREN, () =&gt; p_leoUI.command(LEOCMD.SORT_CHILDREN, { refreshType: REFRESH_TREE, finalFocus: Focus.Body, keepSelection: true })],
[CMD.SORT_SIBLING, () =&gt; p_leoUI.command(LEOCMD.SORT_SIBLINGS, { refreshType: REFRESH_TREE, finalFocus: Focus.Body, keepSelection: true })],
[CMD.SORT_SIBLING_FO, () =&gt; p_leoUI.command(LEOCMD.SORT_SIBLINGS, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],

</t>
<t tx="felix.20201214150149.11">[CMD.MARK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MARK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MARK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.UNMARK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.UNMARK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.UNMARK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.UNMARK_ALL, () =&gt; p_leoUI.command(LEOCMD.UNMARK_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.12">[CMD.EXTRACT, () =&gt; p_leoUI.command(LEOCMD.EXTRACT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.EXTRACT_NAMES, () =&gt; p_leoUI.command(LEOCMD.EXTRACT_NAMES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

</t>
<t tx="felix.20201214150149.13">[CMD.MOVE_DOWN, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_DOWN_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_LEFT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_LEFT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_RIGHT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_UP, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_UP_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.14">[CMD.REDO, () =&gt; p_leoUI.command(LEOCMD.REDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.REDO_FO, () =&gt; p_leoUI.command(LEOCMD.REDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.UNDO, () =&gt; p_leoUI.command(LEOCMD.UNDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.UNDO_FO, () =&gt; p_leoUI.command(LEOCMD.UNDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.15">[CMD.SHOW_WELCOME, () =&gt; p_leoUI.showSettings()],
[CMD.SHOW_SETTINGS, () =&gt; p_leoUI.showSettings()],
[CMD.SHOW_OUTLINE, () =&gt; p_leoUI.showOutline(true)], // Also focuses on outline
[CMD.SHOW_LOG, () =&gt; p_leoUI.showLogPane()],
[CMD.SHOW_BODY, () =&gt; p_leoUI.showBody(false, undefined)], // Also focuses on body
</t>
<t tx="felix.20201214150149.16">[CMD.COPY_MARKED, () =&gt; p_leoUI.command(LEOCMD.COPY_MARKED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DIFF_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.DIFF_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MARK_CHANGED_ITEMS, () =&gt; p_leoUI.command(LEOCMD.MARK_CHANGED_ITEMS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MARK_SUBHEADS, () =&gt; p_leoUI.command(LEOCMD.MARK_SUBHEADS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.CLONE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.CLONE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DELETE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.DELETE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MOVE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.MOVE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.PREV_NODE, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PREV_NODE_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.NEXT_NODE, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.NEXT_NODE_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.FIND_QUICK, () =&gt; p_leoUI.findQuick()],
[CMD.FIND_QUICK_SELECTED, () =&gt; p_leoUI.findQuickSelected()],
[CMD.FIND_QUICK_TIMELINE, () =&gt; p_leoUI.findQuickTimeline()],
[CMD.FIND_QUICK_CHANGED, () =&gt; p_leoUI.findQuickChanged()],
[CMD.FIND_QUICK_HISTORY, () =&gt; p_leoUI.findQuickHistory()],
[CMD.FIND_QUICK_MARKED, () =&gt; p_leoUI.findQuickMarked()],
[CMD.FIND_QUICK_GO_ANYWHERE, () =&gt; p_leoUI.goAnywhere()],

[CMD.GOTO_NAV_PREV, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.prev)],
[CMD.GOTO_NAV_NEXT, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.next)],
[CMD.GOTO_NAV_FIRST, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.first)],
[CMD.GOTO_NAV_LAST, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.last)],

[CMD.GOTO_NAV_ENTRY, (p_node: LeoGotoNode) =&gt; p_leoUI.gotoNavEntry(p_node)],

[CMD.START_SEARCH, () =&gt; p_leoUI.startSearch()],
[CMD.FIND_ALL, () =&gt; p_leoUI.findAll(false)],
[CMD.FIND_NEXT, () =&gt; p_leoUI.find(false, false)],
[CMD.FIND_NEXT_FO, () =&gt; p_leoUI.find(true, false)],
[CMD.FIND_PREVIOUS, () =&gt; p_leoUI.find(false, true)],
[CMD.FIND_PREVIOUS_FO, () =&gt; p_leoUI.find(true, true)],
[CMD.FIND_VAR, () =&gt; p_leoUI.findSymbol(false)],
[CMD.FIND_DEF, () =&gt; p_leoUI.findSymbol(true)],
[CMD.REPLACE, () =&gt; p_leoUI.replace(false, false)],
[CMD.REPLACE_FO, () =&gt; p_leoUI.replace(true, false)],
[CMD.REPLACE_THEN_FIND, () =&gt; p_leoUI.replace(false, true)],
[CMD.REPLACE_THEN_FIND_FO, () =&gt; p_leoUI.replace(true, true)],
[CMD.REPLACE_ALL, () =&gt; p_leoUI.findAll(true)],
[CMD.GOTO_GLOBAL_LINE, () =&gt; p_leoUI.gotoGlobalLine()],
[CMD.TAG_CHILDREN, () =&gt; p_leoUI.tagChildren()],
[CMD.TAG_NODE, () =&gt; p_leoUI.tagNode()],
[CMD.REMOVE_TAG, () =&gt; p_leoUI.removeTag()],
[CMD.REMOVE_TAGS, () =&gt; p_leoUI.removeTags()],

</t>
<t tx="felix.20201214150149.17">[CMD.CLONE_FIND_ALL, () =&gt; p_leoUI.cloneFind(false, false)],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; p_leoUI.cloneFind(false, true)],
[CMD.CLONE_FIND_TAG, () =&gt; p_leoUI.cloneFindTag()],
[CMD.CLONE_FIND_PARENTS, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_PARENTS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CLONE_FIND_MARKED, () =&gt; p_leoUI.cloneFind(true, false)],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; p_leoUI.cloneFind(true, true)],

[CMD.SET_FIND_EVERYWHERE_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.ENTIRE_OUTLINE)],
[CMD.SET_FIND_NODE_ONLY_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.NODE_ONLY)],
[CMD.SET_FIND_FILE_ONLY_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.FILE_ONLY)],
[CMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.SUBOUTLINE_ONLY)],
[CMD.TOGGLE_FIND_IGNORE_CASE_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.IGNORE_CASE)],
[CMD.TOGGLE_FIND_MARK_CHANGES_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_CHANGES)],
[CMD.TOGGLE_FIND_MARK_FINDS_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_FINDS)],
[CMD.TOGGLE_FIND_REGEXP_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.REG_EXP)],
[CMD.TOGGLE_FIND_WORD_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.WHOLE_WORD)],
[CMD.TOGGLE_FIND_SEARCH_BODY_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_BODY)],
[CMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, () =&gt; p_leoUI.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_HEADLINE)],

</t>
<t tx="felix.20201214150149.2">@others
</t>
<t tx="felix.20201214150149.3">[CMD.EXECUTE, () =&gt; p_leoUI.command(LEOCMD.EXECUTE_SCRIPT, { refreshType: REFRESH_ALL, finalFocus: Focus.NoChange })],

[CMD.MINIBUFFER, () =&gt; p_leoUI.minibuffer()], // Is referenced in package.json
[CMD.SET_LEO_ID, () =&gt; p_leoUI.setLeoIDCommand()],

[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; p_leoUI.clickAtButton(p_node)], // Not referenced in package.json
[CMD.GOTO_SCRIPT, (p_node: LeoButtonNode) =&gt; p_leoUI.gotoScript(p_node)],
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; p_leoUI.removeAtButton(p_node)],

</t>
<t tx="felix.20201214150149.4">[CMD.CLOSE_FILE, () =&gt; p_leoUI.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; p_leoUI.newLeoFile()],
[CMD.OPEN_FILE, (p_uri?: vscode.Uri) =&gt; p_leoUI.openLeoFile(p_uri)],
[CMD.SAVE_AS_FILE, () =&gt; p_leoUI.saveAsLeoFile()],
[CMD.SAVE_AS_LEOJS, () =&gt; p_leoUI.saveAsLeoJsFile()],
[CMD.SAVE_FILE, () =&gt; p_leoUI.saveLeoFile()],
[CMD.SAVE_FILE_FO, () =&gt; p_leoUI.saveLeoFile(true)],

[CMD.SWITCH_FILE, () =&gt; p_leoUI.switchLeoFile()],
[CMD.RECENT_FILES, () =&gt; p_leoUI.showRecentLeoFiles()],

[CMD.WRITE_AT_FILE_NODES, () =&gt; p_leoUI.command(LEOCMD.WRITE_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.WRITE_AT_FILE_NODES_FO, () =&gt; p_leoUI.command(LEOCMD.WRITE_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.WRITE_DIRTY_AT_FILE_NODES, () =&gt; p_leoUI.command(LEOCMD.WRITE_DIRTY_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.WRITE_DIRTY_AT_FILE_NODES_FO, () =&gt; p_leoUI.command(LEOCMD.WRITE_DIRTY_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.SET_OPENED_FILE, (p_index: number) =&gt; p_leoUI.selectOpenedLeoDocument(p_index, true)],

[CMD.REFRESH_FROM_DISK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.GIT_DIFF, () =&gt; p_leoUI.command(LEOCMD.GIT_DIFF, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

</t>
<t tx="felix.20201214150149.5">[CMD.HEADLINE, (p_node: Position) =&gt; p_leoUI.editHeadline(p_node, true)],
[CMD.HEADLINE_SELECTION, () =&gt; p_leoUI.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; p_leoUI.editHeadline(U, true)],

</t>
<t tx="felix.20201214150149.6">// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.COPY_PNODE, { node: p_node, refreshType: NO_REFRESH, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.CUT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.DELETE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PASTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PASTE_CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],

// cut/copy/paste/delete current selection (self.commander.p)
[CMD.COPY_SELECTION, () =&gt; p_leoUI.command(LEOCMD.COPY_PNODE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.CUT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.CUT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DELETE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.DELETE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.PASTE_CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.PASTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PASTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.SET_UA, () =&gt; p_leoUI.command(LEOCMD.SET_UA, { refreshType: REFRESH_TREE, finalFocus: Focus.NoChange })],

</t>
<t tx="felix.20201214150149.7">// Called by nodes in the tree when selected either by mouse, or with enter
[CMD.SELECT_NODE, (p_outlineNode: LeoOutlineNode) =&gt; p_leoUI.selectTreeNode(p_outlineNode.position, false)], // Select is NOT a Position!
[CMD.OPEN_ASIDE, (p_position: Position) =&gt; p_leoUI.selectTreeNode(p_position, true)],

[CMD.CONTRACT_ALL, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.CONTRACT_ALL_FO, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.CONTRACT_OR_GO_LEFT, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_OR_GO_LEFT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.EXPAND_AND_GO_RIGHT, () =&gt; p_leoUI.command(LEOCMD.EXPAND_AND_GO_RIGHT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

</t>
<t tx="felix.20201214150149.8">[CMD.GOTO_NEXT_CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { node: p_node, refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Body, isNavigation: true })],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

[CMD.GOTO_NEXT_MARKED, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_MARKED, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_FIRST_SIBLING, () =&gt; p_leoUI.command(LEOCMD.GOTO_FIRST_SIBLING, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_LAST_SIBLING, () =&gt; p_leoUI.command(LEOCMD.GOTO_LAST_SIBLING, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_FIRST_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_FIRST_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_LAST_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_LAST_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_PREV_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

[CMD.PAGE_UP, () =&gt; p_leoUI.command(LEOCMD.PAGE_UP, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.PAGE_DOWN, () =&gt; p_leoUI.command(LEOCMD.PAGE_DOWN, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

</t>
<t tx="felix.20201214150149.9">[CMD.DEHOIST, () =&gt; p_leoUI.command(LEOCMD.DEHOIST, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.DEHOIST_FO, () =&gt; p_leoUI.command(LEOCMD.DEHOIST, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.HOIST, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.HOIST_SELECTION, () =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.HOIST_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.CHAPTER_NEXT, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_NEXT, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.CHAPTER_BACK, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_BACK, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.CHAPTER_MAIN, () =&gt; p_leoUI.chapterMain()],
[CMD.CHAPTER_SELECT, () =&gt; p_leoUI.chapterSelect()],

</t>
<t tx="felix.20201214151326.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151326.10">/**
 * All commands this expansion exposes to the user via GUI/keybindings in package.json
 */
public static COMMANDS = {
    // Access to the Settings/Welcome Webview
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    STATUS_BAR: Constants.NAME + ".statusBar", // Status Bar Click Command
    // Leo Documents
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    CLEAR_RECENT_FILES: Constants.NAME + ".clearRecentFiles",
    // Import Export Commands
    IMPORT_ANY_FILE: Constants.NAME + ".importAnyFile",
    READ_FILE_INTO_NODE: Constants.NAME + ".readFileIntoNode",
    EXPORT_HEADLINES: Constants.NAME + ".exportHeadlines",
    FLATTEN_OUTLINE: Constants.NAME + ".flattenOutline",
    OUTLINE_TO_CWEB: Constants.NAME + ".outlineToCweb",
    OUTLINE_TO_NOWEB: Constants.NAME + ".outlineToNoweb",
    REMOVE_SENTINELS: Constants.NAME + ".removeSentinels",
    WEAVE: Constants.NAME + ".weave",
    WRITE_FILE_FROM_NODE: Constants.NAME + ".writeFileFromNode",
    // Leo Document Files
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile",
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline",
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    SAVE_AS_LEOJS: Constants.NAME + ".saveAsLeoJsFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    SET_LEO_ID: Constants.NAME + ".setLeoID",
    GIT_DIFF: Constants.NAME + ".gitDiff",
    WRITE_AT_FILE_NODES: Constants.NAME + ".writeAtFileNodes",
    WRITE_AT_FILE_NODES_FO: Constants.NAME + ".writeAtFileNodesFromOutline",
    WRITE_DIRTY_AT_FILE_NODES: Constants.NAME + ".writeDirtyAtFileNodes",
    WRITE_DIRTY_AT_FILE_NODES_FO: Constants.NAME + ".writeDirtyAtFileNodesFromOutline",
    // At-buttons
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    GOTO_SCRIPT: Constants.NAME + ".gotoScript",
    // Outline Node User Interaction
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside", // selects and opens body splitting the workspace
    // Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_FIRST_SIBLING: Constants.NAME + ".gotoFirstSibling",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection",
    SORT_CHILDREN_FO: Constants.NAME + ".sortChildrenSelectionFromOutline",
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    PREV_NODE: Constants.NAME + ".prev",
    PREV_NODE_FO: Constants.NAME + ".prevFromOutline",
    NEXT_NODE: Constants.NAME + ".next",
    NEXT_NODE_FO: Constants.NAME + ".nextFromOutline",
    // Commands from tree panel buttons or context: focus on OUTLINE
    SET_UA: Constants.NAME + ".setUa",
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    INSERT_CHILD: Constants.NAME + ".insertChildNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version
    INSERT_CHILD_SELECTION: Constants.NAME + ".insertChildNodeSelection", // Can be interrupted
    INSERT_CHILD_SELECTION_INTERRUPT: Constants.NAME + ".insertChildNodeSelectionInterrupt", // Can be interrupted
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // Commands from keyboard, while focus on OUTLINE (no need for COPY_SELECTION)
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    INSERT_CHILD_SELECTION_FO: Constants.NAME + ".insertChildNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    CHAPTER_NEXT: Constants.NAME + ".chapterNext",
    CHAPTER_BACK: Constants.NAME + ".chapterBack",
    CHAPTER_MAIN: Constants.NAME + ".chapterMain",
    CHAPTER_SELECT: Constants.NAME + ".chapterSelect",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",

    FIND_QUICK: Constants.NAME + ".findQuick",
    FIND_QUICK_SELECTED: Constants.NAME + ".findQuickSelected",
    FIND_QUICK_TIMELINE: Constants.NAME + ".findQuickTimeline",
    FIND_QUICK_CHANGED: Constants.NAME + ".findQuickChanged",
    FIND_QUICK_HISTORY: Constants.NAME + ".history",
    FIND_QUICK_MARKED: Constants.NAME + ".markedList",
    FIND_QUICK_GO_ANYWHERE: Constants.NAME + ".goAnywhere",
    GOTO_NAV_ENTRY: Constants.NAME + ".gotoNav",

    GOTO_NAV_PREV: Constants.NAME + ".gotoNavPrev",
    GOTO_NAV_NEXT: Constants.NAME + ".gotoNavNext",
    GOTO_NAV_FIRST: Constants.NAME + ".gotoNavFirst",
    GOTO_NAV_LAST: Constants.NAME + ".gotoNavLast",

    START_SEARCH: Constants.NAME + ".startSearch",
    FIND_ALL: Constants.NAME + ".findAll",
    FIND_NEXT: Constants.NAME + ".findNext",
    FIND_NEXT_FO: Constants.NAME + ".findNextFromOutline",
    FIND_PREVIOUS: Constants.NAME + ".findPrevious",
    FIND_PREVIOUS_FO: Constants.NAME + ".findPreviousFromOutline",
    FIND_VAR: Constants.NAME + ".findVar",
    FIND_DEF: Constants.NAME + ".findDef",
    REPLACE: Constants.NAME + ".replace",
    REPLACE_FO: Constants.NAME + ".replaceFromOutline",
    REPLACE_THEN_FIND: Constants.NAME + ".replaceThenFind",
    REPLACE_THEN_FIND_FO: Constants.NAME + ".replaceThenFindFromOutline",
    REPLACE_ALL: Constants.NAME + ".replaceAll",

    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_TAG: Constants.NAME + ".cloneFindTag",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
    // TODO
    CLONE_FIND_PARENTS: Constants.NAME + ".cloneFindParents",
    GOTO_GLOBAL_LINE: Constants.NAME + ".gotoGlobalLine",
    TAG_CHILDREN: Constants.NAME + ".tagChildren",
    TAG_NODE: Constants.NAME + ".tagNode",
    REMOVE_TAG: Constants.NAME + ".removeTag",
    REMOVE_TAGS: Constants.NAME + ".removeTags",
    SET_FIND_EVERYWHERE_OPTION: Constants.NAME + ".setFindEverywhereOption",
    SET_FIND_NODE_ONLY_OPTION: Constants.NAME + ".setFindNodeOnlyOption",
    SET_FIND_FILE_ONLY_OPTION: Constants.NAME + ".setFindFileOnlyOption",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: Constants.NAME + ".setFindSuboutlineOnlyOption",
    TOGGLE_FIND_IGNORE_CASE_OPTION: Constants.NAME + ".toggleFindIgnoreCaseOption",
    TOGGLE_FIND_MARK_CHANGES_OPTION: Constants.NAME + ".toggleFindMarkChangesOption",
    TOGGLE_FIND_MARK_FINDS_OPTION: Constants.NAME + ".toggleFindMarkFindsOption",
    TOGGLE_FIND_REGEXP_OPTION: Constants.NAME + ".toggleFindRegexpOption",
    TOGGLE_FIND_WORD_OPTION: Constants.NAME + ".toggleFindWordOption",
    TOGGLE_FIND_SEARCH_BODY_OPTION: Constants.NAME + ".toggleFindSearchBodyOption",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: Constants.NAME + ".toggleFindSearchHeadlineOption",
    SET_ENABLE_PREVIEW: Constants.NAME + ".setEnablePreview",
    CLEAR_CLOSE_EMPTY_GROUPS: Constants.NAME + ".clearCloseEmptyGroups",
};

</t>
<t tx="felix.20201214151326.11">/**
 * Leo command names that are called from vscode's gui/menu/buttons/keybindings triggers
 */
public static LEO_COMMANDS = {

    // * File Commands
    NEW: 'new',
    OPEN_OUTLINE: 'open_outline',
    WRITE_AT_FILE_NODES: 'write-at-file-nodes',
    WRITE_DIRTY_AT_FILE_NODES: 'write-dirty-at-file-nodes',

    // * More Commands
    //  TODO
    // GOTO_GLOBAL_LINE: "!goto_global_line",
    // TAG_CHILDREN: "!tag_children",
    SET_UA: 'set-ua',
    // START_SEARCH: "!start_search",
    // FIND_ALL: "!find_all",
    // FIND_NEXT: "!find_next",
    // FIND_PREVIOUS: "!find_previous",
    // FIND_VAR: "!find_var",
    // FIND_DEF: "!find_def",
    // REPLACE: "!replace",
    // REPLACE_THEN_FIND: "!replace_then_find",
    // REPLACE_ALL: "!replace_all",

    // * Undo Operations
    UNDO: "undo",
    REDO: "redo",
    // * Tree Building
    EXECUTE_SCRIPT: "execute-script",
    REFRESH_FROM_DISK: "TODO_REFRESH_FROM_DISK", // TODO
    REFRESH_FROM_DISK_PNODE: "TODO_REFRESH_FROM_DISK_PNODE", // TODO
    GIT_DIFF: "TODO_GIT_DIFF", // TODO
    // * Outline from body text
    EXTRACT: "TODO_EXTRACT", // TODO
    EXTRACT_NAMES: "TODO_EXTRACT_NAMES", // TODO
    // * Hoist Operations
    HOIST_PNODE: "hoist",
    DEHOIST: "de-hoist",
    CHAPTER_NEXT: "chapter-next",
    CHAPTER_BACK: "chapter-back",
    // * History Navigation
    GOTO_PREV_HISTORY: "goto-prev-history-node",
    GOTO_NEXT_HISTORY: "goto-next-history-node",
    // * Goto &amp; Folding
    PAGE_UP: "tree-page-up",
    PAGE_DOWN: "tree-page-down",
    GOTO_FIRST_VISIBLE: "goto-first-visible-node",
    GOTO_LAST_VISIBLE: "goto-last-visible-node",
    GOTO_FIRST_SIBLING: "goto-first-sibling",
    GOTO_LAST_SIBLING: "goto-last-sibling",
    GOTO_NEXT_VISIBLE: "goto-next-visible",
    GOTO_PREV_VISIBLE: "goto-prev-visible",
    GOTO_NEXT_MARKED: "goto-next-marked",
    GOTO_NEXT_CLONE: "goto-next-clone",
    CONTRACT_OR_GO_LEFT: "contract-or-go-left",
    EXPAND_AND_GO_RIGHT: "expand-and-go-right",
    CONTRACT_ALL: "contract-all",
    // * Mark Operations
    TOGGLE_MARK: "toggle-mark",
    COPY_MARKED: "copy-marked-nodes",
    DIFF_MARKED_NODES: "diff-marked-nodes", // TODO from leoCompare.py
    MARK_CHANGED_ITEMS: "mark-changed-items",
    MARK_SUBHEADS: "mark-subheads",
    UNMARK_ALL: "unmark-all",
    CLONE_MARKED_NODES: "clone-marked-nodes",
    DELETE_MARKED_NODES: "delete-marked-nodes",
    MOVE_MARKED_NODES: "move-marked-nodes",
    // * Clipboard Operations
    COPY_PNODE: "copy-node",
    CUT_PNODE: "cut-node",
    PASTE_PNODE: "async-paste-node",
    PASTE_CLONE_PNODE: "async-paste-retaining-clones",
    // * Outline Editing
    DELETE_PNODE: "delete-node",
    MOVE_PNODE_DOWN: "move-outline-down",
    MOVE_PNODE_LEFT: "move-outline-left",
    MOVE_PNODE_RIGHT: "move-outline-right",
    MOVE_PNODE_UP: "move-outline-up",
    INSERT_PNODE: "insert-node",
    INSERT_CHILD_PNODE: "insert-child",
    CLONE_PNODE: "clone-node",
    // * Marshalling Operations
    PROMOTE_PNODE: "promote",
    DEMOTE_PNODE: "demote",
    SORT_CHILDREN: "sort-children",
    SORT_SIBLINGS: "sort-siblings",
    // * Clone-find functionality
    CLONE_FIND_ALL: "TODO_CLONE_FIND_ALL", // TODO
    CLONE_FIND_ALL_FLATTENED: "TODO_CLONE_FIND_ALL_FLATTENED", // TODO
    CLONE_FIND_MARKED: "TODO_CLONE_FIND_MARKED", // TODO
    CLONE_FIND_FLATTENED_MARKED: "TODO_CLONE_FIND_FLATTENED_MARKED", // TODO
    CLONE_FIND_PARENTS: "TODO_CLONE_FIND_PARENTS", // TODO
};

</t>
<t tx="felix.20201214151326.2">/**
 * Text and numeric constants used throughout leojs
 */
export class Constants {

    /**
     * Identity of account that can publish extensions to the Visual Studio Code Marketplace. 
     */
    public static PUBLISHER: string = "boltex";

    /**
     * The name of the extension - should be all lowercase with no spaces.
     */
    @others
}
</t>
<t tx="felix.20201214151326.3">public static NAME: string = "leojs";

public static TREEVIEW_ID: string = "leojsOutline";
public static TREEVIEW_EXPLORER_ID: string = "leojsOutlineExplorer";

public static DOCUMENTS_ID: string = "leojsDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leojsDocumentsExplorer";

public static BUTTONS_ID: string = "leojsButtons";
public static BUTTONS_EXPLORER_ID: string = "leojsButtonsExplorer";

public static FIND_ID: string = "leojsFindPanel";
public static FIND_EXPLORER_ID: string = "leojsFindPanelExplorer";

public static GOTO_ID: string = "leojsGotoPanel";
public static GOTO_EXPLORER_ID: string = "leojsGotoPanelExplorer";

public static UNDOS_ID: string = "leojsUndos";
public static UNDOS_EXPLORER_ID: string = "leojsUndosExplorer";

public static VERSION_STATE_KEY: string = "leojsVersion";

public static FILE_EXTENSION: string = "leo";
public static DB_FILE_EXTENSION: string = "db";
public static JS_FILE_EXTENSION: string = "leojs";

public static LEO_LANGUAGE_PREFIX: string = "leojsbody."; // all lowercase.

public static URI_LEO_SCHEME: string = "leojs";
public static URI_FILE_SCHEME: string = "file";
public static URI_SCHEME_HEADER: string = "leojs:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files"; // Meant for all 3 leo, db and leojs.
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leojsRecentFiles";
public static LAST_FILES_KEY: string = "leojsLastFiles";

public static STATUSBAR_DEBOUNCE_DELAY: number = 70;
public static REFRESH_DEBOUNCE_DELAY: number = 50;
public static STATES_DEBOUNCE_DELAY: number = 60;
public static TITLE_DEBOUNCE_DELAY: number = 20;
public static BUTTONS_DEBOUNCE_DELAY: number = 160;
public static DOCUMENTS_DEBOUNCE_DELAY: number = 80;
public static UNDOS_DEBOUNCE_DELAY: number = 140;
public static UNDOS_REVEAL_DEBOUNCE_DELAY: number = 50;
public static GOTO_DEBOUNCE_DELAY: number = 50;
public static BODY_STATES_DEBOUNCE_DELAY: number = 120;

public static CONFIG_NAME: string = "leojs";
public static CONFIG_WORKBENCH_ENABLED_PREVIEW: string = "workbench.editor.enablePreview";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

</t>
<t tx="felix.20201214151326.4">/**
 * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_PARENT: "resources/light/parent.svg",
    ICON_DARK_PARENT: "resources/dark/parent.svg",
    ICON_LIGHT_NODE: "resources/light/node.svg",
    ICON_DARK_NODE: "resources/dark/node.svg",
    ICON_LIGHT_BODY: "resources/light/body.svg",
    ICON_DARK_BODY: "resources/dark/body.svg",
    ICON_LIGHT_TAG: "resources/light/tag.svg",
    ICON_DARK_TAG: "resources/dark/tag.svg",

    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",

    ICON_LIGHT_UNDO_ACTIVE: "resources/light/undo.svg",
    ICON_DARK_UNDO_ACTIVE: "resources/dark/undo.svg",
    ICON_LIGHT_UNDO: "resources/dark/undo.svg",
    ICON_DARK_UNDO: "resources/light/undo.svg",
    ICON_LIGHT_REDO_ACTIVE: "resources/light/redo.svg",
    ICON_DARK_REDO_ACTIVE: "resources/dark/redo.svg",
    ICON_LIGHT_REDO: "resources/dark/redo.svg",
    ICON_DARK_REDO: "resources/light/redo.svg",

    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_RCLICK: "resources/light/button-rclick.svg",
    ICON_DARK_BUTTON_RCLICK: "resources/dark/button-rclick.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",

    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    SVG_SHEME: "data",
    SVG_OPEN: 'image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"&gt;',
    SVG_CLOSE: "&lt;/svg&gt;",
    STATUSBAR_INDICATOR: "$(keyboard) ",
    STATUSBAR_COLOR: "fb7c47",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leojs: ",
    EXPLORER_TREEVIEW_PREFIX: "LEOJS ",
    TREEVIEW_TITLE: "OUTLINE",
    BODY_TITLE: "LEOJS BODY",
    LOG_PANE_TITLE: "LeoJS Log Window",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20201214151326.5">/**
 * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "Creates a button from selected node's script",
    SCRIPT_BUTTON_TOOLTIP:
        "The 'Script Button' button creates a new button.\n" +
        "Its name will be the headline of the presently selected node\n" +
        "Hitting this newly created button executes the button's script.\n" +
        "\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing a script. (Ex.: \"g.es(p.h)\")\n" +
        "2.  Press 'Script Button'. This will create a new button.\n" +
        "3.  Select a node on which you want to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    SAVE_DIALOG_LABEL: "Save Leo File",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOJS: "Open this Leojs file?",
    OPEN_RECENT_FILE: "Open Recent Leojs File",
    RIGHT_CLICK_TO_OPEN: "Right-click to open with leojs",
    FILE_ALREADY_OPENED: "Leojs file already opened",

    CLEARED_RECENT: "Cleared recent files list",
    CHOOSE_OPENED_FILE: "Select an opened Leojs File",
    FILE_NOT_OPENED: "No files opened.",
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    DEFAULT_HEADLINE: "New Headline",
    TITLE_GOTO_GLOBAL_LINE: "Goto global line",
    PLACEHOLDER_GOTO_GLOBAL_LINE: "#",
    PROMPT_GOTO_GLOBAL_LINE: "Line number",

    TITLE_TAG_CHILDREN: "Tag Children",
    TITLE_REMOVE_TAG: "Remove Tag",
    TITLE_TAG_NODE: "Tag Node",
    PLACEHOLDER_TAG: "&lt;tag&gt;",
    PROMPT_TAG: "Enter a tag name",

    CLOSE_ERROR: "Cannot close: No files opened.",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    CHOOSE_BUTTON: "Choose @button or @rclick",
    SEARCH_POSITION_BY_HEADLINE: "Search positions by headline",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    SELECT_CHAPTER_PROMPT: "Select chapter",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "Leo is busy! ", // with voluntary trailing space

    UNKNOWN_LANGUAGE_NOT_SUPPORTED: "Language not yet supported.",
    LANGUAGE_NOT_SUPPORTED: " language not yet supported.", // with leading space
    MINIBUFFER_BUTTON_START: "@button-",
    MINIBUFFER_DEL_BUTTON_START: "delete-@button-",
    MINIBUFFER_COMMAND_START: "@command-",
    MINIBUFFER_USER_DEFINED: "$(run) User defined command.",
    MINIBUFFER_HISTORY_LABEL: "Minibuffer History",
    MINIBUFFER_HISTORY_DESC: "$(history) Choose from last run commands...",

    ZOOM_LEVEL_RANGE_LIMIT: "Value for zoom level should be between -12 and 12",
    FONT_SIZE_RANGE_LIMIT: "Value for font size should be between 6 and 30",
    FIX_IT: "Fix it",
    ENABLE_PREVIEW_SET: "'Enable Preview' setting was set",
    ENABLE_PREVIEW_RECOMMEND: "'Enable Preview' setting is recommended (currently disabled)",
    CLOSE_EMPTY_CLEARED: "'Close Empty Groups' setting was cleared",
    CLOSE_EMPTY_RECOMMEND: "'Close Empty Groups' setting is NOT recommended!",
    CLOSE_ON_DELETE_SET: "'Close on File Delete' setting was set",
    CLOSE_ON_DELETE_RECOMMEND: "'Close on File Delete' setting is recommended (currently disabled)",
    SET_LEO_ID_MESSAGE: "Leo ID not found. Please enter an id that identifies you uniquely.",
    GET_LEO_ID_PROMPT: "Please enter an id that identifies you uniquely.\n(Letters and numbers only, and at least 3 characters in length)",
    ENTER_LEO_ID: "Enter Leo id"
};

</t>
<t tx="felix.20201214151326.6">/**
 * * Strings used in 'at-button' panel display in LeoButtonNode
 */
public static BUTTON_STRINGS = {
    NULL_WIDGET: "nullButtonWidget",
    SCRIPT_BUTTON: "script-button",
    ADD_BUTTON: "leoButtonAdd",
    NORMAL_BUTTON: "leoButtonNode"
};

</t>
<t tx="felix.20201214151326.7">/**
 * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20201214151326.8">/**
 * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    LEO_STARTUP_DONE: "leojsStartupDone",
    LEO_READY: "leojsReady", // Extension activated and classes created and ready
    TREE_OPENED: "leojsTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leojsTreeTitled", // Tree is a Leo file and not a new untitled document

    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leojsChanged",
    LEO_CAN_UNDO: "leojsCanUndo",
    LEO_CAN_REDO: "leojsCanRedo",
    LEO_CAN_BACK: "leojsCanGoBack",
    LEO_CAN_NEXT: "leojsCanGoNext",
    LEO_CAN_DEMOTE: "leojsCanDemote",
    LEO_CAN_PROMOTE: "leojsCanPromote",
    LEO_CAN_DEHOIST: "leojsCanDehoist",
    LEO_CAN_HOIST: "leojsCanHoist", // isNotRoot equivalent, Computed by hand
    LEO_IN_CHAPTER: "leojsInChapter", // TODO
    LEO_TOP_HOIST_CHAPTER: "leojsTopHoistChapter", // TODO

    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leojsMarked", // no need for unmarked here, use !leojsMarked
    SELECTED_CLONE: "leojsCloned",
    SELECTED_DIRTY: "leojsDirty",
    SELECTED_EMPTY: "leojsEmpty",
    SELECTED_CHILD: "leojsChild", // Has children
    SELECTED_ATFILE: "LeojsAtFile", // Can be refreshed

    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leojsObjectSelected", // keybindings "On": Outline or body has focus

    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leojsNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leojsNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leojsNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leojsNodeCloned",
    NODE_ROOT: "leojsNodeRoot",
    NODE_NOT_ROOT: "leojsNodeNotRoot",

    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leojsDocumentSelectedTitled",
    DOCUMENT_TITLED: "leojsDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leojsDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leojsDocumentUntitled",

    // Flags for focus context
    FOCUS_FIND: "leojsFindFocus",

    // Context flags that are mapped 'directly' onto leojs config settings
    // * PREFIXED WITH 'leojs' *
    LEO_TREE_BROWSE: Constants.NAME + Constants.CONFIG_NAMES.LEO_TREE_BROWSE[0].toUpperCase() + Constants.CONFIG_NAMES.LEO_TREE_BROWSE.slice(1), // Force ar'jan's suggestion of Leo's tree behavior override
    TREE_IN_EXPLORER: Constants.NAME + Constants.CONFIG_NAMES.TREE_IN_EXPLORER[0].toUpperCase() + Constants.CONFIG_NAMES.TREE_IN_EXPLORER.slice(1), // Leo outline also in the explorer view
    SHOW_OPEN_ASIDE: Constants.NAME + Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE.slice(1),   // Show 'open aside' in context menu
    SHOW_EDIT: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EDIT[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EDIT.slice(1),              // Hover Icons on outline nodes
    SHOW_ARROWS: Constants.NAME + Constants.CONFIG_NAMES.SHOW_ARROWS[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_ARROWS.slice(1),           // Hover Icons on outline nodes
    SHOW_ADD: Constants.NAME + Constants.CONFIG_NAMES.SHOW_ADD[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_ADD.slice(1),                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.NAME + Constants.CONFIG_NAMES.SHOW_MARK[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_MARK.slice(1),               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.NAME + Constants.CONFIG_NAMES.SHOW_CLONE[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_CLONE.slice(1),             // Hover Icons on outline nodes
    SHOW_COPY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_COPY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_COPY.slice(1),               // Hover Icons on outline nodes

    // SHOW_EDITION_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EDITION_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EDITION_BODY.slice(1),
    // SHOW_CLIPBOARD_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY.slice(1),
    // SHOW_PROMOTE_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY.slice(1),
    // SHOW_EXECUTE_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY.slice(1),
    // SHOW_EXTRACT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY.slice(1),
    // SHOW_IMPORT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_IMPORT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_IMPORT_BODY.slice(1),
    // SHOW_REFRESH_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_REFRESH_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_REFRESH_BODY.slice(1),
    // SHOW_HOIST_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_HOIST_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_HOIST_BODY.slice(1),
    // SHOW_MARK_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_MARK_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_MARK_BODY.slice(1),
    // SHOW_SORT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_SORT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_SORT_BODY.slice(1)
};

</t>
<t tx="felix.20201214151326.9">/**
 * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20201214151419.1">import * as vscode from "vscode";
import { Icon, LeoButton } from "./types";
import { Constants } from "./constants";
import { LeoStates } from "./leoStates";

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20201214151419.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private fakeAtButtons: LeoButton[] = [
        { name: 'script-button', index: 'nullButtonWidget' },
        { name: 'button name 2', index: 'key2' },
        { name: 'button name 3', index: 'key3' },
    ];

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _icons: Icon[],
    ) { }

    @others
}

</t>
<t tx="felix.20201214151419.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201214151419.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20201214151419.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {
    const w_children: LeoButtonNode[] = [];
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element) {
        this.fakeAtButtons.forEach(p_button =&gt; {
            w_children.push(new LeoButtonNode(p_button, this._icons));
        });
    }
    return Promise.resolve(w_children); // Defaults to an empty list of children
}

</t>
<t tx="felix.20201214151419.6">public getParent(element: LeoButtonNode): vscode.ProviderResult&lt;LeoButtonNode&gt; | null {
    // Buttons are just a list, as such, entries are always child of root so return null
    return null;
}

</t>
<t tx="felix.20201214151425.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;

    // is the special 'add' button used to create button from a given node's script
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _buttonIcons: Icon[], // pointer to global array of node icons
    ) {
        super(button.name);
        // Setup this instance (just differentiate 'script-button' for now)
        this.command = {
            command: Constants.COMMANDS.CLICK_BUTTON,
            title: '',
            arguments: [this]
        };
        this._isAdd = (this.button.index.startsWith(Constants.BUTTON_STRINGS.NULL_WIDGET) &amp;&amp;
            this.button.name === Constants.BUTTON_STRINGS.SCRIPT_BUTTON);
        this.contextValue = this._isAdd ? Constants.BUTTON_STRINGS.ADD_BUTTON : Constants.BUTTON_STRINGS.NORMAL_BUTTON;
    }

    @others
}

</t>
<t tx="felix.20201214151425.3">// @ts-ignore
public get iconPath(): Icon {
    return this._buttonIcons[this._isAdd ? 1 : 0];
}

</t>
<t tx="felix.20201214151425.4">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to index to prevent accidental duplicates
    return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20201214151425.5">// @ts-ignore
public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20201214151425.6">// @ts-ignore
public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20201214151429.1">import * as vscode from "vscode";
import { LeoUI } from './leoUI';
import { LeoStates } from "./leoStates";
import { Constants } from "./constants";
import * as utils from "./utils";
import * as g from './core/leoGlobals';
import { Commands } from "./core/leoCommands";
import { LeoFrame } from "./core/leoFrame";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151429.2">/**
 * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoFrame&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoFrame | undefined&gt; = new vscode.EventEmitter&lt;LeoFrame | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoFrame | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _leoUI: LeoUI,
    ) { }

    @others
}

</t>
<t tx="felix.20201214151429.3">/**
 * Refresh the whole Leo Document panel
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201214151429.4">public getTreeItem(element: LeoFrame): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return new LeoDocumentNode(element, this._leoUI,);
}

</t>
<t tx="felix.20201214151429.5">public getChildren(element?: LeoFrame): LeoFrame[] {
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element) {
        return g.app.windowList;
    } else {
        return []; // Should not happen!
    }
}

</t>
<t tx="felix.20201214151429.6">public getParent(element: LeoFrame): vscode.ProviderResult&lt;LeoFrame&gt; {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return undefined;
}

</t>
<t tx="felix.20201214151434.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    constructor(
        public frame: LeoFrame,
        private _leoUI: LeoUI,
    ) {
        super(frame.c.fileName() ? utils.getFileFromPath(frame.c.fileName()) : frame.title);

        const c: Commands = frame.c;
        const isNamed: boolean = !!c.fileName();
        this.label = isNamed ? utils.getFileFromPath(c.fileName()) : frame.title;
        this.tooltip = isNamed ? c.fileName() : frame.title;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [g.app.windowList.indexOf(frame)]
        };

        if (frame === g.app.windowList[this._leoUI.frameIndex]) {
            // If this was created as a selected node, make sure it's selected
            this._leoUI.setDocumentSelection(frame);
            this.contextValue = isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }

        this.id = `d${g.app.windowList.indexOf(frame)}f${c.fileName()}c${c.changed.toString()}`;
        this.iconPath = this._leoUI.documentIcons[c.changed ? 1 : 0];
    }

}
</t>
<t tx="felix.20201214151447.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { LeoUI } from "./leoUI";
import { Constants } from "./constants";
import { LeoPackageStates } from "./types";
import { Position } from "./core/leoNodes";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151447.10">/**
 * Current selection allows promote command
 */
private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20201214151447.11">/**
 * Currently selected can de-hoist state
 */
private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20201214151447.12"></t>
<t tx="felix.20201214151447.13">// * 'states' flags about current selection, for visibility and commands availability
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20201214151447.14">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20201214151447.15">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20201214151447.16">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20201214151447.17">private _leoChild: boolean = false;
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20201214151447.18">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20201214151447.19">// * Special is-root 'state' flag about current selection, for visibility and commands availability
private _leoRoot: boolean = false;
get leoRoot(): boolean {
    return this._leoRoot;
}
set leoRoot(p_value: boolean) {
    this._leoRoot = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_HOIST, !p_value);
}

</t>
<t tx="felix.20201214151447.2">/**
 * * Global states service
 * Holds state flags used to restrict command availability and icon visibility
 * Changes UI by changing vscode's context variables
 */
export class LeoStates {

    public qLastContextChange: Thenable&lt;unknown&gt;; // Promise that the last state change is applied

    @others
}
</t>
<t tx="felix.20201214151447.20">constructor(
    private _context: vscode.ExtensionContext,
    private _leoJs: LeoUI
) {
    this.qLastContextChange = Promise.resolve(); // Temporary.
}

</t>
<t tx="felix.20201214151447.21">public setSelectedNodeFlags(p_node: Position): void {
    this.leoMarked = p_node.isMarked();
    this.leoCloned = p_node.isCloned();
    this.leoDirty = p_node.isDirty();
    this.leoEmpty = !p_node.v.hasBody();
    this.leoChild = p_node.hasChildren();
    this.leoAtFile = p_node.isAtFileNode();
    this.leoRoot = p_node._isRoot;
}

</t>
<t tx="felix.20201214151447.22">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoChanged = p_states.changed;
    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;
    this.leoCanGoBack = p_states.canGoBack;
    this.leoCanGoNext = p_states.canGoNext;
    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;
    this.leoCanDehoist = p_states.canDehoist;
    this.leoRoot = !p_states.canHoist;
}
</t>
<t tx="felix.20201214151447.3"></t>
<t tx="felix.20201214151447.4">/**
 * A Leo file is opened
 */
private _fileOpenedReady: boolean = false; // Sets context flag along with treeview title
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.5">/**
 * Currently opened Leo file path and name, empty string if new unsaved file.
 */
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {
    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.6">/**
 * Currently opened commander is dirty
 */
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    if (this._leoChanged !== p_value) {
        // Refresh Documents Panel
        // ? Needed?
        this._leoJs.refreshDocumentsPane();
    }
    this._leoChanged = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.7">/**
 * Undo operation available state
 */
private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20201214151447.8">/**
 * Redo operation available state
 */
private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20201214151447.9">/**
 * Current selection allows demote command
 */
private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20201214151451.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoUI } from "./leoUI";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151451.2">/**
 * * Statusbar indicator controller service
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _statusbarNormalColor = new vscode.ThemeColor(Constants.GUI.THEME_STATUSBAR);  // "statusBar.foreground"
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the default from config

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoJs: LeoUI
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._context.subscriptions.push(this._leoStatusBarItem); // Disposable 

        this._leoStatusBarItem.color = Constants.GUI.STATUSBAR_COLOR;
        // this._leoStatusBarItem.command = Constants.COMMANDS.SWITCH_FILE;
        this._leoStatusBarItem.command = Constants.COMMANDS.SHOW_LOG;
        // this._leoStatusBarItem.command = "leojs.test"; // just call test function for now to help debugging
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;

        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20201214151451.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20201214151451.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20201214151451.5">/**
 * * Sets string to replace default from config &amp; refresh it
 */
public setString(p_string: string): void {
    this._string = p_string;
    this._updateLeoObjectIndicator();
}

</t>
<t tx="felix.20201214151451.6">/**
 * * Updates the status bar visual indicator visual indicator with optional debouncing delay
 * @param p_state True/False flag for On or Off status
 * @param p_debounceDelay Optional, in milliseconds
 */
public update(p_state: boolean, p_debounceDelay?: number, p_forced?: boolean): void {
    if (p_forced || (p_state !== this.statusBarFlag)) {
        this.statusBarFlag = p_state;
        if (p_debounceDelay) {
            this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
        } else {
            this._updateLeoObjectIndicator();
        }
    }
}

</t>
<t tx="felix.20201214151451.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20201214151451.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }

    utils.setContext(Constants.CONTEXT_FLAGS.LEO_SELECTED, !!this.statusBarFlag);

    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR +
        (this._string ? this._string : '') + " " +
        (this._leoJs.leoStates.leoOpenedFileName ? utils.getFileFromPath(this._leoJs.leoStates.leoOpenedFileName) : Constants.UNTITLED_FILE_NAME);

    // Also check in constructor for statusBar properties (the createStatusBarItem call itself)
    if (this.statusBarFlag &amp;&amp; this._leoJs.leoStates.fileOpenedReady) {
        this._leoStatusBarItem.color = "#" + Constants.GUI.STATUSBAR_COLOR;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
    } else {
        this._leoStatusBarItem.color = this._statusbarNormalColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_OFF;
    }
}

</t>
<t tx="felix.20201214154816.1">import * as vscode from "vscode";
import { Position } from "./core/leoNodes";
import { LeoOutlineNode } from "./leoOutline";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214154816.10">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string | vscode.Uri;
    dark: string | vscode.Uri;
}

</t>
<t tx="felix.20201214154816.11">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    "initialFile": string;
    "title": string;
    "message": string;
    "filetypes": string[];
    "defaultExtension": string;
}

</t>
<t tx="felix.20201214154816.12">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    "ask": string;
    "message": string;
    "yes_all": boolean;
    "no_all": boolean;
}

</t>
<t tx="felix.20201214154816.13">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    "warn": string;
    "message": string;
}

</t>
<t tx="felix.20201214154816.14">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    "message": string;
}

</t>
<t tx="felix.20201214154816.15">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20201214154816.16">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20201214154816.17">/**
 * * Used by the minibuffer command pallette
 */
export interface MinibufferCommand extends vscode.QuickPickItem {
    func: string;
}
</t>
<t tx="felix.20201214154816.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // Re-use the old treeId with "NoReveal" for the selected node.
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20201214154816.4">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    scroll?: boolean; // Body needs to set and reveal text selection

    states?: boolean; // Currently opened tree view states needs refresh:
    // changed, canUndo, canRedo, canGoBack, canGoNext, canDemote, canPromote, 
    // canHoist, canDehoist, inChapter, topHoistChapter

    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
    goto?: boolean; // Goto pane needs refresh
}

</t>
<t tx="felix.20201214154816.6">/**
 * * Object container for parameters of leoJs "apply-selected-node-to-body" method
 */
export interface ShowBodyParam {
    node: LeoOutlineNode,
    aside: boolean,
    showBodyKeepFocus: boolean,
    force_open?: boolean
}

</t>
<t tx="felix.20201214154816.7">/**
 * * General state flags for UI representation and controls visibility.
 */
export interface LeoPackageStates {
    changed: boolean; // Leo document has changed (is dirty)
    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'
    canGoBack: boolean; // Has history
    canGoNext: boolean; // Has used goBack at least once
    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted
    canDehoist: boolean; // Leo Document is currently hoisted and can be de-hoisted
    canHoist: boolean; // Selected node is not the first top node already root
}

</t>
<t tx="felix.20201214154816.8">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20201214154816.9">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider
 */
export interface LeoButton {
    name: string;
    index: string; // STRING KEY
}

</t>
<t tx="felix.20201214194144.1">import * as vscode from "vscode";
import { Utils as uriUtils } from "vscode-uri";
import { debounce } from "lodash";
import * as path from 'path';

import * as utils from "./utils";
import * as commandBindings from "./commandBindings";
import { Constants } from "./constants";
import {
    RevealType,
    Icon,
    ReqRefresh,
    LeoPackageStates,
    ConfigSetting,
    LeoSearchSettings,
    Focus,
    BodySelectionInfo,
    CommandOptions,
    LeoGotoNavKey,
    LeoGuiFindTabManagerSettings
} from "./types";

import { Config } from "./config";
import { LeoOutlineProvider } from './leoOutline';
import { LeoButtonNode, LeoButtonsProvider } from "./leoButtons";
import { LeoDocumentsProvider } from "./leoDocuments";
import { LeoStates } from "./leoStates";
import { LeoBodyProvider } from "./leoBody";
import { LeoUndoNode, LeoUndosProvider } from "./leoUndos";

import * as g from './core/leoGlobals';
import { Commands } from "./core/leoCommands";
import { Position } from "./core/leoNodes";
import { LeoGotoNode, LeoGotoProvider } from "./leoGoto";
import { LeoFrame } from "./core/leoFrame";
import { LeoFindPanelProvider } from "./leoFindPanelWebview";
import { ISettings } from "./core/leoFind";
import { NullGui } from "./core/leoGui";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214194144.2">constructor(guiName = 'vscodeGui', private _context: vscode.ExtensionContext) {
    super(guiName);
    this.isNullGui = false;

    // * Log pane instanciation
    this._leoLogPane = vscode.window.createOutputChannel(Constants.GUI.LOG_PANE_TITLE);
    this._context.subscriptions.push(this._leoLogPane);

    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);

    // * Set required vscode configs if needed
    this.config.checkEnablePreview(true);
    this.config.checkCloseEmptyGroups(true);

    // * also check workbench.editor.enablePreview
    this.config.buildFromSavedSettings();
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.undoIcons = utils.buildUndoIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);
    this.gotoIcons = utils.buildGotoIconPaths(_context);

    // * Debounced refresh flags and UI parts, other than the tree and body, when operation(s) are done executing
    this.getStates = debounce(
        this._triggerGetStates,
        Constants.STATES_DEBOUNCE_DELAY
    );
    this.setTreeViewTitle = debounce(
        this._setTreeViewTitle,
        Constants.TITLE_DEBOUNCE_DELAY
    );
    this.refreshDocumentsPane = debounce(
        this._refreshDocumentsPane,
        Constants.DOCUMENTS_DEBOUNCE_DELAY
    );
    this.refreshButtonsPane = debounce(
        this._refreshButtonsPane,
        Constants.BUTTONS_DEBOUNCE_DELAY
    );
    this.refreshGotoPane = debounce(
        this._refreshGotoPane,
        Constants.GOTO_DEBOUNCE_DELAY
    );
    this.refreshUndoPane = debounce(
        this._refreshUndoPane,
        Constants.UNDOS_DEBOUNCE_DELAY
    );
    this.setUndoSelection = debounce(
        this._setUndoSelection,
        Constants.UNDOS_REVEAL_DEBOUNCE_DELAY
    );
    this.launchRefresh = debounce(
        this._launchRefresh,
        Constants.REFRESH_DEBOUNCE_DELAY
    );

</t>
<t tx="felix.20201214194144.3"></t>
<t tx="felix.20201214194144.4"></t>
<t tx="felix.20201214194144.5"></t>
<t tx="felix.20201214194144.6"></t>
<t tx="felix.20201214194144.7"></t>
<t tx="felix.20201214194144.8"></t>
<t tx="felix.20201214195752.1">/**
 * Creates and manages instances of the UI elements along with their events
 */
export class LeoUI extends NullGui {
    // * State flags
    public leoStates: LeoStates;
    public verbose: boolean = true;
    public trace: boolean = false; //true;

    private _minibufferHistory: string[] = [];
    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE; // VScode's outline pane title: Might need to be re-set when switching visibility
    private _hasShownContextOpenMessage: boolean = false;

    // * Timers
    public refreshTimer: [number, number] | undefined; // until the selected node is found - even if already started refresh
    public lastRefreshTimer: [number, number] | undefined; // until the selected node is found - refreshed even if not found
    public commandRefreshTimer: [number, number] | undefined; // until the selected node is found -  keep if starting a new command already pending
    public lastCommandRefreshTimer: [number, number] | undefined; // until the selected node is found - refreshed if starting a new command
    public commandTimer: [number, number] | undefined; // until the command done - keep if starting a new one already pending
    public lastCommandTimer: [number, number] | undefined; // until the command done - refreshed if starting a new one

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, and leoNode for inverted contrast

    // * Icon Paths (Singleton static arrays)
    public nodeIcons: Icon[] = [];
    public undoIcons: Icon[] = [];
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];
    public gotoIcons: Icon[] = [];

    // * Refresh Cycle
    private _refreshType: ReqRefresh = {}; // Flags for commands to require parts of UI to refresh
    private _revealType: RevealType = RevealType.NoReveal; // Type of reveal for the selected node (when refreshing outline)
    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing.
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    public finalFocus: Focus = Focus.NoChange; // Set in _setupRefresh : Last command issued had focus on outline, as opposed to the body
    public showBodyIfClosed: boolean = false;
    public showOutlineIfClosed: boolean = false;

    private __refreshNode: Position | undefined; // Set in _setupRefresh : Last command issued a specific node to reveal
    private _lastRefreshNodeTS: number = 0;
    get _refreshNode(): Position | undefined {
        return this.__refreshNode;
    }
    set _refreshNode(p_ap: Position | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this.__refreshNode = p_ap;
        this._lastRefreshNodeTS = utils.performanceNow();
    }

    // * Outline Pane
    private _leoTreeProvider!: LeoOutlineProvider; // TreeDataProvider single instance
    private _leoTreeView!: vscode.TreeView&lt;Position&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExView!: vscode.TreeView&lt;Position&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastTreeView!: vscode.TreeView&lt;Position&gt;; // Last visible treeview

    private _revealNodeRetriedRefreshOutline: boolean = false; // USED IN _refreshOutline and _revealNode

    private _lastSelectedNode: Position | undefined;
    private _lastSelectedNodeTS: number = 0;
    get lastSelectedNode(): Position | undefined {
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_ap: Position | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this._lastSelectedNode = p_ap;
        this._lastSelectedNodeTS = utils.performanceNow();
    }

    // * Find panel
    private _leoFindPanelProvider!: vscode.WebviewViewProvider;
    private _findPanelWebviewView: vscode.WebviewView | undefined;
    private _findPanelWebviewExplorerView: vscode.WebviewView | undefined;
    private _lastFindView: vscode.WebviewView | undefined;  // ? Maybe unused ?
    private _findNeedsFocus: boolean = false;
    private _lastSettingsUsed: LeoSearchSettings | undefined; // Last settings loaded / saved for current document

    // * Documents Pane
    private _leoDocumentsProvider!: LeoDocumentsProvider;
    private _leoDocuments!: vscode.TreeView&lt;LeoFrame&gt;;
    private _leoDocumentsExplorer!: vscode.TreeView&lt;LeoFrame&gt;;
    private _lastLeoDocuments: vscode.TreeView&lt;LeoFrame&gt; | undefined;

    // * Goto nav panel
    private _leoGotoProvider!: LeoGotoProvider;
    private _leoGoto!: vscode.TreeView&lt;LeoGotoNode&gt;;
    private _leoGotoExplorer!: vscode.TreeView&lt;LeoGotoNode&gt;;

    // * '@button' pane
    private _leoButtonsProvider!: LeoButtonsProvider;
    private _leoButtons!: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer!: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _lastLeoButtons: vscode.TreeView&lt;LeoButtonNode&gt; | undefined;

    // * Undos pane
    private _leoUndosProvider!: LeoUndosProvider;
    private _leoUndos!: vscode.TreeView&lt;LeoUndoNode&gt;;
    private _leoUndosShown = false;
    private _leoUndosExplorer!: vscode.TreeView&lt;LeoUndoNode&gt;;
    private _leoUndosExplorerShown = false;
    private _lastLeoUndos: vscode.TreeView&lt;LeoUndoNode&gt; | undefined;

    // * Body pane
    private _bodyFileSystemStarted: boolean = false;
    private _bodyEnablePreview: boolean = true;
    private _leoFileSystem!: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _languageFlagged: string[] = [];

    private _bodyPreviewMode: boolean = true;

    private _editorTouched: boolean = false; // Flag for applying editor changes to body when 'icon' state change and 'undo' back to untouched

    private _bodyStatesTimer: NodeJS.Timeout | undefined;

    public preventIconChange: boolean = false; // Prevent refresh outline to keep selected node icon

    private _bodyUri: vscode.Uri = utils.strToLeoUri("");
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setNewBodyUriTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * Selection &amp; scroll
    private _selectionDirty: boolean = false; // Flag set when cursor selection is changed
    private _selectionGnx: string = ''; // Packaged into 'BodySelectionInfo' structures, sent to Leo
    private _selection: vscode.Selection | undefined; // also packaged into 'BodySelectionInfo'
    private _scrollDirty: boolean = false; // Flag set when cursor selection is changed
    private _scrollGnx: string = '';
    private _scroll: vscode.Range | undefined;

    // * Settings / Welcome webview
    // public leoSettingsWebview: LeoSettingsProvider; // TODO !

    // * Log Pane
    private _leoLogPane: vscode.OutputChannel;

    // * Status Bar
    // private _leoStatusBar: LeoStatusBar; // TODO !

    // * Edit/Insert Headline Input Box options instance, setup so clicking outside cancels the headline change
    private _headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: '',
        valueSelection: undefined,
        prompt: '',
    };

    // * Timing
    private _needLastSelectedRefresh = false; // USED IN showBody
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged
    private _bodyLastChangedDocumentSaved: boolean = true; // don't use 'isDirty' of the document!

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void);

    // * Debounced method used to set the outline tree title
    public setTreeViewTitle: (() =&gt; void);

    // * Debounced method used to get opened Leo Files for the documents pane
    public refreshDocumentsPane: (() =&gt; void);

    // * Debounced method used to get content of the at-buttons pane
    public refreshButtonsPane: (() =&gt; void);

    // * Debounced method used to get content of the goto pane
    public refreshGotoPane: (() =&gt; void);

    // * Debounced method used to get content of the undos pane
    public refreshUndoPane: (() =&gt; void);

    // * Debounced method used to set focused element of the undos pane
    public setUndoSelection: ((p_node: LeoUndoNode) =&gt; void);

    // * Debounced method for refreshing the UI
    public launchRefresh: (() =&gt; void);

    @others
}

</t>
<t tx="felix.20201214202058.1">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {
    if (this._refreshType.states) {
        this._refreshType.states = false;
        const c = g.app.windowList[this.frameIndex].c;
        const p = c.p;
        let w_canHoist = true;
        if (c.hoistStack.length) {
            const w_ph = c.hoistStack[c.hoistStack.length - 1].p;
            if (p.__eq__(w_ph)) {
                // p is already the hoisted node
                w_canHoist = false;
            }
        } else {
            // not hoisted, was it the single top child of the real root?
            if (c.rootPosition()!.__eq__(p) &amp;&amp; c.hiddenRootNode.children.length === 1) {
                w_canHoist = false;
            }
        }
        const w_states: LeoPackageStates = {
            changed: c.changed, // Document has changed (is dirty)
            canUndo: c.canUndo(), // Document can undo the last operation done
            canRedo: c.canRedo(), // Document can redo the last operation 'undone'
            canGoBack: c.nodeHistory.beadPointer &gt; 0,
            canGoNext: c.nodeHistory.beadPointer + 1 &lt; c.nodeHistory.beadList.length,
            canDemote: c.canDemote(), // Selected node can have its siblings demoted
            canPromote: c.canPromote(), // Selected node can have its children promoted
            canDehoist: c.canDehoist(), // Document is currently hoisted and can be de-hoisted
            canHoist: w_canHoist
        };
        this.leoStates.setLeoStateFlags(w_states);
        this.refreshUndoPane();
    }
    // Set leoChanged and leoOpenedFilename
    const c = g.app.windowList[this.frameIndex].c;
    this.leoStates.leoChanged = c.changed;
    this.leoStates.leoOpenedFileName = c.fileName();

    if (this._refreshType.documents) {
        this._refreshType.documents = false;
        this.refreshDocumentsPane();
    }
    if (this._refreshType.buttons) {
        this._refreshType.buttons = false;
        this._leoButtonsProvider.refreshTreeRoot();
    }
}

</t>
<t tx="felix.20201214202118.1">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public showOutline(p_focusOutline?: boolean): void {
    const c = g.app.windowList[this.frameIndex].c;
    this._lastTreeView.reveal(c.p, {
        select: true,
        focus: !!p_focusOutline
    }).then(
        () =&gt; { }, // Ok
        (p_error) =&gt; {
            console.log('showOutline could not reveal');
        }
    );
}

</t>
<t tx="felix.20201214202123.1">/**
 * * Public method exposed as 'refreshDocumentsPane' setter/getter to refresh the documents pane
 * Document Panel May be refreshed by other services (states service, ...)
 */
private _refreshDocumentsPane(): void {
    this._leoDocumentsProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20201214202625.1">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private _onChangeCollapsedState(p_event: vscode.TreeViewExpansionEvent&lt;Position&gt;, p_expand: boolean, p_treeView: vscode.TreeView&lt;Position&gt;): void {

    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo.
    this.triggerBodySave(true); // Get any modifications from the editor into the Leo's body model
    if (p_treeView.selection.length &amp;&amp; p_treeView.selection[0] &amp;&amp; p_treeView.selection[0].__eq__(p_event.element)) {
        // * This happens if the tree selection is the same as the expanded/collapsed node: Just have Leo do the same
        // pass
    } else {
        // * This part only happens if the user clicked on the arrow without trying to select the node
        if (this.config.leoTreeBrowse) {
            // * This part only happens if the user clicked on the arrow without trying to select the node
            this._revealNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
            this.selectTreeNode(p_event.element, true); // not waiting for a .then(...) so not to add any lag
        }
    }

    // * vscode will update its tree by itself, but we need to change Leo's model of its outline
    if (p_expand) {
        p_event.element.expand();
    } else {
        p_event.element.contract();
    }
}

</t>
<t tx="felix.20201214202627.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (!this.leoStates.leoReady || !this.leoStates.leojsStartupDone || !this.leoStates.fileOpenedReady) {
        return;
    }
    if (p_event.visible) {
        this._lastTreeView = p_explorerView ? this._leoTreeExView : this._leoTreeView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        if (this.leoStates.fileOpenedReady) {
            this.loadSearchSettings();
        }
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20201214202631.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._lastLeoDocuments = p_explorerView ? this._leoDocumentsExplorer : this._leoDocuments;
        // TODO: Check if needed
        // this.refreshDocumentsPane(); // List may not have changed, but it's selection may have
    }
}

</t>
<t tx="felix.20201214202634.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._lastLeoButtons = p_explorerView ? this._leoButtonsExplorer : this._leoButtons;
        // TODO: Check if needed
        // this._leoButtonsProvider.refreshTreeRoot(); // May not need to set selection...?
    }
}

</t>
<t tx="felix.20201214202749.1">/**
 * * Called by UI when the user selects in the tree (click or 'open aside' through context menu)
 * @param p_node is the position node selected in the tree
 * @param p_reveal 
 * @returns thenable for reveal to finish or select position to finish
 */
public selectTreeNode(
    p_node: Position,
    p_internalCall?: boolean,
    p_aside?: boolean
    // p_reveal?: boolean, p_aside?: boolean
): Thenable&lt;unknown&gt; {

    this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    if (
        p_aside &amp;&amp;
        c.positionExists(p_node) &amp;&amp;
        !p_node.__eq__(this.lastSelectedNode)
    ) {
        this._revealNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    }

    this.showBodyIfClosed = true;

    this.leoStates.setSelectedNodeFlags(p_node);
    // this._leoStatusBar.update(true); // Just selected a node directly, or via expand/collapse
    const w_showBodyKeepFocus = p_aside
        ? this.config.treeKeepFocusWhenAside
        : this.config.treeKeepFocus;

    // * Check if having already this exact node position selected : Just show the body and exit
    // (other tree nodes with same gnx may have different syntax language coloring because of parents lineage)
    if (p_node.__eq__(this.lastSelectedNode)) {
        this._locateOpenedBody(p_node.gnx); // LOCATE NEW GNX
        return this.showBody(!!p_aside, w_showBodyKeepFocus).catch((p_error) =&gt; {
            return Promise.resolve(); // intercept cancellation as success: next one is going to replace anyways.
        });
        // Voluntary exit
    }

    // * Set selected node in Leo 
    c.selectPosition(p_node);

    if (!p_internalCall) {
        this._refreshType.states = true;
        this.getStates();
    }

    // * Apply the node to the body text without waiting for the selection promise to resolve
    return this._tryApplyNodeToBody(p_node, !!p_aside, w_showBodyKeepFocus);

}

</t>
<t tx="felix.20201214202755.1">/**
 * Leo Command
 * @param p_cmd Command name string
 * @param p_options: CommandOptions for the command
 */
public async command(
    p_cmd: string,
    p_options: CommandOptions
): Promise&lt;unknown&gt; {
    this.lastCommandTimer = process.hrtime();
    if (this.commandTimer === undefined) {
        this.commandTimer = this.lastCommandTimer;
    }
    this.lastCommandRefreshTimer = this.lastCommandTimer;
    if (this.commandRefreshTimer === undefined) {
        this.commandRefreshTimer = this.lastCommandTimer;
    }

    await this.triggerBodySave();

    if (p_options.isNavigation) {
        // If any navigation command is used from outline or command palette: show body.
        this.showBodyIfClosed = true;
        // If alt+arrow is used to navigate: SHOW and leave focus on outline.
        this.showOutlineIfClosed = true;
    }

    const c = g.app.windowList[this.frameIndex].c;
    this.setupRefresh(p_options.finalFocus, p_options.refreshType);

    let value: any = undefined;
    const p = p_options.node ? p_options.node : c.p;

    let w_offset = 0;
    if (p_options.keepSelection) {
        if (Constants.OLD_POS_OFFSETS.DELETE.includes(p_cmd)) {
            w_offset = -1;
        } else if (Constants.OLD_POS_OFFSETS.ADD.includes(p_cmd)) {
            w_offset = 1;
        }
    }


    try {
        if (p.__eq__(c.p)) {
            value = c.doCommandByName(p_cmd); // no need for re-selection
        } else {
            const old_p = c.p;
            c.selectPosition(p);
            value = c.doCommandByName(p_cmd);
            if (p_options.keepSelection) {
                if (value &amp;&amp; value.then) {
                    (value as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
                        if (c.positionExists(old_p)) {
                            c.selectPosition(old_p);
                        } else {
                            old_p._childIndex = old_p._childIndex + w_offset;
                            if (c.positionExists(old_p)) {
                                c.selectPosition(old_p);
                            }
                        }
                    });
                } else {
                    if (c.positionExists(old_p)) {
                        c.selectPosition(old_p);
                    } else {
                        old_p._childIndex = old_p._childIndex + w_offset;
                        if (c.positionExists(old_p)) {
                            c.selectPosition(old_p);
                        }
                    }
                }
            }
        }
    } catch (e) {
        vscode.window.showErrorMessage(
            "LeoUI Error: " + e
        );
    }


    if (this.trace) {
        if (this.lastCommandTimer) {
            console.log('lastCommandTimer', utils.getDurationMs(this.lastCommandTimer));
        }
    }
    this.lastCommandTimer = undefined;

    if (value &amp;&amp; value.then) {
        (value as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
            this.launchRefresh();
        });
    } else {
        this.launchRefresh();
    }


    if (value &amp;&amp; value.then) {
        return value;
    } else {
        return Promise.resolve(value); // value may be a promise but it will resolve all at once.

    }
}

</t>
<t tx="felix.20201214202757.1">/**
 * Opens quickPick minibuffer pallette to choose from all commands in this file's Thenable
 * @returns Promise from the command resolving - or resolve with undefined if cancelled
 */
public async minibuffer(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(false);
    const c = g.app.windowList[this.frameIndex].c;
    const commands: vscode.QuickPickItem[] = [];
    for (let key in c.commandsDict) {
        const command = c.commandsDict[key];
        // Going to get replaced. Don't take those that begin with 'async-'
        if (!(command as any).__name__.startsWith('async-')) {
            commands.push({
                label: key,
                detail: (command as any).__doc__
            });
        }
    }

    const w_noDetails = commands
        .filter(
            p_command =&gt; !p_command.detail &amp;&amp; !(
                p_command.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START) ||
                p_command.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_DEL_BUTTON_START) ||
                p_command.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START)
            )
        );
    for (const p_command of w_noDetails) {
        p_command.description = Constants.USER_MESSAGES.MINIBUFFER_USER_DEFINED;
    }

    const w_withDetails = commands.filter(p_command =&gt; !!p_command.detail);

    // Only sort 'regular' Leo commands, leaving custom commands at the top
    w_withDetails.sort((a, b) =&gt; {
        return a.label &lt; b.label ? -1 : (a.label === b.label ? 0 : 1);
    });

    const w_result: vscode.QuickPickItem[] = [];

    if (this._minibufferHistory.length) {
        w_result.push({
            label: Constants.USER_MESSAGES.MINIBUFFER_HISTORY_LABEL,
            description: Constants.USER_MESSAGES.MINIBUFFER_HISTORY_DESC
        });
    }

    // Finish minibuffer list
    if (w_noDetails.length) {
        w_result.push(...w_noDetails);
    }

    // Separator above real commands, if needed...
    if (w_noDetails.length || this._minibufferHistory.length) {
        w_result.push({
            label: "", kind: vscode.QuickPickItemKind.Separator
        });
    }

    w_result.push(...w_withDetails);

    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
        matchOnDetail: true,
    };
    const w_picked = await vscode.window.showQuickPick(w_result, w_options);
    // First, check for undo-history list being requested
    if (w_picked &amp;&amp; w_picked.label === Constants.USER_MESSAGES.MINIBUFFER_HISTORY_LABEL) {
        return this.minibufferHistory();
    }
    return this._doMinibufferCommand(w_picked);

}

</t>
<t tx="felix.20201214202759.1">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @returns Thenable that resolves when done
 */
public editHeadline(p_node?: Position, p_fromOutline?: boolean): Thenable&lt;unknown&gt; {
    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        { tree: true, states: true }
    );

    const c = g.app.windowList[this.frameIndex].c;
    const u = c.undoer;
    if (!p_node) {
        p_node = c.p; // Current selection
    }
    this._headlineInputOptions.prompt =
        Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE;
    this._headlineInputOptions.value = p_node.h; // preset input pop up
    return vscode.window.showInputBox(this._headlineInputOptions).then((p_newHeadline) =&gt; {
        if (p_newHeadline &amp;&amp; p_newHeadline !== "\n") {
            let w_truncated = false;
            if (p_newHeadline.indexOf("\n") &gt;= 0) {
                p_newHeadline = p_newHeadline.split("\n")[0];
                w_truncated = true;
            }
            if (p_newHeadline.length &gt; 1000) {
                p_newHeadline = p_newHeadline.substring(0, 1000);
                w_truncated = true;
            }

            if (p_newHeadline &amp;&amp; p_node &amp;&amp; p_node.h !== p_newHeadline) {
                if (w_truncated) {
                    vscode.window.showInformationMessage("Truncating headline");
                }

                const undoData = u.beforeChangeHeadline(p_node);
                c.setHeadString(p_node, p_newHeadline);  // Set v.h *after* calling the undoer's before method.
                if (!c.changed) {
                    c.setChanged();
                }
                u.afterChangeHeadline(p_node, 'Edit Headline', undoData);
                this.launchRefresh();
                // if edited and accepted
                return Promise.resolve(true);
            }

        } else {
            if (p_fromOutline) {
                this.showOutline(true);
            }
            return Promise.resolve(undefined); // if cancelled or unchanged
        }
    });
}

</t>
<t tx="felix.20201214202800.1">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_interrupt Signifies the insert action is actually interrupting itself (e.g. rapid CTRL+I actions by the user)
 * @returns Thenable that resolves when done
 */
public insertNode(p_node: Position | undefined, p_fromOutline: boolean, p_interrupt: boolean, p_asChild: boolean): Thenable&lt;unknown&gt; {
    let w_finalFocus: Focus = p_fromOutline ? Focus.Outline : Focus.Body; // Use w_fromOutline for where we intend to leave focus when done with the insert
    if (p_interrupt) {
        this._focusInterrupt = true;
        w_finalFocus = Focus.NoChange; // Going to use last state
    }
    this.triggerBodySave(true); // Don't wait for saving to resolve because we're waiting for user input anyways
    this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_INSERT_NODE;
    this._headlineInputOptions.value = Constants.USER_MESSAGES.DEFAULT_HEADLINE;

    return vscode.window.showInputBox(this._headlineInputOptions).then((p_newHeadline) =&gt; {
        // * if node has child and is expanded: turn p_asChild to true!

        this.lastCommandTimer = process.hrtime();
        if (this.commandTimer === undefined) {
            this.commandTimer = this.lastCommandTimer;
        }
        this.lastCommandRefreshTimer = this.lastCommandTimer;
        if (this.commandRefreshTimer === undefined) {
            this.commandRefreshTimer = this.lastCommandTimer;
        }

        const c = g.app.windowList[this.frameIndex].c;

        let value: any = undefined;
        const p = p_node ? p_node : c.p;

        if (p.__eq__(c.p)) {
            this.setupRefresh(w_finalFocus, { tree: true, body: true, documents: true, buttons: true, states: true });
            this._insertAndSetHeadline(p_newHeadline, p_asChild); // no need for re-selection
        } else {
            const old_p = c.p;  // c.p is old already selected
            c.selectPosition(p); // p is now the new one to be operated on
            this._insertAndSetHeadline(p_newHeadline, p_asChild);
            // Only if 'keep' old position was needed (specified with a p_node parameter), and old_p still exists
            if (!!p_node &amp;&amp; c.positionExists(old_p)) {
                // no need to refresh body
                this.setupRefresh(w_finalFocus, { tree: true, documents: true, buttons: true, states: true });
                c.selectPosition(old_p);
            } else {
                old_p._childIndex = old_p._childIndex + 1;
                if (!!p_node &amp;&amp; c.positionExists(old_p)) {
                    // no need to refresh body
                    this.setupRefresh(w_finalFocus, { tree: true, documents: true, buttons: true, states: true });
                    c.selectPosition(old_p);
                } else {
                    this.setupRefresh(w_finalFocus, { tree: true, body: true, documents: true, buttons: true, states: true });
                }
            }
        }
        if (this.trace) {
            if (this.lastCommandTimer) {
                console.log('lastCommandTimer', utils.getDurationMs(this.lastCommandTimer));
            }
        }
        this.lastCommandTimer = undefined;
        this.launchRefresh();
        return Promise.resolve(value);
    });
}

</t>
<t tx="felix.20201214205159.1">@language json
@tabwidth -2
{
  "name": "leojs",
  "displayName": "Leo Editor for Visual Studio Code",
  "description": "Leo, the literate editor with outline extension for Visual Studio Code.",
  "version": "0.1.2",
  "publisher": "boltex",
  "author": {
    "name": "Félix Malboeuf"
  },
  "license": "SEE LICENSE IN LICENSE",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leojs"
  },
  "engines": {
    "vscode": "^1.71.0"
  },
  "keywords": [
    "leo",
    "tree",
    "outline",
    "editor",
    "literate"
  ],
  "categories": [
    "Other"
  ],
  "icon": "resources/leoapp128px.png",
  "galleryBanner": {
    "color": "#f1af88",
    "theme": "light"
  },
  "activationEvents": [
    "onStartupFinished"
  ],
  "qna": false,
  "main": "./dist/extension-node",
  "browser": "./dist/extension-web",
  "contributes": {
    &lt;&lt; contributes &gt;&gt;
  },
  "scripts": {
    &lt;&lt; scripts &gt;&gt;
  },
  "devDependencies": {
    &lt;&lt; devDependencies &gt;&gt;
  },
  "dependencies": {
    "@types/safe-json-stringify": "^1.1.2",
    &lt;&lt; dependencies &gt;&gt;
  }
}
</t>
<t tx="felix.20201214205159.10">{
  "command": "leojs.openLeoFile",
  "title": "Open with LeoJS",
  "category": "Leojs",
  "enablement": "leojsReady",
  "icon": {
    "light": "resources/light/folder.svg",
    "dark": "resources/dark/folder.svg"
  }
},
{
  "command": "leojs.recentLeoFiles",
  "category": "Leojs",
  "enablement": "leojsReady",
  "title": "Recent Files"
},
{
  "command": "leojs.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leojs",
  "enablement": "leojsReady &amp;&amp; leojsTreeOpened",
  "icon": {
    "light": "resources/light/switch.svg",
    "dark": "resources/dark/switch.svg"
  }
},
{
  "command": "leojs.newLeoFile",
  "title": "New Leo File",
  "category": "Leojs",
  "enablement": "leojsReady",
  "icon": {
    "light": "resources/light/new-file.svg",
    "dark": "resources/dark/new-file.svg"
  }
},
{
  "command": "leojs.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leojs.saveLeoFile",
  "category": "Leojs",
  "title": "Save Leo File",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leojs.saveLeoFileFromOutline",
  "category": "Leojs",
  "title": "Save Leo File",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leojs.saveAsLeoFile",
  "category": "Leojs",
  "title": "Save Leo File as...",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/save-as.svg",
    "dark": "resources/dark/save-as.svg"
  }
},
{
  "command": "leojs.saveAsLeoJsFile",
  "category": "Leojs",
  "title": "Save as leojs JSON File...",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/save-as-leojs.svg",
    "dark": "resources/dark/save-as-leojs.svg"
  }
},
{
  "command": "leojs.refreshFromDisk",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leojs.refreshFromDiskSelection",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened &amp;&amp; LeojsAtFile",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leojs.refreshFromDiskSelectionFromOutline",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened &amp;&amp; LeojsAtFile",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leojs.writeAtFileNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write @&lt;file&gt; Nodes",
  "icon": {
    "light": "resources/light/write-at-file-nodes.svg",
    "dark": "resources/dark/write-at-file-nodes.svg"
  }
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write @&lt;file&gt; Nodes",
  "icon": {
    "light": "resources/light/write-at-file-nodes.svg",
    "dark": "resources/dark/write-at-file-nodes.svg"
  }
},
{
  "command": "leojs.writeDirtyAtFileNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write Dirty @&lt;file&gt; Nodes",
  "icon": {
    "light": "resources/light/write-dirty-at-file-nodes.svg",
    "dark": "resources/dark/write-dirty-at-file-nodes.svg"
  }
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write Dirty @&lt;file&gt; Nodes",
  "icon": {
    "light": "resources/light/write-dirty-at-file-nodes.svg",
    "dark": "resources/dark/write-dirty-at-file-nodes.svg"
  }
},
{
  "command": "leojs.gitDiff",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Git Diff"
},
</t>
<t tx="felix.20201214205159.11">{
  "command": "leojs.openAside",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Open to the Side"
},
{
  "command": "leojs.contractAll",
  "category": "Leojs",
  "title": "Contract All",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leojs.contractAllFromOutline",
  "category": "Leojs",
  "title": "Contract All",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leojs.prev",
  "category": "Leojs",
  "title": "Prev",
  "enablement": "leojsCanGoBack",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leojs.prevFromOutline",
  "category": "Leojs",
  "title": "Prev",
  "enablement": "leojsCanGoBack",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leojs.next",
  "category": "Leojs",
  "title": "Next",
  "enablement": "leojsCanGoNext",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
{
  "command": "leojs.nextFromOutline",
  "category": "Leojs",
  "title": "Next",
  "enablement": "leojsCanGoNext",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
</t>
<t tx="felix.20201214205159.12">{
  "command": "leojs.editHeadline",
  "category": "Leojs",
  "title": "Edit Headline",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/edit.svg",
    "dark": "resources/dark/edit.svg"
  }
},
{
  "command": "leojs.editSelectedHeadline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Edit Headline"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Edit Headline"
},
</t>
<t tx="felix.20201214205159.13">{
  "command": "leojs.mark",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leojs.markSelection",
  "category": "Leojs",
  "title": "Mark",
  "enablement": "leojsTreeOpened &amp;&amp; !leojsMarked",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leojs.markSelectionFromOutline",
  "category": "Leojs",
  "title": "Mark",
  "enablement": "leojsTreeOpened &amp;&amp; !leojsMarked",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leojs.unmark",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leojs.unmarkSelection",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened &amp;&amp; leojsMarked",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened &amp;&amp; leojsMarked",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leojs.unmarkAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Unmark All"
},
{
  "command": "leojs.copyMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Copy Marked"
},
{
  "command": "leojs.diffMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Diff Marked Nodes"
},
{
  "command": "leojs.markChangedItems",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark Changed Items"
},
{
  "command": "leojs.markSubheads",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark Subheads"
},
{
  "command": "leojs.cloneMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Clone Marked Nodes"
},
{
  "command": "leojs.deleteMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Delete Marked Nodes"
},
{
  "command": "leojs.moveMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Marked Nodes"
},
</t>
<t tx="felix.20201214205159.14">{
  "command": "leojs.copyNode",
  "category": "Leojs",
  "title": "Copy Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leojs.copyNodeSelection",
  "category": "Leojs",
  "title": "Copy Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leojs.cutNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Cut Node"
},
{
  "command": "leojs.cutNodeSelection",
  "category": "Leojs",
  "title": "Cut Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/cut.svg",
    "dark": "resources/dark/cut.svg"
  }
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Cut Node"
},
{
  "command": "leojs.pasteNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node"
},
{
  "command": "leojs.pasteNodeAtSelection",
  "category": "Leojs",
  "title": "Paste Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/paste.svg",
    "dark": "resources/dark/paste.svg"
  }
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node"
},
{
  "command": "leojs.pasteNodeAsClone",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node as Clone"
},
{
  "command": "leojs.pasteNodeAsCloneAtSelection",
  "category": "Leojs",
  "title": "Paste Node as Clone",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/paste-clone.svg",
    "dark": "resources/dark/paste-clone.svg"
  }
},
{
  "command": "leojs.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node as Clone"
},
{
  "command": "leojs.delete",
  "category": "Leojs",
  "title": "Delete",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leojs.deleteSelection",
  "category": "Leojs",
  "title": "Delete Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/delete.svg",
    "dark": "resources/dark/delete.svg"
  }
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Delete Node"
},
{
  "command": "leojs.setUa",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Set uA"
},
</t>
<t tx="felix.20201214205159.15">{
  "command": "leojs.extract",
  "category": "Leojs",
  "title": "Extract",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/extract.svg",
    "dark": "resources/dark/extract.svg"
  }
},
{
  "command": "leojs.extractNames",
  "category": "Leojs",
  "title": "Extract Names",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/extract-name.svg",
    "dark": "resources/dark/extract-name.svg"
  }
},
</t>
<t tx="felix.20201214205159.16">{
  "command": "leojs.moveOutlineDown",
  "category": "Leojs",
  "title": "Move Outline Down",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/arrow-down.svg",
    "dark": "resources/dark/arrow-down.svg"
  }
},
{
  "command": "leojs.moveOutlineDownSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Down"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Down"
},
{
  "command": "leojs.moveOutlineLeft",
  "category": "Leojs",
  "title": "Move Outline Left",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/arrow-left.svg",
    "dark": "resources/dark/arrow-left.svg"
  }
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Left"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Left"
},
{
  "command": "leojs.moveOutlineRight",
  "category": "Leojs",
  "title": "Move Outline Right",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/arrow-right.svg",
    "dark": "resources/dark/arrow-right.svg"
  }
},
{
  "command": "leojs.moveOutlineRightSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Right"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Right"
},
{
  "command": "leojs.moveOutlineUp",
  "category": "Leojs",
  "title": "Move Outline Up",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/arrow-up.svg",
    "dark": "resources/dark/arrow-up.svg"
  }
},
{
  "command": "leojs.moveOutlineUpSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Up"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Up"
},
</t>
<t tx="felix.20201214205159.17">{
  "command": "leojs.insertNode",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leojs.insertChildNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leojs.insertNodeSelection",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leojs.insertChildNodeSelection",
  "category": "Leojs",
  "title": "Insert Child",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Insert Child",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leojs.insertNodeSelectionInterrupt",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leojs.insertChildNodeSelectionInterrupt",
  "category": "Leojs",
  "title": "Insert Child",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leojs.cloneNode",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leojs.cloneNodeSelection",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leojs.promote",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leojs.promoteSelection",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsCanPromote",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsCanPromote",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leojs.demote",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leojs.demoteSelection",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsCanDemote",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsCanDemote",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leojs.sortChildrenSelection",
  "category": "Leojs",
  "title": "Sort Children",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "icon": {
    "light": "resources/light/sort-children.svg",
    "dark": "resources/dark/sort-children.svg"
  }
},
{
  "command": "leojs.sortChildrenSelectionFromOutline",
  "category": "Leojs",
  "title": "Sort Children",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "icon": {
    "light": "resources/light/sort-children.svg",
    "dark": "resources/dark/sort-children.svg"
  }
},
{
  "command": "leojs.sortSiblingsSelection",
  "category": "Leojs",
  "title": "Sort Siblings",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/sort-siblings.svg",
    "dark": "resources/dark/sort-siblings.svg"
  }
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "category": "Leojs",
  "title": "Sort Siblings",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/sort-siblings.svg",
    "dark": "resources/dark/sort-siblings.svg"
  }
},
</t>
<t tx="felix.20201214205159.18">{
  "command": "leojs.gotoFirstVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto First Visible"
},
{
  "command": "leojs.gotoLastVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Last Visible"
},
{
  "command": "leojs.pageUp",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Page Up"
},
{
  "command": "leojs.pageDown",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Page Down"
},
{
  "command": "leojs.gotoFirstSibling",
  "category": "leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto First Sibling"
},
{
  "command": "leojs.gotoLastSibling",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Last Sibling"
},
{
  "command": "leojs.gotoNextVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Visible"
},
{
  "command": "leojs.gotoPrevVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Prev Visible"
},
{
  "command": "leojs.contractOrGoLeft",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Contract Or Go Left"
},
{
  "command": "leojs.expandAndGoRight",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Expand And Go Right"
},
{
  "command": "leojs.gotoNextMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Marked"
},
{
  "command": "leojs.gotoNextClone",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Clone"
},
{
  "command": "leojs.gotoNextCloneSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCloned",
  "title": "Goto Next Clone"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCloned",
  "title": "Goto Next Clone"
},
</t>
<t tx="felix.20201214205159.2">@others
</t>
<t tx="felix.20201214205159.20">{
  "command": "leojs.undo",
  "category": "Leojs",
  "title": "Undo",
  "enablement": "leojsCanUndo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leojs.undoFromOutline",
  "category": "Leojs",
  "title": "Undo",
  "enablement": "leojsCanUndo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leojs.redo",
  "category": "Leojs",
  "title": "Redo",
  "enablement": "leojsCanRedo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leojs.redoFromOutline",
  "category": "Leojs",
  "title": "Redo",
  "enablement": "leojsCanRedo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
</t>
<t tx="felix.20201214205159.23">"menus": {
  @others
},
</t>
<t tx="felix.20201214205159.24">"commandPalette": [
  @others
],
</t>
<t tx="felix.20201214205159.3">"viewsContainers": {
  "activitybar": [
    {
      "id": "leojsView",
      "title": "Leojs",
      "icon": "resources/icon.svg"
    }
  ]
},
</t>
<t tx="felix.20201214205159.4">"views": {
  "explorer": [
    {
      "id": "leojsOutlineExplorer",
      "name": "Leojs Outline",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer",
      "visibility": "visible"
    },
    {
      "type": "webview",
      "id": "leojsFindPanelExplorer",
      "contextualTitle": "Leojs",
      "name": "Leojs Find",
      "title": "Leojs Find",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsGotoPanelExplorer",
      "name": "Leojs Goto",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsDocumentsExplorer",
      "name": "Leojs Documents",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsUndosExplorer",
      "name": "Leojs Undo History",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsButtonsExplorer",
      "name": "Leojs Buttons",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    }
  ],
  "leojsView": [
    {
      "id": "leojsOutline",
      "contextualTitle": "Leojs",
      "name": "Outline",
      "visibility": "visible"
    },
    {
      "type": "webview",
      "contextualTitle": "Leojs",
      "id": "leojsFindPanel",
      "name": "Find",
      "title": "Find",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsGotoPanel",
      "contextualTitle": "Leojs",
      "name": "Goto",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsDocuments",
      "contextualTitle": "Leojs",
      "name": "Documents",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsUndos",
      "contextualTitle": "Leojs",
      "name": "Undo History",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsButtons",
      "contextualTitle": "Leojs",
      "name": "Buttons",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    }
  ]
},
</t>
<t tx="felix.20201214205159.42">{
  "command": "leojs.removeButton",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.44">{
  "command": "leojs.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leojs.refreshFromDisk",
  "when": "false"
},
{
  "command": "leojs.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "when": "false"
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.45">{
  "command": "leojs.openAside",
  "when": "false"
},
{
  "command": "leojs.contractAllFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.46">{
  "command": "leojs.editHeadline",
  "when": "false"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.47">{
  "command": "leojs.mark",
  "when": "false"
},
{
  "command": "leojs.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.unmark",
  "when": "false"
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.48">{
  "command": "leojs.copyNode",
  "when": "false"
},
{
  "command": "leojs.cutNode",
  "when": "false"
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.pasteNode",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.delete",
  "when": "false"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.49">{
  "command": "leojs.moveOutlineDown",
  "when": "false"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineRight",
  "when": "false"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineUp",
  "when": "false"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.5">"viewsWelcome": [
  {
    "view": "leojsOutline",
    "contents": "Starting up leojs...",
    "when": "!leojsReady &amp;&amp; !leojsStartupDone"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "Starting up leojs...",
    "when": "!leojsReady &amp;&amp; !leojsStartupDone"
  },
  {
    "view": "leojsOutline",
    "contents": "Open a remote repository first to enable LeoJS\n[Open Remote Repository](command:remoteHub.openRepository)\nSee [Opening a project](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for more info.",
    "when": "!leojsReady &amp;&amp; leojsStartupDone"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "Open a remote repository first to enable LeoJS\n[Open Remote Repository](command:remoteHub.openRepository)\nSee [Opening a project](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for more info.",
    "when": "!leojsReady &amp;&amp; leojsStartupDone"
  },
  {
    "view": "leojsOutline",
    "contents": "[Open Leo File](command:leojs.openLeoFile)\n[Create Leo File](command:leojs.newLeoFile)",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened &amp;&amp; leojsStartupDone"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "[Open Leo File](command:leojs.openLeoFile)\n[Create Leo File](command:leojs.newLeoFile)",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened &amp;&amp; leojsStartupDone"
  },
  {
    "view": "leojsDocuments",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsDocumentsExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsGotoPanel",
    "contents": "No Results",
    "when": "leojsReady"
  },
  {
    "view": "leojsGotoPanelExplorer",
    "contents": "No Results",
    "when": "leojsReady"
  },
  {
    "view": "leojsButtons",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsButtonsExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsButtons",
    "contents": "There are no @buttons in this outline",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsButtonsExplorer",
    "contents": "There are no @buttons in this outline",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsUndos",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsUndosExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsUndos",
    "contents": "Can't undo",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsUndosExplorer",
    "contents": "Can't undo",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  }
],
</t>
<t tx="felix.20201214205159.50">{
  "command": "leojs.insertNode",
  "when": "false"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.insertNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leojs.insertChildNode",
  "when": "false"
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.insertChildNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leojs.cloneNode",
  "when": "false"
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.promote",
  "when": "false"
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.demote",
  "when": "false"
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.51">{
  "command": "leojs.gotoNextClone",
  "when": "false"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leojs.gotoLastVisible",
  "when": "false"
},
{
  "command": "leojs.gotoFirstSibling",
  "when": "false"
},
{
  "command": "leojs.gotoLastSibling",
  "when": "false"
},
{
  "command": "leojs.gotoNextVisible",
  "when": "false"
},
{
  "command": "leojs.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leojs.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leojs.expandAndGoRight",
  "when": "false"
},
{
  "command": "leojs.pageUp",
  "when": "false"
},
{
  "command": "leojs.pageDown",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.52">{
  "command": "leojs.hoistNode",
  "when": "false"
},
{
  "command": "leojs.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.53">{
  "command": "leojs.undoFromOutline",
  "when": "false"
},
{
  "command": "leojs.redoFromOutline",
  "when": "false"
}
</t>
<t tx="felix.20201214205159.54">"explorer/context": [
  {
    "command": "leojs.openLeoFile",
    "when": "resourceExtname == .leo || resourceExtname == .leojs",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20201214205159.55">"view/title": [
  {
    "command": "leojs.showSettingsPage",
    "when": "view =~ /^leojsDocuments|^leojsButtons/ &amp;&amp; leojsReady",
    "group": "navigation@9"
  },
  {
    "command": "leojs.showLogPane",
    "when": "view =~ /^leojsDocuments|^leojsButtons/ &amp;&amp; leojsReady",
    "group": "navigation@9"
  },
  {
    "command": "leojs.findQuickSelected",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findQuickTimeline",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findQuickChanged",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.history",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.markedList",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.openLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsReady",
    "group": "navigation@1"
  },
  {
    "command": "leojs.newLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsReady",
    "group": "navigation@1"
  },
  {
    "command": "leojs.saveLeoFileFromOutline",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.saveAsLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; !leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.saveAsLeoJsFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; !leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.prevFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leojs.nextFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leojs.undoFromOutline",
    "when": "view =~ /^leojsOutline|^leojsUndo/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.redoFromOutline",
    "when": "view =~ /^leojsOutline|^leojsUndo/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.deHoistFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@7"
  },
  {
    "command": "leojs.hoistSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leojs.chapterBack",
    "when": "view =~ /^leojsFindPanel|^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterNext",
    "when": "view =~ /^leojsFindPanel|^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterSelect",
    "when": "view =~ /^leojsFindPanel|^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterMain",
    "when": "view =~ /^leojsFindPanel|^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.promoteSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leojs.demoteSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@10"
  },
  {
    "command": "leojs.contractAllFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@11"
  }
],
</t>
<t tx="felix.20201214205159.56">"view/item/context": [
  @others
]
</t>
<t tx="felix.20201214205159.57">{
  "command": "leojs.editHeadline",
  "when": "config.leojs.showEditOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@1"
},
</t>
<t tx="felix.20201214205159.58">{
  "command": "leojs.insertNode",
  "when": "config.leojs.showAddOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@2"
},
</t>
<t tx="felix.20201214205159.6">"commands": [
  @others
],
</t>
<t tx="felix.20201214205159.60">{
  "command": "leojs.copyNode",
  "when": "config.leojs.showCopyOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@4"
},
{
  "command": "leojs.cloneNode",
  "when": "config.leojs.showCloneOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@4"
},
</t>
<t tx="felix.20201214205159.61">{
  "command": "leojs.mark",
  "when": "config.leojs.showMarkOnNodes &amp;&amp; viewItem =~ /^leojsNodeUnmarked/",
  "group": "inline@5"
},
{
  "command": "leojs.unmark",
  "when": "config.leojs.showMarkOnNodes &amp;&amp; viewItem =~ /^leojsNodeMarked/",
  "group": "inline@5"
},
</t>
<t tx="felix.20201214205159.62">{
  "command": "leojs.openAside",
  "when": "config.leojs.showOpenAside &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext1@1"
},
</t>
<t tx="felix.20201214205159.63">{
  "command": "leojs.hoistNode",
  "when": "viewItem =~ /leojsNodeNotRoot/",
  "group": "leojsNodeContext1@2"
},
{
  "command": "leojs.deHoist",
  "when": "leojsCanDehoist &amp;&amp; viewItem =~ /leojsNodeRoot/",
  "group": "leojsNodeContext1@2"
},
</t>
<t tx="felix.20201214205159.64">{
  "command": "leojs.refreshFromDisk",
  "when": "viewItem =~ /leojsNodeAtFile/",
  "group": "leojsNodeContext1@3"
},
</t>
<t tx="felix.20201214205159.65">{
  "command": "leojs.mark",
  "when": "viewItem =~ /^leojsNodeUnmarked/",
  "group": "leojsNodeContext2@1"
},
{
  "command": "leojs.unmark",
  "when": "viewItem =~ /^leojsNodeMarked/",
  "group": "leojsNodeContext2@2"
},
</t>
<t tx="felix.20201214205159.66">{
  "command": "leojs.copyNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@3"
},
{
  "command": "leojs.cutNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@4"
},
{
  "command": "leojs.pasteNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@5"
},
{
  "command": "leojs.pasteNodeAsClone",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@6"
},
{
  "command": "leojs.delete",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@7"
},
{
  "command": "leojs.insertNode",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext3@1"
},
{
  "command": "leojs.cloneNode",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext3@2"
},
{
  "command": "leojs.gotoNextClone",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /leojsNodeCloned/",
  "group": "leojsNodeContext3@3"
},
</t>
<t tx="felix.20201214205159.67">"keybindings": [
  @others
],
</t>
<t tx="felix.20201214205159.68">{
  "command": "leojs.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.minibuffer",
  "key": "alt+x",
  "when": "leojsTreeOpened"
},
</t>
<t tx="felix.20201214205159.69">{
  "command": "leojs.showOutline",
  "key": "alt+t",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
{
  "command": "leojs.showBody",
  "key": "alt+d",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
{
  "command": "leojs.showBody",
  "key": "ctrl+g",
  "mac": "cmd+g",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
{
  "command": "leojs.showBody",
  "key": "tab",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsButtons|^leojsUndos/"
},
{
  "command": "leojs.showBody",
  "key": "enter",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.70">{
  "command": "leojs.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
{
  "command": "leojs.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.newLeoFile",
  "key": "ctrl+n",
  "mac": "cmd+n",
  "when": "editorTextFocus &amp;&amp; resourceScheme == leojs || leojsFindFocus || sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
{
  "command": "leojs.openLeoFile",
  "key": "ctrl+o",
  "mac": "cmd+o",
  "when": "editorTextFocus &amp;&amp; resourceScheme == leojs || leojsFindFocus || sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
{
  "command": "leojs.writeAtFileNodes",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
{
  "command": "leojs.writeDirtyAtFileNodes",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
</t>
<t tx="felix.20201214205159.71">{
  "command": "leojs.contractAll",
  "key": "alt+-",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.contractAllFromOutline",
  "key": "alt+-",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsButtons|^leojsGoto|^leojsUndos/"
},
</t>
<t tx="felix.20201214205159.72">{
  "command": "leojs.editSelectedHeadline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsButtons|^leojsUndos/"
},
</t>
<t tx="felix.20201214205159.73">{
  "command": "leojs.markSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsTreeOpened &amp;&amp; !leojsMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.markSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsTreeOpened &amp;&amp; !leojsMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsButtons|^leojsUndos/"
},
{
  "command": "leojs.unmarkSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsTreeOpened &amp;&amp; leojsMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsTreeOpened &amp;&amp; leojsMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsButtons|^leojsUndos/"
},
</t>
<t tx="felix.20201214205159.74">{
  "command": "leojs.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd+shift+n",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20201214205159.75">{
  "command": "leojs.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "shift+down",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "shift+left",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "shift+right",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "shift+up",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.76">{
  "command": "leojs.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertNodeSelectionInterrupt",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "!terminalFocus &amp;&amp; !panelFocus &amp;&amp; leojsTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leojs.insertNodeSelection",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "insert",
  "mac": "insert",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertNodeSelectionInterrupt",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "!terminalFocus &amp;&amp; !panelFocus &amp;&amp; leojsTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leojs.insertChildNodeSelection",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertChildNodeSelectionInterrupt",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "!terminalFocus &amp;&amp; !panelFocus &amp;&amp; leojsTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leojs.cloneNodeSelection",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/"
},
</t>
<t tx="felix.20201214205159.77">{
  "command": "leojs.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/"
},
{
  "command": "leojs.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/"
},
{
  "command": "leojs.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "key": "delete",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.78">{
  "command": "leojs.gotoFirstVisible",
  "key": "alt+home",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoLastSibling",
  "key": "alt+end",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoFirstVisible",
  "key": "home",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoLastVisible",
  "key": "end",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.pageUp",
  "key": "pageup",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.pageDown",
  "key": "pagedown",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoNextVisible",
  "key": "down",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNextVisible",
  "key": "alt+down",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoPrevVisible",
  "key": "up",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoPrevVisible",
  "key": "alt+up",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.contractOrGoLeft",
  "key": "left",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.contractOrGoLeft",
  "key": "alt+left",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.expandAndGoRight",
  "key": "right",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.expandAndGoRight",
  "key": "alt+right",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20201214205159.79">"cleanup": "node ./cleanup.js",
"vscode:prepublish": "npm run package",
"compile": "webpack",
"compile-web": "webpack",
"open-in-browser": "node ./prepare.js &amp;&amp; vscode-test-web --browserType=chromium --extensionDevelopmentPath=. &amp;&amp; node ./cleanup.js",
"watch": "webpack --watch",
"watch-web": "webpack --watch",
"package": "webpack --mode production --devtool hidden-source-map",
"package-web": "webpack --mode production --devtool hidden-source-map",
"compile-tests": "tsc -p . --outDir out",
"watch-tests": "tsc -p . -w --outDir out",
"pretest": "npm run compile-tests &amp;&amp; npm run compile &amp;&amp; npm run lint",
"lint": "eslint src --ext ts",
"test": "node ./out/test/runTest.js",
"test-web": "node ./prepare.js &amp;&amp; vscode-test-web --extensionDevelopmentPath=. --extensionTestsPath=dist/test/suite/index-web.js &amp;&amp; node ./cleanup.js"
</t>
<t tx="felix.20201214205159.8">{
  "command": "leojs.executeScript",
  "category": "Leojs",
  "title": "Execute Script",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/execute.svg",
    "dark": "resources/dark/execute.svg"
  }
},
{
  "command": "leojs.minibuffer",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Minibuffer"
},
{
  "command": "leojs.gotoScript",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Script"
},
{
  "command": "leojs.removeButton",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Button"
},
</t>
<t tx="felix.20201214205159.80">"@types/debounce": "^1.2.0",
"@types/elementtree": "^0.1.1",
"@types/glob": "^7.2.0",
"@types/lodash": "^4.14.177",
"@types/md5": "^2.3.1",
"@types/mocha": "^9.1.0",
"@types/node": "16.x",
"@types/vscode": "^1.71.0",
"@types/webpack-env": "^1.16.3",
"@typescript-eslint/eslint-plugin": "^5.16.0",
"@typescript-eslint/parser": "^5.16.0",
"@vscode/test-electron": "^2.0.3",
"@vscode/test-web": "^0.0.24",
"assert": "^2.0.0",
"buffer": "^6.0.3",
"eslint": "^8.11.0",
"glob": "^7.2.0",
"mocha": "^9.1.3",
"process": "^0.11.10",
"terser-webpack-plugin": "^5.3.1",
"ts-loader": "^9.2.6",
"typescript": "^4.5.5",
"webpack": "^5.70.0",
"webpack-cli": "^4.9.2",
"webpack-shell-plugin-next": "^2.2.2"
</t>
<t tx="felix.20201214205159.81">"binascii": "^0.0.2",
"bowser": "^2.11.0",
"browser-process-hrtime": "^1.0.0",
"console-browserify": "^1.2.0",
"crypto-browserify": "^3.12.0",
"date-format-lite": "^17.7.0",
"dayjs": "^1.11.3",
"dayjs-plugin-utc": "^0.1.2",
"difflib": "^0.2.4",
"elementtree": "^0.1.7",
"lodash": "^4.17.21",
"md5": "^2.3.0",
"os-browserify": "^0.3.0",
"path-browserify": "^1.0.1",
"safe-json-stringify": "^1.2.0",
"stream": "^0.0.2"
</t>
<t tx="felix.20201214205159.9">{
  "command": "leojs.showSettingsPage",
  "title": "Open Leojs Settings",
  "category": "Leojs",
  "icon": {
    "light": "resources/light/gear.svg",
    "dark": "resources/dark/gear.svg"
  }
},
{
  "command": "leojs.showWelcomePage",
  "title": "Welcome",
  "category": "Leojs"
},
{
  "command": "leojs.setLeoID",
  "category": "Leojs",
  "enablement": "!leojsReady",
  "title": "Set Leo ID"
},
{
  "command": "leojs.showBody",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus to Body"
},
{
  "command": "leojs.showOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus to Tree"
},
{
  "command": "leojs.showLogPane",
  "category": "Leojs",
  "title": "Show Log Pane",
  "enablement": "leojsReady",
  "icon": {
    "light": "resources/light/show-log.svg",
    "dark": "resources/dark/show-log.svg"
  }
},
</t>
<t tx="felix.20201214211742.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was clicked
 * @returns Promises that resolves when done
 */
public clickAtButton(p_node: LeoButtonNode): Thenable&lt;unknown&gt; {

    this.setupRefresh(Focus.NoChange, {
        tree: true,
        body: true,
        documents: true,
        buttons: true,
        states: true
    });

    vscode.window.showInformationMessage('TODO: Implement clickAtButton ' + p_node.label);

    this.launchRefresh();

    // if edited and accepted
    return Promise.resolve(true);

    // return Promise.resolve(undefined); // if cancelled
}

</t>
<t tx="felix.20201214211744.1">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was chosen to remove
 * @returns Thenable that resolves when done
 */
public removeAtButton(p_node: LeoButtonNode): Thenable&lt;unknown&gt; {

    this.setupRefresh(Focus.NoChange, { buttons: true });

    vscode.window.showInformationMessage('TODO: Implement removeAtButton ' + p_node.label);

    this.launchRefresh();

    // if edited and accepted
    return Promise.resolve(true);

    // return Promise.resolve(undefined); // if cancelled
}

</t>
<t tx="felix.20201214211830.1">/**
* * Close an opened Leo file
* @returns the promise started after it's done closing the Leo document
*/
public async closeLeoFile(): Promise&lt;unknown&gt; {

    await this.triggerBodySave();

    this.setupRefresh(Focus.Body, {
        tree: true,
        body: true,
        documents: true,
        buttons: true,
        states: true
    });

    const c = g.app.windowList[this.frameIndex].c;
    await c.close();
    this.launchRefresh();
    return Promise.resolve();
}

</t>
<t tx="felix.20201214211832.1">/**
 * * Sets up the call to the 'open-outline' command and its possible file url parameter.
 * @param p_leoFileUri optional uri for specifying a file, if missing, a dialog will open
 * @returns A promise that resolves when done trying to open the file
 */
public async openLeoFile(p_uri?: vscode.Uri): Promise&lt;unknown&gt; {

    // make sure it's a real uri because vscode may send selected
    // node from other tree that has this command in title
    if (p_uri &amp;&amp; !!p_uri.toJSON) {
        console.log('p_uri', p_uri);
        console.log('OPEN p_uri', JSON.stringify(p_uri.toJSON()));
    }

    this.setupRefresh(this.finalFocus, {
        tree: true,
        body: true,
        states: true,
        documents: true,
        buttons: true
    });
    if (!this.leoStates.fileOpenedReady) {
        // override with given argument
        let fileName: string;

        // make sure it's a real uri because vscode may send selected
        // node from other tree that has this command in title
        if (p_uri &amp;&amp; !!p_uri.fsPath &amp;&amp; p_uri.fsPath.trim &amp;&amp; p_uri.fsPath.trim() &amp;&amp; g.app.loadManager) {
            fileName = p_uri.fsPath.replace(/\\/g, '/');
            await g.app.loadManager.loadLocalFile(fileName, this);
        } else {
            const fileNames = await this.runOpenFileDialog(
                undefined,
                "Open",
                [
                    ["Leo files", "*.leo *.db"],
                    ["Python files", "*.py"],
                    ["All files", "*"]
                ],
                g.defaultLeoFileExtension(),
                false
            );
            if (fileNames &amp;&amp; fileNames.length &amp;&amp; g.app.loadManager) {
                await g.app.loadManager.loadLocalFile(fileNames[0], this);
            } else {
                return Promise.resolve();
            }
        }
    } else {
        await this.triggerBodySave();
        const c = g.app.windowList[this.frameIndex].c;
        await c.open_outline(p_uri);
    }

    this.launchRefresh();
    return Promise.resolve();

}

</t>
<t tx="felix.20201214211834.1">/**
 * * Shows the recent Leo files list, choosing one will open it
 * @returns A promise that resolves when the a file is finally opened, rejected otherwise
 */
public showRecentLeoFiles(): Thenable&lt;unknown&gt; {
    vscode.window.showInformationMessage('TODO: Implement showRecentLeoFiles');

    // if shown, chosen and opened
    return Promise.resolve(true);

    // return Promise.resolve(undefined); // if cancelled
}

</t>
<t tx="felix.20201214211835.1">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results.
 */
public async saveAsLeoFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave();

    const c = g.app.windowList[this.frameIndex].c;

    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        {
            tree: true,
            states: true,
            documents: true
        }
    );

    await c.saveAs();
    this.launchRefresh();
    return Promise.resolve();
}

</t>
<t tx="felix.20201214211836.1">/**
 * * Invokes the commander.save() command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns Promise that resolves when the save command is done
 */
public async saveLeoFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave();

    const c = g.app.windowList[this.frameIndex].c;

    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        {
            tree: true,
            states: true,
            documents: true
        }
    );

    await c.save();
    this.launchRefresh();
    return Promise.resolve();
}

</t>
<t tx="felix.20201214211837.1">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly selected document
 */
public switchLeoFile(): Thenable&lt;unknown&gt; {

    vscode.window.showInformationMessage('TODO: Implement switchLeoFile');

    // vscode.window.showQuickPick(w_entries, w_pickOptions);
    //     then
    // return Promise.resolve(this.selectOpenedLeoDocument(p_chosenDocument.value));

    return Promise.resolve(true);

    // return Promise.resolve(undefined); // if cancelled
}

</t>
<t tx="felix.20201214211839.1">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 * @param p_index position of the opened Leo document in the document array
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly opened document
 */
public selectOpenedLeoDocument(p_index: number, p_fromOutline?: boolean): Thenable&lt;unknown&gt; {

    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        {
            tree: true,
            body: true,
            buttons: true,
            states: true,
            documents: true
        }
    );

    this.frameIndex = p_index;

    this.launchRefresh();

    // if selected and opened
    return Promise.resolve(true);
}

</t>
<t tx="felix.20201214233119.1">/**
 * General 'Leo is ready' state, equivalent to leoBridgeReady in leoInteg
 */
private _leoReady: boolean = false;
get leoReady(): boolean {
    return this._leoReady;
}
set leoReady(p_value: boolean) {
    this._leoReady = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_READY, p_value);
}

</t>
<t tx="felix.20201222013904.1">/**
 * * Refreshes the outline. A reveal type can be passed along to specify the reveal type for the selected node
 * @param p_incrementTreeId Make all node id's be 'new' by incrementing the treeId prefix of the id's.
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_incrementTreeId: boolean, p_revealType?: RevealType): void {
    if (p_incrementTreeId) {
        this._leoTreeProvider.incTreeId();
    }
    if (p_revealType !== undefined &amp;&amp; p_revealType.valueOf() &gt;= this._revealType.valueOf()) { // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    try {
        if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            this.showOutlineIfClosed = false;
            // Force showing last used Leo outline first
            let w_viewName: string;
            if (this._lastTreeView === this._leoTreeExView) {
                w_viewName = Constants.TREEVIEW_EXPLORER_ID;
            } else {
                w_viewName = Constants.TREEVIEW_ID;
            }
            vscode.commands.executeCommand(w_viewName + ".focus").then(
                () =&gt; {
                    this._revealNodeRetriedRefreshOutline = false;
                    this._leoTreeProvider.refreshTreeRoot();
                },
                (p_reason) =&gt; {
                    // Reveal failed: retry once.
                    console.log('_refreshOutline could not reveal. Rejected reason: ', p_reason);
                    this._leoTreeProvider.refreshTreeRoot();
                }
            );

        } else {
            this.showOutlineIfClosed = false;
            // was visible, just refresh
            this._leoTreeProvider.refreshTreeRoot();
        }
    } catch (error) {
        // Also retry once on error
        console.log('_refreshOutline could not reveal. Catch Error: ', error);
        this._leoTreeProvider.refreshTreeRoot();
    }

}

</t>
<t tx="felix.20201227014627.1">/**
 * * Launches refresh for UI components and context states (Debounced)
 */
public async _launchRefresh(): Promise&lt;unknown&gt; {

    // check states for having at least a document opened
    if (this.leoStates.leoReady &amp;&amp; this.leoStates.fileOpenedReady) {
        // Had some opened
        if (!g.app.windowList.length) {
            return this._setupNoOpenedLeoDocument(); // All closed now!
        }
    }
    if (this.leoStates.leoReady &amp;&amp; !this.leoStates.fileOpenedReady) {
        // Was all closed
        if (g.app.windowList.length) {
            this._setupOpenedLeoDocument();
            // Has a commander opened, but wait for UI!
            await this.leoStates.qLastContextChange;
        }
    }

    // Consider last command finished since the refresh cycle is starting
    if (this.trace) {
        if (this.commandTimer !== undefined) {
            console.log('commandTimer', utils.getDurationMs(this.commandTimer));
        }
    }
    this.commandTimer = undefined;

    // Start reset-timer capture, if has been reset.
    this.lastRefreshTimer = process.hrtime();
    if (this.refreshTimer === undefined) {
        this.refreshTimer = this.lastRefreshTimer;
    }

    let w_revealType: RevealType;
    if (this.finalFocus.valueOf() === Focus.Outline) {
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        w_revealType = RevealType.RevealSelect;
    }

    const c = g.app.windowList[this.frameIndex].c;
    this._refreshNode = c.p;

    if (
        this._refreshNode &amp;&amp;
        this._refreshType.body &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty
    ) {
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        // Do this only if gnx is different from what is coming from Leo in this refresh cycle.
        const w_lastChangedDocGnx = utils.leoUriToStr(this._bodyLastChangedDocument.uri);
        if (
            this._refreshNode.gnx !== w_lastChangedDocGnx &amp;&amp; !this._bodyLastChangedDocumentSaved
        ) {
            this._bodyLastChangedDocument.save(); // Voluntarily save to 'clean' any pending body (no await)
            this._bodyLastChangedDocumentSaved = true;
        }
        if (this._refreshNode.gnx === w_lastChangedDocGnx) {
            this._leoFileSystem.preventSaveToLeo = true;
            await this._bodyLastChangedDocument.save(); // SAME GNX : so wait for it! (await)
        }
    }

    // * _focusInterrupt insertNode Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }

    const w_showBodyNoFocus: boolean = this.finalFocus.valueOf() !== Focus.Body;

    // * Either the whole tree refreshes, or a single tree node is revealed when just navigating
    if (this._refreshType.tree) {
        this._refreshType.tree = false;
        this._refreshType.node = false; // Also clears node
        if (!this.isOutlineVisible() &amp;&amp; !this.showOutlineIfClosed &amp;&amp; this._refreshType.body) {
            // wont get 'gotSelectedNode so show body!
            this._refreshType.body = false;
            this._tryApplyNodeToBody(this._refreshNode || this.lastSelectedNode!, false, w_showBodyNoFocus);
        } else if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            let w_treeName;
            if (this._lastTreeView === this._leoTreeExView) {
                w_treeName = Constants.TREEVIEW_EXPLORER_ID;
            } else {
                w_treeName = Constants.TREEVIEW_ID;
            }
            // Reveal will trigger a native outline refresh
            this._leoTreeProvider.incTreeId();
            this._revealType = w_revealType;
            vscode.commands.executeCommand(w_treeName + '.focus');
            // } else if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            //     const c = g.app.windowList[this.frameIndex].c;
            //     this._lastTreeView.reveal(c.p, { select: true });
            // } else {
            //     this._refreshOutline(true, w_revealType);
            // }
        } else {
            this._refreshOutline(true, w_revealType);
        }
    } else if (this._refreshType.node &amp;&amp; this._refreshNode) {
        // * Force single node "refresh" by revealing it, instead of "refreshing" it
        this._refreshType.node = false;
        this.leoStates.setSelectedNodeFlags(this._refreshNode);
        let w_showOutline = this.isOutlineVisible();
        if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            this.showOutlineIfClosed = false;
            w_showOutline = true;
        }
        this._revealNode(
            this._refreshNode,
            {
                select: true,
                focus: w_showOutline
            }
        );
        if (this._refreshType.body) {
            // * if no outline visible, just update body pane as needed
            if (!this.isOutlineVisible()) {
                this._refreshType.body = false;
                this._tryApplyNodeToBody(this._refreshNode, false, w_showBodyNoFocus);
            }
        }
    } else if (this._refreshType.body) {
        this._refreshType.body = false;
        this._tryApplyNodeToBody(this._refreshNode || this.lastSelectedNode!, false, w_showBodyNoFocus);
    }

    // * DEBUG INFO

    // console.log('***********************finished refresh');
    // console.log('**** c.config should be lowercase: ', c.config.new_leo_file_encoding);
    // // @ts-expect-error
    // console.log('**** g.app.config should be uppercase: ', g.app.config.new_leo_file_encoding);
    // console.log('**** c.collapse_on_lt_arrow :', c.collapse_on_lt_arrow);
    // console.log('**** c.collapse_nodes_after_move :', c.collapse_nodes_after_move);
    // console.log('**** c.sparse_move: ', c.sparse_move);

    // getStates will check if documents, buttons and states flags are set and refresh accordingly
    return this.getStates();
}

</t>
<t tx="felix.20201227155008.1">/**
 * * Setup global refresh options
 * @param p_finalFocus Flag for focus to be placed in outline
 * @param p_refreshType Refresh flags for each UI part
*/
public setupRefresh(p_finalFocus: Focus, p_refreshType: ReqRefresh): void {
    // Set final "focus-placement" EITHER true or false
    this.finalFocus = p_finalFocus;
    // Set all properties WITHOUT clearing others.
    Object.assign(this._refreshType, p_refreshType);
}

</t>
<t tx="felix.20201227230901.1">/**
 * * Setup UI for having no opened Leo documents
 */
private _setupNoOpenedLeoDocument(): void {
    this.leoStates.fileOpenedReady = false;
    this._bodyTextDocument = undefined;
    this.lastSelectedNode = undefined;
    this._refreshOutline(false, RevealType.NoReveal);
    this.refreshDocumentsPane();
    this.refreshButtonsPane();
    this.refreshUndoPane();
    this.closeBody();
}

</t>
<t tx="felix.20201227230912.1">/**
 * * A Leo file was opened: setup UI accordingly.
 * @param p_openFileResult Returned info about currently opened and editing document
 * @return a promise that resolves to an opened body pane text editor
 */
private _setupOpenedLeoDocument(): Promise&lt;unknown&gt; {
    this._needLastSelectedRefresh = true;

    const c = g.app.windowList[this.frameIndex].c;
    this.leoStates.leoOpenedFileName = c.fileName();
    this.leoStates.leoChanged = c.changed;

    // * Startup flag
    this.leoStates.fileOpenedReady = true;

    this._revealType = RevealType.RevealSelect; // For initial outline 'visible' event

    this.showBodyIfClosed = true;
    this.showOutlineIfClosed = true;
    this.setupRefresh(
        Focus.Body, // Original Leo seems to open itself with focus in body.
        {
            tree: true,
            body: true,
            states: true,
            buttons: true,
            documents: true,
            goto: true
        },
    );

    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEO_SCHEME,
                this._leoFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._bodyFileSystemStarted = true;
    }

    // this._leoStatusBar.update(true, 0, true); // todo 
    // this._leoStatusBar.show(); // Just selected a node // todo
    this.loadSearchSettings();

    return Promise.resolve(true);
}

</t>
<t tx="felix.20201229025520.1">/**
 * * Handle selected node being created for the outline
 * @param p_node Position that was just created and detected as selected node
 */
public gotSelectedNode(p_node: Position): void {

    const w_focusTree = (this._revealType.valueOf() &gt;= RevealType.RevealSelectFocus.valueOf());
    const w_last = this.lastSelectedNode;

    if (
        !w_focusTree &amp;&amp;
        this._refreshType.scroll &amp;&amp;
        w_last &amp;&amp;
        w_last.__eq__(p_node) &amp;&amp; // utils.isApEqual(w_last, p_node) &amp;&amp;
        this._lastTreeView &amp;&amp;
        this._lastTreeView.visible

    ) {
        // ! MINIMAL TIMEOUT REQUIRED ! WHY ?? (works so leave)
        setTimeout(() =&gt; {
            // SAME with scroll information specified
            this.showBody(false, this.finalFocus.valueOf() !== Focus.Body);
        }, 25);
    } else {

        if (this._revealType) {
            setTimeout(() =&gt; {
                this._lastTreeView.reveal(p_node, {
                    select: true,
                    focus: w_focusTree
                }).then(() =&gt; {
                    // ok
                    if (this.trace) {
                        if (this.refreshTimer) {
                            console.log('refreshTimer', utils.getDurationMs(this.refreshTimer));
                        }
                        if (this.lastRefreshTimer) {
                            console.log('lastRefreshTimer', utils.getDurationMs(this.lastRefreshTimer));
                        }
                        if (this.commandRefreshTimer) {
                            console.log('commandRefreshTimer', utils.getDurationMs(this.commandRefreshTimer));
                        }
                        if (this.lastCommandRefreshTimer) {
                            console.log('lastCommandRefreshTimer', utils.getDurationMs(this.lastCommandRefreshTimer));
                        }
                    }
                    this.refreshTimer = undefined;
                    this.lastRefreshTimer = undefined;
                    this.commandRefreshTimer = undefined;
                    this.lastCommandRefreshTimer = undefined;
                }, (p_reason) =&gt; {
                    // Reveal failed. Retry refreshOutline once
                    this._refreshOutline(true, RevealType.RevealSelect);
                });
                // Done, so reset reveal type 'flag'
                this._revealType = RevealType.NoReveal;
            }, 0);
        }

        // Apply node to body pane
        let w_showBodyNoFocus: boolean = this.finalFocus.valueOf() !== Focus.Body; // Will preserve focus where it is without forcing into the body pane if true
        if (this._focusInterrupt) {
            this._focusInterrupt = false;
            w_showBodyNoFocus = true;
        }
        if (!w_last || this._needLastSelectedRefresh) {
            // lastSelectedNode will be set in _tryApplyNodeToBody !
            this._needLastSelectedRefresh = false;
        }

        if (this._bodyTextDocument &amp;&amp;
            !this._bodyTextDocument.isClosed &amp;&amp; // IS OPENED
            !this._refreshType.body &amp;&amp; // NO NEED TO REFRESH BODY !
            this._locateOpenedBody(p_node.gnx) // DID LOCATE NEW GNX =&gt; ALREADY SHOWN!
        ) {
            // * Just make sure body selection is considered done.
            this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context
            this._preventShowBody = false; // in case it was a config-changed-refresh
        } else {
            // * Actually run the normal 'APPLY NODE TO BODY' to show or switch
            this._tryApplyNodeToBody(p_node, false, w_showBodyNoFocus);
        }

        // Set context flags
        this.leoStates.setSelectedNodeFlags(p_node);
    }

}

</t>
<t tx="felix.20210102000055.1"></t>
<t tx="felix.20210102000100.1"></t>
<t tx="felix.20210110210346.1">@language typescript
@tabwidth -4

// ambient module declaration for https://www.npmjs.com/package/date-format-lite
declare module "date-format-lite" { }

// date-format-lite augments built-in Date
interface Date {
    format: (format?: string) =&gt; string;
    masks: { default: string };
}

</t>
<t tx="felix.20211002194716.1"></t>
<t tx="felix.20211003223641.1">/**
 * * Builds a unique Id from gnx and stack, plus collapsed state,
 * for vscode to distinguish the collapsed state.
 */
private _buildId(p_position: Position, p_collapsed: number): string {
    // concatenate gnx, stacks gnx's, and collapsible state number.
    // (vscode uses id for collapsible state)
    let w_stringId = this.treeId.toString() +
        p_position.v.gnx + p_position.childIndex().toString() +
        p_position.stack.map(p_stackEntry =&gt; p_stackEntry[0].gnx + p_stackEntry[1].toString()).join("");
    // NOT NEEDED -&gt; p_collapsed.toString(); // Added Uniqueness: VSCode's collapsible state in id
    return w_stringId;
}

</t>
<t tx="felix.20211003233639.1">/**
 * * Force uniqueness of ids generated for nodes in the  next tree refresh
 */
public incTreeId(): void {
    this.treeId++;
}

</t>
<t tx="felix.20211006225245.1">"configuration": {
  "title": "Leojs",
  "properties": {
    "leojs.checkForChangeExternalFiles": {
      "scope": "application",
      "default": "none",
      "type": "string",
      "description": "Set default for checking changes to external files",
      "enum": [
        "none",
        "force-check",
        "force-ignore"
      ],
      "enumDescriptions": [
        "Default from Leo's config",
        "Check for changes",
        "Ignore all changes"
      ]
    },
    "leojs.defaultReloadIgnore": {
      "scope": "application",
      "default": "none",
      "type": "string",
      "description": "Set default for derived files to always reload, or always ignore, when changes are detected",
      "enum": [
        "none",
        "yes-all",
        "no-all"
      ],
      "enumDescriptions": [
        "Choose each time",
        "Reload All",
        "Ignore All"
      ]
    },
    "leojs.leoTreeBrowse": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
    },
    "leojs.treeKeepFocus": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
    },
    "leojs.treeKeepFocusWhenAside": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
    },
    "leojs.goAnywhereShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables Leo's 'Go Anywhere' to replace 'Go to file' with the Ctrl+P keyboard shortcut when focus in in outline or body"
    },
    "leojs.collapseAllShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables the Alt+'-' keyboard shortcut for collapsing all folders in the Explorer View"
    },
    "leojs.activityViewShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables the Ctrl+Shift+L keyboard shortcut for showing the LeoJS view"
    },
    "leojs.statusBarString": {
      "scope": "application",
      "default": "",
      "type": "string",
      "description": "Sets the message string of the Status Bar Indicator"
    },
    "leojs.statusBarColor": {
      "scope": "application",
      "default": "fb7c47",
      "type": "string",
      "description": "Specifies the hexadecimal color string for the Status Bar Indicator"
    },
    "leojs.treeInExplorer": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Show the outline tree in the explorer view"
    },
    "leojs.showOpenAside": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Offer 'Open to the Side' in nodes context menu"
    },
    "leojs.showEditOnNodes": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Shows 'Edit Headline' button on tree nodes"
    },
    "leojs.showAddOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Insert' button on tree nodes"
    },
    "leojs.showMarkOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Mark/Unmark' buttons on tree nodes"
    },
    "leojs.showCloneOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Clone' button on tree nodes"
    },
    "leojs.showCopyOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Copy' button on tree nodes"
    },
    "leojs.invertNodeContrast": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
    },
    "leojs.leoID": {
      "scope": "application",
      "default": "",
      "type": "string",
      "description": "Used to uniquely identify nodes - Defaults to the OS/Environment user name",
      "pattern": "(^$|^[a-zA-Z0-9]*$)",
      "patternErrorMessage": "Your id should contain only letters and numbers, and must contain at least 3 characters."
    }
  }
},
</t>
<t tx="felix.20211007213344.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, ConfigSetting, FontSettings } from "./types";
import { Constants } from "./constants";
import { LeoUI } from "./leoUI";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20211007213344.10">/**
 * * Check if the workbench.editor.enablePreview flag is set
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkEnablePreview(p_forced?: boolean): void {
    let w_result: any = true;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("enablePreview")!.globalValue === undefined) {
        w_result = w_setting.inspect("enablePreview")!.defaultValue;
    } else {
        w_result = w_setting.inspect("enablePreview")!.globalValue;
    }
    if (w_result === false) {
        if (p_forced) {
            this.setEnablePreview();
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.ENABLE_PREVIEW_SET);
        } else {
            vscode.window.showWarningMessage(
                Constants.USER_MESSAGES.ENABLE_PREVIEW_RECOMMEND,
                Constants.USER_MESSAGES.FIX_IT
            ).then(p_chosenButton =&gt; {
                if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                    vscode.commands.executeCommand(Constants.COMMANDS.SET_ENABLE_PREVIEW);
                }
            });
        }
    }
}

</t>
<t tx="felix.20211007213344.11">/**
 * * Check if the 'workbench.editor.closeEmptyGroups' setting is false
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkCloseEmptyGroups(p_forced?: boolean): void {
    let w_result: any = false;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("closeEmptyGroups")!.globalValue === undefined) {
        w_result = w_setting.inspect("closeEmptyGroups")!.defaultValue;
    } else {
        w_result = w_setting.inspect("closeEmptyGroups")!.globalValue;
    }
    if (w_result === true) {
        if (p_forced) {
            this.clearCloseEmptyGroups();
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_EMPTY_CLEARED);
        } else {
            vscode.window.showWarningMessage(
                Constants.USER_MESSAGES.CLOSE_EMPTY_RECOMMEND,
                Constants.USER_MESSAGES.FIX_IT
            ).then(p_chosenButton =&gt; {
                if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                    vscode.commands.executeCommand(Constants.COMMANDS.CLEAR_CLOSE_EMPTY_GROUPS);
                }
            });
        }
    }
}

</t>
<t tx="felix.20211007213344.13">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    // Shorthand pointers for readability
    const GET = vscode.workspace.getConfiguration;
    const NAME = Constants.CONFIG_NAME;
    const NAMES = Constants.CONFIG_NAMES;
    const DEFAULTS = Constants.CONFIG_DEFAULTS;
    const FLAGS = Constants.CONTEXT_FLAGS;

    if (this._isBusySettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        this.checkForChangeExternalFiles = GET(NAME).get(NAMES.CHECK_FOR_CHANGE_EXTERNAL_FILES, DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES);
        this.defaultReloadIgnore = GET(NAME).get(NAMES.DEFAULT_RELOAD_IGNORE, DEFAULTS.DEFAULT_RELOAD_IGNORE);
        this.leoTreeBrowse = GET(NAME).get(NAMES.LEO_TREE_BROWSE, DEFAULTS.LEO_TREE_BROWSE);
        this.treeKeepFocus = GET(NAME).get(NAMES.TREE_KEEP_FOCUS, DEFAULTS.TREE_KEEP_FOCUS);
        this.treeKeepFocusWhenAside = GET(NAME).get(NAMES.TREE_KEEP_FOCUS_WHEN_ASIDE, DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE);

        this.collapseAllShortcut = GET(NAME).get(NAMES.COLLAPSE_ALL_SHORTCUT, DEFAULTS.COLLAPSE_ALL_SHORTCUT);
        this.activityViewShortcut = GET(NAME).get(NAMES.ACTIVITY_VIEW_SHORTCUT, DEFAULTS.ACTIVITY_VIEW_SHORTCUT);
        this.goAnywhereShortcut = GET(NAME).get(NAMES.GO_ANYWHERE_SHORTCUT, DEFAULTS.GO_ANYWHERE_SHORTCUT);

        // this.statusBarString = GET(NAME).get(NAMES.STATUSBAR_STRING, DEFAULTS.STATUSBAR_STRING);
        // if (this.statusBarString.length &gt; 8) {
        //     this.statusBarString = DEFAULTS.STATUSBAR_STRING;
        // }
        this.statusBarColor = GET(NAME).get(NAMES.STATUSBAR_COLOR, DEFAULTS.STATUSBAR_COLOR);
        if (!utils.isHexColor(this.statusBarColor)) {
            this.statusBarColor = DEFAULTS.STATUSBAR_COLOR;
        }
        this.treeInExplorer = GET(NAME).get(NAMES.TREE_IN_EXPLORER, DEFAULTS.TREE_IN_EXPLORER);
        this.showOpenAside = GET(NAME).get(NAMES.SHOW_OPEN_ASIDE, DEFAULTS.SHOW_OPEN_ASIDE);
        this.showEditOnNodes = GET(NAME).get(NAMES.SHOW_EDIT, DEFAULTS.SHOW_EDIT);
        this.showAddOnNodes = GET(NAME).get(NAMES.SHOW_ADD, DEFAULTS.SHOW_ADD);
        this.showMarkOnNodes = GET(NAME).get(NAMES.SHOW_MARK, DEFAULTS.SHOW_MARK);
        this.showCloneOnNodes = GET(NAME).get(NAMES.SHOW_CLONE, DEFAULTS.SHOW_CLONE);
        this.showCopyOnNodes = GET(NAME).get(NAMES.SHOW_COPY, DEFAULTS.SHOW_COPY);

        // this.showArrowsOnNodes = GET(NAME).get(NAMES.SHOW_ARROWS, DEFAULTS.SHOW_ARROWS);

        // this.showEditionOnBody = GET(NAME).get(NAMES.SHOW_EDITION_BODY, DEFAULTS.SHOW_EDITION_BODY);
        // this.showClipboardOnBody = GET(NAME).get(NAMES.SHOW_CLIPBOARD_BODY, DEFAULTS.SHOW_CLIPBOARD_BODY);
        // this.showPromoteOnBody = GET(NAME).get(NAMES.SHOW_PROMOTE_BODY, DEFAULTS.SHOW_PROMOTE_BODY);
        // this.showExecuteOnBody = GET(NAME).get(NAMES.SHOW_EXECUTE_BODY, DEFAULTS.SHOW_EXECUTE_BODY);
        // this.showExtractOnBody = GET(NAME).get(NAMES.SHOW_EXTRACT_BODY, DEFAULTS.SHOW_EXTRACT_BODY);
        // this.showImportOnBody = GET(NAME).get(NAMES.SHOW_IMPORT_BODY, DEFAULTS.SHOW_IMPORT_BODY);
        // this.showRefreshOnBody = GET(NAME).get(NAMES.SHOW_REFRESH_BODY, DEFAULTS.SHOW_REFRESH_BODY);
        // this.showHoistOnBody = GET(NAME).get(NAMES.SHOW_HOIST_BODY, DEFAULTS.SHOW_HOIST_BODY);
        // this.showMarkOnBody = GET(NAME).get(NAMES.SHOW_MARK_BODY, DEFAULTS.SHOW_MARK_BODY);
        // this.showSortOnBody = GET(NAME).get(NAMES.SHOW_SORT_BODY, DEFAULTS.SHOW_SORT_BODY);

        this.invertNodeContrast = GET(NAME).get(NAMES.INVERT_NODES, DEFAULTS.INVERT_NODES);
        this.leoID = GET(NAME).get(NAMES.LEO_ID, DEFAULTS.LEO_ID);

    }
}

</t>
<t tx="felix.20211007213344.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {

    // Config settings used on Leo's side
    public checkForChangeExternalFiles: string = Constants.CONFIG_DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES;
    public defaultReloadIgnore: string = Constants.CONFIG_DEFAULTS.DEFAULT_RELOAD_IGNORE;

    // Config settings used on vscode's side
    public leoTreeBrowse: boolean = Constants.CONFIG_DEFAULTS.LEO_TREE_BROWSE; // Used as Context Flag
    public treeKeepFocus: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS;
    public treeKeepFocusWhenAside: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE;

    public collapseAllShortcut: boolean = Constants.CONFIG_DEFAULTS.COLLAPSE_ALL_SHORTCUT;
    public activityViewShortcut: boolean = Constants.CONFIG_DEFAULTS.ACTIVITY_VIEW_SHORTCUT;
    public goAnywhereShortcut: boolean = Constants.CONFIG_DEFAULTS.GO_ANYWHERE_SHORTCUT;

    // public statusBarString: string = Constants.CONFIG_DEFAULTS.STATUSBAR_STRING;
    public statusBarColor: string = Constants.CONFIG_DEFAULTS.STATUSBAR_COLOR;
    public treeInExplorer: boolean = Constants.CONFIG_DEFAULTS.TREE_IN_EXPLORER; // Used as Context Flag
    public showOpenAside: boolean = Constants.CONFIG_DEFAULTS.SHOW_OPEN_ASIDE; // Used as Context Flag
    public showEditOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDIT; // Used as Context Flag

    // public showArrowsOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ARROWS; // Used as Context Flag
    public showAddOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ADD; // Used as Context Flag
    public showMarkOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK; // Used as Context Flag
    public showCloneOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLONE; // Used as Context Flag
    public showCopyOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_COPY; // Used as Context Flag

    // public showEditionOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDITION_BODY; // Used as Context Flag
    // public showClipboardOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLIPBOARD_BODY; // Used as Context Flag
    // public showPromoteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_PROMOTE_BODY; // Used as Context Flag
    // public showExecuteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXECUTE_BODY; // Used as Context Flag
    // public showExtractOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXTRACT_BODY; // Used as Context Flag
    // public showImportOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_IMPORT_BODY; // Used as Context Flag
    // public showRefreshOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_REFRESH_BODY; // Used as Context Flag
    // public showHoistOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_HOIST_BODY; // Used as Context Flag
    // public showMarkOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK_BODY; // Used as Context Flag
    // public showSortOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_SORT_BODY; // Used as Context Flag

    public invertNodeContrast: boolean = Constants.CONFIG_DEFAULTS.INVERT_NODES;
    public leoID: string = Constants.CONFIG_DEFAULTS.LEO_ID;

    private _isBusySettingConfig: boolean = false;
    private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoUI: LeoUI
    ) { }

    @others
}
</t>
<t tx="felix.20211007213344.3">/**
 * * Get actual 'live' Leojs configuration
 * @returns An object with config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,
        defaultReloadIgnore: this.defaultReloadIgnore,
        leoTreeBrowse: this.leoTreeBrowse, // Used as Context Flag
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,

        collapseAllShortcut: this.collapseAllShortcut,
        activityViewShortcut: this.activityViewShortcut,
        goAnywhereShortcut: this.goAnywhereShortcut,

        // statusBarString: this.statusBarString,
        statusBarColor: this.statusBarColor,
        treeInExplorer: this.treeInExplorer, // Used as Context Flag
        showOpenAside: this.showOpenAside,  // Used as Context Flag
        showEditOnNodes: this.showEditOnNodes, // Used as Context Flag
        // showArrowsOnNodes: this.showArrowsOnNodes, // Used as Context Flag
        showAddOnNodes: this.showAddOnNodes, // Used as Context Flag
        showMarkOnNodes: this.showMarkOnNodes, // Used as Context Flag
        showCloneOnNodes: this.showCloneOnNodes, // Used as Context Flag
        showCopyOnNodes: this.showCopyOnNodes, // Used as Context Flag

        // showEditionOnBody: this.showEditionOnBody, // Used as Context Flag
        // showClipboardOnBody: this.showClipboardOnBody, // Used as Context Flag
        // showPromoteOnBody: this.showPromoteOnBody, // Used as Context Flag
        // showExecuteOnBody: this.showExecuteOnBody, // Used as Context Flag
        // showExtractOnBody: this.showExtractOnBody, // Used as Context Flag
        // showImportOnBody: this.showImportOnBody, // Used as Context Flag
        // showRefreshOnBody: this.showRefreshOnBody, // Used as Context Flag
        // showHoistOnBody: this.showHoistOnBody, // Used as Context Flag
        // showMarkOnBody: this.showMarkOnBody, // Used as Context Flag
        // showSortOnBody: this.showSortOnBody, // Used as Context Flag

        invertNodeContrast: this.invertNodeContrast,
        leoID: this.leoID
    };
}

</t>
<t tx="felix.20211007213344.4">/**
 * * Get config from vscode for the UI font sizes
 * @returns the font settings object (zoom level and editor font size)
 */
public getFontConfig(): FontSettings {
    let w_zoomLevel = vscode.workspace.getConfiguration(
        "window"
    ).get("zoomLevel");

    let w_fontSize = vscode.workspace.getConfiguration(
        "editor"
    ).get("fontSize");

    const w_config: FontSettings = {
        zoomLevel: Number(w_zoomLevel),
        fontSize: Number(w_fontSize)
    };

    return w_config;
}

</t>
<t tx="felix.20211007213344.5">/**
 * * Apply changes to the expansion config settings and save them in user settings.
 * @param p_changes is an array of codes and values to be changed
 * @returns a promise that resolves upon completion
 */
public async setLeojsSettings(p_changes: ConfigSetting[]): Promise&lt;unknown&gt; {
    this._isBusySettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (i_change.code.includes(Constants.CONFIG_REFRESH_MATCH)) {
            // Check if tree refresh is required for hover-icons to be displayed or hidden accordingly
            this._needsTreeRefresh = true;
        }
        // tslint:disable-next-line: strict-comparisons
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // Set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
        } else {
            // Set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
        }
    });

    await Promise.all(w_promises);
    if (this._needsTreeRefresh) {
        this._needsTreeRefresh = false;
        setTimeout(() =&gt; {
            this._leoUI.configTreeRefresh();
        }, 200);
    }
    this._isBusySettingConfig = false;
    return this.buildFromSavedSettings(); // Refresh config from settings from vscode's saved config

}

</t>
<t tx="felix.20211007213344.6">/**
 * * Apply changes in font size settings and save them in user settings.
 */
public setFontConfig(p_settings: FontSettings): void {
    if (p_settings.zoomLevel || p_settings.zoomLevel === 0) {
        if (!isNaN(p_settings.zoomLevel) &amp;&amp; p_settings.zoomLevel &lt;= 12 &amp;&amp; p_settings.zoomLevel &gt;= -12) {
            vscode.workspace.getConfiguration("window")
                .update("zoomLevel", p_settings.zoomLevel, true);
        } else {
            vscode.window.showInformationMessage(
                Constants.USER_MESSAGES.ZOOM_LEVEL_RANGE_LIMIT
            );
        }
    }
    if (p_settings.fontSize) {
        if (!isNaN(p_settings.fontSize) &amp;&amp; p_settings.fontSize &lt;= 30 &amp;&amp; p_settings.fontSize &gt;= 6) {
            vscode.workspace.getConfiguration("editor")
                .update("fontSize", p_settings.fontSize, true);
        } else {
            vscode.window.showInformationMessage(
                Constants.USER_MESSAGES.FONT_SIZE_RANGE_LIMIT
            );
        }
    }
}

</t>
<t tx="felix.20211007213344.7">/**
 * * Set the workbench.editor.enablePreview vscode setting
 */
public setEnablePreview(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("enablePreview", true, true);
}

</t>
<t tx="felix.20211007213344.8">/**
 * * Clears the workbench.editor.closeEmptyGroups vscode setting
 */
public clearCloseEmptyGroups(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("closeEmptyGroups", false, true);
}

</t>
<t tx="felix.20211007213900.1">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;

    collapseAllShortcut: boolean;
    activityViewShortcut: boolean;
    goAnywhereShortcut: boolean;

    // statusBarString: string;
    statusBarColor: string;

    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    // showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;

    // showEditionOnBody: boolean; // clone delete insert(s)
    // showClipboardOnBody: boolean; // cut copy paste(s)
    // showPromoteOnBody: boolean; // promote demote
    // showExecuteOnBody: boolean; // extract(s)
    // showExtractOnBody: boolean;
    // showImportOnBody: boolean;
    // showRefreshOnBody: boolean;
    // showHoistOnBody: boolean;
    // showMarkOnBody: boolean;
    // showSortOnBody: boolean;

    invertNodeContrast: boolean;
    leoID: string;
}

</t>
<t tx="felix.20211007213909.1">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20211007213915.1">/**
 * * Structure for the two vscode font settings
 */
export interface FontSettings {
    zoomLevel: number;
    fontSize: number;
}

</t>
<t tx="felix.20211007214102.1">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG_NAMES = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    STATUSBAR_STRING: "statusBarString",
    STATUSBAR_COLOR: "statusBarColor",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_OPEN_ASIDE: "showOpenAside",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ARROWS: "showArrowsOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",

    COLLAPSE_ALL_SHORTCUT: "collapseAllShortcut",
    ACTIVITY_VIEW_SHORTCUT: "ActivityViewShortcut",
    GO_ANYWHERE_SHORTCUT: "goAnywhereShortcut",

    // SHOW_EDITION_BODY: "showEditionOnBody",
    // SHOW_CLIPBOARD_BODY: "showClipboardOnBody",
    // SHOW_PROMOTE_BODY: "showPromoteOnBody",
    // SHOW_EXECUTE_BODY: "showExecuteOnBody",
    // SHOW_EXTRACT_BODY: "showExtractOnBody",
    // SHOW_IMPORT_BODY: "showImportOnBody",
    // SHOW_REFRESH_BODY: "showRefreshOnBody",
    // SHOW_HOIST_BODY: "showHoistOnBody",
    // SHOW_MARK_BODY: "showMarkOnBody",
    // SHOW_SORT_BODY: "showSortOnBody",

    INVERT_NODES: "invertNodeContrast",
    LEO_ID: "leoID"
};

</t>
<t tx="felix.20211007214110.1">/**
 * * Configuration Defaults used in config.ts
 * Used when setting itself and getting parameters from vscode
 */
public static CONFIG_DEFAULTS = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "none",  // Used in leoBridge scrip,
    DEFAULT_RELOAD_IGNORE: "none", // Used in leoBridge scrip,
    LEO_TREE_BROWSE: true,
    TREE_KEEP_FOCUS: true,
    TREE_KEEP_FOCUS_WHEN_ASIDE: false,

    COLLAPSE_ALL_SHORTCUT: true,
    ACTIVITY_VIEW_SHORTCUT: true,
    GO_ANYWHERE_SHORTCUT: true,

    // STATUSBAR_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: \u{1F981}

    STATUSBAR_COLOR: "fb7c47",
    TREE_IN_EXPLORER: true,
    SHOW_OPEN_ASIDE: true,
    SHOW_EDIT: true,
    SHOW_ARROWS: false,
    SHOW_ADD: false,
    SHOW_MARK: false,
    SHOW_CLONE: false,
    SHOW_COPY: false,

    // SHOW_EDITION_BODY: true,
    // SHOW_CLIPBOARD_BODY: true,
    // SHOW_PROMOTE_BODY: true,
    // SHOW_EXECUTE_BODY: true,
    // SHOW_EXTRACT_BODY: true,
    // SHOW_IMPORT_BODY: true,
    // SHOW_REFRESH_BODY: true,
    // SHOW_HOIST_BODY: true,
    // SHOW_MARK_BODY: true,
    // SHOW_SORT_BODY: true,

    INVERT_NODES: false,
    LEO_ID: ""
};

</t>
<t tx="felix.20211007214455.1">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="felix.20211007232334.1">/**
 * * Refresh tree for 'node hover icons' to show up properly after changing their settings
 */
public configTreeRefresh(): void {
    if (this.leoStates.fileOpenedReady) {
        this._preventShowBody = true;
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20211008004139.1">/**
 * * Find panel controls ids
 */
public static FIND_INPUTS_IDS = {
    FIND_TEXT: "findText",
    REPLACE_TEXT: "replaceText",
    ENTIRE_OUTLINE: "entireOutline",
    FILE_ONLY: "fileOnly",
    NODE_ONLY: "nodeOnly",
    SUBOUTLINE_ONLY: "subOutlineOnly",
    IGNORE_CASE: "ignoreCase",
    MARK_CHANGES: "markChanges",
    MARK_FINDS: "markFinds",
    REG_EXP: "regExp",
    WHOLE_WORD: "wholeWord",
    SEARCH_BODY: "searchBody",
    SEARCH_HEADLINE: "searchHeadline"
};

</t>
<t tx="felix.20211010192923.1">import * as vscode from "vscode";
import { Utils as uriUtils } from "vscode-uri";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { BodyTimeInfo } from "./types";
import { LeoUI } from "./leoUI";
import * as g from './core/leoGlobals';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20211010192923.10">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20211010192923.11">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    if (!this.preventSaveToLeo) {
        this._leoUi.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    } else {
        this.preventSaveToLeo = false;
    }
    const w_gnx = utils.leoUriToStr(p_uri);
    if (!this._openedBodiesGnx.includes(w_gnx)) {
        console.error("LeoJS: Tried to save body other than selected node's body", w_gnx);
    }

    this.setOpenedBodyTime(w_gnx);

    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20211010192923.12">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('Called rename on ', p_oldUri.fsPath, p_newUri.fsPath); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20211010192923.13">public delete(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.splice(this._openedBodiesGnx.indexOf(w_gnx), 1);
        delete this._openedBodiesInfo[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20211010192923.14">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20211010192923.15">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20211010192923.2">/**
 * * Body panes implementation as a file system using "leojs" as a scheme identifier
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;
    private _errorRefreshFlag: boolean = false;

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastBodyLength: number = 0; // length of last file read

    // * List of currently opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    private _watchedBodiesGnx: string[] = [];

    // * List of gnx that should be available (from more.selectNode and fs.delete)
    private _openedBodiesGnx: string[] = [];
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    private _lastBodyTimeGnx: string = "";

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being watched by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoUi: LeoUI) { }

    @others
}
</t>
<t tx="felix.20211010192923.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setNewBodyUriTime(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._lastBodyTimeGnx = w_gnx;
    this.setOpenedBodyTime(w_gnx);
}

/**
 * * Adds entries in _openedBodiesGnx and _openedBodiesInfo if needed
 * * and sets the modified time of an opened body.
 */
public setOpenedBodyTime(p_gnx: string): void {
    const w_now = new Date().getTime();
    let w_created = w_now;
    if (!this._openedBodiesGnx.includes(p_gnx)) {
        this._openedBodiesGnx.push(p_gnx);
    } else {
        w_created = this._openedBodiesInfo[p_gnx].ctime; // Already created?
    }
    this._openedBodiesInfo[p_gnx] = {
        ctime: w_now, // maybe kept.
        mtime: w_now // new 'modified' time for sure.
    };
}
</t>
<t tx="felix.20211010192923.4">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {
    console.log('fireRefreshFile', p_gnx);

    if (!this._openedBodiesGnx.includes(p_gnx)) {
        console.error("ASKED TO REFRESH NOT EVEN IN SELECTED BODY: ", p_gnx);
    }

    this.setOpenedBodyTime(p_gnx);

    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    } as vscode.FileChangeEvent]);
}

</t>
<t tx="felix.20211010192923.5">/**
 * ? Maybe deprecated 
 * * Refreshes the '_possibleGnxList' list of all unique gnx from Leo
 * @returns a 'fresh' gnx string array
 */
public refreshPossibleGnxList(): string[] {
    // * Get updated list of possible gnx

    // all_gnx = [p.v.gnx for p in c.all_unique_positions(copy=False)]
    const c = g.app.windowList[this._leoUi.frameIndex].c;
    return [...c.all_unique_positions(false)].map(p =&gt; p.v.gnx);
}

</t>
<t tx="felix.20211010192923.6">public watch(p_resource: vscode.Uri, p_options: { readonly recursive: boolean; readonly excludes: readonly string[] }): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this._watchedBodiesGnx.includes(w_gnx)) {
        this._watchedBodiesGnx.push(w_gnx); // add gnx
    }
    // else already in list
    return new vscode.Disposable(() =&gt; {
        const w_position = this._watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this._watchedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20211010192923.7">public stat(p_uri: vscode.Uri): vscode.FileStat {
    if (this._leoUi.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        if (p_uri.fsPath.length === 1) {
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
        } else if (w_gnx === this._lastGnx &amp;&amp; this._openedBodiesGnx.includes(this._lastGnx)) {
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._lastBodyLength
            };
        } else if (this._openedBodiesGnx.includes(w_gnx)) {
            const c = g.app.windowList[this._leoUi.frameIndex].c;
            const w_v = c.fileCommands.gnxDict[w_gnx];
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[w_gnx].ctime,
                mtime: this._openedBodiesInfo[w_gnx].mtime,
                size: w_v.b.length
            };
        }
    }
    // throw vscode.FileSystemError.FileNotFound();
    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
    return { type: vscode.FileType.File, ctime: 0, mtime: 0, size: 0 };
}

</t>
<t tx="felix.20211010192923.8">public readFile(p_uri: vscode.Uri): Uint8Array {
    if (this._leoUi.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);

            if (!this._openedBodiesGnx.includes(w_gnx)) {
                console.log(
                    " _openedBodiesGnx length: ", this._openedBodiesGnx.length,
                    '\n *** readFile: ERROR File not in _openedBodiesGnx! readFile missing refreshes? gnx: ', w_gnx
                );
            }

            const c = g.app.windowList[this._leoUi.frameIndex].c;
            const w_v = c.fileCommands.gnxDict[w_gnx];
            if (w_v) {
                this._errorRefreshFlag = false; // got body so reset possible flag!
                this._lastGnx = w_gnx;
                this._lastBodyData = w_v.b;

                const w_buffer: Uint8Array = Buffer.from(this._lastBodyData);
                this._lastBodyLength = w_buffer.byteLength;
                return w_buffer;
            } else {
                if (!this._errorRefreshFlag) {
                    this._leoUi.fullRefresh(); // TODO ?
                }
                if (this._lastGnx === w_gnx) {
                    // was last gnx of closed file about to be switched to new document selected
                    console.log('Passed in not found: ' + w_gnx);
                    return Buffer.from(this._lastBodyData);
                }
                console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                return Buffer.from("");
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20211010192923.9">public readDirectory(p_uri: vscode.Uri): [string, vscode.FileType][] {
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._lastBodyTimeGnx, vscode.FileType.File]);
        return w_directory;
    } else {
        throw vscode.FileSystemError.FileNotFound(p_uri);
    }
}

</t>
<t tx="felix.20211010221959.1">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20211012233514.1">/**
 * * Asks for .leojs file name and path, then saves the JSON Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results.
 */
public async saveAsLeoJsFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave();

    const c = g.app.windowList[this.frameIndex].c;

    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        {
            tree: true,
            states: true,
            documents: true
        }
    );

    await c.save_as_leojs();
    this.launchRefresh();
    return Promise.resolve();
}

</t>
<t tx="felix.20211024012523.1">/**
 * Returns clipboard content
*/
public getTextFromClipboard(): string {
    return this.clipboardContents;
}

</t>
<t tx="felix.20211024012536.1"></t>
<t tx="felix.20211030165058.1"></t>
<t tx="felix.20211117232843.1">{
  "command": "leojs.undoFromOutline",
  "key": "ctrl+z",
  "mac": "cmd+z",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsUndos|^leojsDocuments|^leojsButtons/"
},
{
  "command": "leojs.redoFromOutline",
  "key": "ctrl+shift+z",
  "mac": "cmd+shift+z",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsUndos|^leojsDocuments|^leojsButtons/"
},
</t>
<t tx="felix.20211119001637.1">"resourceLabelFormatters": [
  {
    "scheme": "leojs",
    "formatting": {
      "label": "LEOJS: BODY",
      "separator": "/",
      "workspaceSuffix": ""
    }
  }
]
</t>
<t tx="felix.20211122205011.1">import * as vscode from "vscode";
import { LeoStates } from "./leoStates";
import * as g from './core/leoGlobals';
import { Icon } from "./types";
import { LeoUI } from "./leoUI";

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20211122205031.1">/**
 * * Undo beads shown as a list with this TreeDataProvider implementation
 */
export class LeoUndosProvider implements vscode.TreeDataProvider&lt;LeoUndoNode&gt; {

    private _beadId = 0;

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoUndoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoUndoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoUndoNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _leoUI: LeoUI,
        private _icons: Icon[],
    ) { }

    @others
}

</t>
<t tx="felix.20211122212823.1">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoUndoNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public contextValue: string = "leojsUndoNode";

    constructor(
        public label: string,
        public description: string,
        public id: string,
        public iconPath?: Icon
    ) {
        super(label);
    }

    @others
}

</t>
<t tx="felix.20211122213012.1">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20211122213023.1">public getTreeItem(element: LeoUndoNode): Thenable&lt;LeoUndoNode&gt; | LeoUndoNode {
    return element;
}

</t>
<t tx="felix.20211122213037.1">public getParent(element: LeoUndoNode): vscode.ProviderResult&lt;LeoUndoNode&gt; {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return undefined;
}

</t>
<t tx="felix.20211122214230.1">public getChildren(element?: LeoUndoNode): LeoUndoNode[] {
    const w_children: LeoUndoNode[] = [];
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element &amp;&amp; g.app.windowList.length) {
        const c = g.app.windowList[this._leoUI.frameIndex].c;
        const undoer = c.undoer;

        if (undoer.beads.length) {

            let i: number = 0;
            let w_defaultIcon = 1;

            undoer.beads.forEach(p_bead =&gt; {
                let w_description: string = "";
                let w_undoFlag: boolean = false;
                let w_icon = w_defaultIcon;
                if (i === undoer.bead) {
                    w_description = "Undo";
                    w_undoFlag = true;
                    w_icon = 0;
                    w_defaultIcon = 2;
                }
                if (i === undoer.bead + 1) {
                    w_description = "Redo";
                    w_icon = 2;
                    w_defaultIcon = 3;
                }
                const w_node = new LeoUndoNode(
                    p_bead.undoType || "unknown",
                    w_description,
                    (this._beadId++).toString(),
                    this._icons[w_icon]
                );
                w_children.push(w_node);
                if (w_undoFlag) {
                    this._leoUI.setUndoSelection(w_node);
                }
                i++;
            });
        } else {
            const w_node = new LeoUndoNode(
                "Unchanged",
                "",
                (this._beadId++).toString(),
                undefined
            );
            w_children.push(w_node);
        }

    }
    return w_children; // Defaults to an empty list of children
}

</t>
<t tx="felix.20211122230343.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onUndosTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        if (p_explorerView) {
            this._lastLeoUndos = this._leoUndosExplorer;
            if (this._leoUndosExplorerShown) {
                this._leoUndosProvider.refreshTreeRoot(); // Already shown, will redraw but not re-select
            }
            this._leoUndosExplorerShown = true; // either way set it
        } else {
            this._lastLeoUndos = this._leoUndos;
            if (this._leoUndosShown) {
                this._leoUndosProvider.refreshTreeRoot(); // Already shown, will redraw but not re-select
            }
            this._leoUndosShown = true; // either way set it
        }
    }
}

</t>
<t tx="felix.20211124223735.1">/**
 * * Refreshes the undo pane
 */
private _refreshUndoPane(): void {
    this._leoUndosProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20211201001847.1">export class LeoOutlineNode extends vscode.TreeItem {

    constructor(
        public label: string, // Node headline
        public collapsibleState: vscode.TreeItemCollapsibleState,
        public position: Position, // Pointer/reference for leo's node position
        public description: string,
        public iconPath: Icon,
        public id: string,
        public contextValue: string // For contextual menu on each node (not the global 'selected node' flag!)
    ) {
        super(label, collapsibleState);
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            // using 'this' as LeoOutlineNode instead of position, to match 'openToTheSide' paramter
            arguments: [this]
        };
    }

}
</t>
<t tx="felix.20211204144931.1"></t>
<t tx="felix.20211204144931.2">/**
 * * Save body to Leo if its dirty. That is, only if a change has been made to the body 'document' so far
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean): Thenable&lt;unknown&gt; {
    // * Save body to Leo if a change has been made to the body 'document' so far
    let q_savePromise: Thenable&lt;boolean&gt;;
    if (
        this._bodyLastChangedDocument &amp;&amp;
        (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
        !this._bodyLastChangedDocumentSaved
    ) {
        // * Is dirty and unsaved, so proper save is in order
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        this._bodyLastChangedDocumentSaved = true;
        this._editorTouched = false;
        q_savePromise = this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else if (
        p_forcedVsCodeSave &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        this._bodyLastChangedDocumentSaved
    ) {
        // * Had 'forcedVsCodeSave' and isDirty only, so just clean up dirty VSCODE document flag.
        this._bodySaveSelection(); // just save selection if it's changed
        q_savePromise = this._bodyLastChangedDocument.save(); // ! USED INTENTIONALLY: This trims trailing spaces
    } else {
        this._bodyLastChangedDocumentSaved = true;
        this._bodySaveSelection();  // just save selection if it's changed
        q_savePromise = Promise.resolve(true);
    }
    return q_savePromise.then((p_result) =&gt; {
        return p_result;
    }, (p_reason) =&gt; {
        console.log('BodySave rejected :', p_reason);
        return false;
    });
}

</t>
<t tx="felix.20211204144931.3">/**
 * * Saves the cursor position along with the text selection range and scroll position
 */
private _bodySaveSelection(): void {

    if (!this._selectionDirty || !this._selection) {
        return;
    }
    // Prepare scroll data separately

    let scroll: number;
    if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
        scroll = this._scroll?.start.line || 0;
    } else {
        scroll = 0;
    }
    const gnx = this._selectionGnx;

    const start = {
        line: this._selection.start.line || 0,
        col: this._selection.start.character || 0,
    };
    const end = {
        line: this._selection.end.line || 0,
        col: this._selection.end.character || 0,
    };
    const active = {
        line: this._selection.active.line || 0,
        col: this._selection.active.character || 0,
    };

    const c = g.app.windowList[this.frameIndex].c;
    let p: Position | undefined;
    if (c.p.gnx === gnx) {
        p = c.p;
    } else {
        // find p.
        for (let p_p of c.all_positions()) {
            if (p_p.v.gnx === gnx) {
                p = p_p;
                break;
            }
        }
    }
    if (!p) {
        return;
    }

    // - "ap":     An archived position for position p.
    // - "start":  The start of the selection.
    // - "end":    The end of the selection.
    // - "active": The insert point. Must be either start or end.
    // - "scroll": An optional scroll position.

    const v = p.v;
    const wrapper = c.frame.body.wrapper;
    const insert = g.convertRowColToPythonIndex(v.b, active['line'], active['col']);
    const startSel = g.convertRowColToPythonIndex(v.b, start['line'], start['col']);
    const endSel = g.convertRowColToPythonIndex(v.b, end['line'], end['col']);

    // If it's the currently selected node set the wrapper's states too
    if (p.__eq__(c.p)) {
        wrapper.setSelectionRange(startSel, endSel, insert);
        wrapper.setYScrollPosition(scroll);
    }
    // Always set vnode attrs.
    v.scrollBarSpot = scroll;
    v.insertSpot = insert;
    v.selectionStart = startSel;
    v.selectionLength = Math.abs(startSel - endSel);

    this._scrollDirty = false;
    this._selectionDirty = false;

}

</t>
<t tx="felix.20211204144931.4">/**
 * * Sets new body text on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the complete saving process is finished
 */
private async _bodySaveDocument(
    p_document: vscode.TextDocument,
    p_forcedVsCodeSave?: boolean
): Promise&lt;boolean&gt; {
    if (p_document) {

        const c = g.app.windowList[this.frameIndex].c;
        const u = c.undoer;
        const w_gnx = utils.leoUriToStr(p_document.uri);
        const body = p_document.getText(); // new body text

        const w_v = c.fileCommands.gnxDict[w_gnx]; // target to change
        if (w_v) {

            if (body !== w_v.b) {
                // if different, replace body and set dirty
                let w_p: Position | undefined;
                if (c.p.gnx === w_v.gnx) {
                    // same gnx so it's the same position for saving the new body pane text.
                    w_p = c.p;
                } else {
                    // find p.
                    for (let p of c.all_positions()) {
                        if (p.v.gnx === w_gnx) {
                            w_p = p;
                            break;
                        }
                    }
                }
                if (w_p) {
                    // ok we got a valid p.
                    const bunch = u.beforeChangeNodeContents(w_p);
                    w_p.v.setBodyString(body);
                    u.afterChangeNodeContents(w_p, "Body Text", bunch);

                    if (!c.isChanged()) {
                        c.setChanged();
                    }
                    if (!w_p.v.isDirty()) {
                        w_p.setDirty();
                    }
                }

            }

        } else {
            console.error("ERROR SAVING BODY FROM VSCODE TO LEOJS");
        }

        // await for bodySaveSelection that is placed on the stack right after saving body
        await this._bodySaveSelection();

        this._refreshType.states = true;
        this.getStates();
        if (p_forcedVsCodeSave) {
            return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
        }

        return Promise.resolve(p_document.isDirty);
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20211204144931.5">/**
 * * Sets new body text on leo's side before vscode closes itself if body is dirty
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDeactivate(
    p_document: vscode.TextDocument
): Thenable&lt;unknown&gt; {
    const w_gnx = utils.leoUriToStr(p_document.uri);
    const c = g.app.windowList[this.frameIndex].c;
    const w_v = c.fileCommands.gnxDict[w_gnx];
    if (w_v) {
        w_v.b = p_document.getText();
    }

    return Promise.resolve(true);
}

</t>
<t tx="felix.20211204181418.1">/**
 * * Perform insert and rename commands
 */
private _insertAndSetHeadline(p_name?: string, p_asChild?: boolean): any {
    const LEOCMD = Constants.LEO_COMMANDS;
    const w_command = p_asChild ? LEOCMD.INSERT_CHILD_PNODE : LEOCMD.INSERT_PNODE;
    const c = g.app.windowList[this.frameIndex].c;
    const u = c.undoer;
    let value: any = c.doCommandByName(w_command);
    if (!p_name) {
        return value;
    }
    const undoData = u.beforeChangeHeadline(c.p);
    c.setHeadString(c.p, p_name);  // Set v.h *after* calling the undoer's before method.
    if (!c.changed) {
        c.setChanged();
    }
    u.afterChangeHeadline(c.p, 'Edit Headline', undoData);
    return value;
}

</t>
<t tx="felix.20211208011642.1">/**
 * * Overridden 'good' minibuffer commands
 */
public static MINIBUFFER_OVERRIDDEN_COMMANDS: { [key: string]: string } = {
    // "tag-children": Constants.COMMANDS.TAG_CHILDREN,
    // "clone-find-tag": Constants.COMMANDS.CLONE_FIND_TAG,
    // "import-file": Constants.COMMANDS.IMPORT_ANY_FILE,
    // "redo": Constants.COMMANDS.REDO,
    // "undo": Constants.COMMANDS.UNDO,
    // "clone-find-all": Constants.COMMANDS.CLONE_FIND_ALL,
    // "clone-find-all-flattened": Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,

    // 'import-MORE-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    // 'import-free-mind-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    // 'import-jupyter-notebook': Constants.COMMANDS.IMPORT_ANY_FILE,
    // 'import-legacy-external-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    // 'import-mind-jet-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    // 'import-tabbed-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    // 'import-todo-text-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    // 'import-zim-folder': Constants.COMMANDS.IMPORT_ANY_FILE,

    // 'file-new': Constants.COMMANDS.NEW_FILE,
    // 'file-open-by-name': Constants.COMMANDS.OPEN_FILE,
    // 'new': Constants.COMMANDS.NEW_FILE,
    // 'open-outline': Constants.COMMANDS.OPEN_FILE,
    // 'file-save': Constants.COMMANDS.SAVE_FILE,
    // 'file-save-as': Constants.COMMANDS.SAVE_AS_FILE,
    // 'file-save-as-leojs': Constants.COMMANDS.SAVE_AS_LEOJS,
    // 'file-save-as-unzipped': Constants.COMMANDS.SAVE_AS_FILE,
    // 'file-save-by-name': Constants.COMMANDS.SAVE_AS_FILE,
    // 'file-save-to': Constants.COMMANDS.SAVE_AS_FILE,
    // 'save': Constants.COMMANDS.SAVE_FILE,
    // 'save-as': Constants.COMMANDS.SAVE_AS_FILE,
    // 'save-file': Constants.COMMANDS.SAVE_FILE,
    // 'save-file-as': Constants.COMMANDS.SAVE_AS_FILE,
    // 'save-file-as-leojs': Constants.COMMANDS.SAVE_AS_LEOJS,
    // 'save-file-as-unzipped': Constants.COMMANDS.SAVE_AS_FILE,
    // 'save-file-by-name': Constants.COMMANDS.SAVE_AS_FILE,
    // 'save-file-to': Constants.COMMANDS.SAVE_AS_FILE,
    // 'save-to': Constants.COMMANDS.SAVE_AS_FILE,

    // 'clone-find-all-flattened-marked': Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED,
    // 'clone-find-all-marked': Constants.COMMANDS.CLONE_FIND_MARKED,

    // 'clone-marked-nodes': Constants.COMMANDS.CLONE_MARKED_NODES,

    // 'cfa': Constants.COMMANDS.CLONE_FIND_ALL,
    // 'cfam': Constants.COMMANDS.CLONE_FIND_MARKED,
    // 'cff': Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,
    // 'cffm': Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED,
    // 'cft': Constants.COMMANDS.CLONE_FIND_TAG,

    // 'git-diff': Constants.COMMANDS.GIT_DIFF,
    // 'gd': Constants.COMMANDS.GIT_DIFF,

    // 'find-tab-open': Constants.COMMANDS.START_SEARCH,
    // 'find-clone-all': Constants.COMMANDS.CLONE_FIND_ALL,
    // 'find-clone-all-flattened': Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,
    // 'find-clone-tag': Constants.COMMANDS.CLONE_FIND_TAG,
    // 'find-all': Constants.COMMANDS.FIND_ALL,
    // 'start-search': Constants.COMMANDS.START_SEARCH,
    // 'find-next': Constants.COMMANDS.FIND_NEXT,
    // 'find-prev': Constants.COMMANDS.FIND_PREVIOUS,
    // 'search-backward': Constants.COMMANDS.FIND_NEXT,
    // 'search-forward': Constants.COMMANDS.FIND_PREVIOUS,
    // 'find-var': Constants.COMMANDS.FIND_VAR,
    // 'find-def': Constants.COMMANDS.FIND_DEF,
    // 'replace': Constants.COMMANDS.REPLACE,
    // 'replace-all': Constants.COMMANDS.REPLACE_ALL,
    // 'change-all': Constants.COMMANDS.REPLACE_ALL,
    // 'change-then-find': Constants.COMMANDS.REPLACE_THEN_FIND,
    // 'replace-then-find': Constants.COMMANDS.REPLACE_THEN_FIND,
    // 'show-find-options': Constants.COMMANDS.START_SEARCH,
    // 'toggle-find-ignore-case-option': Constants.COMMANDS.TOGGLE_FIND_IGNORE_CASE_OPTION,
    // 'toggle-find-in-body-option': Constants.COMMANDS.TOGGLE_FIND_SEARCH_BODY_OPTION,
    // 'toggle-find-in-headline-option': Constants.COMMANDS.TOGGLE_FIND_SEARCH_HEADLINE_OPTION,
    // 'toggle-find-mark-changes-option': Constants.COMMANDS.TOGGLE_FIND_MARK_CHANGES_OPTION,
    // 'toggle-find-mark-finds-option': Constants.COMMANDS.TOGGLE_FIND_MARK_FINDS_OPTION,
    // 'toggle-find-regex-option': Constants.COMMANDS.TOGGLE_FIND_REGEXP_OPTION,
    // 'toggle-find-word-option': Constants.COMMANDS.TOGGLE_FIND_WORD_OPTION,

    // 'goto-next-history-node': Constants.COMMANDS.PREV_NODE,
    // 'goto-prev-history-node': Constants.COMMANDS.NEXT_NODE,


};

</t>
<t tx="felix.20211212205241.1">public replaceClipboardWith(s: string): Thenable&lt;void&gt; {
    this.clipboardContents = s; // also set immediate clipboard string
    return vscode.env.clipboard.writeText(s);
}

</t>
<t tx="felix.20220103203600.1">public asyncGetTextFromClipboard(): Thenable&lt;string&gt; {
    return vscode.env.clipboard.readText().then((s) =&gt; {
        // also set immediate clipboard string for possible future read
        this.clipboardContents = s;
        return this.getTextFromClipboard();
    });
}

</t>
<t tx="felix.20220103222715.1">/**
 * * Overridden 'good' minibuffer command name strings
 */
public static MINIBUFFER_OVERRIDDEN_NAMES: { [key: string]: string } = {
    'paste-node': 'async-paste-node',
    'paste-retaining-clones': 'async-paste-retaining-clones',
    'paste-as-template': 'async-paste-as-template'
};
</t>
<t tx="felix.20220107223824.1">public runOpenFileDialog(
    c: Commands | undefined,
    title: string,
    filetypes: [string, string][],
    defaultExtension: string,
    multiple?: boolean,
    startpath?: string // TODO 
): Thenable&lt;string[]&gt; {
    // convert to { [name: string]: string[] } typing
    const types: { [name: string]: string[] } = utils.convertLeoFiletypes(filetypes);
    return vscode.window.showOpenDialog(
        {
            title: title,
            canSelectMany: !!multiple,
            filters: types
        }
    ).then((p_uris) =&gt; {
        const names: string[] = [];
        if (p_uris &amp;&amp; p_uris.length) {
            p_uris.forEach(w_uri =&gt; {
                names.push(w_uri.fsPath);
            });
        }
        //return p_uris || [];
        return names;
    });
}

</t>
<t tx="felix.20220108211750.1">public runAskOkDialog(
    c: Commands,
    title: string,
    message: string,
    text = "Ok"
): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage(
        title,
        {
            modal: true,
            detail: message
        });
}

</t>
<t tx="felix.20220108211806.1">public runSaveFileDialog(
    c: Commands | undefined,
    title: string,
    filetypes: [string, string][],
    defaultExtension: string,
): Thenable&lt;string&gt; {
    // convert to { [name: string]: string[] } typing
    const types: { [name: string]: string[] } = utils.convertLeoFiletypes(filetypes);
    return vscode.window.showSaveDialog(
        {
            title: title,
            filters: types
        }
    ).then((p_uri) =&gt; {
        if (p_uri) {
            console.log('CHOSE SAVE URI');
            console.log('SAVE fsPath: ' + JSON.stringify(p_uri.fsPath));
            console.log('SAVE json: ' + JSON.stringify(p_uri.toJSON()));
            console.log('SAVE toString: ' + p_uri.toString());
            console.log('test path: ' + path.normalize(p_uri.path));


            return p_uri.fsPath;
        } else {
            return "";
        }
    });
}

</t>
<t tx="felix.20220109180351.1">/**
 * Convert Leo's internal filetype descriptions array
 * to vscode's option format for open/save dialogs.
 */
export function convertLeoFiletypes(p_filetypes: [string, string][]): { [name: string]: string[] } {
    /*
        from :
            [
                ["", ""],
                ["Leo files", "*.leo *.db"]
            ],

        to :
        {
            'Images': ['png', 'jpg']
            'TypeScript': ['ts', 'tsx']
        }

    */
    const w_types: { [name: string]: string[] } = {};
    p_filetypes.forEach(type =&gt; {
        w_types[type[0]] = type[1].split(" ").map((p_entry) =&gt; {

            return p_entry.startsWith("*.") ? p_entry.substring(2) : p_entry;
        });
    });
    return w_types;
}
</t>
<t tx="felix.20220109220155.1">public runAskYesNoDialog(
    c: Commands,
    title: string,
    message: string,
    yes_all = false,
    no_all = false,

): Thenable&lt;string&gt; {
    return vscode.window
        .showInformationMessage(
            title,
            {
                modal: true,
                detail: message
            },
            Constants.USER_MESSAGES.YES,
            Constants.USER_MESSAGES.NO
        )
        .then((answer) =&gt; {
            if (answer === Constants.USER_MESSAGES.YES) {
                return Constants.USER_MESSAGES.YES.toLowerCase();
            } else {
                return Constants.USER_MESSAGES.NO.toLowerCase();
            }
        });
}

</t>
<t tx="felix.20220128232146.1"></t>
<t tx="felix.20220131234257.1">/**
 * * Sets the leoID setting for immediate use, and in next activation
 */
public setIdSetting(p_leoID: string): Promise&lt;unknown&gt; {
    const w_changes: ConfigSetting[] = [{
        code: "leoID",
        value: p_leoID
    }];
    g.app.leoID = p_leoID;
    if (g.app.nodeIndices) {
        g.app.nodeIndices.defaultId = p_leoID;
        g.app.nodeIndices.userId = p_leoID;
    }
    return this.config.setLeojsSettings(w_changes);
}

</t>
<t tx="felix.20220131235418.1">/**
 * * Returns the leoID from the leojs settings
 */
public getIdFromSetting(): string {
    return this.config.leoID;
}

</t>
<t tx="felix.20220201194319.1">/**
 * * Command to get the LeoID from dialog, save it to user settings.
 * Start leojs if the ID is valid, and not already started.
 */
public setLeoIDCommand(): void {
    utils.getIdFromDialog().then((p_id) =&gt; {
        p_id = p_id.trim();
        p_id = g.app.cleanLeoID(p_id, '');
        if (p_id &amp;&amp; p_id.length &gt;= 3 &amp;&amp; utils.isAlphaNumeric(p_id)) {
            // valid id: set in config settings
            this.setIdSetting(p_id);
        } else {
            // Canceled or invalid: (re)warn user.
            this.showLeoIDMessage();
        }
    });
}

</t>
<t tx="felix.20220201195806.1">export function isAlphaNumeric(str: string): boolean {
    let code: number;
    let i: number;
    let len: number;
    for (i = 0, len = str.length; i &lt; len; i++) {
        code = str.charCodeAt(i);
        if (!(code &gt; 47 &amp;&amp; code &lt; 58) &amp;&amp; // numeric (0-9)
            !(code &gt; 64 &amp;&amp; code &lt; 91) &amp;&amp; // upper alpha (A-Z)
            !(code &gt; 96 &amp;&amp; code &lt; 123) // lower alpha (a-z)
        ) {
            return false;
        }
    }
    return true;
};
</t>
<t tx="felix.20220201225503.1">public ensure_commander_visible(c: Commands): void {
    // TODO !
    console.log("TODO ensure_commander_visible");
}

</t>
<t tx="felix.20220201230041.1">/**
 * Show info window about requiring leoID to start
 * and a button to perform the 'set leoID' command.
 */
public showLeoIDMessage(): void {
    vscode.window.showInformationMessage(
        Constants.USER_MESSAGES.SET_LEO_ID_MESSAGE,
        Constants.USER_MESSAGES.ENTER_LEO_ID
    ).then(p_chosenButton =&gt; {
        if (p_chosenButton === Constants.USER_MESSAGES.ENTER_LEO_ID) {
            vscode.commands.executeCommand(Constants.COMMANDS.SET_LEO_ID);
        }
    });
}

</t>
<t tx="felix.20220201235548.1">    // * Create a single data provider for both outline trees, Leo view and Explorer view
    this._leoTreeProvider = new LeoOutlineProvider(this.nodeIcons, this);

    this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    this._context.subscriptions.push(
        this._leoTreeView,
        this._leoTreeView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeView))),
        this._leoTreeView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeView))),
        this._leoTreeView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, false)))
    );

    this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    this._context.subscriptions.push(
        this._leoTreeExView,
        this._leoTreeExView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeExView))),
        this._leoTreeExView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeExView))),
        this._leoTreeExView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, true)))
    );

    if (this.config.treeInExplorer) {
        this._lastTreeView = this._leoTreeExView;
    } else {
        this._lastTreeView = this._leoTreeView;
    }

    this.showLogPane();
}

/**
 * * Set all remaining local objects, set ready flag(s) and refresh all panels
 */
public finishStartup(): void {
    g.app.windowList[this.frameIndex].startupWindow = true;

    // // * Create a single data provider for both outline trees, Leo view and Explorer view
    // this._leoTreeProvider = new LeoOutlineProvider(this.nodeIcons, this);

    // this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    // this._context.subscriptions.push(
    //     this._leoTreeView,
    //     this._leoTreeView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeView))),
    //     this._leoTreeView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeView))),
    //     this._leoTreeView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, false)))
    // );

    // this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    // this._context.subscriptions.push(
    //     this._leoTreeExView,
    //     this._leoTreeExView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeExView))),
    //     this._leoTreeExView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeExView))),
    //     this._leoTreeExView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, true)))
    // );

    // if (this.config.treeInExplorer) {
    //     this._lastTreeView = this._leoTreeExView;
    // } else {
    //     this._lastTreeView = this._leoTreeView;
    // }

    // * Create Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this.leoStates, this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._context.subscriptions.push(
        this._leoDocuments,
        this._leoDocuments.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._context.subscriptions.push(
        this._leoDocumentsExplorer,
        this._leoDocumentsExplorer.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoDocuments = this._leoDocumentsExplorer;

    // * Create '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this.leoStates, this.buttonIcons);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._context.subscriptions.push(
        this._leoButtons,
        this._leoButtons.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._context.subscriptions.push(
        this._leoButtonsExplorer,
        this._leoButtonsExplorer.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoButtons = this._leoButtonsExplorer;

    // * Create goto Treeview Providers and tree views
    this._leoGotoProvider = new LeoGotoProvider(this);
    this._leoGoto = vscode.window.createTreeView(Constants.GOTO_ID, { showCollapseAll: false, treeDataProvider: this._leoGotoProvider });
    this._context.subscriptions.push(
        this._leoGoto,
        this._leoGoto.onDidChangeVisibility((p_event) =&gt;
            this._onGotoTreeViewVisibilityChanged(p_event, false)
        )
    );
    this._leoGotoExplorer = vscode.window.createTreeView(Constants.GOTO_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoGotoProvider });
    this._context.subscriptions.push(
        this._leoGotoExplorer,
        this._leoGotoExplorer.onDidChangeVisibility((p_event) =&gt;
            this._onGotoTreeViewVisibilityChanged(p_event, true)
        )
    );

    // * Create Undos Treeview Providers and tree views
    this._leoUndosProvider = new LeoUndosProvider(this.leoStates, this, this.undoIcons);
    this._leoUndos = vscode.window.createTreeView(Constants.UNDOS_ID, { showCollapseAll: false, treeDataProvider: this._leoUndosProvider });
    this._context.subscriptions.push(
        this._leoUndos,
        this._leoUndos.onDidChangeVisibility((p_event =&gt; this._onUndosTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoUndosExplorer = vscode.window.createTreeView(Constants.UNDOS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoUndosProvider });
    this._context.subscriptions.push(
        this._leoUndosExplorer,
        this._leoUndosExplorer.onDidChangeVisibility((p_event =&gt; this._onUndosTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoUndos = this._leoUndosExplorer;

    // * Create Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);

    this._bodyMainSelectionColumn = 1;

    // * Create Status bar Entry
    // this._leoStatusBar = new LeoStatusBar(_context, this);

    // * Leo Find Panel
    this._leoFindPanelProvider = new LeoFindPanelProvider(
        this._context.extensionUri,
        this._context,
        this
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        ),
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_EXPLORER_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );

    // * Configuration / Welcome webview
    // this.leoSettingsWebview = new LeoSettingsProvider(_context, this);

    // * 'onDid' event detections all pushed as disposables in context.subscription
    this._context.subscriptions.push(
        // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
        vscode.window.onDidChangeActiveTextEditor((p_editor) =&gt;
            this._onActiveEditorChanged(p_editor)
        ),

        // * React to change in selection, cursor position and scroll position
        vscode.window.onDidChangeTextEditorSelection((p_event) =&gt;
            this._onChangeEditorSelection(p_event)
        ),
        vscode.window.onDidChangeTextEditorVisibleRanges((p_event) =&gt;
            this._onChangeEditorScroll(p_event)
        ),

        // * Triggers when a different text editor/vscode window changed focus or visibility, or dragged
        // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
        vscode.window.onDidChangeTextEditorViewColumn((p_columnChangeEvent) =&gt;
            this._changedTextEditorViewColumn(p_columnChangeEvent)
        ), // Also triggers after drag and drop
        vscode.window.onDidChangeVisibleTextEditors((p_editors) =&gt;
            this._changedVisibleTextEditors(p_editors)
        ), // Window.visibleTextEditors changed
        vscode.window.onDidChangeWindowState((p_windowState) =&gt;
            this._changedWindowState(p_windowState)
        ), // Focus state of the current window changes

        // * React when typing and changing body pane
        vscode.workspace.onDidChangeTextDocument((p_textDocumentChange) =&gt;
            this._onDocumentChanged(p_textDocumentChange)
        ),

        // * React to configuration settings events
        vscode.workspace.onDidChangeConfiguration((p_configChange) =&gt;
            this._onChangeConfiguration(p_configChange)
        ),

        // * React to opening of any file in vscode
        vscode.workspace.onDidOpenTextDocument((p_document) =&gt;
            this._onDidOpenTextDocument(p_document)
        )
    );

    this._setupOpenedLeoDocument(); // this sets this.leoStates.fileOpenedReady 

    // * _setupOpenedLeoDocument above already does the setupRefresh below
    // this.setupRefresh(
    //     this.finalFocus,
    //     {
    //         tree: true,
    //         body: true,
    //         documents: true,
    //         buttons: true,
    //         states: true,
    //         goto: true,
    //     }
    // );

    this.leoStates.leoReady = true;
    this.leoStates.leojsStartupDone = true;

    // this.leoStates.qLastContextChange.then(() =&gt; {
    //     if (!this._lastTreeView.visible &amp;&amp; g.app.windowList.length) {
    //         console.log('Had to reveal!');
    //         // const c = g.app.windowList[this.frameIndex].c;
    //         // this._lastTreeView.reveal(c.p, { select: true });
    //         this._setupOpenedLeoDocument(); // this sets this.leoStates.fileOpenedReady 
    //         this.launchRefresh();

    //     }
    //     // this._launchRefresh();
    //     // this.getStates();
    // });

}

</t>
<t tx="felix.20220417151556.1">export function getIdFromDialog(): Thenable&lt;string&gt; {
    return vscode.window.showInputBox({
        title: Constants.USER_MESSAGES.ENTER_LEO_ID,
        prompt: Constants.USER_MESSAGES.GET_LEO_ID_PROMPT

    }).then((p_id) =&gt; {
        if (p_id) {
            return p_id;
        }
        return '';
    });
}

</t>
<t tx="felix.20220417155704.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { Position } from "./core/leoNodes";
import { LeoButtonNode } from "./leoButtons";
import { LeoGotoNode } from "./leoGoto";
import { LeoOutlineNode } from "./leoOutline";
import { LeoUI } from "./leoUI";
import { ReqRefresh, Focus, LeoGotoNavKey } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20220417155732.1">/**
 * * Make all command/key bindings 
 */
export function makeAllBindings(p_leoUI: LeoUI, p_context: vscode.ExtensionContext): void {
    // Shortcut pointers for readability
    const U = undefined;
    const CMD = Constants.COMMANDS;
    const LEOCMD = Constants.LEO_COMMANDS;

    const NO_REFRESH: ReqRefresh = {};
    const REFRESH_NODE_BODY: ReqRefresh = {
        node: true, // Reveal the returned 'selected position' without changes to the tree
        body: true, // Goto/select another node needs the body pane refreshed
        states: true
    };
    const REFRESH_TREE: ReqRefresh = {
        tree: true,
        states: true
    };
    const REFRESH_TREE_BODY: ReqRefresh = {
        tree: true,
        body: true,
        states: true
    };
    const REFRESH_ALL: ReqRefresh = {
        tree: true,
        body: true,
        states: true,
        documents: true,
        buttons: true
    };

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        &lt;&lt; Define entries for all commands &gt;&gt;
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });
}

</t>
<t tx="felix.20220417215549.1">/** 
 * Make all key and commands bindings
 */
public makeAllBindings(): void {
    commandBindings.makeAllBindings(this, this._context);
}

</t>
<t tx="felix.20220505215916.1"></t>
<t tx="felix.20220505215916.2">/**
 * Opens the Nav tab and focus on nav text input
 */
public findQuick(p_string?: string): Thenable&lt;unknown&gt; {
    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        const w_message: { [key: string]: string } = { type: 'selectNav' };
        if (p_string &amp;&amp; p_string?.trim()) {
            w_message["text"] = p_string.trim();
        }
        w_panel?.webview.postMessage(w_message);
    });
    return Promise.resolve();
}

</t>
<t tx="felix.20220505215916.3">/**
 * Opens the Nav tab with the selected text as the search string
 */
public findQuickSelected(): Thenable&lt;unknown&gt; {
    if (vscode.window.activeTextEditor) {
        const editor = vscode.window.activeTextEditor;
        const selection = editor.selection;
        if (!selection.isEmpty) {
            const text = editor.document.getText(selection);
            return this.findQuick(text);
        }
    }
    return this.findQuick();
}

</t>
<t tx="felix.20220505215916.4">/**
 * Lists all nodes in reversed gnx order, newest to oldest
 */
public findQuickTimeline(): Thenable&lt;unknown&gt; {
    // return this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_TIMELINE)
    //     .then((p_result: LeoBridgePackage) =&gt; {
    //         this._leoGotoProvider.refreshTreeRoot();
    //         return this.showGotoPane(); // Finish by opening and focussing nav pane
    //     });
    return vscode.window.showInformationMessage("TODO: findQuickTimeline");
}

</t>
<t tx="felix.20220505215916.5">/**
 * Lists all nodes that are changed (aka "dirty") since last save.
 */
public findQuickChanged(): Thenable&lt;unknown&gt; {
    // return this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_CHANGED)
    //     .then((p_result: LeoBridgePackage) =&gt; {
    //         this._leoGotoProvider.refreshTreeRoot();
    //         return this.showGotoPane(); // Finish by opening and focussing nav pane
    //     });
    return vscode.window.showInformationMessage("TODO: findQuickChanged");

}

</t>
<t tx="felix.20220505215916.6">/**
 * Lists nodes from c.nodeHistory.
 */
public findQuickHistory(): Thenable&lt;unknown&gt; {
    // return this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_HISTORY)
    //     .then((p_result: LeoBridgePackage) =&gt; {
    //         this._leoGotoProvider.refreshTreeRoot();
    //         return this.showGotoPane(); // Finish by opening and focussing nav pane
    //     });
    return vscode.window.showInformationMessage("TODO: findQuickHistory");

}

</t>
<t tx="felix.20220505215916.7">/**
 * List all marked nodes.
 */
public findQuickMarked(): Thenable&lt;unknown&gt; {
    // return this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_MARKED)
    //     .then((p_result: LeoBridgePackage) =&gt; {
    //         this._leoGotoProvider.refreshTreeRoot();
    //         return this.showGotoPane(); // Finish by opening and focussing nav pane
    //     });
    return vscode.window.showInformationMessage("TODO: findQuickMarked");

}

</t>
<t tx="felix.20220505215916.8">/**
 * Opens goto and focus in depending on passed options
 */
public showGotoPane(p_options?: { preserveFocus?: boolean }): Thenable&lt;unknown&gt; {
    let w_panel = "";

    if (this._lastTreeView === this._leoTreeExView) {
        w_panel = Constants.GOTO_EXPLORER_ID;
    } else {
        w_panel = Constants.GOTO_ID;
    }

    vscode.commands.executeCommand(w_panel + '.focus', p_options);

    return Promise.resolve();
}

</t>
<t tx="felix.20220505215916.9">public gotoNavEntry(p_node: LeoGotoNode): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage("TODO: gotoNavEntry");

    // if (p_node.entryType === 'tag') {

    //     return this._isBusyTriggerSave(false, true)
    //         .then((p_saveResult) =&gt; {

    //             let w_string: string = p_node.label as string;

    //             let w_panelID = '';
    //             let w_panel: vscode.WebviewView | undefined;
    //             if (this._lastTreeView === this._leoTreeExView) {
    //                 w_panelID = Constants.FIND_EXPLORER_ID;
    //                 w_panel = this._findPanelWebviewExplorerView;
    //             } else {
    //                 w_panelID = Constants.FIND_ID;
    //                 w_panel = this._findPanelWebviewView;
    //             }
    //             vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
    //                 if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
    //                     w_panel.show(false);
    //                 }
    //                 const w_message: { [key: string]: string } = { type: 'selectNav' };
    //                 if (w_string &amp;&amp; w_string?.trim()) {
    //                     w_message["text"] = w_string.trim();
    //                 }
    //                 return w_panel!.webview.postMessage(w_message);
    //             }).then(() =&gt; {
    //                 // Do search
    //                 setTimeout(() =&gt; {
    //                     this.sendAction(
    //                         Constants.LEOBRIDGE.NAV_SEARCH
    //                     ).then((p_package) =&gt; {
    //                         this._leoGotoProvider.refreshTreeRoot();
    //                         this.showGotoPane({ preserveFocus: true }); // show but dont change focus
    //                         return p_package;
    //                     });
    //                 }, 10);

    //             });
    //         });

    // }

    // // Was not a tag
    // if (p_node.entryType !== 'generic' &amp;&amp; p_node.entryType !== 'parent') {
    //     return this._isBusyTriggerSave(false, true)
    //         .then((p_saveResult) =&gt; {
    //             return this.sendAction(
    //                 Constants.LEOBRIDGE.GOTO_NAV_ENTRY,
    //                 JSON.stringify({ key: p_node.key })
    //             );
    //         })
    //         .then((p_navEntryResult: LeoBridgePackage) =&gt; {
    //             if (!p_navEntryResult.focus) {
    //                 vscode.window.showInformationMessage('Not found');
    //             } else {
    //                 let w_focusOnOutline = false;
    //                 const w_focus = p_navEntryResult.focus.toLowerCase();

    //                 if (w_focus.includes('tree') || w_focus.includes('head')) {
    //                     // tree
    //                     w_focusOnOutline = true;
    //                 }
    //                 this.launchRefresh(
    //                     {
    //                         tree: true,
    //                         body: true,
    //                         scroll: !w_focusOnOutline,
    //                         documents: false,
    //                         buttons: false,
    //                         states: true,
    //                     },
    //                     w_focusOnOutline
    //                 );
    //             }
    //         });
    // }
    // return Promise.resolve();
}
</t>
<t tx="felix.20220505215924.1"></t>
<t tx="felix.20220505215924.10">/**
 * * Find / Replace All
 * @returns Promise of LeoBridgePackage from execution or undefined if cancelled
 */
public findAll(p_replace: boolean): Thenable&lt;unknown&gt; {
    // return vscode.window.showInformationMessage("TODO: findAll");

    // const w_action: string = p_replace
    //     ? Constants.LEOBRIDGE.REPLACE_ALL
    //     : Constants.LEOBRIDGE.FIND_ALL;

    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_replaceString: string = this._lastSettingsUsed!.replaceText;

    return this.triggerBodySave(false)
        .then((p_saveResult) =&gt; {
            return this._inputFindPattern()
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    if (p_replace) {
                        return this._inputFindPattern(true).then((p_replaceString) =&gt; {
                            if (p_replaceString === undefined) {
                                return true;
                            }
                            w_replaceString = p_replaceString;
                            return false;
                        });
                    }
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                this._lastSettingsUsed.findText = w_searchString;
                this._lastSettingsUsed.replaceText = w_replaceString;

                // this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.

                const c = g.app.windowList[this.frameIndex].c;
                const fc = c.findCommands;

                fc.ftm.get_settings();
                const w_changeSettings: ISettings = {
                    // this._lastSettingsUsed
                    // State...
                    in_headline: false, // ! TODO ! 
                    // p: Position,
                    // Find/change strings...
                    find_text: this._lastSettingsUsed.findText,
                    change_text: this._lastSettingsUsed.replaceText,
                    // Find options...
                    file_only: this._lastSettingsUsed.searchOptions === 3,
                    ignore_case: this._lastSettingsUsed.ignoreCase,
                    mark_changes: this._lastSettingsUsed.markChanges,
                    mark_finds: this._lastSettingsUsed.markFinds,
                    node_only: this._lastSettingsUsed.searchOptions === 2,
                    pattern_match: this._lastSettingsUsed.regExp,
                    reverse: false,
                    search_body: this._lastSettingsUsed.searchBody,
                    search_headline: this._lastSettingsUsed.searchHeadline,
                    suboutline_only: this._lastSettingsUsed.searchOptions === 1,
                    whole_word: this._lastSettingsUsed.wholeWord,
                    wrapping: false, // unused
                };
                const w_result = fc.do_change_all(w_changeSettings);

                // TODO : GET FOCUS!
                const w_focus = ""; // = g.app.gui.get_focus();
                //                     focus = g.app.gui.widget_name(w)

                let w_finalFocus = Focus.Body;

                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_finalFocus = Focus.Outline;
                }
                this.loadSearchSettings();
                this.setupRefresh(
                    w_finalFocus,
                    {
                        tree: true,
                        body: true,
                        // documents: false,
                        // buttons: false,
                        states: true
                    }
                );
                this.launchRefresh();

                return;

            }
        });
}

</t>
<t tx="felix.20220505215924.11">/**
 * * Clone Find All / Marked / Flattened
 * @param p_marked flag for finding marked nodes
 * @param p_flat flag to get flattened results
 * @returns Promise of LeoBridgePackage from execution or undefined if cancelled
 */
public cloneFind(p_marked: boolean, p_flat: boolean): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage("TODO: cloneFind");

    // let w_searchString: string = this._lastSettingsUsed!.findText;
    // let w_action: string;
    // if (p_marked) {
    //     w_action = p_flat
    //         ? Constants.LEOBRIDGE.CLONE_FIND_FLATTENED_MARKED
    //         : Constants.LEOBRIDGE.CLONE_FIND_MARKED;
    // } else {
    //     w_action = p_flat
    //         ? Constants.LEOBRIDGE.CLONE_FIND_ALL_FLATTENED
    //         : Constants.LEOBRIDGE.CLONE_FIND_ALL;
    // }

    // if (p_marked) {
    //     // don't use find methods.
    //     return this.nodeCommand({
    //         action: w_action,
    //         node: undefined,
    //         refreshType: { tree: true, body: true, states: true },
    //         fromOutline: false,
    //     }) || Promise.resolve();
    // }

    // return this._isBusyTriggerSave(false, true)
    //     .then(() =&gt; {
    //         return this._inputFindPattern()
    //             .then((p_findString) =&gt; {
    //                 if (!p_findString) {
    //                     return true; // Cancelled with escape or empty string.
    //                 }
    //                 w_searchString = p_findString;
    //                 return false;
    //             });
    //     })
    //     .then((p_cancelled: boolean) =&gt; {
    //         if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
    //             this._lastSettingsUsed.findText = w_searchString;
    //             this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
    //             return this.sendAction(w_action)
    //                 .then((p_cloneFindResult: LeoBridgePackage) =&gt; {
    //                     let w_focusOnOutline = false;
    //                     const w_focus = p_cloneFindResult.focus!.toLowerCase();
    //                     if (w_focus.includes('tree') || w_focus.includes('head')) {
    //                         // tree
    //                         w_focusOnOutline = true;
    //                     }
    //                     this.loadSearchSettings();
    //                     this.launchRefresh(
    //                         { tree: true, body: true, documents: false, buttons: false, states: true },
    //                         w_focusOnOutline
    //                     );
    //                 });
    //         }
    //     });
}

</t>
<t tx="felix.20220505215924.12">/**
 * * Set search setting in the search webview
 * @param p_id string id of the setting name
 */
public setSearchSetting(p_id: string): void {
    this._findPanelWebviewExplorerView!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
    this._findPanelWebviewView!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
}

</t>
<t tx="felix.20220505215924.13">/**
 * * Gets the search settings from Leo, and applies them to the find panel webviews
 */
public loadSearchSettings(): void {
    // vscode.window.showInformationMessage("TODO: loadSearchSettings");

    const c = g.app.windowList[this.frameIndex].c;
    const scon = c.quicksearchController;
    const leoISettings = c.findCommands.ftm.get_settings();

    const w_searchSettings: LeoGuiFindTabManagerSettings = {
        // Nav options
        nav_text: scon.navText,
        show_parents: scon.showParents,
        is_tag: scon.isTag,
        search_options: scon.searchOptions,
        //Find/change strings...
        find_text: leoISettings.find_text,
        change_text: leoISettings.change_text,
        // Find options...
        ignore_case: leoISettings.ignore_case,
        mark_changes: leoISettings.mark_changes,
        mark_finds: leoISettings.mark_finds,
        node_only: leoISettings.node_only,
        file_only: leoISettings.file_only,
        pattern_match: leoISettings.pattern_match,
        search_body: leoISettings.search_body,
        search_headline: leoISettings.search_headline,
        suboutline_only: leoISettings.suboutline_only,
        whole_word: leoISettings.whole_word
    };


    const w_settings: LeoSearchSettings = {
        isTag: w_searchSettings.is_tag,
        navText: w_searchSettings.nav_text,
        showParents: w_searchSettings.show_parents,
        searchOptions: w_searchSettings.search_options,
        //Find/change strings...
        findText: w_searchSettings.find_text,
        replaceText: w_searchSettings.change_text,
        // Find options...
        wholeWord: w_searchSettings.whole_word,
        ignoreCase: w_searchSettings.ignore_case,
        regExp: w_searchSettings.pattern_match,
        markFinds: w_searchSettings.mark_finds,
        markChanges: w_searchSettings.mark_changes,
        searchHeadline: w_searchSettings.search_headline,
        searchBody: w_searchSettings.search_body,
        // 0, 1 or 2 for outline, sub-outline, or node.
        searchScope:
            0 +
            (w_searchSettings.suboutline_only ? 1 : 0) +
            (w_searchSettings.node_only ? 2 : 0) +
            (w_searchSettings.file_only ? 3 : 0),
    };
    if (w_settings.searchScope &gt; 2) {
        console.error('searchScope SHOULD BE 0, 1, 2 only: ', w_settings.searchScope);
    }
    this._lastSettingsUsed = w_settings;
    if (this._findPanelWebviewExplorerView) {
        this._findPanelWebviewExplorerView.webview.postMessage({
            type: 'setSettings',
            value: w_settings,
        });
    }
    if (this._findPanelWebviewView) {
        this._findPanelWebviewView.webview.postMessage({
            type: 'setSettings',
            value: w_settings,
        });
    }

    // this.sendAction(Constants.LEOBRIDGE.GET_SEARCH_SETTINGS).then(
    //     (p_result: LeoBridgePackage) =&gt; {
    //         const w_searchSettings: LeoGuiFindTabManagerSettings = p_result.searchSettings!;
    //         const w_settings: LeoSearchSettings = {
    //             isTag: w_searchSettings.is_tag,
    //             navText: w_searchSettings.nav_text,
    //             showParents: w_searchSettings.show_parents,
    //             searchOptions: w_searchSettings.search_options,
    //             //Find/change strings...
    //             findText: w_searchSettings.find_text,
    //             replaceText: w_searchSettings.change_text,
    //             // Find options...
    //             wholeWord: w_searchSettings.whole_word,
    //             ignoreCase: w_searchSettings.ignore_case,
    //             regExp: w_searchSettings.pattern_match,
    //             markFinds: w_searchSettings.mark_finds,
    //             markChanges: w_searchSettings.mark_changes,
    //             searchHeadline: w_searchSettings.search_headline,
    //             searchBody: w_searchSettings.search_body,
    //             // 0, 1 or 2 for outline, sub-outline, or node.
    //             searchScope:
    //                 0 +
    //                 (w_searchSettings.suboutline_only ? 1 : 0) +
    //                 (w_searchSettings.node_only ? 2 : 0) +
    //                 (w_searchSettings.file_only ? 3 : 0),
    //         };
    //         if (w_settings.searchScope &gt; 2) {
    //             console.error('searchScope SHOULD BE 0, 1, 2 only: ', w_settings.searchScope);
    //         }
    //         this._lastSettingsUsed = w_settings;
    //         if (this._findPanelWebviewExplorerView) {
    //             this._findPanelWebviewExplorerView.webview.postMessage({
    //                 type: 'setSettings',
    //                 value: w_settings,
    //             });
    //         }
    //         if (this._findPanelWebviewView) {
    //             this._findPanelWebviewView.webview.postMessage({
    //                 type: 'setSettings',
    //                 value: w_settings,
    //             });
    //         }
    //     }
    // );
}

</t>
<t tx="felix.20220505215924.14">/**
 * * Send the settings to Leo implementation
 * @param p_settings the search settings to be set in Leo implementation to affect next results
 * @returns 
 */
public saveSearchSettings(p_settings: LeoSearchSettings): Thenable&lt;unknown&gt; {

    return vscode.window.showInformationMessage("TODO: saveSearchSettings");

    // this._lastSettingsUsed = p_settings;
    // // convert to LeoGuiFindTabManagerSettings
    // const w_settings: LeoGuiFindTabManagerSettings = {
    //     // Nav settings
    //     is_tag: p_settings.isTag,
    //     nav_text: p_settings.navText,
    //     show_parents: p_settings.showParents,
    //     search_options: p_settings.searchOptions,
    //     // Find/change strings...
    //     find_text: p_settings.findText,
    //     change_text: p_settings.replaceText,
    //     // Find options...
    //     ignore_case: p_settings.ignoreCase,
    //     mark_changes: p_settings.markChanges,
    //     mark_finds: p_settings.markFinds,
    //     node_only: !!(p_settings.searchScope === 2),
    //     file_only: !!(p_settings.searchScope === 3),
    //     pattern_match: p_settings.regExp,
    //     search_body: p_settings.searchBody,
    //     search_headline: p_settings.searchHeadline,
    //     suboutline_only: !!(p_settings.searchScope === 1),
    //     whole_word: p_settings.wholeWord,
    // };
    // return this.sendAction(
    //     Constants.LEOBRIDGE.SET_SEARCH_SETTINGS,
    //     JSON.stringify({ searchSettings: w_settings })
    // );
}

</t>
<t tx="felix.20220505215924.15">/**
 * * Goto Global Line
 */
public gotoGlobalLine(): void {
    vscode.window.showInformationMessage("TODO: gotoGlobalLine");

    // this.triggerBodySave(false)
    //     .then((p_saveResult: boolean) =&gt; {
    //         return vscode.window.showInputBox({
    //             title: Constants.USER_MESSAGES.TITLE_GOTO_GLOBAL_LINE,
    //             placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_GOTO_GLOBAL_LINE,
    //             prompt: Constants.USER_MESSAGES.PROMPT_GOTO_GLOBAL_LINE,
    //         });
    //     })
    //     .then((p_inputResult?: string) =&gt; {
    //         if (p_inputResult) {
    //             const w_line = parseInt(p_inputResult);
    //             if (!isNaN(w_line)) {
    //                 this.sendAction(
    //                     Constants.LEOBRIDGE.GOTO_GLOBAL_LINE,
    //                     JSON.stringify({ line: w_line })
    //                 ).then((p_resultGoto: LeoBridgePackage) =&gt; {
    //                     if (!p_resultGoto.found) {
    //                         // Not found
    //                     }
    //                     this.launchRefresh(
    //                         {
    //                             tree: true,
    //                             body: true,
    //                             documents: false,
    //                             buttons: false,
    //                             states: true,
    //                         },
    //                         false
    //                     );
    //                 });
    //             }
    //         }
    //     });
}

</t>
<t tx="felix.20220505215924.16">/**
 * * Tag Children
 */
public tagChildren(): void {
    vscode.window.showInformationMessage("TODO: tagChildren");

    // this.triggerBodySave(false)
    //     .then((p_saveResult: boolean) =&gt; {
    //         return vscode.window.showInputBox({
    //             title: Constants.USER_MESSAGES.TITLE_TAG_CHILDREN,
    //             placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_TAG,
    //             prompt: Constants.USER_MESSAGES.PROMPT_TAG,
    //         });
    //     })
    //     .then((p_inputResult?: string) =&gt; {
    //         if (p_inputResult &amp;&amp; p_inputResult.trim()) {
    //             p_inputResult = p_inputResult.trim();
    //             // check for special chars first
    //             if (p_inputResult.split(/(&amp;|\||-|\^)/).length &gt; 1) {
    //                 vscode.window.showInformationMessage('Cannot add tags containing any of these characters: &amp;|^-');
    //                 return;
    //             }
    //             this.sendAction(
    //                 Constants.LEOBRIDGE.TAG_CHILDREN,
    //                 JSON.stringify({ tag: p_inputResult })
    //             ).then((p_resultTag: LeoBridgePackage) =&gt; {
    //                 this.launchRefresh(
    //                     {
    //                         tree: true,
    //                         body: false,
    //                         documents: false,
    //                         buttons: false,
    //                         states: true,
    //                     },
    //                     false
    //                 );
    //             });
    //         }
    //     });
}

</t>
<t tx="felix.20220505215924.17">/**
 * * Tag Node
 */
public tagNode(): void {
    vscode.window.showInformationMessage("TODO: tagNode");

    // this.triggerBodySave(false)
    //     .then((p_saveResult: boolean) =&gt; {
    //         return vscode.window.showInputBox({
    //             title: Constants.USER_MESSAGES.TITLE_TAG_NODE,
    //             placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_TAG,
    //             prompt: Constants.USER_MESSAGES.PROMPT_TAG,
    //         });
    //     })
    //     .then((p_inputResult?: string) =&gt; {

    //         if (p_inputResult &amp;&amp; p_inputResult.trim()) {
    //             p_inputResult = p_inputResult.trim();
    //             // check for special chars first
    //             if (p_inputResult.split(/(&amp;|\||-|\^)/).length &gt; 1) {
    //                 vscode.window.showInformationMessage('Cannot add tags containing any of these characters: &amp;|^-');
    //                 return;
    //             }
    //             this.sendAction(
    //                 Constants.LEOBRIDGE.TAG_NODE,
    //                 JSON.stringify({ tag: p_inputResult })
    //             ).then((p_resultTag: LeoBridgePackage) =&gt; {
    //                 this.launchRefresh(
    //                     {
    //                         tree: true,
    //                         body: false,
    //                         documents: false,
    //                         buttons: false,
    //                         states: true,
    //                     },
    //                     false
    //                 );
    //             });
    //         }
    //     });
}

</t>
<t tx="felix.20220505215924.18">/**
 * * Remove single Tag on selected node
 */
public removeTag(): void {
    vscode.window.showInformationMessage("TODO: removeTag");

    // if (this.lastSelectedNode &amp;&amp; this.lastSelectedNode.u &amp;&amp;
    //     this.lastSelectedNode.u.__node_tags &amp;&amp; this.lastSelectedNode.u.__node_tags.length) {
    //     this.triggerBodySave(false)
    //         .then((p_saveResult: boolean) =&gt; {
    //             return vscode.window.showQuickPick(this.lastSelectedNode!.u.__node_tags, {
    //                 title: Constants.USER_MESSAGES.TITLE_REMOVE_TAG,
    //                 placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_TAG,
    //                 canPickMany: false
    //                 // prompt: Constants.USER_MESSAGES.PROMPT_TAG,
    //             });
    //         })
    //         .then((p_inputResult?: string) =&gt; {
    //             if (p_inputResult &amp;&amp; p_inputResult.trim()) {
    //                 this.sendAction(
    //                     Constants.LEOBRIDGE.REMOVE_TAG,
    //                     JSON.stringify({ tag: p_inputResult.trim() })
    //                 ).then((p_resultTag: LeoBridgePackage) =&gt; {
    //                     this.launchRefresh(
    //                         {
    //                             tree: true,
    //                             body: false,
    //                             documents: false,
    //                             buttons: false,
    //                             states: true,
    //                         },
    //                         false
    //                     );
    //                 });
    //             }
    //         });
    // } else if (this.lastSelectedNode) {
    //     vscode.window.showInformationMessage("No tags on node: " + this.lastSelectedNode.label);
    // } else {
    //     return;
    // }

}

</t>
<t tx="felix.20220505215924.19">/**
 * * Remove all tags on selected node
 */
public removeTags(): void {
    vscode.window.showInformationMessage("TODO: removeTags");

    // if (this.lastSelectedNode &amp;&amp; this.lastSelectedNode.u &amp;&amp;
    //     this.lastSelectedNode.u.__node_tags &amp;&amp; this.lastSelectedNode.u.__node_tags.length) {
    //     this.triggerBodySave(false)
    //         .then((p_saveResult: boolean) =&gt; {
    //             this.sendAction(
    //                 Constants.LEOBRIDGE.REMOVE_TAGS
    //             ).then((p_resultTag: LeoBridgePackage) =&gt; {
    //                 this.launchRefresh(
    //                     {
    //                         tree: true,
    //                         body: false,
    //                         documents: false,
    //                         buttons: false,
    //                         states: true,
    //                     },
    //                     false
    //                 );
    //             });
    //         });
    // } else if (this.lastSelectedNode) {
    //     vscode.window.showInformationMessage("No tags on node: " + this.lastSelectedNode.label);
    // } else {
    //     return;
    // }
}

</t>
<t tx="felix.20220505215924.2">
public navEnter(): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage("TODO: navEnter");

    // return this._isBusyTriggerSave(false, true).then(() =&gt; {

    //     return this.sendAction(
    //         Constants.LEOBRIDGE.NAV_SEARCH
    //     ).then((p_package) =&gt; {
    //         this._leoGotoProvider.refreshTreeRoot();
    //         this.showGotoPane({ preserveFocus: true }); // show but dont change focus
    //         return p_package;
    //     });

    // });
</t>
<t tx="felix.20220505215924.20">/**
 * * Clone Find Tag
 */
public cloneFindTag(): void {
    vscode.window.showInformationMessage("TODO: cloneFindTag");

    // this.triggerBodySave(false)
    //     .then((p_saveResult: boolean) =&gt; {
    //         return vscode.window.showInputBox({
    //             title: Constants.USER_MESSAGES.TITLE_FIND_TAG,
    //             placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_CLONE_FIND_TAG,
    //             prompt: Constants.USER_MESSAGES.PROMPT_CLONE_FIND_TAG,
    //         });
    //     })
    //     .then((p_inputResult?: string) =&gt; {
    //         if (p_inputResult &amp;&amp; p_inputResult.trim()) {
    //             this.sendAction(
    //                 Constants.LEOBRIDGE.CLONE_FIND_TAG,
    //                 JSON.stringify({ tag: p_inputResult.trim() })
    //             ).then((p_resultFind: LeoBridgePackage) =&gt; {
    //                 if (!p_resultFind.found) {
    //                     // Not found
    //                 }
    //                 this.launchRefresh(
    //                     {
    //                         tree: true,
    //                         body: true,
    //                         documents: false,
    //                         buttons: false,
    //                         states: true,
    //                     },
    //                     false
    //                 );
    //             });
    //         }
    //     });
}

</t>
<t tx="felix.20220505215924.3">
}

public navTextChange(): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage("TODO: navTextChange");

    // return this._isBusyTriggerSave(false, true).then(() =&gt; {

    //     return this.sendAction(
    //         Constants.LEOBRIDGE.NAV_HEADLINE_SEARCH
    //     ).then((p_package) =&gt; {
    //         this._leoGotoProvider.refreshTreeRoot();
    //         this.showGotoPane({ preserveFocus: true }); // show but dont change focus
    //         return p_package;
    //     });

    // });

}

</t>
<t tx="felix.20220505215924.4">/**
 * * Opens the find panel and selects all &amp; focuses on the find field.
 */
public startSearch(): void {
    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        w_panel?.webview.postMessage({ type: 'selectFind' });
    });
}

</t>
<t tx="felix.20220505215924.6">/**
 * * Get a find pattern string input from the user
 * @param p_replace flag for doing a 'replace' instead of a 'find'
 * @returns Promise of string or undefined if cancelled
 */
private _inputFindPattern(p_replace?: boolean): Thenable&lt;string | undefined&gt; {
    return vscode.window.showInputBox({
        title: p_replace ? "Replace with" : "Search for",
        prompt: p_replace ? "Type text to replace with and press enter." : "Type text to search for and press enter.",
        placeHolder: p_replace ? "Replace pattern here" : "Find pattern here",
    });
}

</t>
<t tx="felix.20220505215924.7">/**
 * * Find next / previous commands
 * @param p_fromOutline
 * @param p_reverse
 * @returns Promise that resolves when the "launch refresh" is started
 */
public find(p_fromOutline: boolean, p_reverse: boolean): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage("TODO: find");

    // const w_action: string = p_reverse
    //     ? Constants.LEOBRIDGE.FIND_PREVIOUS
    //     : Constants.LEOBRIDGE.FIND_NEXT;
    // return this._isBusyTriggerSave(false, true)
    //     .then((p_saveResult) =&gt; {
    //         return this.sendAction(w_action, JSON.stringify({ fromOutline: !!p_fromOutline }));
    //     })
    //     .then((p_findResult: LeoBridgePackage) =&gt; {
    //         if (!p_findResult.found || !p_findResult.focus) {
    //             vscode.window.showInformationMessage('Not found');
    //         } else {
    //             let w_focusOnOutline = false;
    //             const w_focus = p_findResult.focus.toLowerCase();
    //             if (w_focus.includes('tree') || w_focus.includes('head')) {
    //                 // tree
    //                 w_focusOnOutline = true;
    //             }
    //             this.launchRefresh(
    //                 {
    //                     tree: true,
    //                     body: true,
    //                     scroll: p_findResult.found &amp;&amp; !w_focusOnOutline,
    //                     documents: false,
    //                     buttons: false,
    //                     states: true,
    //                 },
    //                 w_focusOnOutline
    //             );
    //         }
    //     });
}

</t>
<t tx="felix.20220505215924.8">/**
 * * find-var or find-def commands
 * @param p_def find-def instead of find-var
 * @returns Promise that resolves when the "launch refresh" is started
 */
public findSymbol(p_def: boolean): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage("TODO: findSymbol");

    // const w_action: string = p_def
    //     ? Constants.LEOBRIDGE.FIND_DEF
    //     : Constants.LEOBRIDGE.FIND_VAR;
    // return this._isBusyTriggerSave(false, true)
    //     .then((p_saveResult) =&gt; {
    //         return this.sendAction(w_action, JSON.stringify({ fromOutline: false }));
    //     })
    //     .then((p_findResult: LeoBridgePackage) =&gt; {
    //         if (!p_findResult.found || !p_findResult.focus) {
    //             vscode.window.showInformationMessage('Not found');
    //         } else {
    //             let w_focusOnOutline = false;
    //             const w_focus = p_findResult.focus.toLowerCase();
    //             if (w_focus.includes('tree') || w_focus.includes('head')) {
    //                 // tree
    //                 w_focusOnOutline = true;
    //             }
    //             this.loadSearchSettings();
    //             this.launchRefresh(
    //                 {
    //                     tree: true,
    //                     body: true,
    //                     scroll: p_findResult.found &amp;&amp; !w_focusOnOutline,
    //                     documents: false,
    //                     buttons: false,
    //                     states: true,
    //                 },
    //                 w_focusOnOutline
    //             );
    //         }
    //     });
}

</t>
<t tx="felix.20220505215924.9">/**
 * * Replace / Replace-Then-Find commands
 * @param p_fromOutline
 * @param p_thenFind
 * @returns Promise that resolves when the "launch refresh" is started
 */
public replace(p_fromOutline: boolean, p_thenFind: boolean): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage("TODO: replace");

    // const w_action: string = p_thenFind
    //     ? Constants.LEOBRIDGE.REPLACE_THEN_FIND
    //     : Constants.LEOBRIDGE.REPLACE;
    // return this._isBusyTriggerSave(false, true)
    //     .then((p_saveResult) =&gt; {
    //         return this.sendAction(w_action, JSON.stringify({ fromOutline: !!p_fromOutline }));
    //     })
    //     .then((p_replaceResult: LeoBridgePackage) =&gt; {
    //         if (!p_replaceResult.found || !p_replaceResult.focus) {
    //             vscode.window.showInformationMessage('Not found');
    //         } else {
    //             let w_focusOnOutline = false;
    //             const w_focus = p_replaceResult.focus.toLowerCase();
    //             if (w_focus.includes('tree') || w_focus.includes('head')) {
    //                 // tree
    //                 w_focusOnOutline = true;
    //             }
    //             this.launchRefresh(
    //                 {
    //                     tree: true,
    //                     body: true,
    //                     scroll: true,
    //                     documents: false,
    //                     buttons: false,
    //                     states: true,
    //                 },
    //                 w_focusOnOutline
    //             );
    //         }
    //     });
}

</t>
<t tx="felix.20220505220527.1">export type TGotoTypes = "tag" | "headline" | "body" | "parent" | "generic";

</t>
<t tx="felix.20220505220532.1">export interface LeoGoto {
    key: number; // id from python
    h: string;
    t: TGotoTypes;
}

</t>
<t tx="felix.20220505220537.1">/**
 * * Enum type for the search scope radio buttons of the find panel.
 */
export const enum LeoSearchScope {
    entireOutline = 0,
    subOutlineOnly,
    nodeOnly,
    fileOnly
}

</t>
<t tx="felix.20220505220544.1">/**
 * * Search settings structure for use with the 'find' webview
 */
export interface LeoSearchSettings {
    // Nav options
    navText: string;
    isTag: boolean;
    showParents: boolean;
    searchOptions: number;
    // Find/change strings...
    findText: string;  // find_text
    replaceText: string; // change_text
    // Find options...
    wholeWord: boolean;
    ignoreCase: boolean;
    regExp: boolean;
    markFinds: boolean;
    markChanges: boolean;
    searchHeadline: boolean;
    searchBody: boolean;
    searchScope: LeoSearchScope; // 0, 1 or 2 for outline, sub-outline, or node.
}

</t>
<t tx="felix.20220505220550.1">/**
 * * Leo's GUI search settings internal structure
 */
export interface LeoGuiFindTabManagerSettings {
    // Nav options
    nav_text: string;
    is_tag: boolean;
    show_parents: boolean;
    search_options: number;
    //Find/change strings...
    find_text: string,
    change_text: string,
    // Find options...
    ignore_case: boolean,
    mark_changes: boolean,
    mark_finds: boolean,
    node_only: boolean,
    file_only: boolean,
    pattern_match: boolean,
    search_body: boolean,
    search_headline: boolean,
    suboutline_only: boolean,
    whole_word: boolean
}

</t>
<t tx="felix.20220505220619.1">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20220505220626.1">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20220505220630.1">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    // ! TEST scroll as single number only (for Leo vertical scroll value)
    scroll: number;
    // scroll: {
    //     start: BodyPosition;
    //     end: BodyPosition;
    // }
    insert: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20220505220706.1">/**
 * * Used to select a button's rclick by index
 */
export interface ChooseRClickItem extends vscode.QuickPickItem {
    index: number;
    rclick?: RClick;
}

</t>
<t tx="felix.20220505220722.1">/**
 * * Returned from Leo with buttons data
 */
export interface RClick {
    name: string;
    children: RClick[];
}

</t>
<t tx="felix.20220505221929.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoUI } from "./leoUI";
import { LeoGoto, TGotoTypes } from "./types";
import * as utils from "./utils";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20220505222045.1">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoGotoProvider implements vscode.TreeDataProvider&lt;LeoGotoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoGotoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoGotoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoGotoNode | undefined&gt; = this._onDidChangeTreeData.event;

    private _lastGotoView: vscode.TreeView&lt;LeoGotoNode&gt; | undefined;

    private _topNode: LeoGotoNode | undefined;

    constructor(private _leoUI: LeoUI) { }

    public showGotoPanel(): Thenable&lt;void&gt; {
        if (this._lastGotoView &amp;&amp; this._topNode) {
            return this._lastGotoView.reveal(this._topNode, { select: false, focus: false });
        }
        return Promise.resolve();
    }

    public setLastGotoView(p_view: vscode.TreeView&lt;LeoGotoNode&gt;): void {
        this._lastGotoView = p_view;
    }

    /**
     * * Refresh the whole outline
     */
    public refreshTreeRoot(): void {
        this._onDidChangeTreeData.fire(undefined);
    }

    public getTreeItem(element: LeoGotoNode): Thenable&lt;LeoGotoNode&gt; | LeoGotoNode {
        return element;
    }

    public getChildren(element?: LeoGotoNode): Thenable&lt;LeoGotoNode[]&gt; {

        // if called with element, or not ready, give back empty array as there won't be any children
        if (this._leoUI.leoStates.fileOpenedReady &amp;&amp; !element) {

            // TODO !
            return Promise.resolve([]);

            /* 

            // call action to get get list, and convert to LeoButtonNode(s) array
            return this._leoUI.sendAction(Constants.LEOBRIDGE.GET_GOTO_PANEL).then(p_package =&gt; {
                if (p_package &amp;&amp; p_package.navList) {

                    const w_list: LeoGotoNode[] = [];
                    this._topNode = undefined;
                    const w_navList: LeoGoto[] = p_package.navList;
                    if (w_navList &amp;&amp; w_navList.length) {
                        w_navList.forEach((p_goto: LeoGoto) =&gt; {
                            const w_newNode = new LeoGotoNode(this._leoUI, p_goto, p_package.navOptions!);
                            if (!this._topNode) {
                                this._topNode = w_newNode;
                            }
                            w_list.push(w_newNode);
                        });
                    }
                    return w_list;
                } else {
                    return [];
                }
            });

            */

        } else {
            return Promise.resolve([]); // Defaults to an empty list of children
        }
    }

    public getParent(element: LeoGotoNode): vscode.ProviderResult&lt;LeoGotoNode&gt; | null {
        // Leo documents are just a list, as such, entries are always child of root, so return null
        return null;
    }

}
</t>
<t tx="felix.20220505222101.1">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoGotoNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public entryType: TGotoTypes;
    private _id: string;
    private _description: string | boolean;
    private _headline: string;
    private _iconIndex: number; // default to tag
    private _leoUI: LeoUI;
    public key: number; // id from python

    constructor(
        p_leoUI: LeoUI,
        p_gotoEntry: LeoGoto,
        p_navOptions: { isTag: boolean, showParents: boolean },

    ) {
        let w_spacing = "";
        if (p_navOptions.showParents &amp;&amp; !p_navOptions.isTag) {
            w_spacing = "    ";
        }
        let w_label = "";
        if (["tag", "headline"].includes(p_gotoEntry.t)) {
            w_label = w_spacing + p_gotoEntry.h;
        }
        super(w_label);

        // Setup this instance
        this._leoUI = p_leoUI;
        this._id = utils.getUniqueId();
        this.entryType = p_gotoEntry.t;
        this.key = p_gotoEntry.key;
        this._headline = p_gotoEntry.h.trim();

        this._description = false;
        if (this.entryType === 'body') {
            this._iconIndex = 2;
            if (p_navOptions.showParents) {
                this._description = "    " + this._headline;
            } else {
                this._description = "  " + this._headline;
            }
        } else if (this.entryType === 'parent') {
            this._iconIndex = 0;
            this._description = this._headline.trim();
        } else if (this.entryType === 'generic') {
            this._iconIndex = 4;
            this._description = this._headline;
        } else if (this.entryType === 'headline') {
            this._iconIndex = 1;
        } else {
            this._iconIndex = 3; // tag
        }

        this.command = {
            command: Constants.COMMANDS.GOTO_NAV_ENTRY,
            title: '',
            arguments: [this]
        };

    }

    // @ts-ignore
    public get tooltip(): string {
        if (this.entryType !== "generic") {
            return this.entryType.charAt(0).toUpperCase() + this.entryType.slice(1);
        }
        return this._headline;
    }

    // @ts-ignore
    public get description(): string | boolean {
        return this._description;
    }

    // @ts-ignore
    public get iconPath(): Icon | vscode.ThemeIcon | string {
        if (this._iconIndex &lt; 4) {
            return this._leoUI.gotoIcons[this._iconIndex];
        }
        // else return undefined for generic text without icon
        return undefined;
    }

    // @ts-ignore
    public get id(): string {
        // Add prefix and suffix salt to numeric index to prevent accidental duplicates
        // Should be unique when refreshed
        return "g" + this._id + "o";
    }

}
</t>
<t tx="felix.20220505225023.1">/**
 * * Get new uniqueID
 */
export function getUniqueId(): string {
    const id = uniqueId++;
    return id.toString();
}

</t>
<t tx="felix.20220505225030.1">/**
 * * Unique numeric Id
 */
var uniqueId: number = 0;

</t>
<t tx="felix.20220505225236.1">/**
 * * Build all possible strings for the goto panel
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the goto anywhere tree view
 */
export function buildGotoIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_PARENT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_PARENT)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_NODE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_NODE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BODY),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BODY)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_TAG),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_TAG)
        }
    ];
}

</t>
<t tx="felix.20220508201944.1">/**
 * Redo operation available state
 */
private _leoCanGoBack: boolean = false;
get leoCanGoBack(): boolean {
    return this._leoCanGoBack;
}
set leoCanGoBack(p_value: boolean) {
    this._leoCanGoBack = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_BACK, p_value);
}

</t>
<t tx="felix.20220508201944.2">/**
 * Redo operation available state
 */
private _leoCanGoNext: boolean = false;
get leoCanGoNext(): boolean {
    return this._leoCanGoNext;
}
set leoCanGoNext(p_value: boolean) {
    this._leoCanGoNext = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_NEXT, p_value);
}

</t>
<t tx="felix.20220516005841.1">public runAskYesNoCancelDialog(
    c: Commands,
    title: string,
    message: string,
    yesMessage = "Yes",
    noMessage = "No",
    yesToAllMessage = "",
    defaultButton = "Yes",
    cancelMessage = ""
): Thenable&lt;string&gt; {
    return vscode.window
        .showInformationMessage(
            title,
            {
                modal: true,
                detail: message
            },
            Constants.USER_MESSAGES.YES,
            Constants.USER_MESSAGES.NO
            // Already shows a 'cancel' 
        )
        .then((answer) =&gt; {
            if (answer === Constants.USER_MESSAGES.YES) {
                return Constants.USER_MESSAGES.YES.toLowerCase();
            } else if (answer === Constants.USER_MESSAGES.NO) {
                return Constants.USER_MESSAGES.NO.toLowerCase();
            } else {
                return Constants.USER_MESSAGES.CANCEL.toLowerCase();
            }
        });
}

</t>
<t tx="felix.20220517002104.1">/**
* * Creates a new Leo file
* @returns the promise started after it's done creating the frame and commander
*/
public async newLeoFile(): Promise&lt;unknown&gt; {

    this.setupRefresh(Focus.NoChange, {
        tree: true,
        body: true,
        documents: true,
        buttons: true,
        states: true
    });

    if (!this.leoStates.fileOpenedReady) {
        if (g.app.loadManager) {
            await g.app.loadManager.openEmptyLeoFile(this);
        }
    } else {
        await this.triggerBodySave();
        const c = g.app.windowList[this.frameIndex].c;
        c.new(this);
    }
    this.launchRefresh();
    return Promise.resolve();
}

</t>
<t tx="felix.20220517202245.1">{
  "command": "leojs.saveLeoFileFromOutline",
  "when": "viewItem =~ /^leojsDocumentSelectedTitled/",
  "group": "inline@1"
},
{
  "command": "leojs.saveAsLeoFile",
  "when": "viewItem =~ /^leojsDocumentSelected/",
  "group": "inline@1"
},
{
  "command": "leojs.saveAsLeoJsFile",
  "when": "viewItem =~ /^leojsDocumentSelectedUntitled/",
  "group": "inline@1"
},
{
  "command": "leojs.closeLeoFile",
  "when": "viewItem =~ /^leojsDocumentSelected/",
  "group": "inline@2"
},
</t>
<t tx="felix.20220517203332.1">{
  "command": "leojs.removeButton",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsButtonNode/",
  "group": "leojsButtonContext1@1"
},
{
  "command": "leojs.gotoScript",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsButtonNode/",
  "group": "leojsButtonContext1@2"
}
</t>
<t tx="felix.20220517212706.1">/**
 * * Show input window to select
 */
private _handleRClicks(p_rclicks: any[], topLevelName?: string): Thenable&lt;any&gt; {
    // private _handleRClicks(p_rclicks: RClick[], topLevelName?: string): Thenable&lt;ChooseRClickItem&gt; {
    /* 
    const w_choices: ChooseRClickItem[] = [];
    let w_index = 0;
    if (topLevelName) {
        w_choices.push(
            { label: topLevelName, picked: true, alwaysShow: true, index: w_index++ }
        );
    }
    w_choices.push(
        ...p_rclicks.map((p_rclick): ChooseRClickItem =&gt; { return { label: p_rclick.name, index: w_index++, rclick: p_rclick }; })
    );

    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.CHOOSE_BUTTON
    };
    return vscode.window.showQuickPick(w_choices, w_options).then((p_picked) =&gt; {
        if (p_picked) {
            this._rclickSelected.push(p_picked.index);
            if (topLevelName &amp;&amp; p_picked.index === 0) {
                return Promise.resolve(p_picked);
            }
            if (p_picked.rclick &amp;&amp; p_picked.rclick.children &amp;&amp; p_picked.rclick.children.length) {
                return this._handleRClicks(p_picked.rclick.children);
            } else {
                return Promise.resolve(p_picked);
            }
        }
        // Escaped
        return Promise.reject();
    });
    */
    return Promise.resolve();
}

</t>
<t tx="felix.20220517212718.1">/**
 * * Finds and goes to the script of an at-button. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was right-clicked
 * @returns the launchRefresh promise started after it's done finding the node
 */
public gotoScript(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return Promise.resolve(true);
    /* 
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.GOTO_SCRIPT,
                JSON.stringify({ index: p_node.button.index })
            );
        })
        .then((p_gotoScriptResult: LeoBridgePackage) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.DO_NOTHING);
        })
        .then((p_package) =&gt; {
            // refresh and reveal selection
            this.launchRefresh({ tree: true, body: true, states: true, buttons: false, documents: false }, false, p_package.node);
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
    */
}

</t>
<t tx="felix.20220519232002.1">public resolveTreeItem(item: LeoOutlineNode, element: Position, token: vscode.CancellationToken): vscode.ProviderResult&lt;LeoOutlineNode&gt; {
    if (element.v.u) {
        const w_u = element.v.u;
        const w_uaLength = Object.keys(w_u).length;
        if (w_uaLength) {

            if (w_uaLength === 1 &amp;&amp; w_u.__node_tags &amp;&amp; w_u.__node_tags.length) {
                // list tags instead
                item.tooltip = item.label + "\n\u{1F3F7} " + w_u.__node_tags.join('\n\u{1F3F7} ');

            } else {
                item.tooltip = item.label + "\n" +
                    JSON.stringify(w_u, undefined, 2);
            }

            return item;
        }

    }
    item.tooltip = item.label; // * Fallsback to whole headline as tooltip
    return item;
}

</t>
<t tx="felix.20220520011951.1">public resolveTreeItem(item: LeoUndoNode, element: LeoUndoNode, token: vscode.CancellationToken): vscode.ProviderResult&lt;LeoUndoNode&gt; {
    item.tooltip = "TODO leojs Undo Tooltip";
    return item;
}
</t>
<t tx="felix.20220523140004.1">function runLeo(p_context: vscode.ExtensionContext) {
    const w_start = process.hrtime(); // For calculating total startup time duration

    // Initialize and run Leo
    console.assert(g.app);

    g.app.loadManager = new LoadManager(p_context);
    g.app.loadManager.load().then(() =&gt; {
        console.log(`leojs startup launched in ${utils.getDurationMs(w_start)} ms`);
    });
}

</t>
<t tx="felix.20220523151725.1">function setScheme(p_event: vscode.WorkspaceFoldersChangeEvent, p_context: vscode.ExtensionContext) {
    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders.length) {
        console.log('WORKSPACE CHANGE DETECTED! length ' + vscode.workspace.workspaceFolders.length);

        g.app.vscodeWorkspaceUri = vscode.workspace.workspaceFolders[0].uri;
        g.app.vscodeUriScheme = vscode.workspace.workspaceFolders[0].uri.scheme;
        g.app.vscodeUriAuthority = vscode.workspace.workspaceFolders[0].uri.authority;
        g.app.vscodeUriPath = vscode.workspace.workspaceFolders[0].uri.path;
        console.log('Writable filesystem: ', vscode.workspace.fs.isWritableFileSystem(g.app.vscodeUriScheme));

        console.log('WORKSPACE CHANGE DETECTED! workspace JSON: ' + JSON.stringify(g.app.vscodeWorkspaceUri.toJSON()));
        console.log('WORKSPACE CHANGE DETECTED! workspace toString: ' + g.app.vscodeWorkspaceUri.toString());

        // not started yet? 
        if (!g.app.loadManager &amp;&amp; g.isBrowser) {
            // Check if not file scheme : only virtual workspaces are suported if g.isBrowser is true.
            if (g.app.vscodeUriScheme !== 'file') {
                runLeo(p_context);
            } else {
                // Is local filesystem
                vscode.window.showInformationMessage("LeoJS in browser supports remote virtual filesystems: Local Filesystem requires desktop VSCode application: ", "More Info").then(selection =&gt; {
                    if (selection === "More Info") {
                        vscode.env.openExternal(vscode.Uri.parse(
                            'https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project'));
                    }
                });
                console.log('NOT started because no remote workspace yet');
                setStartupDoneContext(true);
                return;
            }
        }
    } else {
        console.log('TODO : HANDLE WORKSPACE CHANGE DETECTED! but no workspace');
        setStartupDoneContext(true);
    }

}

</t>
<t tx="felix.20220613164517.1">public runAboutLeoDialog(
    c: Commands,
    version: string,
    theCopyright: string,
    url: string,
    email: string
): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage(
        version,
        {
            modal: true,
            detail: theCopyright
        });
}

</t>
<t tx="felix.20220725004247.1">/**
 * * Sets the outline pane top bar string message or refreshes with existing title if no title passed
 * @param p_title new string to replace the current title
 */
private _setTreeViewTitle(p_title?: string): void {
    const w_changed = this.leoStates.fileOpenedReady &amp;&amp; this.leoStates.leoOpenedFileName &amp;&amp; this.leoStates.leoChanged ? "*" : "";
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    let w_title = this._currentOutlineTitle + w_changed;
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    if (this._leoTreeView &amp;&amp; w_title !== this._leoTreeView.title) {
        this._leoTreeView.title = w_title;
    }
    w_title = Constants.GUI.EXPLORER_TREEVIEW_PREFIX + w_title;
    if (this._leoTreeExView &amp;&amp; w_title !== this._leoTreeExView.title) {
        this._leoTreeExView.title = w_title;
    }
    this.refreshDesc();
}

</t>
<t tx="felix.20220917013425.1">[CMD.SET_ENABLE_PREVIEW, () =&gt; p_leoUI.config.setEnablePreview()],
[CMD.CLEAR_CLOSE_EMPTY_GROUPS, () =&gt; p_leoUI.config.clearCloseEmptyGroups()],

</t>
<t tx="felix.20220918234128.1">"languages": [
  {
    "id": "leojsbody.plain",
    "aliases": [
      "Leo Body Plain",
      "leojsbody"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.plain.language-configuration.json"
  },
  {
    "id": "leojsbody.python",
    "aliases": [
      "Leo Body Python",
      "leojsbody.python"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.python.language-configuration.json"
  },
  {
    "id": "leojsbody.typescript",
    "aliases": [
      "Leo Body Typescript",
      "leojsbody.typescript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.typescript.language-configuration.json"
  },
  {
    "id": "leojsbody.javascript",
    "aliases": [
      "Leo Body Javascript",
      "leojsbody.javascript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.javascript.language-configuration.json"
  },
  {
    "id": "leojsbody.c",
    "aliases": [
      "Leo Body c",
      "leojsbody.c"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.c.language-configuration.json"
  },
  {
    "id": "leojsbody.cpp",
    "aliases": [
      "Leo Body C++",
      "leojsbody.cpp"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.cpp.language-configuration.json"
  },
  {
    "id": "leojsbody.css",
    "aliases": [
      "Leo Body CSS",
      "leojsbody.css"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.css.language-configuration.json"
  },
  {
    "id": "leojsbody.fortran",
    "aliases": [
      "Leo Body Fortran",
      "leojsbody.fortran"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.fortran.language-configuration.json"
  },
  {
    "id": "leojsbody.fortran90",
    "aliases": [
      "Leo Body Fortran90",
      "leojsbody.fortran90"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.fortran.language-configuration.json"
  },
  {
    "id": "leojsbody.html",
    "aliases": [
      "Leo Body HTML",
      "leojsbody.html"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.html.language-configuration.json"
  },
  {
    "id": "leojsbody.java",
    "aliases": [
      "Leo Body Java",
      "leojsbody.java"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.java.language-configuration.json"
  },
  {
    "id": "leojsbody.json",
    "aliases": [
      "Leo Body Json",
      "leojsbody.json"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.json.language-configuration.json"
  },
  {
    "id": "leojsbody.markdown",
    "aliases": [
      "Leo Body Markdown",
      "leojsbody.markdown"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.markdown.language-configuration.json"
  },
  {
    "id": "leojsbody.php",
    "aliases": [
      "Leo Body PHP",
      "leojsbody.php"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.php.language-configuration.json"
  },
  {
    "id": "leojsbody.restructuredtext",
    "aliases": [
      "Leo Body reStructuredText",
      "leojsbody.restructuredtext"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.rst.language-configuration.json"
  },
  {
    "id": "leojsbody.rust",
    "aliases": [
      "Leo Body Rust",
      "leojsbody.rust"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.rust.language-configuration.json"
  }
],
</t>
<t tx="felix.20220918234147.1">"grammars": [
  {
    "language": "leojsbody.plain",
    "scopeName": "source.leojsbody.plain",
    "path": "./syntaxes/leojsbody.plain.tmLanguage.json"
  },
  {
    "language": "leojsbody.python",
    "scopeName": "source.leojsbody.python",
    "path": "./syntaxes/leojsbody.python.tmLanguage.json"
  },
  {
    "language": "leojsbody.typescript",
    "scopeName": "source.leojsbody.typescript",
    "path": "./syntaxes/leojsbody.typescript.tmLanguage.json"
  },
  {
    "language": "leojsbody.javascript",
    "scopeName": "source.leojsbody.javascript",
    "path": "./syntaxes/leojsbody.javascript.tmLanguage.json"
  },
  {
    "language": "leojsbody.c",
    "scopeName": "source.leojsbody.c",
    "path": "./syntaxes/leojsbody.c.tmLanguage.json"
  },
  {
    "language": "leojsbody.cpp",
    "scopeName": "source.leojsbody.cpp",
    "path": "./syntaxes/leojsbody.cpp.tmLanguage.json"
  },
  {
    "language": "leojsbody.css",
    "scopeName": "source.leojsbody.css",
    "path": "./syntaxes/leojsbody.css.tmLanguage.json"
  },
  {
    "language": "leojsbody.fortran",
    "scopeName": "source.leojsbody.fortran",
    "path": "./syntaxes/leojsbody.fortran.tmLanguage.json"
  },
  {
    "language": "leojsbody.fortran90",
    "scopeName": "source.leojsbody.fortran90",
    "path": "./syntaxes/leojsbody.fortran90.tmLanguage.json"
  },
  {
    "language": "leojsbody.html",
    "scopeName": "source.leojsbody.html",
    "path": "./syntaxes/leojsbody.html.tmLanguage.json"
  },
  {
    "language": "leojsbody.java",
    "scopeName": "source.leojsbody.java",
    "path": "./syntaxes/leojsbody.java.tmLanguage.json"
  },
  {
    "language": "leojsbody.json",
    "scopeName": "source.leojsbody.json",
    "path": "./syntaxes/leojsbody.json.tmLanguage.json"
  },
  {
    "language": "leojsbody.markdown",
    "scopeName": "source.leojsbody.markdown",
    "path": "./syntaxes/leojsbody.markdown.tmLanguage.json"
  },
  {
    "language": "leojsbody.php",
    "scopeName": "source.leojsbody.php",
    "path": "./syntaxes/leojsbody.php.tmLanguage.json"
  },
  {
    "language": "leojsbody.restructuredtext",
    "scopeName": "source.leojsbody.restructuredtext",
    "path": "./syntaxes/leojsbody.rst.tmLanguage.json"
  },
  {
    "language": "leojsbody.rust",
    "scopeName": "source.leojsbody.rust",
    "path": "./syntaxes/leojsbody.rust.tmLanguage.json"
  },
  {
    "injectTo": [
      "source.leojsbody.c",
      "source.leojsbody.cpp",
      "source.leojsbody.css",
      "source.leojsbody.fortran",
      "source.leojsbody.fortran90",
      "source.leojsbody.html",
      "source.leojsbody.java",
      "source.leojsbody.javascript",
      "source.leojsbody.json",
      "source.leojsbody.markdown",
      "source.leojsbody.php",
      "source.leojsbody.plain",
      "source.leojsbody.python",
      "source.leojsbody.restructuredtext",
      "source.leojsbody.rust",
      "source.leojsbody.typescript"
    ],
    "path": "./syntaxes/leojsbody.tmLanguage.json",
    "scopeName": "leojs.injection"
  }
],
</t>
<t tx="felix.20220918234152.1">"snippets": [
  {
    "language": "leojsbody.c",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leojsbody.cpp",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leojsbody.fortran90",
    "path": "./snippets/fortran90.code-snippets"
  },
  {
    "language": "leojsbody.javascript",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leojsbody.typescript",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leojsbody.java",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leojsbody.php",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leojsbody.markdown",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leojsbody.restructuredtext",
    "path": "./snippets/restructuredtext.code-snippets"
  },
  {
    "language": "leojsbody.rust",
    "path": "./snippets/rust.code-snippets"
  }
],
</t>
<t tx="felix.20220920001018.1"></t>
<t tx="felix.20220920001018.2">/**
 * * Adds a message string to LeoJS log pane. Used when leoBridge receives an async 'log' command.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    this._leoLogPane.appendLine(p_message);
}

</t>
<t tx="felix.20220920001018.3">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(): Thenable&lt;unknown&gt; {
    if (this._leoLogPane) {
        this._leoLogPane.show(true); // Just show, so use flag to preserve focus
        return Promise.resolve(true);
    } else {
        return Promise.resolve(undefined); // if cancelled
    }
}

</t>
<t tx="felix.20220920001202.1">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    this._leoLogPane.hide();
}

</t>
<t tx="felix.20220922000450.1"></t>
<t tx="felix.20220922000450.10">
/**
 * * Closes any body pane opened in this vscode window instance
 * @returns a promise that resolves when the file is closed and removed from recently opened list
 */
public closeBody(): Thenable&lt;any&gt; {

    const w_foundTabs: vscode.Tab[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        w_foundTabs.forEach((p_tab) =&gt; {
            if (p_tab.input) {

                vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                vscode.workspace.applyEdit(w_edit);
            }
        });
    } else {
        q_closedTabs = Promise.resolve(true);

    }

    let q_closedBody;
    if (this.bodyUri) {
        q_closedBody = vscode.commands.executeCommand(
            'vscode.removeFromRecentlyOpened',
            this.bodyUri
        );
    } else {
        q_closedBody = Promise.resolve(true);
    }

    return Promise.all([q_closedTabs, q_closedBody]);
}

</t>
<t tx="felix.20220922000450.11">/**
 * * cleanupBody closes all remaining body pane to shut down this vscode window
 * @returns a promise that resolves when done saving and closing
 */
public cleanupBody(): Thenable&lt;any&gt; {
    let q_save: Thenable&lt;any&gt;;
    //
    if (this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        utils.leoUriToStr(this.bodyUri) === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
    ) {
        q_save = this._bodySaveDeactivate(this._bodyLastChangedDocument);
    } else {
        q_save = Promise.resolve(true);
    }

    // Adding log in the chain of events
    let q_edit: Thenable&lt;boolean&gt;;
    if (this.bodyUri) {
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(this.bodyUri, { ignoreIfNotExists: true });
        q_edit = vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            // console.log('applyEdit done');
            return true;
        }, () =&gt; {
            // console.log('applyEdit failed');
            return false;
        });
    } else {
        q_edit = Promise.resolve(true);
    }
    Promise.all([q_save, q_edit])
        .then(() =&gt; {
            // console.log('cleaned both');
            return this.closeBody();
        }, () =&gt; {
            // console.log('cleaned both failed');
            return true;
        });

    return q_save;
}

</t>
<t tx="felix.20220922000450.12">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preventTakingFocus flag that when true will stop the editor from taking focus once opened
 * @returns a promise of an editor, or void if body had been changed again in the meantime.
 */
public async showBody(p_aside: boolean, p_preventTakingFocus?: boolean): Promise&lt;vscode.TextEditor | void&gt; {
    const w_openedDocumentTS = utils.performanceNow();
    const w_openedDocumentGnx = utils.leoUriToStr(this.bodyUri);
    let q_saved: Thenable&lt;unknown&gt; | undefined;

    // First setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._refreshType.body) {
        this._refreshType.body = false;

        if (this._bodyLastChangedDocument &amp;&amp;
            !this._bodyLastChangedDocument.isClosed &amp;&amp;
            (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
            w_openedDocumentGnx === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
        ) {
            console.log('had to save so ------ fireRefreshFile !!'); // TODO : CLEANUP !

            // ! FAKE SAVE to make sure body is not dirty !
            this._leoFileSystem.preventSaveToLeo = true;
            this._editorTouched = false;
            q_saved = this._bodyLastChangedDocument.save();
        }

        if (q_saved) {
            await q_saved;
            this._leoFileSystem.fireRefreshFile(w_openedDocumentGnx);
        }

    }

    // Handle 'Config was changed -&gt; refresh without showing body' and return
    // (because _tryApplyNodeToBody will always call showBody if outline refreshes with )
    if (this._preventShowBody) {
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }

    // let w_preFoundDocOpened = false;
    // let w_preFoundTabOpened = false;
    // vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
    //     p_tabGroup.tabs.forEach((p_tab) =&gt; {

    //         if (p_tab.input &amp;&amp;
    //             (p_tab.input as vscode.TabInputText).uri &amp;&amp;
    //             (p_tab.input as vscode.TabInputText).uri.fsPath === this.bodyUri.fsPath) {
    //             w_preFoundTabOpened = true;
    //             vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
    //                 if (p_textDocument.uri.fsPath === (p_tab.input as vscode.TabInputText).uri.fsPath) {
    //                     w_preFoundDocOpened = true;
    //                 }
    //             });
    //         }
    //     });
    // });


    // * Step 1 : Open the document
    const w_openedDocument = await vscode.workspace.openTextDocument(this.bodyUri);

    this._bodyTextDocument = w_openedDocument;
    let w_bodySelection: BodySelectionInfo | undefined;
    // * Set document language along with the proper cursor position, selection range and scrolling position
    if (!this._needLastSelectedRefresh) {

        // * Get the language.
        const c = g.app.windowList[this.frameIndex].c;
        const p = c.p;
        const w_gnx = c.p.gnx;

        const aList = g.get_directives_dict_list(p);
        const d = g.scanAtCommentAndAtLanguageDirectives(aList);
        let w_language =
            (d &amp;&amp; d['language'])
            || g.getLanguageFromAncestorAtFileNode(p)
            || c.config.getLanguage('target-language')
            || 'plain';
        w_language = w_language.toLowerCase();

        // # Get the body wrap state
        const w_wrap = !!g.scanAllAtWrapDirectives(c, p);
        const tempTabWidth = g.scanAllAtTabWidthDirectives(c, p);
        const w_tabWidth: number | boolean = tempTabWidth || !!tempTabWidth;

        const insert = p.v.insertSpot;
        const start = p.v.selectionStart;
        const end = p.v.selectionStart + p.v.selectionLength;
        const scroll = p.v.scrollBarSpot;

        const row_col_pv_dict = (i: number, s: string) =&gt; {
            if (!i) {
                i = 0; // prevent none type
            }
            // BUG: this uses current selection wrapper only, use
            // g.convertPythonIndexToRowCol instead !
            let line: number;
            let col: number;
            [line, col] = g.convertPythonIndexToRowCol(s, i);
            return { "line": line, "col": col, "index": i };
        };

        w_bodySelection = {
            "gnx": p.v.gnx,
            "scroll": scroll,
            "insert": row_col_pv_dict(insert, p.v.b),
            "start": row_col_pv_dict(start, p.v.b),
            "end": row_col_pv_dict(end, p.v.b)
        };

        // TODO : Apply tabwidth
        // console.log('TABWIDTH: ', w_tabWidth);
        // TODO : Apply Wrap. see https://github.com/microsoft/vscode/issues/136927
        // console.log('WRAP: ', w_wrap);

        // Replace language string if in 'exceptions' array
        w_language = Constants.LEO_LANGUAGE_PREFIX + (Constants.LANGUAGE_CODES[w_language] || w_language);

        let w_debugMessage = "";
        let w_needRefreshFlag = false;

        // Apply language if the selected node is still the same after all those events
        if (!w_openedDocument.isClosed) {
            // w_openedDocument still OPEN
            if (this.isTsStillValid(w_openedDocumentTS)) { // No need to check gnx of command stack){
                // command stack last node is still valid
                if (this.lastSelectedNode &amp;&amp; w_openedDocumentGnx === this.lastSelectedNode.gnx) {
                    // still same gnx as this.bodyUri
                    this._setBodyLanguage(w_openedDocument, w_language);
                } else {
                    // NOT SAME GNX!
                    w_debugMessage = "all good but not same GNX!?!";
                    w_needRefreshFlag = true;
                }

            } else {
                // NOT VALID : NEW NODE SELECTED SINCE THIS STARTED!
                w_debugMessage = "New node selected since this started!";
                w_needRefreshFlag = false;
            }

        } else {
            w_debugMessage = "w_openedDocument is CLOSED " + w_openedDocument.uri.fsPath;
            w_needRefreshFlag = false;
        }

        // * Debug Info
        // if (w_debugMessage) {
        //     console.log(w_debugMessage);
        //     console.log("w_openedDocumentGnx", w_openedDocumentGnx);
        //     console.log("this.lastSelectedNode.gnx", this.lastSelectedNode!.gnx);
        //     console.log("w_gnx", w_gnx);
        // }

        if (w_needRefreshFlag) {

            // redo apply to body!
            setTimeout(() =&gt; {
                if (this.lastSelectedNode) {
                    this._switchBody(false, p_preventTakingFocus);
                }
            }, 0);
            return;

        }
    }

    // Find body pane's position if already opened with same gnx (language still needs to be set per position)
    let w_foundDocOpened = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {

            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.fsPath === w_openedDocument.uri.fsPath) {
                vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
                    if (p_textDocument.uri.fsPath === (p_tab.input as vscode.TabInputText).uri.fsPath) {
                        this._bodyTextDocument = p_textDocument; // vscode.workspace.openTextDocument
                        this._bodyMainSelectionColumn = p_tab.group.viewColumn;
                        w_foundDocOpened = true;
                    }
                });
            }
        });
    });

    // console.log('pre found TAB: ', w_preFoundTabOpened);
    // console.log('pre found DOC: ', w_preFoundDocOpened);

    // console.log('POST found TAB: ', w_foundTabOpened);
    // console.log('POST found DOC: ', w_foundDocOpened);


    if (w_foundDocOpened &amp;&amp; !q_saved) {
        // Was the same and was asked to show body (and did not already had to fake-save and refresh)
        this._leoFileSystem.fireRefreshFile(w_openedDocumentGnx);
    }

    // Setup options for the preview state of the opened editor, and to choose which column it should appear
    const w_showOptions: vscode.TextDocumentShowOptions = p_aside
        ? {
            viewColumn: vscode.ViewColumn.Beside,
            preserveFocus: p_preventTakingFocus,
            preview: true, // should text document be in preview only? set false for fully opened
        }
        : {
            viewColumn: this._bodyMainSelectionColumn
                ? this._bodyMainSelectionColumn
                : 1,
            preserveFocus: p_preventTakingFocus,
            preview: true, // should text document be in preview only? set false for fully opened
        };

    // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER "await vscode.workspace.openTextDocument"
    if (
        w_openedDocument.isClosed ||
        !this.isTsStillValid(w_openedDocumentTS) // No need to check gnx

        // Should the gnx be relevant? -&gt; !this.isGnxStillValid(w_openedDocumentGnx, w_openedDocumentTS)

    ) {
        return;
    }

    // * Actually Show the body pane document in a text editor
    const q_showTextDocument = vscode.window.showTextDocument(
        this._bodyTextDocument,
        w_showOptions
    ).then(
        (p_result) =&gt; {
            this.showBodyIfClosed = false; // * BODY IS ACTUALLY SHOWN!
            return p_result;
        },
        (p_reason) =&gt; {
            console.log('showTextDocument rejected: ', p_reason);
        }
    );

    // else q_bodyStates will exist.
    if (!this._needLastSelectedRefresh) {
        q_showTextDocument.then(
            (p_textEditor: vscode.TextEditor) =&gt; {

                // * Set text selection range
                const w_bodyTextEditor = p_textEditor;
                if (!w_bodySelection) {
                    console.log("no selection in returned package from get_body_states");
                }

                const w_leoBodySel: BodySelectionInfo = w_bodySelection!;

                // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER q_bodyStates &amp; q_showTextDocument
                if (
                    w_openedDocument.isClosed ||
                    !this.isTsStillValid(w_openedDocumentTS) ||
                    (this.lastSelectedNode &amp;&amp; w_leoBodySel.gnx !== this.lastSelectedNode.gnx)
                    // Should the gnx be relevant? -&gt; !this.isGnxStillValid(w_openedDocumentGnx, w_openedDocumentTS)
                ) {
                    return;
                }

                // Cursor position and selection range
                const w_activeRow: number = w_leoBodySel.insert.line;
                const w_activeCol: number = w_leoBodySel.insert.col;
                let w_anchorLine: number = w_leoBodySel.start.line;
                let w_anchorCharacter: number = w_leoBodySel.start.col;

                if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                    // Active insertion same as start selection, so use the other ones
                    w_anchorLine = w_leoBodySel.end.line;
                    w_anchorCharacter = w_leoBodySel.end.col;
                }

                const w_selection = new vscode.Selection(
                    w_anchorLine,
                    w_anchorCharacter,
                    w_activeRow,
                    w_activeCol
                );

                let w_scrollRange: vscode.Range | undefined;

                // Build scroll position from selection range.
                w_scrollRange = new vscode.Range(
                    w_activeRow,
                    w_activeCol,
                    w_activeRow,
                    w_activeCol
                );

                if (w_bodyTextEditor) {
                    // this._revealType = RevealType.NoReveal; // ! IN CASE THIS WAS STILL UP FROM SHOW_OUTLINE

                    w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                    if (!w_scrollRange) {
                        w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                    }

                    if (this._refreshType.scroll) {
                        this._refreshType.scroll = false;
                        // Set scroll approximation
                        w_bodyTextEditor.revealRange(w_scrollRange, vscode.TextEditorRevealType.InCenterIfOutsideViewport);
                        // ! Compensate for reveal that steals the focus.
                        if (this._refreshType.goto) {
                            this._refreshType.goto = false;
                            let w_viewName: string;
                            if (this._lastTreeView === this._leoTreeExView) {
                                w_viewName = Constants.GOTO_EXPLORER_ID;
                            } else {
                                w_viewName = Constants.GOTO_ID;
                            }
                            vscode.commands.executeCommand(w_viewName + ".focus");
                        }
                    }

                } else {
                    console.log("no selection in returned package from showTextDocument");
                }

            }
        );
    }

    return q_showTextDocument;
}

</t>
<t tx="felix.20220922000450.13">/**
 * * Sets vscode's body-pane editor's language
 */
private _setBodyLanguage(p_document: vscode.TextDocument, p_language: string): Thenable&lt;vscode.TextDocument&gt; {
    return vscode.languages.setTextDocumentLanguage(p_document, p_language).then(
        (p_mewDocument) =&gt; { return p_mewDocument; }, // ok - language found
        (p_error) =&gt; {
            let w_langName: string = p_error.toString().split('\n')[0];
            if (w_langName.length &gt; 36 &amp;&amp; w_langName.includes(Constants.LEO_LANGUAGE_PREFIX)) {
                w_langName = w_langName.substring(36);
            } else {
                w_langName = "";
            }
            if (w_langName &amp;&amp; !this._languageFlagged.includes(w_langName)) {
                this._languageFlagged.push(w_langName);
                vscode.window.showInformationMessage(
                    w_langName + Constants.USER_MESSAGES.LANGUAGE_NOT_SUPPORTED
                );
            } else if (!w_langName) {
                // Document was closed: refresh after a timeout cycle (should not happen!)
                setTimeout(() =&gt; {
                    this.setupRefresh(
                        this.finalFocus,
                        {
                            // tree: true,
                            body: true,
                            // documents: true,
                            // buttons: false,
                            states: true,
                        }
                    );
                    this.launchRefresh();
                }, 0);
            }
            return p_document;
        }
    );
}

</t>
<t tx="felix.20220922000450.14">/**
 * * Refreshes body pane's statuses such as applied language file type, word-wrap state, etc.
 */
public refreshBodyStates(): void {
    if (!this._bodyTextDocument || !this.lastSelectedNode) {
        return;
    }

    // * Set document language along with the proper cursor position, selection range and scrolling position
    const c = g.app.windowList[this.frameIndex].c;
    const p = c.p;
    const aList = g.get_directives_dict_list(p);
    const d = g.scanAtCommentAndAtLanguageDirectives(aList);
    let w_language =
        (d &amp;&amp; d['language'])
        || g.getLanguageFromAncestorAtFileNode(p)
        || c.config.getLanguage('target-language')
        || 'plain';
    w_language = w_language.toLowerCase();

    // # Get the body wrap state
    let w_wrap = !!g.scanAllAtWrapDirectives(c, p);

    // TODO : Apply Wrap. see https://github.com/microsoft/vscode/issues/136927
    // console.log('WRAP: ', w_wrap);

    // Replace language string if in 'exceptions' array
    w_language = Constants.LEO_LANGUAGE_PREFIX + (Constants.LANGUAGE_CODES[w_language] || w_language);
    // Apply language if the selected node is still the same after all those events
    if (this._bodyTextDocument &amp;&amp;
        !this._bodyTextDocument.isClosed &amp;&amp;
        this.lastSelectedNode &amp;&amp;
        w_language !== this._bodyTextDocument.languageId &amp;&amp;
        utils.leoUriToStr(this._bodyTextDocument.uri) === this.lastSelectedNode.gnx
    ) {
        this._setBodyLanguage(this._bodyTextDocument, w_language);
    }

}

</t>
<t tx="felix.20220922000450.15">/**
 * * Refresh body states after a small debounced delay.
 */
public debouncedRefreshBodyStates() {
    if (this._bodyStatesTimer) {
        clearTimeout(this._bodyStatesTimer);
    }
    this._bodyStatesTimer = setTimeout(() =&gt; {
        // this.triggerBodySave(true);
        this._bodySaveDocument(this._bodyLastChangedDocument!);
        this.refreshBodyStates();
    }, Constants.BODY_STATES_DEBOUNCE_DELAY);
}

</t>
<t tx="felix.20220922000450.2">/**
 * * Makes sure the body now reflects the selected node.
 * This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_preventTakingFocus Flag used to keep focus where it was instead of forcing in body
 * @returns a text editor of the p_node parameter's gnx (As 'leo' file scheme). Or rejects if interrupted.
 */
private async _tryApplyNodeToBody(
    p_node: Position,
    p_aside: boolean,
    p_preventTakingFocus: boolean,
): Promise&lt;void | vscode.TextEditor&gt; {

    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context

    // if not first time and still opened - also not somewhat exactly opened somewhere.
    if (this._bodyTextDocument &amp;&amp;
        !this._bodyTextDocument.isClosed &amp;&amp;
        !this._locateOpenedBody(p_node.gnx) // COULD NOT LOCATE NEW GNX
    ) {
        // if needs switching by actually having different gnx
        if (utils.leoUriToStr(this.bodyUri) !== p_node.gnx) {
            // * LOCATE OLD GNX FOR PROPER COLUMN
            this._locateOpenedBody(utils.leoUriToStr(this.bodyUri));
            // Make sure any pending changes in old body are applied before switching
            return this._bodyTextDocument.save().then(() =&gt; {
                return this._switchBody(p_aside, p_preventTakingFocus);
            });
        }
    }

    // first time or no body opened
    this.bodyUri = utils.strToLeoUri(p_node.gnx);
    if (this._isBodyVisible() === 0 &amp;&amp; !this.showBodyIfClosed) {
        return Promise.resolve();
    }
    return this.showBody(p_aside, p_preventTakingFocus);
}

</t>
<t tx="felix.20220922000450.3">/**
 * * Close body pane document and change the bodyUri to this.lastSelectedNode's gnx
 * This blocks 'undos' from crossing over
 * @param p_aside From 'Open Aside'.
 * @param p_preventTakingFocus prevents forcing focus on text body.
 */
private _switchBody(
    p_aside: boolean,
    p_preventTakingFocus?: boolean
): Thenable&lt;void | vscode.TextEditor&gt; {
    const w_oldUri: vscode.Uri = this.bodyUri;
    const w_newUri: vscode.Uri = utils.strToLeoUri(this.lastSelectedNode!.gnx);
    const w_newTS = utils.performanceNow();
    const w_visibleCount = this._isBodyVisible();

    this.bodyUri = w_newUri; // New GLOBAL BODY URI

    if (w_visibleCount === 0 &amp;&amp; !this.showBodyIfClosed) {
        return Promise.resolve();
    }

    if (w_visibleCount === 1) {
        this._bodyPreviewMode = this._isBodyPreview(); // recheck in case user double clicked on title
    }

    if (this.lastSelectedNode &amp;&amp; this._bodyPreviewMode &amp;&amp; this._bodyEnablePreview &amp;&amp; w_visibleCount &lt; 2) {

        // just show in same column and delete after
        const q_showBody = this.showBody(p_aside, p_preventTakingFocus);

        if (w_oldUri.fsPath !== this.bodyUri.fsPath) {
            q_showBody.then(() =&gt; {
                const w_tabsToCloseFound: vscode.Tab[] = [];
                let q_lastSecondSaveFound: Thenable&lt;boolean&gt; = Promise.resolve(true);
                vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
                    p_tabGroup.tabs.forEach((p_tab) =&gt; {
                        if (p_tab.input &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri.fsPath === w_oldUri.fsPath
                        ) {
                            // Make sure it's saved AGAIN!!
                            if (
                                p_tab.isDirty &amp;&amp;
                                this._bodyLastChangedDocument &amp;&amp;
                                (p_tab.input as vscode.TabInputText).uri.fsPath === this._bodyLastChangedDocument.uri.fsPath
                            ) {
                                console.log('LAST SECOND SAVE1!'); // TODO : CLEANUP !
                                this._leoFileSystem.preventSaveToLeo = true;
                                this._editorTouched = false;
                                q_lastSecondSaveFound = this._bodyLastChangedDocument.save();
                            }
                            w_tabsToCloseFound.push(p_tab);
                        }
                    });
                });
                if (w_tabsToCloseFound.length) {
                    q_lastSecondSaveFound.then(() =&gt; {
                        vscode.window.tabGroups.close(w_tabsToCloseFound, true);
                    });
                }
                // Remove from potential 'recently opened'
                vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri);

            });
        }
        return q_showBody;
    } else {
        // Close ALL LEO EDITORS first !
        const w_tabsToCloseAll: vscode.Tab[] = [];
        let q_lastSecondSaveAll: Thenable&lt;boolean&gt; = Promise.resolve(true);

        vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
            p_tabGroup.tabs.forEach((p_tab) =&gt; {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
                    w_newUri.fsPath !== (p_tab.input as vscode.TabInputText).uri.fsPath // Maybe useless to check if different!
                ) {

                    if (
                        p_tab.isDirty &amp;&amp;
                        this._bodyLastChangedDocument &amp;&amp;
                        (p_tab.input as vscode.TabInputText).uri.fsPath === this._bodyLastChangedDocument.uri.fsPath
                    ) {
                        console.log('LAST SECOND SAVE2!'); // TODO : CLEANUP !
                        this._leoFileSystem.preventSaveToLeo = true;
                        this._editorTouched = false;
                        q_lastSecondSaveAll = this._bodyLastChangedDocument.save();
                    }

                    w_tabsToCloseAll.push(p_tab);
                }
            });
        });

        let q_closeAll: Thenable&lt;unknown&gt;;
        if (w_tabsToCloseAll.length) {
            q_closeAll = q_lastSecondSaveAll.then(() =&gt; {
                return vscode.window.tabGroups.close(w_tabsToCloseAll, true);
            });

        } else {
            q_closeAll = Promise.resolve();
        }

        // async, so don't wait for this to finish
        if (w_oldUri.fsPath !== w_newUri.fsPath) {
            vscode.commands.executeCommand(
                'vscode.removeFromRecentlyOpened',
                w_oldUri
            );
        }

        return q_closeAll.then(() =&gt; {
            this._bodyPreviewMode = true;
            // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER q_bodyStates &amp; q_showTextDocument
            if (
                // Should the gnx be relevant?  !this.isGnxStillValid(w_newGnx, w_newTS)
                !this.isTsStillValid(w_newTS)
            ) {
                return;
            }
            return this.showBody(p_aside, p_preventTakingFocus);
        });
    }
}

</t>
<t tx="felix.20220922000450.4">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 * @returns true if located and found, false otherwise
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri) === p_gnx
            ) {
                vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
                    if (
                        utils.leoUriToStr(p_textDocument.uri) === p_gnx
                    ) {
                        w_found = true;
                        this._bodyTextDocument = p_textDocument; // vscode.workspace.openTextDocument
                        this._bodyMainSelectionColumn = p_tab.group.viewColumn;
                    }
                });
            }
        });
    });
    return w_found;
}

</t>
<t tx="felix.20220922000450.5">/**
 * * Checks for all tabs if any are 'leoBody' scheme
 * @returns total found
 */
private _isBodyVisible(): number {
    let w_total = 0;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME
            ) {
                w_total++;
            }
        });
    });
    return w_total;
}

</t>
<t tx="felix.20220922000450.6">/**
 * * Checks for all tabs if any are 'leoBody' scheme
 * @returns total found
 */
private _isBodyPreview(): boolean {
    let w_isPreview: boolean = true;
    let w_found: boolean = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME
            ) {
                w_found = true;
                if (!p_tab.isPreview) {
                    w_isPreview = false;
                }
            }
        });
    });
    if (w_found) {
        return w_isPreview;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20220922000450.7">/**
 * * Checks if outline is visible
 * @returns true if either outline is visible
 */
public isOutlineVisible(): boolean {
    return this._leoTreeExView.visible || this._leoTreeView.visible;
}

</t>
<t tx="felix.20220922000450.8">/**
 * * Closes non-existing text-editor body if it doesn't match bodyUri
 * @param p_textEditor the editor to close
 * @returns promise that resolves to true if it closed tabs, false if none were found
 */
private _hideDeleteBody(p_textEditor: vscode.TextEditor): void {
    const w_foundTabs: vscode.Tab[] = [];
    const w_editorFsPath = p_textEditor.document.uri.fsPath;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.fsPath === w_editorFsPath &amp;&amp;
                this.bodyUri.fsPath !== w_editorFsPath // if BODY is now the same, dont hide!
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    // * Make sure the closed/deleted body is not remembered as vscode's recent files!
    vscode.commands.executeCommand(
        'vscode.removeFromRecentlyOpened',
        p_textEditor.document.uri
    );

    if (w_foundTabs.length) {
        vscode.window.tabGroups.close(w_foundTabs, true);
        return;
    }

    return;
}

</t>
<t tx="felix.20220922000450.9">/**
 * * Clears the global 'Preview Mode' flag if the given editor is not in the main body column
 * @param p_editor is the editor to check for is in the same column as the main one
 */
private _checkPreviewMode(p_editor: vscode.TextEditor): void {
    // if selected gnx but in another column
    if (
        p_editor.document.uri.fsPath === this.bodyUri.fsPath &amp;&amp;
        p_editor.viewColumn !== this._bodyMainSelectionColumn
    ) {
        this._bodyPreviewMode = false;
        this._bodyMainSelectionColumn = p_editor.viewColumn;
    }
}

</t>
<t tx="felix.20220922215553.1">/**
 * * Location of focus to be set when current/last command is resolved
 */
export const enum Focus {
    NoChange = 0, // Stays on goto pane, or other current panel.
    Body, // Forces body to appear, refresh leaves focus on body.
    Outline, // Forces outline to appear, refresh leaves focus on Outline.
    Goto
}

</t>
<t tx="felix.20220922235942.1">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 * @returns Thenable from the reveal tree node action, resolves directly if no tree visible
 */
private _revealNode(
    p_leoNode: Position,
    p_options?: { select?: boolean; focus?: boolean; expand?: boolean | number }
): Thenable&lt;void&gt; {
    let w_treeview: vscode.TreeView&lt;Position&gt; | undefined;
    if (this._leoTreeView.visible) {
        w_treeview = this._leoTreeView;
    }
    if (this._leoTreeExView.visible &amp;&amp; this.config.treeInExplorer) {
        w_treeview = this._leoTreeExView;
    }
    if (!w_treeview &amp;&amp; (this.showOutlineIfClosed || (p_options &amp;&amp; p_options.focus))) {
        this.showOutlineIfClosed = false;
        w_treeview = this._lastTreeView;
        if (p_options) {
            p_options.focus = true;
        } else {
            p_options = {
                focus: true,
                select: true
            };
        }
    }
    try {
        if (w_treeview) {
            return w_treeview.reveal(p_leoNode, p_options).then(
                () =&gt; {
                    // ok
                    this._revealNodeRetriedRefreshOutline = false;
                },
                (p_reason) =&gt; {
                    console.log('_revealNode could not reveal. Reason: ', p_reason);

                    if (!this._revealNodeRetriedRefreshOutline) {
                        this._revealNodeRetriedRefreshOutline = true;
                        // Reveal failed. Retry refreshOutline once
                        this._refreshOutline(true, RevealType.RevealSelect);
                    }
                }
            );
        }

    } catch (p_error) {
        console.error("_revealNode error: ", p_error);
        // Retry refreshOutline once
        if (!this._revealNodeRetriedRefreshOutline) {
            this._revealNodeRetriedRefreshOutline = true;
            // Reveal failed. Retry refreshOutline once
            this._refreshOutline(true, RevealType.RevealSelect);
        }
    }
    return Promise.resolve(); // Defaults to resolving even if both are hidden
}

</t>
<t tx="felix.20220923001235.1">/**
 * * Checks timestamp only, if is still the latest lastReceivedNode
  * @param ts timestamp of last time
 */
public isTsStillValid(ts: number): boolean {

    // TODO !
    // if (
    //     this._commandStack.lastReceivedNode &amp;&amp;
    //     this._commandStack.lastReceivedNodeTS &gt; ts &amp;&amp;
    //     (this._commandStack._finalRefreshType.tree || this._commandStack._finalRefreshType.node)
    // ) {
    //     // new commandStack lastReceivedNode, is different and newer and tree/node has to refresh
    //     return false;
    // }

    // also test other sources, and check if command also not started to go back to original gnx
    // by checking if the test above only failed for gnx being the same
    if (
        this._refreshNode &amp;&amp;
        this._lastRefreshNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new _refreshNode is different and newer
        return false;
    }
    if (
        this.lastSelectedNode &amp;&amp;
        this._lastSelectedNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS
        // this._commandStack.lastReceivedNodeTS &lt; this._lastSelectedNodeTS // TODO !
    ) {
        // new lastSelectedNode is different and newer
        return false;
    }
    return true;
}

</t>
<t tx="felix.20220923001725.1">/**
 * * Adds 'do nothing' to the frontend stack and refreshes all parts.
 * @returns Promise back from command's execution, if added on stack, undefined otherwise.
 */
public fullRefresh(): void {
    // Todo : Check if timeout necessary
    setTimeout(() =&gt; {
        this.setupRefresh(
            this.finalFocus,
            {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true,
            }
        );
        this.launchRefresh();
    }, 0);
}

</t>
<t tx="felix.20220923003944.1">/**
 * * Table for converting Leo languages names for the currently opened body pane
 * Used in showBody method of leoUI.ts
 */
public static LANGUAGE_CODES: { [key: string]: string | undefined } = {
    cplusplus: 'cpp',
    md: 'markdown',
    rest: 'restructuredtext',
    rst: 'restructuredtext'
};

</t>
<t tx="felix.20220929001102.1">/**
 * * window.performace.now browser/node crossover utility
 */
export function performanceNow(): number {
    const w_now = process.hrtime();
    const [w_secs, w_nanosecs] = w_now;
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20220930212953.1">/**
 * * Handles the opening of a file in vscode, and check if it's a Leo file to suggest opening options
 * @param p_event The opened document event passed by vscode
 */
private _onDidOpenTextDocument(p_document: vscode.TextDocument): void {
    if (
        this.leoStates.leoReady &amp;&amp;
        (
            p_document.uri.fsPath.toLowerCase().endsWith('.leo') ||
            p_document.uri.fsPath.toLowerCase().endsWith('.leojs')
        )
    ) {
        if (!this._hasShownContextOpenMessage) {
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.RIGHT_CLICK_TO_OPEN);
            this._hasShownContextOpenMessage = true;
        }
    }
}

</t>
<t tx="felix.20220930214434.1">/**
 * * Handle the change of visibility of either goto treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onGotoTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {

    // if (p_explorerView) {
    // } // (Facultative/unused) Do something different if explorer view is used
    // if (p_event.visible) {
    //     this._leoGotoProvider.setLastGotoView(p_explorerView ? this._leoGotoExplorer : this._leoGoto);
    //     // this.refreshGotoPane();  // No need to refresh because no selection needs to be set
    // }
}

</t>
<t tx="felix.20220930214530.1">/**
 * * Handle the change of visibility of either find panel
 * @param p_event The visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onFindViewVisibilityChanged(p_explorerView: boolean): void {
    // * todo
    // if (p_explorerView) {
    //     if (this._findPanelWebviewExplorerView?.visible) {
    //         this._lastFindView = this._findPanelWebviewExplorerView;
    //         this.checkForceFindFocus(false);
    //     }

    // } else {
    //     if (this._findPanelWebviewView?.visible) {
    //         this._lastFindView = this._findPanelWebviewView;
    //         this.checkForceFindFocus(false);

    //     }
    // }
}

</t>
<t tx="felix.20220930214929.1">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * @param p_editor The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by LeoJS itself
 */
private _onActiveEditorChanged(
    p_editor: vscode.TextEditor | undefined,
    p_internalCall?: boolean
): void {
    if (p_editor &amp;&amp; p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (this.bodyUri.fsPath !== p_editor.document.uri.fsPath) {
            this._hideDeleteBody(p_editor);
        }
        this._checkPreviewMode(p_editor);
    }
    if (!p_internalCall) {
        this.triggerBodySave(true); // Save in case edits were pending
    }
    // todo : Bring back status bar item?
    // // * Status flag check
    // if (!p_editor &amp;&amp; this._leoStatusBar.statusBarFlag) {
    //     return;
    //     // this._leoStatusBar.update(false);
    // }
    // // * Status flag check
    // setTimeout(() =&gt; {
    //     if (vscode.window.activeTextEditor) {
    //         this._leoStatusBar.update(
    //             vscode.window.activeTextEditor.document.uri.scheme === Constants.URI_LEO_SCHEME
    //         );
    //     }
    // }, 0);
}

</t>
<t tx="felix.20220930214943.1">/**
 * * Moved a document to another column
 * @param p_columnChangeEvent  event describing the change of a text editor's view column
 */
public _changedTextEditorViewColumn(
    p_columnChangeEvent: vscode.TextEditorViewColumnChangeEvent
): void {
    if (p_columnChangeEvent &amp;&amp; p_columnChangeEvent.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        this._checkPreviewMode(p_columnChangeEvent.textEditor);
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20220930214948.1">/**
 * * Tabbed on another editor
 * @param p_editors text editor array (to be checked for changes in this method)
 */
public _changedVisibleTextEditors(p_editors: readonly vscode.TextEditor[]): void {
    // todo cleanup test log
    if (p_editors &amp;&amp; p_editors.length) {
        // console.log('editors changed visibility', p_editors[0].document, p_editors[0].document.uri.fsPath, p_editors[0].document.uri.scheme);
    }

    if (p_editors &amp;&amp; p_editors.length) {
        // May be no changes - so check length
        p_editors.forEach((p_textEditor) =&gt; {
            if (p_textEditor &amp;&amp; p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
                if (this.bodyUri.fsPath !== p_textEditor.document.uri.fsPath) {
                    this._hideDeleteBody(p_textEditor);
                }
                this._checkPreviewMode(p_textEditor);
            }
        });
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20220930214953.1">/**
 * * Whole window has been minimized/restored
 * @param p_windowState the state of the window that changed
 */
public _changedWindowState(p_windowState: vscode.WindowState): void {
    // no other action
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20220930214959.1">/**
 * * Handles detection of the active editor's selection change or cursor position
 * @param p_event a change event containing the active editor's selection, if any.
 */
private _onChangeEditorSelection(p_event: vscode.TextEditorSelectionChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (p_event.selections.length) {
            this._selectionDirty = true;
            this._selection = p_event.selections[0];
            this._selectionGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20220930215005.1">/**
 * * Handles detection of the active editor's scroll position changes
 * @param p_event a change event containing the active editor's visible range, if any.
 */
private _onChangeEditorScroll(p_event: vscode.TextEditorVisibleRangesChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (p_event.visibleRanges.length) {
            this._scrollDirty = true;
            this._scroll = p_event.visibleRanges[0];
            this._scrollGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20220930215012.1">/**
 * * Handle typing, undos and read-from-file refreshes that was detected as a document change
 * @param p_textDocumentChange Text changed event passed by vscode
 */
private _onDocumentChanged(p_textDocumentChange: vscode.TextDocumentChangeEvent): void {

    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (
        this.lastSelectedNode &amp;&amp;
        p_textDocumentChange.contentChanges.length &amp;&amp;
        p_textDocumentChange.document.uri.scheme === Constants.URI_LEO_SCHEME
    ) {

        // * There was a on a Leo Body by the user OR FROM LEO REFRESH FROM FILE
        this._bodyLastChangedDocument = p_textDocumentChange.document;
        this._bodyLastChangedDocumentSaved = false;
        this._editorTouched = true; // To make sure to transfer content to Leo even if all undone
        this._bodyPreviewMode = false;

        // * If icon should change then do it now (if there's no document edit pending)
        if (
            utils.leoUriToStr(p_textDocumentChange.document.uri) === this.lastSelectedNode.gnx
        ) {
            const w_hasBody = !!p_textDocumentChange.document.getText().length;
            const w_iconChanged = utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody);

            if (!this.leoStates.leoChanged || w_iconChanged) {
                if (this.preventIconChange) {
                    this.preventIconChange = false;
                } else {
                    // Document pane icon needs refresh (changed) and/or outline icon changed
                    this._bodySaveDocument(p_textDocumentChange.document).then(() =&gt; {
                        // todo : Really saved to node, no need to set dirty or hasbody -&gt; Check &amp; test to see if icon changes!
                        // if (this.lastSelectedNode) {
                        //     this.lastSelectedNode.dirty = true;
                        //     this.lastSelectedNode.hasBody = w_hasBody;
                        // }
                        if (w_iconChanged) {
                            // NOT incrementing this.treeID to keep ids intact
                            // NoReveal since we're keeping the same id.
                            this._refreshOutline(false, RevealType.NoReveal);
                        }
                    });
                }

                if (!this.leoStates.leoChanged) {
                    // also refresh document panel (icon may be dirty now)
                    this.refreshDocumentsPane();
                }
            }
        }

        // * If body changed a line with and '@' directive refresh body states
        let w_needsRefresh = false;
        p_textDocumentChange.contentChanges.forEach(p_contentChange =&gt; {
            if (p_contentChange.text.includes('@')) {
                // There may have been an @
                w_needsRefresh = true;
            }
        });

        const w_textEditor = vscode.window.activeTextEditor;

        if (w_textEditor &amp;&amp; p_textDocumentChange.document.uri.fsPath === w_textEditor.document.uri.fsPath) {
            w_textEditor.selections.forEach(p_selection =&gt; {
                // if line starts with @
                let w_line = w_textEditor.document.lineAt(p_selection.active.line).text;
                if (w_line.trim().startsWith('@')) {
                    w_needsRefresh = true;
                }
            });
        }
        if (w_needsRefresh) {
            this.debouncedRefreshBodyStates();
        }

    }
}

</t>
<t tx="felix.20220930215020.1">/**
 * * Capture instance for further calls on find panel webview
 * @param p_panel The panel (usually that got the latest onDidReceiveMessage)
 */
public setFindPanel(p_panel: vscode.WebviewView): void {
    if (p_panel.viewType === "leoFindPanelExplorer") {
        // Explorer find panel
        this._lastFindView = this._findPanelWebviewExplorerView;
        this._findPanelWebviewExplorerView = p_panel;
        this._context.subscriptions.push(
            p_panel.onDidChangeVisibility(() =&gt;
                this._onFindViewVisibilityChanged(true)
            ));
    } else {
        // Leo Pane find panel
        this._findPanelWebviewView = p_panel;
        this._lastFindView = this._findPanelWebviewView;
        this._context.subscriptions.push(
            p_panel.onDidChangeVisibility(() =&gt;
                this._onFindViewVisibilityChanged(false)
            ));
    }
    this.checkForceFindFocus(true);
}

</t>
<t tx="felix.20220930215434.1">/**
 * * Places selection on the required node with a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_frame Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_frame: LeoFrame): void {
    setTimeout(() =&gt; {
        if (this._lastLeoDocuments &amp;&amp; this._lastLeoDocuments.selection.length &amp;&amp; this._lastLeoDocuments.selection[0] === p_frame) {
            // console.log('setDocumentSelection: already selected!');
        } else if (this._lastLeoDocuments &amp;&amp; this._lastLeoDocuments.visible) {
            this._lastLeoDocuments.reveal(p_frame, { select: true, focus: false }).then(
                () =&gt; { }, // Ok
                (p_error) =&gt; {
                    console.log('setDocumentSelection could not reveal');
                }
            );
        }
    }, 0);
}

</t>
<t tx="felix.20220930215533.1"></t>
<t tx="felix.20220930215540.1">/**
 * * highlights the current undo state without disturbing focus
 * @param p_undoNode Node instance in the Leo History view to be the 'selected' one.
 */
private _setUndoSelection(p_undoNode: LeoUndoNode): void {
    if (this._lastLeoUndos &amp;&amp; this._lastLeoUndos.visible) {
        this._lastLeoUndos.reveal(p_undoNode, { select: true, focus: false }).then(
            () =&gt; { }, // Ok - do nothing
            (p_error) =&gt; {
                console.log('setUndoSelection could not reveal');
            }
        );
    }
}

</t>
<t tx="felix.20220930215747.1">/**
 * * Reverts to a particular undo bead state
 */
public async revertToUndo(p_undo: LeoUndoNode): Promise&lt;any&gt; {
    // TODO 
    // if (p_undo.label === 'Unchanged') {
    //     return Promise.resolve();
    // }
    // let action = Constants.LEOBRIDGE.REDO;
    // let repeat = p_undo.beadIndex;
    // if (p_undo.beadIndex &lt;= 0) {
    //     action = Constants.LEOBRIDGE.UNDO;
    //     repeat = (-p_undo.beadIndex) + 1;
    // }
    // const w_package = await this.sendAction(
    //     action,
    //     { repeat: repeat }
    // );
    // this.setupRefresh(
    //     Focus.Outline,
    //     {
    //         tree: true,
    //         body: true,
    //         documents: true,
    //         states: true,
    //         buttons: true,
    //     }
    // );
    // this.launchRefresh();
    // return w_package;

}

</t>
<t tx="felix.20220930222931.1">/**
 * Check if search input should be forced-focused again
 */
public checkForceFindFocus(p_fromInit: boolean): void {
    if (this._findNeedsFocus) {
        setTimeout(() =&gt; {
            let w_panel: vscode.WebviewView | undefined;
            if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
                w_panel = this._findPanelWebviewView;
            } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
                w_panel = this._findPanelWebviewExplorerView;
            }
            if (w_panel) {
                this._findNeedsFocus = false;
                w_panel.webview.postMessage({ type: 'selectFind' });
                return;
            }
        }, 60);

    }
}

</t>
<t tx="felix.20221001002338.1">/**
 * * Public method exposed as 'refreshButtonsPane' setter/getter to refresh the buttons pane
 * Buttons Panel May be refreshed by other services (states service, ...)
 */
private _refreshButtonsPane(): void {
    this._leoButtonsProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20221002011858.1">/**
 * * Closes all visible text editors that have Leo filesystem scheme
 */
function closeLeoTextEditors(): Thenable&lt;unknown&gt; {
    const w_foundTabs: vscode.Tab[] = [];

    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        w_foundTabs.forEach((p_tab) =&gt; {
            if (p_tab.input) {
                vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                vscode.workspace.applyEdit(w_edit);
            }
        });
    } else {
        q_closedTabs = Promise.resolve(true);
    }
    return q_closedTabs;
}

</t>
<t tx="felix.20221002011903.1">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns A promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leojs first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            vscode.window.showInformationMessage(`leojs upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        // todo
        // return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}
</t>
<t tx="felix.20221002124249.1">/**
 * * Opens quickPick minibuffer pallette to choose from all commands in this file's commander
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
public async minibufferHistory(): Promise&lt;unknown&gt; {

    // Wait for _isBusyTriggerSave resolve because the full body save may change available commands
    await this.triggerBodySave(false);
    if (!this._minibufferHistory.length) {
        return Promise.resolve(undefined);
    }
    const w_commandList: vscode.QuickPickItem[] = this._minibufferHistory.map(
        p_command =&gt; { return { label: p_command }; }
    );
    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
        matchOnDetail: true,
    };
    const w_picked = await vscode.window.showQuickPick(w_commandList, w_options);
    return this._doMinibufferCommand(w_picked);
}

</t>
<t tx="felix.20221002124535.1">/**
 * * Perform chosen minibuffer command
 */
private async _doMinibufferCommand(p_picked: vscode.QuickPickItem | undefined): Promise&lt;unknown&gt; {
    // * First check for overridden command: Exit by doing the overridden command
    if (p_picked &amp;&amp;
        p_picked.label &amp;&amp;
        Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]) {
        this._minibufferHistory.push(p_picked.label); // Add to minibuffer history
        return vscode.commands.executeCommand(
            Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]
        );
    }
    // * Ok, it was really a minibuffer command
    if (p_picked &amp;&amp; p_picked.label) {
        // Setup refresh
        this.setupRefresh(Focus.NoChange,
            {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true
            }
        );

        this._minibufferHistory.unshift(p_picked.label); // Add to minibuffer history
        const c = g.app.windowList[this.frameIndex].c;
        const w_commandResult = c.executeMinibufferCommand(p_picked.label);

        if (w_commandResult &amp;&amp; w_commandResult.then) {
            // IS A PROMISE
            (w_commandResult as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
                this.launchRefresh();
            });
        } else {
            this.launchRefresh();
        }
        return Promise.resolve(w_commandResult);
    } else {
        // Canceled
        return Promise.resolve(undefined);
    }
}

</t>
<t tx="felix.20221004234249.1">/**
 * Used mostly for leojsOutline ViewsWelcome content
 */
private _leojsStartupDone: boolean = false;
get leojsStartupDone(): boolean {
    return this._leojsStartupDone;
}
set leojsStartupDone(p_value: boolean) {
    this._leojsStartupDone = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_STARTUP_DONE, p_value);
}

</t>
<t tx="felix.20221005002719.1">function setStartupDoneContext(p_value: boolean): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, Constants.CONTEXT_FLAGS.LEO_STARTUP_DONE, p_value);
}

</t>
<t tx="felix.20221009011653.1">export interface CommandOptions {
    node?: Position, // facultative, precise node onto which the command is run (also see p_keepSelection)
    refreshType: ReqRefresh, // Object containing flags for sections needing to refresh after command ran
    finalFocus: Focus, // final focus placement
    keepSelection?: boolean, // flag to bring back selection on the original node
    isNavigation?: boolean // Navigation commands force-show the body and outline
}

</t>
<t tx="felix.20221009233703.1">/**
 * List of command names for both categories of possible offsets when keeping selection.
 */
public static OLD_POS_OFFSETS = {
    DELETE: ["cut-node", "delete-node"],
    ADD: ["clone-node", "async-paste-node", "async-paste-retaining-clones"]
};

</t>
<t tx="felix.20221026222034.1">public set_focus(commander: Commands, widget: any): void {
    this.focusWidget = widget;
}
</t>
<t tx="felix.20221026222040.1">public get_focus(c: Commands): any {
    return this.focusWidget;
}

</t>
<t tx="felix.20221027153815.1">public widget_name(widget: any): string {
    console.log('UI ASKED FOR WIDGET NAME');
    return "test";

}
</t>
<t tx="felix.20221027155442.1">export const enum LeoGotoNavKey {
    prev = 0,
    next,
    first,
    last
}

</t>
<t tx="felix.20221027155905.1">/**
 * * Goto the next, previous, first or last nav entry via arrow keys in
 */
public navigateNavEntry(p_nav: LeoGotoNavKey): void {
    console.log('TODO : navigateNavEntry');

    // this._leoGotoProvider.navigateNavEntry(p_nav);
}

</t>
<t tx="felix.20221027230322.1">/**
 * * Build all possible strings for undo icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the undo tree view
 */
export function buildUndoIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_UNDO_ACTIVE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_UNDO_ACTIVE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_UNDO),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_UNDO)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_REDO_ACTIVE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_REDO_ACTIVE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_REDO),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_REDO)
        }
    ];
}

</t>
<t tx="felix.20221101220727.1">/**
 * Set filename as description
 */
public refreshDesc(): void {
    let titleDesc = "";

    if (this.leoStates.fileOpenedReady) {

        const s = this.leoStates.leoOpenedFileName;
        const w_filename = s ? utils.getFileFromPath(s) : Constants.UNTITLED_FILE_NAME;
        let w_path = "";
        const n = s ? s.lastIndexOf(w_filename) : -1;
        if (n &gt;= 0 &amp;&amp; n + w_filename.length &gt;= s.length) {
            w_path = s.substring(0, n);
        }
        titleDesc = w_filename + (w_path ? " in " + w_path : '');

        if (this._leoTreeView) {
            this._leoTreeView.description = titleDesc;
        }
        if (this._leoTreeExView) {
            this._leoTreeExView.description = titleDesc;
        }
    }
    if (this._leoTreeView.description === titleDesc) {
        return;
    }
    if (this._leoTreeView) {
        this._leoTreeView.description = titleDesc;
    }
    if (this._leoTreeExView) {
        this._leoTreeExView.description = titleDesc;
    }
}

</t>
<t tx="felix.20221106230554.1">/**
 * Handle a successful find match.
 */
public show_find_success(c: Commands, in_headline: boolean, insert: number, p: Position): void {

    // ? needed ?

    // trace = False and not g.unitTesting
    // if in_headline:
    //     if trace:
    //         g.trace('HEADLINE', p.h)
    //     c.frame.tree.widget.select_leo_node(p)
    //     self.focus_to_head(c, p)  # Does not return.
    // else:
    //     w = c.frame.body.widget
    //     row, col = g.convertPythonIndexToRowCol(p.b, insert)
    //     if trace:
    //         g.trace('BODY ROW', row, p.h)
    //     w.cursor_line = row
    //     self.focus_to_body(c)  # Does not return.
}

</t>
<t tx="felix.20221108222157.1">{
  "command": "leojs.hoistNode",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leojs.hoistSelection",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanHoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leojs.hoistSelectionFromOutline",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanHoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leojs.deHoist",
  "category": "Leojs",
  "title": "De-Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanDehoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leojs.deHoistFromOutline",
  "category": "Leojs",
  "title": "De-Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanDehoist &amp;&amp; !leojsTopHoistChapter",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leojs.chapterNext",
  "category": "Leojs",
  "title": "Chapter Next",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/chapter-next.svg",
    "dark": "resources/dark/chapter-next.svg"
  }
},
{
  "command": "leojs.chapterBack",
  "category": "Leojs",
  "title": "Chapter Back",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/chapter-back.svg",
    "dark": "resources/dark/chapter-back.svg"
  }
},
{
  "command": "leojs.chapterMain",
  "category": "Leojs",
  "title": "Chapter Main",
  "enablement": "leojsTreeOpened &amp;&amp; leojsInChapter &amp;&amp; leojsTopHoistChapter",
  "icon": {
    "light": "resources/light/chapter-main.svg",
    "dark": "resources/dark/chapter-main.svg"
  }
},
{
  "command": "leojs.chapterSelect",
  "category": "Leojs",
  "title": "Chapter Select",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/chapter-select.svg",
    "dark": "resources/dark/chapter-select.svg"
  }
},
</t>
<t tx="felix.20221108224707.1">/**
 * * Selects chapter 'main'
 */
public async chapterMain(): Promise&lt;unknown&gt; {

    this.triggerBodySave(true); // Don't wait for saving to resolve because we're waiting for user input anyways

    this.setupRefresh(Focus.NoChange, { tree: true, body: true, states: true });
    const c = g.app.windowList[this.frameIndex].c;
    const cc = c.chapterController;
    cc.selectChapterByName('main');

    this.launchRefresh();

    return Promise.resolve();
}

</t>
<t tx="felix.20221108224716.1">/**
 * * Opens chapter list for the user to choose a new chapter, or cancel.
 */
public async chapterSelect(): Promise&lt;unknown&gt; {

    this.triggerBodySave(true); // Don't wait for saving to resolve because we're waiting for user input anyways

    const c = g.app.windowList[this.frameIndex].c;
    const cc = c.chapterController;


    const w_chaptersList: vscode.QuickPickItem[] = cc.setAllChapterNames().map(
        (p_chapter) =&gt; { return { label: p_chapter }; }
    );
    // {
    //     label: p_chapter
    // }

    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.SELECT_CHAPTER_PROMPT
    };

    const p_picked = await vscode.window.showQuickPick(w_chaptersList, w_options);

    if (p_picked &amp;&amp; p_picked.label) {
        this.setupRefresh(Focus.NoChange, { tree: true, body: true, states: true });

        cc.selectChapterByName(p_picked.label);
        this.launchRefresh();
    }

    return Promise.resolve(); // Canceled
}

</t>
<t tx="felix.20221112230919.1">"editor/title": [
  {
    "command": "leojs.prev",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.next",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leojs.executeScript",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leojs.extract",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leojs.extractNames",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.importAnyFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.chapterSelect",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@7"
  },
  {
    "command": "leojs.writeDirtyAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leojs.refreshFromDiskSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leojs.showSettingsPage",
    "when": "resourceScheme == leojs",
    "group": "1_leojs@1"
  },
  {
    "command": "leojs.showLogPane",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs@2"
  },
  {
    "command": "leojs.newLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs1@1"
  },
  {
    "command": "leojs.openLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs1@2"
  },
  {
    "command": "leojs.saveLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs1@3"
  },
  {
    "command": "leojs.saveAsLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs1@4"
  },
  {
    "command": "leojs.sortChildrenSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@1"
  },
  {
    "command": "leojs.sortSiblingsSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@2"
  },
  {
    "command": "leojs.promoteSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@3"
  },
  {
    "command": "leojs.demoteSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@4"
  },
  {
    "command": "leojs.cloneNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@1"
  },
  {
    "command": "leojs.cutNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@2"
  },
  {
    "command": "leojs.copyNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@3"
  },
  {
    "command": "leojs.pasteNodeAtSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@4"
  },
  {
    "command": "leojs.pasteNodeAsCloneAtSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@5"
  },
  {
    "command": "leojs.readFileIntoNode",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@2"
  },
  {
    "command": "leojs.writeFileFromNode",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@3"
  },
  {
    "command": "leojs.writeAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@4"
  },
  {
    "command": "leojs.writeDirtyAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@5"
  },
  {
    "command": "leojs.cloneFindAll",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@1"
  },
  {
    "command": "leojs.cloneFindAllFlattened",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@2"
  },
  {
    "command": "leojs.cloneFindMarked",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@3"
  },
  {
    "command": "leojs.cloneFindFlattenedMarked",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@4"
  },
  {
    "command": "leojs.cloneFindParents",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@5"
  },
  {
    "command": "leojs.cloneFindTag",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@6"
  }
],
</t>
<t tx="felix.20221113002623.1">public showSettings(): void {
    // TODO 
    vscode.window.showInformationMessage('TODO: SHOW WELCOME/SETTINGS !');
}
</t>
<t tx="felix.20221113165005.1">"editor/context": [
  {
    "command": "leojs.findVar",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findDef",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.extract",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.extractNames",
    "when": "editorHasSelection &amp;&amp; !editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20221113221607.1">/**
 * * Public method exposed as 'refreshGotoPane' setter/getter to refresh the Goto pane
 * Goto Panel May be refreshed by other services (states service, ...)
 */
private _refreshGotoPane(): void {
    this._leoGotoProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20221113232048.1">{
  "command": "leojs.startSearch",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Start Search"
},
{
  "command": "leojs.findAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find All"
},
{
  "command": "leojs.findNext",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Next"
},
{
  "command": "leojs.findNextFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Next",
  "icon": {
    "light": "resources/light/find-next.svg",
    "dark": "resources/dark/find-next.svg"
  }
},
{
  "command": "leojs.findPrevious",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Previous"
},
{
  "command": "leojs.findPreviousFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Previous",
  "icon": {
    "light": "resources/light/find-previous.svg",
    "dark": "resources/dark/find-previous.svg"
  }
},
{
  "command": "leojs.findVar",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find the var under the cursor"
},
{
  "command": "leojs.findDef",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Definition",
  "title": "Find the def or class under the cursor"
},
{
  "command": "leojs.replace",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace"
},
{
  "command": "leojs.replaceFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace"
},
{
  "command": "leojs.replaceThenFind",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace Then Find"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace Then Find"
},
{
  "command": "leojs.replaceAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace All"
},
{
  "command": "leojs.gotoGlobalLine",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Global Line"
},
{
  "command": "leojs.setFindEverywhereOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Everywhere",
  "title": "Set Find Everywhere Option"
},
{
  "command": "leojs.setFindNodeOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in Node",
  "title": "Set Find in Node Only Option"
},
{
  "command": "leojs.setFindFileOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in External Files",
  "title": "Set Find in External Files Only Option"
},
{
  "command": "leojs.setFindSuboutlineOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in SubOutline",
  "title": "Set Find in SubOutline Only Option"
},
{
  "command": "leojs.toggleFindIgnoreCaseOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Ignore Case",
  "title": "Toggle Find Ignore Case Option"
},
{
  "command": "leojs.toggleFindMarkChangesOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Mark Changes",
  "title": "Toggle Find Mark Changes Option"
},
{
  "command": "leojs.toggleFindMarkFindsOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Mark Finds",
  "title": "Toggle Find Mark Finds Option"
},
{
  "command": "leojs.toggleFindRegexpOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find RegExp",
  "title": "Toggle Find RegExp Option"
},
{
  "command": "leojs.toggleFindWordOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Whole Word",
  "title": "Toggle Find Whole Word Option"
},
{
  "command": "leojs.toggleFindSearchBodyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Search Body",
  "title": "Toggle Find Search Body Option"
},
{
  "command": "leojs.toggleFindSearchHeadlineOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Search Headline",
  "title": "Toggle Find Search Headline Option"
},
{
  "command": "leojs.cloneFindAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cfa",
  "title": "Clone Find All"
},
{
  "command": "leojs.cloneFindAllFlattened",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cff",
  "title": "Clone Find All Flattened"
},
{
  "command": "leojs.cloneFindMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cfam",
  "title": "cfam - Clone Find All Marked Nodes"
},
{
  "command": "leojs.cloneFindFlattenedMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cffm",
  "title": "cffm - Clone Find Flattened Marked"
},
{
  "command": "leojs.cloneFindParents",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCloned",
  "title": "Clone Find Parents"
},
{
  "command": "leojs.cloneFindTag",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cft",
  "title": "Clone Find Tag"
},
</t>
<t tx="felix.20221113232103.1">{
  "command": "leojs.findQuick",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus on Nav tab"
},
{
  "command": "leojs.goAnywhere",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Go Anywhere"
},
{
  "command": "leojs.gotoNavPrev",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Previous Goto Result"
},
{
  "command": "leojs.gotoNavNext",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Next Goto Result"
},
{
  "command": "leojs.gotoNavFirst",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select First Goto Result"
},
{
  "command": "leojs.gotoNavLast",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Last Goto Result"
},
{
  "command": "leojs.findQuickSelected",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Nav search with current selection",
  "icon": {
    "light": "resources/light/find-quick-selected.svg",
    "dark": "resources/dark/find-quick-selected.svg"
  }
},
{
  "command": "leojs.findQuickTimeline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List timeline of nodes in reverse gnx order",
  "icon": {
    "light": "resources/light/find-quick-timeline.svg",
    "dark": "resources/dark/find-quick-timeline.svg"
  }
},
{
  "command": "leojs.findQuickChanged",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List all changed/dirty nodes",
  "icon": {
    "light": "resources/light/find-quick-changed.svg",
    "dark": "resources/dark/find-quick-changed.svg"
  }
},
{
  "command": "leojs.history",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List visited nodes from history",
  "icon": {
    "light": "resources/light/find-quick-history.svg",
    "dark": "resources/dark/find-quick-history.svg"
  }
},
{
  "command": "leojs.markedList",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List all marked nodes",
  "icon": {
    "light": "resources/light/find-quick-marked.svg",
    "dark": "resources/dark/find-quick-marked.svg"
  }
}
</t>
<t tx="felix.20221113232519.1">{
  "command": "leojs.tagChildren",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "title": "Tag Children"
},
{
  "command": "leojs.tagNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Tag Node"
},
{
  "command": "leojs.removeTag",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Tag"
},
{
  "command": "leojs.removeTags",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove All Tags"
},
</t>
<t tx="felix.20221114213948.1">{
  "command": "leojs.importAnyFile",
  "title": "Import File",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/import.svg",
    "dark": "resources/dark/import.svg"
  }
},
{
  "command": "leojs.readFileIntoNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Read File Into Node..."
},
{
  "command": "leojs.exportHeadlines",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Export Outline..."
},
{
  "command": "leojs.flattenOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Flatten Selected Outline..."
},
{
  "command": "leojs.outlineToCweb",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Outline to CWEB..."
},
{
  "command": "leojs.outlineToNoweb",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Outline to Noweb..."
},
{
  "command": "leojs.removeSentinels",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Sentinels..."
},
{
  "command": "leojs.weave",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Weave..."
},
{
  "command": "leojs.writeFileFromNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write File From Node..."
},
</t>
<t tx="felix.20221114220040.1">[CMD.IMPORT_ANY_FILE, () =&gt; p_leoUI.importAnyFile()], // No URL passed from the command definition.
[CMD.READ_FILE_INTO_NODE, () =&gt; p_leoUI.readFileIntoNode()],

[CMD.EXPORT_HEADLINES, () =&gt; p_leoUI.exportHeadlines()],
[CMD.FLATTEN_OUTLINE, () =&gt; p_leoUI.flattenOutline()],
[CMD.OUTLINE_TO_CWEB, () =&gt; p_leoUI.outlineToCweb()],
[CMD.OUTLINE_TO_NOWEB, () =&gt; p_leoUI.outlineToNoweb()],
[CMD.REMOVE_SENTINELS, () =&gt; p_leoUI.removeSentinels()],
[CMD.WEAVE, () =&gt; p_leoUI.weave()],
[CMD.WRITE_FILE_FROM_NODE, () =&gt; p_leoUI.writeFileFromNode()],

</t>
<t tx="felix.20221114222048.1"></t>
<t tx="felix.20221114222048.10">/**
 * * Read file from node
 */
public readFileIntoNode(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {

    // return this._isBusyTriggerSave(true, true)
    //     .then((p_saveResult) =&gt; {
    //         let q_importFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
    //         if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
    //             const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
    //             q_importFile = this.sendAction(
    //                 Constants.LEOBRIDGE.READ_FILE_INTO_NODE,
    //                 { name: w_fixedFilePath }
    //             );
    //         } else {
    //             q_importFile = this._leoFilesBrowser.getImportFileUrls(
    //                 {
    //                     'All files': ['*'],
    //                     'Python files': ['py'],
    //                     'Leo files': ['leo'],
    //                 },
    //                 true,
    //                 "Read File Into Node"
    //             ).then(
    //                 (p_chosenLeoFiles) =&gt; {
    //                     if (p_chosenLeoFiles.length) {
    //                         return this.sendAction(
    //                             Constants.LEOBRIDGE.READ_FILE_INTO_NODE,
    //                             { name: p_chosenLeoFiles[0] }
    //                         );
    //                     } else {
    //                         return Promise.resolve(undefined);
    //                     }
    //                 },
    //                 (p_errorGetFile) =&gt; {
    //                     return Promise.reject(p_errorGetFile);
    //                 }
    //             );
    //         }
    //         return q_importFile;
    //     })
    //     .then(
    //         (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
    //             if (p_importFileResult) {
    //                 this.setupRefresh(
    //                     Focus.NoChange,
    //                     {
    //                         tree: true,
    //                         body: true,
    //                         documents: true,
    //                         // buttons: false,
    //                         states: true,
    //                     }
    //                 );
    //                 return this.launchRefresh();
    //             } else {
    //                 return Promise.resolve(undefined);
    //             }
    //         },
    //         (p_errorImport) =&gt; {
    //             console.log('Rejection for Read a file into a single node file');
    //             return Promise.reject(p_errorImport);
    //         }
    //     );
    return Promise.resolve();
}

</t>
<t tx="felix.20221114222048.2">/**
 * * Import any File(s)
 * No URL passed from the command definition.
 * @param p_leoFileUri is offered for internal use only
 */
public importAnyFile(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    // return this._isBusyTriggerSave(true, true)
    //     .then((p_saveResult) =&gt; {
    //         let q_importFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
    //         if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
    //             const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
    //             // Array of a single filename
    //             q_importFile = this.sendAction(
    //                 Constants.LEOBRIDGE.IMPORT_ANY_FILE,
    //                 { filenames: [w_fixedFilePath] }
    //             );
    //         } else {
    //             q_importFile = this._leoFilesBrowser.getImportFileUrls().then(
    //                 (p_chosenLeoFiles) =&gt; {
    //                     if (p_chosenLeoFiles.length) {
    //                         // Can be multiple files, so array of string is sent
    //                         return this.sendAction(
    //                             Constants.LEOBRIDGE.IMPORT_ANY_FILE,
    //                             { filenames: p_chosenLeoFiles }
    //                         );
    //                     } else {
    //                         return Promise.resolve(undefined);
    //                     }
    //                 },
    //                 (p_errorGetFile) =&gt; {
    //                     return Promise.reject(p_errorGetFile);
    //                 }
    //             );
    //         }
    //         return q_importFile;
    //     })
    //     .then(
    //         (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
    //             if (p_importFileResult) {
    //                 this.setupRefresh(
    //                     Focus.NoChange,
    //                     {
    //                         tree: true,
    //                         body: true,
    //                         documents: true,
    //                         // buttons: false,
    //                         states: true,
    //                     }
    //                 );
    //                 return this.launchRefresh();
    //             } else {
    //                 return Promise.resolve(undefined);
    //             }
    //         },
    //         (p_errorImport) =&gt; {
    //             console.log('Rejection for import file');
    //             return Promise.reject(p_errorImport);
    //         }
    //     );
    return Promise.resolve();
}

</t>
<t tx="felix.20221114222048.3">/**
 * * Export Outline
 * Export all headlines to an external file.
 */
public exportHeadlines(p_exportFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    // return this._isBusyTriggerSave(true, true)
    //     .then((p_saveResult) =&gt; {
    //         if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
    //             return this._leoFilesBrowser.getExportFileUrl(
    //                 "Export Headlines",
    //                 {
    //                     'Text files': ['txt'],
    //                     'All files': ['*'],
    //                 },
    //             );
    //         } else {
    //             vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //             return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //         }
    //     })
    //     .then((p_chosenLeoFile) =&gt; {
    //         if (p_chosenLeoFile.trim()) {

    //             const q_commandResult = this.nodeCommand({
    //                 action: Constants.LEOBRIDGE.EXPORT_HEADLINES,
    //                 node: undefined,
    //                 refreshType: { tree: true, states: true, documents: true },
    //                 finalFocus: Focus.NoChange, // use last
    //                 name: p_chosenLeoFile,
    //             });
    //             if (q_commandResult) {
    //                 return q_commandResult;
    //             } else {
    //                 return Promise.reject('Export Headlines not added on command stack');
    //             }
    //         } else {
    //             // Canceled
    //             return Promise.resolve(undefined);
    //         }
    //     });
    return Promise.resolve();
}


</t>
<t tx="felix.20221114222048.4">/**
 * * Flatten Selected Outline
 * Export the selected outline to an external file.
 * The outline is represented in MORE format.
 */
public flattenOutline(): Thenable&lt;unknown&gt; {

    // return this._isBusyTriggerSave(true, true)
    //     .then((p_saveResult) =&gt; {
    //         if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
    //             return this._leoFilesBrowser.getExportFileUrl(
    //                 "Flatten Selected Outline",
    //                 {
    //                     'Text files': ['txt'],
    //                     'All files': ['*'],
    //                 },
    //             );
    //         } else {
    //             vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //             return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //         }
    //     })
    //     .then((p_chosenLeoFile) =&gt; {
    //         if (p_chosenLeoFile.trim()) {

    //             const q_commandResult = this.nodeCommand({
    //                 action: Constants.LEOBRIDGE.FLATTEN_OUTLINE,
    //                 node: undefined,
    //                 refreshType: { tree: true, states: true, documents: true },
    //                 finalFocus: Focus.NoChange, // use last
    //                 name: p_chosenLeoFile,
    //             });
    //             if (q_commandResult) {
    //                 return q_commandResult;
    //             } else {
    //                 return Promise.reject('Flatten Selected Outline not added on command stack');
    //             }
    //         } else {
    //             // Canceled
    //             return Promise.resolve(undefined);
    //         }
    //     });
    return Promise.resolve();
}

</t>
<t tx="felix.20221114222048.5">/**
 * * Outline To CWEB
 */
public outlineToCweb(): Thenable&lt;unknown&gt; {

    // return this._isBusyTriggerSave(true, true)
    //     .then((p_saveResult) =&gt; {
    //         if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
    //             return this._leoFilesBrowser.getExportFileUrl(
    //                 "Outline To CWEB",
    //                 {
    //                     'CWEB files': ['w'],
    //                     'Text files': ['txt'],
    //                     'All files': ['*'],
    //                 },
    //             );
    //         } else {
    //             vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //             return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //         }
    //     })
    //     .then((p_chosenLeoFile) =&gt; {
    //         if (p_chosenLeoFile.trim()) {

    //             const q_commandResult = this.nodeCommand({
    //                 action: Constants.LEOBRIDGE.OUTLINE_TO_CWEB,
    //                 node: undefined,
    //                 refreshType: { tree: true, states: true, documents: true },
    //                 finalFocus: Focus.NoChange, // use last
    //                 name: p_chosenLeoFile,
    //             });
    //             if (q_commandResult) {
    //                 return q_commandResult;
    //             } else {
    //                 return Promise.reject('Outline To CWEB not added on command stack');
    //             }
    //         } else {
    //             // Canceled
    //             return Promise.resolve(undefined);
    //         }
    //     });
    return Promise.resolve();
}

</t>
<t tx="felix.20221114222048.6">/**
 * * Outline To Noweb
 */
public outlineToNoweb(): Thenable&lt;unknown&gt; {

    // return this._isBusyTriggerSave(true, true)
    //     .then((p_saveResult) =&gt; {
    //         if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
    //             return this._leoFilesBrowser.getExportFileUrl(
    //                 "Outline To Noweb",
    //                 {
    //                     'Noweb files': ['nw'],
    //                     'Text files': ['txt'],
    //                     'All files': ['*'],
    //                 },
    //             );
    //         } else {
    //             vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //             return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //         }
    //     })
    //     .then((p_chosenLeoFile) =&gt; {
    //         if (p_chosenLeoFile.trim()) {

    //             const q_commandResult = this.nodeCommand({
    //                 action: Constants.LEOBRIDGE.OUTLINE_TO_NOWEB,
    //                 node: undefined,
    //                 refreshType: { tree: true, states: true, documents: true },
    //                 finalFocus: Focus.NoChange, // use last
    //                 name: p_chosenLeoFile,
    //             });
    //             if (q_commandResult) {
    //                 return q_commandResult;
    //             } else {
    //                 return Promise.reject('Outline To Noweb not added on command stack');
    //             }
    //         } else {
    //             // Canceled
    //             return Promise.resolve(undefined);
    //         }
    //     });
    return Promise.resolve();
}

</t>
<t tx="felix.20221114222048.7">/**
 * * Remove Sentinels
 */
public removeSentinels(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    // Convert one or more files, replacing the original files while removing any sentinels they contain.

    // return this._isBusyTriggerSave(true, true)
    //     .then((p_saveResult) =&gt; {
    //         let q_importFiles: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
    //         if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
    //             const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
    //             q_importFiles = this.sendAction(
    //                 Constants.LEOBRIDGE.REMOVE_SENTINELS,
    //                 { names: [w_fixedFilePath] }
    //             );
    //         } else {
    //             q_importFiles = this._leoFilesBrowser.getImportFileUrls(
    //                 {
    //                     'Python files': ['py'],
    //                     'All files': ['*'],
    //                     'C/C++ files': ['c', 'cpp', 'h', 'hpp'],
    //                     'Java files': ['java'],
    //                     'Lua files': ['lua'],
    //                     'Pascal files': ['pas'],
    //                 },
    //                 false,
    //                 "Remove Sentinels"
    //             ).then(
    //                 (p_chosenLeoFiles) =&gt; {
    //                     if (p_chosenLeoFiles.length) {
    //                         return this.sendAction(
    //                             Constants.LEOBRIDGE.REMOVE_SENTINELS,
    //                             { names: p_chosenLeoFiles }
    //                         );
    //                     } else {
    //                         return Promise.resolve(undefined);
    //                     }
    //                 },
    //                 (p_errorGetFile) =&gt; {
    //                     return Promise.reject(p_errorGetFile);
    //                 }
    //             );
    //         }
    //         return q_importFiles;
    //     })
    //     .then(
    //         (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
    //             if (p_importFileResult) {
    //                 this.setupRefresh(
    //                     Focus.NoChange,
    //                     {
    //                         tree: true,
    //                         body: true,
    //                         documents: true,
    //                         // buttons: false,
    //                         states: true,
    //                     }
    //                 );
    //                 return this.launchRefresh();
    //             } else {
    //                 return Promise.resolve(undefined);
    //             }
    //         },
    //         (p_errorImport) =&gt; {
    //             console.log('Rejection for Read a file into a single node file');
    //             return Promise.reject(p_errorImport);
    //         }
    //     );
    return Promise.resolve();
}

</t>
<t tx="felix.20221114222048.8">/**
 * * Weave
 * Simulate a literate-programming weave operation by writing the outline to a text file.
 */
public weave(): Thenable&lt;unknown&gt; {

    // return this._isBusyTriggerSave(true, true)
    //     .then((p_saveResult) =&gt; {
    //         if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
    //             return this._leoFilesBrowser.getExportFileUrl(
    //                 "Weave",
    //                 {
    //                     'Text files': ['txt'],
    //                     'All files': ['*'],
    //                 },
    //             );
    //         } else {
    //             vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //             return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //         }
    //     })
    //     .then((p_chosenLeoFile) =&gt; {
    //         if (p_chosenLeoFile.trim()) {

    //             const q_commandResult = this.nodeCommand({
    //                 action: Constants.LEOBRIDGE.WEAVE,
    //                 node: undefined,
    //                 refreshType: { tree: true, states: true, documents: true },
    //                 finalFocus: Focus.NoChange, // use last
    //                 name: p_chosenLeoFile,
    //             });
    //             if (q_commandResult) {
    //                 return q_commandResult;
    //             } else {
    //                 return Promise.reject('Weave not added on command stack');
    //             }
    //         } else {
    //             // Canceled
    //             return Promise.resolve(undefined);
    //         }
    //     });
    return Promise.resolve();
}

</t>
<t tx="felix.20221114222048.9">/**
 * * Write file from node
 */
public writeFileFromNode(): Thenable&lt;unknown&gt; {

    // * If node starts with @read-file-into-node, use the full path name in the headline.
    // * Otherwise, prompt for a file name.

    // if (!this.leoStates.fileOpenedReady || !this.lastSelectedNode) {
    //     vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //     return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    // }

    // const h = this.lastSelectedNode.headline.trimEnd();
    // const tag = '@read-file-into-node';

    // let fileName = '';
    // if (h.startsWith(tag)) {
    //     fileName = h.substring(tag.length).trim();
    // }

    // let q_fileName: Thenable&lt;string&gt;;
    // if (fileName) {
    //     q_fileName = Promise.resolve(fileName);
    // } else {
    //     q_fileName = this._isBusyTriggerSave(true, true)
    //         .then((p_saveResult) =&gt; {
    //             if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
    //                 return this._leoFilesBrowser.getExportFileUrl(
    //                     "Write file from node",
    //                     {
    //                         'All files': ['*'],
    //                         'Python files': ['py'],
    //                         'Leo files': ['leo'],
    //                     },
    //                 );
    //             } else {
    //                 vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //                 return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    //             }
    //         });
    // }

    // return q_fileName.then((p_chosenLeoFile) =&gt; {
    //     if (p_chosenLeoFile.trim()) {

    //         const q_commandResult = this.nodeCommand({
    //             action: Constants.LEOBRIDGE.WRITE_FILE_FROM_NODE,
    //             node: undefined,
    //             refreshType: { tree: true, states: true, documents: true },
    //             finalFocus: Focus.NoChange, // use last
    //             name: p_chosenLeoFile,
    //         });
    //         this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
    //         this._leoStatusBar.update(true, 0, true);
    //         this._addRecentAndLastFile(p_chosenLeoFile.trim());
    //         if (q_commandResult) {
    //             return q_commandResult;
    //         } else {
    //             return Promise.reject('Write File From Node not added on command stack');
    //         }
    //     } else {
    //         // Canceled
    //         return Promise.resolve(undefined);
    //     }
    // });
    return Promise.resolve();
}

</t>
<t tx="felix.20221115214948.1">{
  "command": "leojs.goAnywhere",
  "key": "ctrl+p",
  "mac": "cmd+p",
  "when": "config.leojs.goAnywhereShortcut &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || config.leojs.goAnywhereShortcut &amp;&amp; leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.findNextFromOutline",
  "key": "f3",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/"
},
{
  "command": "leojs.findNext",
  "key": "f3",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.findPreviousFromOutline",
  "key": "f2",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/"
},
{
  "command": "leojs.findPrevious",
  "key": "f2",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replace",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replaceFromOutline",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/"
},
{
  "command": "leojs.replaceThenFind",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/"
},
{
  "command": "leojs.gotoGlobalLine",
  "key": "alt+g",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindFileOnlyOption",
  "key": "ctrl+alt+l",
  "mac": "cmd+alt+l",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20221115220743.1">{
  "command": "leojs.findNextFromOutline",
  "when": "false"
},
{
  "command": "leojs.findPreviousFromOutline",
  "when": "false"
},
{
  "command": "leojs.replaceFromOutline",
  "when": "false"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20221115230034.1">/**
 * * Wrapper of vscode.window.showInputBox to get a user input with simple prompt
 */
public get1Arg(p_options?: vscode.InputBoxOptions | undefined, p_token?: vscode.CancellationToken | undefined): Thenable&lt;string | undefined&gt; {
    return vscode.window.showInputBox(p_options, p_token);
}

</t>
<t tx="felix.20221119204248.1"></t>
<t tx="felix.20221130233817.1">
</t>
<t tx="felix.20221206201231.1">/**
 * * Mimic vscode's CTRL+P to find any position by it's headline
 */
public async goAnywhere(): Promise&lt;unknown&gt; {
    await this.triggerBodySave(false);

    const allPositions: { label: string; description?: string; position?: Position; }[] = [];
    // Options for date to look like : Saturday, September 17, 2016
    const w_dateOptions: Intl.DateTimeFormatOptions = { weekday: "long", year: 'numeric', month: "long", day: 'numeric' };
    const c = g.app.windowList[this.frameIndex].c;

    // 'true' parameter because each position is kept individually for the time the QuickPick control is opened
    for (const p_position of c.all_unique_positions(true)) {

        let w_description = p_position.gnx; // Defaults as gnx.
        const w_gnxParts = w_description.split('.');
        if (w_gnxParts.length === 3 &amp;&amp; w_gnxParts[1].length === 14) {
            // legit 3 part gnx
            const dateString = w_gnxParts[1];
            const w_year = +dateString.substring(0, 4); // unary + operator to convert the strings to numbers.
            const w_month = +dateString.substring(4, 6);
            const w_day = +dateString.substring(6, 8);
            const w_date = new Date(w_year, w_month - 1, w_day);
            w_description = `by ${w_gnxParts[0]} on ${w_date.toLocaleDateString("en-US", w_dateOptions)}`;
        }
        allPositions.push({
            label: p_position.h,
            position: p_position,
            description: w_description
        });

    }
    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.SEARCH_POSITION_BY_HEADLINE
    };

    const p_picked = await vscode.window.showQuickPick(allPositions, w_options);

    if (p_picked &amp;&amp; p_picked.label &amp;&amp; p_picked.position) {
        if (c.positionExists(p_picked.position)) {
            c.selectPosition(p_picked.position);  // set this node as selection
        }
        this.setupRefresh(
            Focus.Body, // Finish in body pane given explicitly because last focus was in input box.
            {
                tree: true,
                body: true,
                // documents: false,
                // buttons: false,
                states: true,
            }
        );
        this.launchRefresh();
    }

    return Promise.resolve(undefined); // Canceled

}

</t>
<t tx="felix.20221207231723.1">{
  "command": "workbench.files.action.collapseExplorerFolders",
  "key": "alt+-",
  "when": "config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == untitled || config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == file || config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; explorerViewletFocus"
},
{
  "command": "workbench.view.extension.leojsView",
  "key": "ctrl+shift+l",
  "when": "config.leojs.activityViewShortcut &amp;&amp; !editorHasSelection &amp;&amp; !inSearchEditor &amp;&amp; focusedView != workbench.view.search"
}
</t>
</tnodes>
</leo_file>
