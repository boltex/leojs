<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="felix.20201208214250.2"><vh>Documentation</vh>
<v t="felix.20201208214319.1"><vh>@clean README.md</vh></v>
<v t="felix.20201208214506.1"><vh>@clean CHANGELOG.md</vh>
<v t="felix.20240622195331.1"><vh>0.2.15</vh></v>
<v t="felix.20240428224613.1"><vh>0.2.14</vh></v>
<v t="foo.20240309205342.1"><vh>0.2.13</vh></v>
<v t="felix.20240122215450.1"><vh>0.2.12</vh></v>
<v t="felix.20240113195919.1"><vh>0.2.11</vh></v>
<v t="felix.20240107181054.1"><vh>0.2.10</vh></v>
<v t="felix.20231224200501.1"><vh>0.2.9</vh></v>
<v t="felix.20240101211218.1"><vh>0.2.8</vh></v>
<v t="felix.20231216233654.1"><vh>0.2.7</vh></v>
<v t="felix.20231221231533.1"><vh>0.2.6</vh></v>
<v t="fil.20231216220210.1"><vh>0.2.5</vh></v>
<v t="felix.20231216170017.1"><vh>0.2.4</vh></v>
<v t="felix.20231216170011.1"><vh>0.2.3</vh></v>
<v t="felix.20231216170008.1"><vh>0.2.2</vh></v>
<v t="felix.20231216165946.1"><vh>0.2.1</vh></v>
<v t="felix.20231216165857.1"><vh>0.2.0</vh></v>
</v>
<v t="felix.20201208224703.1"><vh>@clean CONTRIBUTING.md</vh></v>
<v t="felix.20230330224010.1"><vh>@clean BACKERS.md</vh></v>
</v>
<v t="ekr.20201209145358.1"><vh>VSCode extension</vh>
<v t="felix.20231219233411.1"><vh>Find Panel Webview</vh>
<v t="fil.20240709150317.1"><vh>@clean find-panel/index.html</vh></v>
<v t="felix.20231219233431.1"><vh>@clean find-panel/style.css</vh></v>
<v t="felix.20231219233427.1"><vh>@clean find-panel/main.js</vh></v>
</v>
<v t="felix.20240224165738.1"><vh>Help Panel Webview</vh>
<v t="felix.20240224200656.1"><vh>@clean help-panel/index.html</vh></v>
<v t="felix.20240224165750.1"><vh>@clean help-panel/style.css</vh></v>
<v t="felix.20240224165747.1"><vh>@clean help-panel/main.js</vh></v>
</v>
<v t="felix.20211007213344.1"><vh>@clean src/config.ts</vh>
<v t="felix.20211007213344.2"><vh>class Config</vh>
<v t="felix.20211007213344.3"><vh>getConfig</vh></v>
<v t="felix.20211007213344.5"><vh>setLeojsSettings</vh></v>
<v t="felix.20211007213344.7"><vh>setEnablePreview</vh></v>
<v t="felix.20211007213344.8"><vh>clearCloseEmptyGroups</vh></v>
<v t="felix.20240121143955.1"><vh>setBodyWrap</vh></v>
<v t="felix.20240221212119.1"><vh>removeOldBodyWrap</vh></v>
<v t="felix.20211007213344.10"><vh>checkEnablePreview</vh></v>
<v t="felix.20211007213344.11"><vh>checkCloseEmptyGroups</vh></v>
<v t="felix.20240121003227.1"><vh>checkBodyWrap</vh></v>
<v t="felix.20231127195758.1"><vh>setConfirmBeforeClose</vh></v>
<v t="felix.20211007213344.13"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20201214151326.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20201214151326.2"><vh>class Constants</vh>
<v t="felix.20201214151326.3"><vh>general constants</vh></v>
<v t="felix.20240121004132.1"><vh>suported languages</vh></v>
<v t="felix.20201214151326.4"><vh>workbench interface panels</vh></v>
<v t="felix.20201214151326.5"><vh>user messages</vh></v>
<v t="felix.20211008004139.1"><vh>find panel ids</vh></v>
<v t="felix.20201214151326.6"><vh>at-buttons strings</vh></v>
<v t="felix.20211007214102.1"><vh>configuration keys</vh></v>
<v t="felix.20211007214110.1"><vh>config defaults</vh></v>
<v t="felix.20230905212324.1"><vh>history quickItem</vh></v>
<v t="felix.20201214151326.7"><vh>ask/save buttons</vh></v>
<v t="felix.20201214151326.8"><vh>context flags</vh></v>
<v t="felix.20201214151326.9"><vh>vscode commands</vh></v>
<v t="felix.20220923003944.1"><vh>body language code strings</vh></v>
<v t="felix.20201214151326.10"><vh>commands strings</vh></v>
<v t="felix.20201214151326.11"><vh>leo commands</vh></v>
<v t="felix.20221009233703.1"><vh>keep-selection old position offsets</vh></v>
<v t="felix.20220103222715.1"><vh>minibuffer overridden names</vh></v>
</v>
</v>
<v t="felix.20201208214322.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20201214150149.1"><vh>activate</vh></v>
<v t="felix.20221005002719.1"><vh>setStartupDoneContext</vh></v>
<v t="felix.20220523151725.1"><vh>setScheme</vh></v>
<v t="felix.20220523140004.1"><vh>runLeo</vh></v>
<v t="felix.20201208215619.1"><vh>deactivate</vh></v>
<v t="felix.20221002011903.1"><vh>showWelcomeIfNewer</vh></v>
</v>
<v t="felix.20231224201746.1"><vh>@clean src/helpPanel.ts</vh>
<v t="felix.20231224201802.1"><vh>class HelpPanel</vh></v>
</v>
<v t="felix.20211010192923.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20211010192923.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20211010192923.3"><vh>setNewBodyUriTime</vh></v>
<v t="felix.20221130233817.1"><vh>_setOpenedBodyTime</vh></v>
<v t="felix.20240421175450.1"><vh>cleanupBodies</vh></v>
<v t="felix.20211010192923.4"><vh>fireRefreshFile</vh></v>
<v t="felix.20211010192923.6"><vh>watch</vh></v>
<v t="felix.20211010192923.7"><vh>stat</vh></v>
<v t="felix.20211010192923.8"><vh>readFile</vh></v>
<v t="felix.20211010192923.9"><vh>readDirectory</vh></v>
<v t="felix.20211010192923.10"><vh>createDirectory</vh></v>
<v t="felix.20211010192923.11"><vh>writeFile</vh></v>
<v t="felix.20211010192923.12"><vh>rename</vh></v>
<v t="felix.20211010192923.13"><vh>delete</vh></v>
<v t="felix.20211010192923.14"><vh>copy</vh></v>
<v t="felix.20211010192923.15"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20240401213604.1"><vh>@clean src/leoBodyDetached.ts</vh>
<v t="felix.20240401213604.2"><vh>class LeoBodyDetachedProvider</vh>
<v t="felix.20240401213604.3"><vh>setNewBodyUriTime</vh></v>
<v t="felix.20240401213604.4"><vh>_setOpenedBodyTime</vh></v>
<v t="felix.20240421172320.1"><vh>cleanupDetachedBodies</vh></v>
<v t="felix.20240401213604.5"><vh>fireRefreshFile</vh></v>
<v t="felix.20240401213604.7"><vh>watch</vh></v>
<v t="felix.20240401213604.8"><vh>stat</vh></v>
<v t="felix.20240401213604.9"><vh>readFile</vh></v>
<v t="felix.20240401213604.10"><vh>readDirectory</vh></v>
<v t="felix.20240401213604.11"><vh>createDirectory</vh></v>
<v t="felix.20240401213604.12"><vh>writeFile</vh></v>
<v t="felix.20240401213604.13"><vh>rename</vh></v>
<v t="felix.20240401213604.14"><vh>delete</vh></v>
<v t="felix.20240401213604.15"><vh>copy</vh></v>
<v t="felix.20240401213604.16"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20201208223553.1"><vh>@clean src/leoOutline.ts</vh>
<v t="felix.20201209011931.1"><vh>class LeoOutlineProvider</vh>
<v t="felix.20201209011931.2"><vh>constructor</vh></v>
<v t="felix.20201209011931.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20211003223641.1"><vh>buildId</vh></v>
<v t="felix.20211003233639.1"><vh>incTreeId</vh></v>
<v t="felix.20201209011931.4"><vh>getTreeItem</vh></v>
<v t="felix.20201209011931.5"><vh>getChildren</vh></v>
<v t="felix.20201209011931.6"><vh>getParent</vh></v>
<v t="felix.20220519232002.1"><vh>resolveTreeItem</vh></v>
</v>
<v t="felix.20211201001847.1"><vh>class LeoNode</vh></v>
</v>
<v t="felix.20201214194144.1"><vh>@clean src/leoUI.ts</vh>
<v t="felix.20201214195752.1"><vh>class LeoUI</vh>
<v t="felix.20201214194144.2"><vh>Constructor</vh></v>
<v t="felix.20220201235548.1"><vh>Finish Startup</vh></v>
<v t="felix.20220417215549.1"><vh>makeAllBindings</vh></v>
<v t="felix.20221113002623.1"><vh>showSettings</vh></v>
<v t="felix.20231224193540.1"><vh>put_help</vh></v>
<v t="felix.20240213205001.1"><vh>statusBar</vh></v>
<v t="felix.20231226210919.1"><vh>handleUnl</vh></v>
<v t="felix.20220920001018.1"><vh>Log Pane</vh>
<v t="felix.20220920001018.2"><vh>addLogPaneEntry</vh></v>
<v t="felix.20220920001018.3"><vh>showLogPane</vh></v>
<v t="felix.20220920001202.1"><vh>hideLogPane</vh></v>
</v>
<v t="felix.20201214194144.3"><vh>Document States</vh>
<v t="felix.20201214202058.1"><vh>_triggerGetStates</vh></v>
<v t="felix.20201227230901.1"><vh>_setupNoOpenedLeoDocument</vh></v>
<v t="felix.20201227230912.1"><vh>_setupOpenedLeoDocument</vh></v>
</v>
<v t="felix.20201214194144.5"><vh>UI Change Events</vh>
<v t="felix.20200719025231.24"><vh>_onChangeConfiguration</vh></v>
<v t="felix.20220930212953.1"><vh>_onDidOpenTextDocument</vh></v>
<v t="felix.20201214202625.1"><vh>_onChangeCollapsedState</vh></v>
<v t="felix.20201214202627.1"><vh>_onTreeViewVisibilityChanged</vh></v>
<v t="felix.20201214202631.1"><vh>_onDocTreeViewVisibilityChanged</vh></v>
<v t="felix.20201214202634.1"><vh>_onButtonsTreeViewVisibilityChanged</vh></v>
<v t="felix.20211122230343.1"><vh>_onUndosTreeViewVisibilityChanged</vh></v>
<v t="felix.20220930214530.1"><vh>_onFindViewVisibilityChanged</vh></v>
<v t="felix.20240403174622.1"><vh>_onTabGroupsChanged</vh></v>
<v t="felix.20240403174627.1"><vh>_onTabsChanged</vh></v>
<v t="felix.20220930214929.1"><vh>_onActiveEditorChanged</vh></v>
<v t="felix.20220930214943.1"><vh>_changedTextEditorViewColumn</vh></v>
<v t="felix.20220930214948.1"><vh>_changedVisibleTextEditors</vh></v>
<v t="felix.20220930214953.1"><vh>_changedWindowState</vh></v>
<v t="felix.20220930214959.1"><vh>_onChangeEditorSelection</vh></v>
<v t="felix.20220930215005.1"><vh>_onChangeEditorScroll</vh></v>
<v t="felix.20220930215012.1"><vh>_onDocumentChanged</vh></v>
<v t="felix.20220930215020.1"><vh>setFindPanel</vh></v>
<v t="felix.20221101220727.1"><vh>refreshDesc</vh></v>
<v t="felix.20231127210614.1"><vh>checkConfirmBeforeClose</vh></v>
</v>
<v t="felix.20211204144931.1"><vh>Body Editing</vh>
<v t="felix.20211204144931.2"><vh>triggerBodySave</vh></v>
<v t="felix.20211204144931.3"><vh>_bodySaveSelection</vh></v>
<v t="felix.20211204144931.4"><vh>_bodySaveDocument</vh></v>
<v t="felix.20211204144931.5"><vh>_bodySaveDeactivate</vh></v>
</v>
<v t="felix.20201214194144.4"><vh>Refresh UI</vh>
<v t="felix.20240708214046.1"><vh>safeReveal</vh></v>
<v t="felix.20240708225108.1"><vh>_performReveal</vh></v>
<v t="felix.20240708225127.1"><vh>_handleRevealCompletion</vh></v>
<v t="felix.20220725004247.1"><vh>_setTreeViewTitle</vh></v>
<v t="felix.20201214202118.1"><vh>showOutline</vh></v>
<v t="felix.20211007232334.1"><vh>configTreeRefresh</vh></v>
<v t="felix.20201227155008.1"><vh>_setupRefresh</vh></v>
<v t="felix.20201227014627.1"><vh>_launchRefresh</vh></v>
<v t="felix.20220923001725.1"><vh>fullRefresh</vh></v>
<v t="felix.20240405235538.1"><vh>_refreshDetachedBodies</vh></v>
<v t="felix.20240529234358.1"><vh>showNavResults</vh></v>
<v t="felix.20220923001235.1"><vh>isTsStillValid</vh></v>
<v t="felix.20201222013904.1"><vh>_refreshOutline</vh></v>
<v t="felix.20220922235942.1"><vh>_revealNode</vh></v>
<v t="felix.20201229025520.1"><vh>gotSelectedNode</vh></v>
<v t="felix.20201214202123.1"><vh>_refreshDocumentsPane</vh></v>
<v t="felix.20221001002338.1"><vh>_refreshButtonsPane</vh></v>
<v t="felix.20221113221607.1"><vh>_refreshGotoPane</vh></v>
<v t="felix.20211124223735.1"><vh>_refreshUndoPane</vh></v>
</v>
<v t="felix.20220922000450.1"><vh>Body Pane Management</vh>
<v t="felix.20220922000450.2"><vh>_tryApplyNodeToBody</vh></v>
<v t="felix.20220922000450.3"><vh>_switchBody</vh></v>
<v t="felix.20220922000450.4"><vh>_locateOpenedBody</vh></v>
<v t="felix.20220922000450.5"><vh>_isBodyVisible</vh></v>
<v t="felix.20220922000450.6"><vh>_isBodyPreview</vh></v>
<v t="felix.20240421175315.1"><vh>_checkClosedTabs</vh></v>
<v t="felix.20220922000450.7"><vh>isOutlineVisible</vh></v>
<v t="felix.20240518222453.1"><vh>_hideBodiesUnknownToFileSys</vh></v>
<v t="felix.20220922000450.8"><vh>_hideDeleteBody</vh></v>
<v t="felix.20220922000450.9"><vh>_checkPreviewMode</vh></v>
<v t="felix.20220922000450.10"><vh>closeBody</vh></v>
<v t="felix.20220922000450.11"><vh>cleanupBody</vh></v>
<v t="felix.20220922000450.12"><vh>showBody</vh></v>
<v t="felix.20230112203533.1"><vh>_row_col_pv_dict</vh></v>
<v t="felix.20230112220003.1"><vh>_row_col_wrapper_dict</vh></v>
<v t="felix.20221214003903.1"><vh>_getBodyLanguage</vh></v>
<v t="felix.20220922000450.13"><vh>_setBodyLanguage</vh></v>
<v t="felix.20220922000450.14"><vh>refreshBodyStates</vh></v>
<v t="felix.20220922000450.15"><vh>debouncedRefreshBodyStates</vh></v>
<v t="felix.20240422231239.1"><vh>_refreshCommanderDetachedLanguage</vh></v>
</v>
<v t="felix.20201214194144.6"><vh>Commands</vh>
<v t="felix.20201214202749.1"><vh>selectTreeNode</vh></v>
<v t="felix.20240401145215.1"><vh>openAside</vh></v>
<v t="felix.20201214202755.1"><vh>command</vh></v>
<v t="felix.20201214202757.1"><vh>minibuffer</vh></v>
<v t="felix.20221002124249.1"><vh>_showMinibufferHistory</vh></v>
<v t="felix.20221002124535.1"><vh>_doMinibufferCommand</vh></v>
<v t="felix.20230222212520.1"><vh>_addToMinibufferHistory</vh></v>
<v t="felix.20231029213146.1"><vh>_showHeadlineInputBox</vh></v>
<v t="felix.20201214202759.1"><vh>editHeadline</vh></v>
<v t="felix.20201214202800.1"><vh>insertNode</vh></v>
<v t="felix.20211204181418.1"><vh>_insertAndSetHeadline</vh></v>
</v>
<v t="felix.20211024012536.1"><vh>Clipboard</vh>
<v t="felix.20211212205241.1"><vh>replaceClipboardWith</vh></v>
<v t="felix.20220103203600.1"><vh>asyncGetTextFromClipboard</vh></v>
<v t="felix.20211024012523.1"><vh>getTextFromClipboard</vh></v>
<v t="felix.20240222233600.1"><vh>unlToClipboard</vh></v>
</v>
<v t="felix.20220505215916.1"><vh>Nav</vh>
<v t="felix.20221206201231.1"><vh>goAnywhere</vh></v>
<v t="felix.20220505215916.2"><vh>findQuick</vh></v>
<v t="felix.20220505215916.3"><vh>findQuickSelected</vh></v>
<v t="felix.20220505215916.4"><vh>findQuickTimeline</vh></v>
<v t="felix.20220505215916.5"><vh>findQuickChanged</vh></v>
<v t="felix.20220505215916.6"><vh>findQuickHistory</vh></v>
<v t="felix.20220505215916.7"><vh>findQuick_marked</vh></v>
<v t="felix.20220505215916.8"><vh>showGotoPane</vh></v>
<v t="felix.20220505215916.9"><vh>gotoNavEntry</vh></v>
<v t="felix.20240630150534.1"><vh>revealGotoNavEntry</vh></v>
<v t="felix.20221027155905.1"><vh>navigateNavEntry</vh></v>
</v>
<v t="felix.20220505215924.1"><vh>Search</vh>
<v t="felix.20221227223718.1"><vh>_get_focus</vh></v>
<v t="felix.20220505215924.2"><vh>navEnter</vh></v>
<v t="felix.20220505215924.3"><vh>navTextChange</vh></v>
<v t="felix.20221222003636.1"><vh>navTextClear</vh></v>
<v t="felix.20220505215924.4"><vh>startSearch</vh></v>
<v t="felix.20220930222931.1"><vh>checkForceFindFocus</vh></v>
<v t="felix.20220505215924.7"><vh>find</vh></v>
<v t="felix.20220505215924.9"><vh>replace &amp; replaceThenFind</vh></v>
<v t="felix.20230121211548.1"><vh>interactiveSearch</vh></v>
<v t="felix.20220505215924.12"><vh>setSearchOption</vh></v>
<v t="felix.20240629151624.1"><vh>setGotoContent</vh></v>
<v t="felix.20220505215924.13"><vh>loadSearchSettings</vh></v>
<v t="felix.20220505215924.14"><vh>saveSearchSettings</vh></v>
</v>
<v t="felix.20201214194144.8"><vh>Leo Documents</vh>
<v t="felix.20220930215434.1"><vh>setDocumentSelection</vh></v>
<v t="felix.20230820145332.1"><vh>tabCycle</vh></v>
<v t="felix.20220517002104.1"><vh>newLeoFile</vh></v>
<v t="felix.20201214211830.1"><vh>closeLeoFile</vh></v>
<v t="felix.20201214211832.1"><vh>openLeoFile</vh></v>
<v t="felix.20201214211834.1"><vh>showRecentLeoFiles</vh></v>
<v t="felix.20201214211835.1"><vh>saveAsLeoFile</vh></v>
<v t="felix.20211012233514.1"><vh>saveAsLeoJsFile</vh></v>
<v t="felix.20201214211836.1"><vh>saveLeoFile</vh></v>
<v t="felix.20201214211837.1"><vh>switchLeoFile</vh></v>
<v t="felix.20201214211839.1"><vh>selectOpenedLeoDocument</vh></v>
</v>
<v t="felix.20201214194144.7"><vh>At Buttons</vh>
<v t="felix.20201214211742.1"><vh>clickAtButton</vh></v>
<v t="felix.20220517212706.1"><vh>_handleRClicks</vh></v>
<v t="felix.20220517212718.1"><vh>gotoScript</vh></v>
<v t="felix.20201214211744.1"><vh>removeAtButton</vh></v>
</v>
<v t="felix.20220930215533.1"><vh>Undos</vh>
<v t="felix.20220930215747.1"><vh>revertToUndo</vh></v>
<v t="felix.20220930215540.1"><vh>_setUndoSelection</vh></v>
</v>
<v t="felix.20211030165058.1"><vh>GUI Wrappers &amp; Helpers</vh>
<v t="felix.20220201230041.1"><vh>showLeoIDMessage</vh></v>
<v t="felix.20221106230554.1"><vh>show_find_success</vh></v>
<v t="felix.20220201225503.1"><vh>LeoGui.ensure_commander_visible</vh></v>
<v t="felix.20220201194319.1"><vh>setLeoIDCommand</vh></v>
<v t="felix.20220131235418.1"><vh>getIdFromSetting</vh></v>
<v t="felix.20220131234257.1"><vh>setIdSetting</vh></v>
<v t="felix.20221027153815.1"><vh>widget_name</vh></v>
<v t="felix.20221026222034.1"><vh>set_focus</vh></v>
<v t="felix.20221026222040.1"><vh>get_focus</vh></v>
<v t="felix.20231231203518.1"><vh>getWorkspaceSession</vh></v>
<v t="felix.20231231203533.1"><vh>setWorkspaceSession</vh></v>
<v t="felix.20230109233134.1"><vh>focus_to_body</vh></v>
<v t="felix.20230109233154.1"><vh>focus_to_head</vh></v>
<v t="felix.20221115230034.1"><vh>get1Arg</vh></v>
<v t="felix.20220613164517.1"><vh>runAboutLeoDialog</vh></v>
<v t="felix.20220108211750.1"><vh>runAskOkDialog</vh></v>
<v t="felix.20220109220155.1"><vh>runAskYesNoDialog</vh></v>
<v t="felix.20220516005841.1"><vh>runAskYesNoCancelDialog</vh></v>
<v t="felix.20220107223824.1"><vh>runOpenFileDialog</vh></v>
<v t="felix.20240617225911.1"><vh>runOpenFilesDialog</vh></v>
<v t="felix.20220108211806.1"><vh>runSaveFileDialog</vh></v>
<v t="felix.20231120232158.1"><vh>destroySelf</vh></v>
</v>
</v>
</v>
<v t="felix.20201214151419.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20201214151419.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20201214151419.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20201214151419.4"><vh>getTreeItem</vh></v>
<v t="felix.20201214151419.5"><vh>getChildren</vh></v>
<v t="felix.20201214151419.6"><vh>getParent</vh></v>
</v>
<v t="felix.20201214151425.2"><vh>class LeoButtonNode</vh>
<v t="felix.20201214151425.3"><vh>iconPath</vh></v>
<v t="felix.20201214151425.4"><vh>id</vh></v>
<v t="felix.20201214151425.5"><vh>tooltip</vh></v>
<v t="felix.20201214151425.6"><vh>description</vh></v>
</v>
</v>
<v t="felix.20201214151429.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20201214151429.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20201214151429.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20201214151429.4"><vh>getTreeItem</vh></v>
<v t="felix.20201214151429.5"><vh>getChildren</vh></v>
<v t="felix.20201214151429.6"><vh>getParent</vh></v>
</v>
<v t="felix.20201214151434.2"><vh>class LeoDocumentNode</vh></v>
</v>
<v t="felix.20220505221929.1"><vh>@clean src/leoGoto.ts</vh>
<v t="felix.20220505222045.1"><vh>class LeoGotoProvider</vh></v>
<v t="felix.20220505222101.1"><vh>class LeoGotoNode</vh></v>
</v>
<v t="felix.20211122205011.1"><vh>@clean src/leoUndos.ts</vh>
<v t="felix.20211122205031.1"><vh>class LeoUndosProvider</vh>
<v t="felix.20211122213012.1"><vh>refreshTreeRoot</vh></v>
<v t="felix.20211122213023.1"><vh>getTreeItem</vh></v>
<v t="felix.20211122214230.1"><vh>getChildren</vh></v>
<v t="felix.20211122213037.1"><vh>getParent</vh></v>
<v t="felix.20220520011951.1"><vh>resolveTreeItem</vh></v>
</v>
<v t="felix.20211122212823.1"><vh>class LeoUndoNode</vh></v>
</v>
<v t="felix.20201214151447.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20201214151447.2"><vh>class LeoStates</vh>
<v t="felix.20201214151447.3"><vh>General State Flags</vh>
<v t="felix.20221004234249.1"><vh>leojsStartupDone &amp; helper</vh></v>
<v t="felix.20201214233119.1"><vh>leoReady &amp; helper</vh></v>
<v t="felix.20240303150445.1"><vh>leoIdReady &amp; helper</vh></v>
<v t="felix.20201214151447.4"><vh>fileOpenedReady &amp; helper</vh></v>
<v t="felix.20201214151447.5"><vh>leoOpenedFileName</vh></v>
<v t="felix.20201214151447.6"><vh>leoChanged &amp; helper</vh></v>
<v t="felix.20201214151447.7"><vh>leoCanUndo &amp; helper</vh></v>
<v t="felix.20201214151447.8"><vh>leoCanRedo &amp; helper</vh></v>
<v t="felix.20220508201944.1"><vh>leoCanGoBack &amp; helper</vh></v>
<v t="felix.20220508201944.2"><vh>leoCanGoNext &amp; helper</vh></v>
<v t="felix.20201214151447.9"><vh>leoCanDemote &amp; helper</vh></v>
<v t="felix.20201214151447.10"><vh>leoCanPromote &amp; helper</vh></v>
<v t="felix.20201214151447.11"><vh>leoCanDehoist &amp; helper</vh></v>
<v t="felix.20230403223923.1"><vh>leoTopHoistChapter &amp; helper</vh></v>
<v t="felix.20231030200350.1"><vh>leoEditHeadline &amp; helper</vh></v>
</v>
<v t="felix.20201214151447.12"><vh>Selected Node Flags</vh>
<v t="felix.20201214151447.13"><vh>leoMarked</vh></v>
<v t="felix.20201214151447.14"><vh>leoCloned</vh></v>
<v t="felix.20201214151447.15"><vh>leoDirty</vh></v>
<v t="felix.20201214151447.16"><vh>leoEmpty</vh></v>
<v t="felix.20201214151447.17"><vh>leoChild</vh></v>
<v t="felix.20201214151447.18"><vh>leoAtFile</vh></v>
<v t="felix.20201214151447.19"><vh>leoRoot</vh></v>
</v>
<v t="felix.20201214151447.20"><vh>constructor</vh></v>
<v t="felix.20201214151447.21"><vh>selectedNodeFlags</vh></v>
<v t="felix.20201214151447.22"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20201214151451.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20201214151451.2"><vh>class LeoStatusBar</vh>
<v t="felix.20201214151451.3"><vh>show</vh></v>
<v t="felix.20201214151451.4"><vh>hide</vh></v>
<v t="felix.20201214151451.5"><vh>setString</vh></v>
<v t="felix.20240222220320.1"><vh>setTooltip</vh></v>
<v t="felix.20240223001320.1"><vh>_buildToolTip</vh></v>
<v t="felix.20201214151451.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20201214151451.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20231226205226.1"><vh>@clean src/unlProvider.ts</vh></v>
<v t="felix.20201214154816.1"><vh>@clean src/types.ts</vh>
<v t="felix.20211007213900.1"><vh>ConfigMembers</vh></v>
<v t="felix.20211007213909.1"><vh>ConfigSetting</vh></v>
<v t="felix.20220922215553.1"><vh>Focus</vh></v>
<v t="felix.20201214154816.3"><vh>RevealType</vh></v>
<v t="felix.20201214154816.4"><vh>ReqRefresh</vh></v>
<v t="felix.20221009011653.1"><vh>CommandOptions</vh></v>
<v t="felix.20211010221959.1"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201214154816.7"><vh>LeoPackageStates</vh></v>
<v t="felix.20201214154816.8"><vh>LeoDocument</vh></v>
<v t="felix.20201214154816.9"><vh>LeoButton</vh></v>
<v t="felix.20220505220527.1"><vh>TGotoTypes</vh></v>
<v t="felix.20220505220532.1"><vh>LeoGoto</vh></v>
<v t="felix.20221027155442.1"><vh>LeoGotoNavKey</vh></v>
<v t="felix.20220505220537.1"><vh>LeoSearchScope</vh></v>
<v t="felix.20220505220544.1"><vh>LeoSearchSettings</vh></v>
<v t="felix.20220505220550.1"><vh>LeoGuiFindTabManagerSettings</vh></v>
<v t="felix.20201214154816.10"><vh>Icon</vh></v>
<v t="felix.20220505220619.1"><vh>BodyTimeInfo</vh></v>
<v t="felix.20220505220626.1"><vh>BodyPosition</vh></v>
<v t="felix.20220505220630.1"><vh>BodySelectionInfo</vh></v>
<v t="felix.20201214154816.11"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20201214154816.12"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20201214154816.13"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20201214154816.14"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20201214154816.15"><vh>AskMessageItem</vh></v>
<v t="felix.20201214154816.16"><vh>ChooseDocumentItem</vh></v>
<v t="felix.20220505220706.1"><vh>ChooseRClickItem</vh></v>
<v t="felix.20201214154816.17"><vh>MinibufferCommand</vh></v>
<v t="felix.20240222233803.1"><vh>UnlType</vh></v>
</v>
<v t="felix.20210110210346.1"><vh>@clean src/declarations.d.ts</vh></v>
<v t="felix.20201208224407.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20220929001102.1"><vh>performanceNow</vh></v>
<v t="felix.20240209012442.1"><vh>closeLeoTextEditors</vh></v>
<v t="felix.20240209012451.1"><vh>closeLeoHelpPanels</vh></v>
<v t="felix.20220505225030.1"><vh>uniqueId</vh></v>
<v t="felix.20220505225023.1"><vh>getUniqueId</vh></v>
<v t="felix.20230315215040.1"><vh>getOnce</vh></v>
<v t="felix.20201208224407.2"><vh>padNumber2</vh></v>
<v t="felix.20201208224407.4"><vh>addFileToGlobal</vh></v>
<v t="felix.20201208224407.5"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20201208224407.6"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20201208224407.7"><vh>buildDocumentIconPaths</vh></v>
<v t="felix.20221027230322.1"><vh>buildUndoIconPaths</vh></v>
<v t="felix.20201208224407.8"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20220505225236.1"><vh>buildGotoIconPaths</vh></v>
<v t="felix.20220109180351.1"><vh>convertLeoFiletypes</vh></v>
<v t="felix.20201208224407.10"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20230416212643.1"><vh>getDurationSeconds</vh></v>
<v t="felix.20201208224407.11"><vh>getFileFromPath</vh></v>
<v t="felix.20220201195806.1"><vh>isAlphaNumeric</vh></v>
<v t="felix.20201208224407.12"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20211007214455.1"><vh>isHexColor</vh></v>
<v t="felix.20201208224407.14"><vh>strToLeoUri</vh></v>
<v t="felix.20240401213850.1"><vh>strToLeoDetachedUri</vh></v>
<v t="felix.20201208224407.15"><vh>leoUriToStr</vh></v>
<v t="felix.20201208224407.16"><vh>setContext</vh></v>
</v>
<v t="felix.20220417155704.1"><vh>@clean src/commandBindings.ts</vh>
<v t="felix.20220417155732.1"><vh>makeAllBindings</vh>
<v t="felix.20201214150149.2"><vh>&lt;&lt; Define entries for all commands &gt;&gt;</vh>
<v t="felix.20201214150149.15"><vh>Show UI panes</vh></v>
<v t="felix.20201214150149.3"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20201214150149.4"><vh>Leo File Documents</vh></v>
<v t="felix.20221114220040.1"><vh>Import Export Files</vh></v>
<v t="felix.20201214150149.5"><vh>Headline Editing</vh></v>
<v t="felix.20201214150149.6"><vh>Node Editing</vh></v>
<v t="felix.20201214150149.7"><vh>Tree View Interaction</vh></v>
<v t="felix.20201214150149.8"><vh>Goto Nodes</vh></v>
<v t="felix.20201214150149.9"><vh>Hoisting</vh></v>
<v t="felix.20201214150149.10"><vh>Outline Editing</vh></v>
<v t="felix.20201214150149.11"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214150149.12"><vh>Body Editing</vh></v>
<v t="felix.20201214150149.13"><vh>Move Nodes</vh></v>
<v t="felix.20201214150149.14"><vh>Undo</vh></v>
<v t="felix.20201214150149.16"><vh>Marked Nodes Commands</vh></v>
<v t="felix.20230121212426.1"><vh>History Commands</vh></v>
<v t="felix.20230121212438.1"><vh>Search and Tag Commands</vh></v>
<v t="felix.20201214150149.17"><vh>Clone Find Commands</vh></v>
<v t="felix.20220917013425.1"><vh>Config Set Recommended</vh></v>
</v>
</v>
</v>
<v t="felix.20201214205159.1"><vh>@clean package.json</vh>
<v t="felix.20201214205159.2"><vh>&lt;&lt; contributes &gt;&gt;</vh>
<v t="felix.20211006225245.1"><vh>configuration</vh></v>
<v t="felix.20201214205159.3"><vh>viewsContainers</vh></v>
<v t="felix.20201214205159.4"><vh>views</vh></v>
<v t="felix.20220918234128.1"><vh>languages</vh></v>
<v t="felix.20220918234147.1"><vh>grammars</vh></v>
<v t="felix.20220918234152.1"><vh>snippets</vh></v>
<v t="felix.20201214205159.5"><vh>viewsWelcome</vh></v>
<v t="felix.20240409221347.1"><vh>icons</vh></v>
<v t="felix.20201214205159.6"><vh>commands</vh>
<v t="felix.20201214205159.9"><vh>Show UI Panes</vh></v>
<v t="felix.20201214205159.8"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20201214205159.10"><vh>Leo File Documents</vh></v>
<v t="felix.20221114213948.1"><vh>Import Export Files</vh></v>
<v t="felix.20201214205159.11"><vh>Tree View</vh></v>
<v t="felix.20201214205159.12"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.13"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.14"><vh>Node Editing</vh></v>
<v t="felix.20201214205159.15"><vh>Body Editing</vh></v>
<v t="felix.20201214205159.16"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.17"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.18"><vh>Goto Nodes</vh></v>
<v t="felix.20221108222157.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20201214205159.20"><vh>Undo/Redo</vh></v>
<v t="felix.20221113232048.1"><vh>Search</vh></v>
<v t="felix.20221113232519.1"><vh>Tags</vh></v>
<v t="felix.20221113232103.1"><vh>Nav</vh></v>
</v>
<v t="felix.20201214205159.23"><vh>menus</vh>
<v t="felix.20201214205159.24"><vh>commandPalette</vh>
<v t="felix.20201214205159.42"><vh>Scripting &amp; @Buttons</vh></v>
<v t="felix.20201214205159.44"><vh>Leo File Documents</vh></v>
<v t="felix.20201214205159.45"><vh>Tree View</vh></v>
<v t="felix.20201214205159.46"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.47"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.48"><vh>Node Editing</vh></v>
<v t="felix.20201214205159.49"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.50"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.51"><vh>Goto Nodes</vh></v>
<v t="felix.20201214205159.52"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20221115220743.1"><vh>Search</vh></v>
<v t="felix.20201214205159.53"><vh>Undo/Redo</vh></v>
</v>
<v t="felix.20201214205159.54"><vh>explorer/context</vh></v>
<v t="felix.20221112230919.1"><vh>editor/title</vh></v>
<v t="felix.20221113165005.1"><vh>editor/context</vh></v>
<v t="felix.20201214205159.55"><vh>view/title</vh></v>
<v t="felix.20201214205159.56"><vh>view/item/context</vh>
<v t="felix.20220517202245.1"><vh>leo documents commands</vh></v>
<v t="felix.20201214205159.57"><vh>Headline Editing Hover Icon</vh></v>
<v t="felix.20201214205159.58"><vh>Insert Node Hover Icon</vh></v>
<v t="felix.20201214205159.60"><vh>Outline Editing Hover Icon</vh></v>
<v t="felix.20201214205159.61"><vh>Mark/Unmark Hover Icon</vh></v>
<v t="felix.20201214205159.62"><vh>Tree View Interaction Context Menu</vh></v>
<v t="felix.20201214205159.63"><vh>Hoisting Context Menu</vh></v>
<v t="felix.20201214205159.64"><vh>Leo File Documents Context Menu</vh></v>
<v t="felix.20201214205159.65"><vh>Mark/Unmark Context Menu</vh></v>
<v t="felix.20230305205014.1"><vh>Tagging Context Menu</vh></v>
<v t="felix.20201214205159.66"><vh>Outline Editing Context Menu</vh></v>
<v t="felix.20220517203332.1"><vh>at buttons</vh></v>
<v t="felix.20221213210705.1"><vh>undos</vh></v>
</v>
<v t="felix.20240610234327.1"><vh>file/newFile</vh></v>
</v>
<v t="felix.20201214205159.67"><vh>keybindings</vh>
<v t="felix.20201214205159.68"><vh>Scripting &amp; @Buttons</vh></v>
<v t="felix.20201214205159.69"><vh>Show UI Panes</vh></v>
<v t="felix.20201214205159.70"><vh>Leo File Documents</vh></v>
<v t="felix.20201214205159.71"><vh>Tree View Interaction</vh></v>
<v t="felix.20201214205159.72"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.73"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.74"><vh>Body Editing</vh></v>
<v t="felix.20201214205159.75"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.76"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.77"><vh>Node Editing</vh></v>
<v t="felix.20211117232843.1"><vh>Undo/Redo</vh></v>
<v t="felix.20221115214948.1"><vh>Search</vh></v>
<v t="felix.20201214205159.78"><vh>Goto Nodes</vh></v>
<v t="felix.20221207231723.1"><vh>VSCode Commands</vh></v>
</v>
<v t="felix.20211119001637.1"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="felix.20201214205159.79"><vh>&lt;&lt; scripts &gt;&gt;</vh></v>
<v t="felix.20201214205159.80"><vh>&lt;&lt; devDependencies &gt;&gt;</vh></v>
<v t="felix.20201214205159.81"><vh>&lt;&lt; dependencies &gt;&gt;</vh></v>
</v>
</v>
<v t="felix.20210102000055.1"><vh>Leo</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="felix.20210102000100.1"><vh>Core classes</vh>
<v t="felix.20211018202009.1"><vh>@file src/core/decorators.ts</vh></v>
<v t="felix.20230509194418.1"><vh>@file src/core/idle_time.ts</vh></v>
<v t="felix.20210102012334.1"><vh>@file src/core/leoApp.ts</vh></v>
<v t="felix.20211211234842.1"><vh>@file src/core/leoAtFile.ts</vh></v>
<v t="felix.20230802145823.1"><vh>@file src/core/leoCache.ts</vh></v>
<v t="felix.20220429005433.1"><vh>@file src/core/leoChapters.ts</vh></v>
<v t="felix.20210110222544.1"><vh>@file src/core/leoCommands.ts</vh></v>
<v t="felix.20230430023337.1"><vh>@file src/core/leoCompare.ts</vh></v>
<v t="felix.20211031230132.1"><vh>@file src/core/leoConfig.ts</vh></v>
<v t="felix.20211212162008.1"><vh>@file src/core/leoExternalFiles.ts</vh></v>
<v t="felix.20210220181245.1"><vh>@file src/core/leoFileCommands.ts</vh></v>
<v t="felix.20210102012410.1"><vh>@file src/core/leoGlobals.ts</vh></v>
<v t="felix.20211021231651.1"><vh>@file src/core/leoHistory.ts</vh></v>
<v t="felix.20220105221256.1"><vh>@file src/core/leoImport.ts</vh></v>
<v t="felix.20210102012632.1"><vh>@file src/core/leoNodes.ts</vh></v>
<v t="felix.20230420210348.1"><vh>@file src/core/leoPersistence.ts</vh></v>
<v t="felix.20240103231120.1"><vh>@file src/core/leoPlugins.ts</vh></v>
<v t="felix.20230427003032.1"><vh>@file src/core/leoRst.ts</vh></v>
<v t="felix.20231003002131.1"><vh>@file src/core/leoSessions.ts</vh></v>
<v t="felix.20211212162359.1"><vh>@file src/core/leoShadow.ts</vh></v>
<v t="felix.20211026230613.1"><vh>@file src/core/leoUndo.ts</vh></v>
<v t="felix.20230924174338.1"><vh>@file src/core/mod_scripting.ts</vh></v>
<v t="felix.20221019001448.1"><vh>@file src/core/nodeTags.ts</vh></v>
<v t="felix.20221105221426.1"><vh>@file src/core/quicksearch.ts</vh></v>
</v>
<v t="felix.20211002194716.1"><vh>Command classes</vh>
<v t="felix.20221220233857.1"><vh>@file src/commands/baseCommands.ts</vh></v>
<v t="felix.20240615152154.1"><vh>@file src/commands/bufferCommands.ts</vh></v>
<v t="felix.20220414231314.1"><vh>@file src/commands/commanderEditCommands.ts</vh></v>
<v t="felix.20211017230407.1"><vh>@file src/commands/commanderFileCommands.ts</vh></v>
<v t="felix.20220612234816.1"><vh>@file src/commands/commanderHelpCommands.ts</vh></v>
<v t="felix.20211002221425.1"><vh>@file src/commands/commanderOutlineCommands.ts</vh></v>
<v t="felix.20220503003653.1"><vh>@file src/commands/editCommands.ts</vh></v>
<v t="felix.20211212162627.1"><vh>@file src/commands/editFileCommands.ts</vh></v>
<v t="felix.20231224164322.1"><vh>@file src/commands/helpCommands.ts</vh></v>
<v t="felix.20220503003725.1"><vh>@file src/commands/gotoCommands.ts</vh></v>
<v t="felix.20240612230730.1"><vh>@file src/commands/killBufferCommands.ts</vh></v>
<v t="felix.20240615151733.1"><vh>@file src/commands/rectangleCommands.ts</vh></v>
</v>
<v t="felix.20221119204248.1"><vh>Gui base classes</vh>
<v t="felix.20221109235435.1"><vh>@file src/core/findTabManager.ts</vh></v>
<v t="felix.20211212000140.1"><vh>@file src/core/leoFind.ts</vh></v>
<v t="felix.20220512205042.1"><vh>@file src/core/leoFrame.ts</vh></v>
<v t="felix.20221119204422.1"><vh>@file src/core/leoGui.ts</vh></v>
</v>
<v t="felix.20230505220205.1"><vh>Importer plugins</vh>
<v t="felix.20230522010520.1"><vh>@file src/importers/base_importer.ts</vh></v>
<v t="felix.20230911193725.1"><vh>@file src/importers/c.ts</vh></v>
<v t="felix.20230912201234.1"><vh>@file src/importers/coffeescript.ts</vh></v>
<v t="felix.20230912201323.1"><vh>@file src/importers/csharp.ts</vh></v>
<v t="felix.20230912201336.1"><vh>@file src/importers/cython.ts</vh></v>
<v t="felix.20230912221938.1"><vh>@file src/importers/dart.ts</vh></v>
<v t="felix.20230912223458.1"><vh>@file src/importers/elisp.ts</vh></v>
<v t="felix.20230912223504.1"><vh>@file src/importers/html.ts</vh></v>
<v t="felix.20230912223510.1"><vh>@file src/importers/ini.ts</vh></v>
<v t="felix.20230913212159.1"><vh>@file src/importers/java.ts</vh></v>
<v t="felix.20230911233839.1"><vh>@file src/importers/javascript.ts</vh></v>
<v t="felix.20230913212609.1"><vh>@file src/importers/leo_rst.ts</vh></v>
<v t="felix.20230913224120.1"><vh>@file src/importers/lua.ts</vh></v>
<v t="felix.20230913225656.1"><vh>@file src/importers/markdown.ts</vh></v>
<v t="felix.20230913231752.1"><vh>@file src/importers/org.ts</vh></v>
<v t="felix.20230913231807.1"><vh>@file src/importers/otl.ts</vh></v>
<v t="felix.20230913235814.1"><vh>@file src/importers/pascal.ts</vh></v>
<v t="felix.20230913235829.1"><vh>@file src/importers/perl.ts</vh></v>
<v t="felix.20230913235836.1"><vh>@file src/importers/php.ts</vh></v>
<v t="felix.20230911210454.1"><vh>@file src/importers/python.ts</vh></v>
<v t="felix.20230914002433.1"><vh>@file src/importers/rust.ts</vh></v>
<v t="felix.20230914002711.1"><vh>@file src/importers/tcl.ts</vh></v>
<v t="felix.20230914002938.1"><vh>@file src/importers/treepad.ts</vh></v>
<v t="felix.20230911234728.1"><vh>@file src/importers/typescript.ts</vh></v>
<v t="felix.20230912233339.1"><vh>@file src/importers/xml.ts</vh></v>
</v>
<v t="felix.20230914004301.1"><vh>Writer plugins</vh>
<v t="felix.20230914004349.1"><vh>@file src/writers/basewriter.ts</vh></v>
<v t="felix.20230914011239.1"><vh>@file src/writers/dart.ts</vh></v>
<v t="felix.20230914214929.1"><vh>@file src/writers/leo_rst.ts</vh></v>
<v t="felix.20230914214935.1"><vh>@file src/writers/markdown.ts</vh></v>
<v t="felix.20230914214940.1"><vh>@file src/writers/org.ts</vh></v>
<v t="felix.20230914214945.1"><vh>@file src/writers/otl.ts</vh></v>
<v t="felix.20230914214949.1"><vh>@file src/writers/treepad.ts</vh></v>
</v>
<v t="felix.20220128232146.1"><vh>unittests</vh>
<v t="felix.20220130224933.1"><vh>@file src/test/leoTest2.ts</vh></v>
<v t="felix.20220129002501.1"><vh>@file src/test/extension.test.ts</vh></v>
<v t="felix.20230529171913.1"><vh>@file src/test/test_importers.test.ts</vh></v>
<v t="felix.20230923150253.1"><vh>@file src/test/test_writers.test.ts</vh></v>
<v t="felix.20230715185802.1"><vh>unittest commands</vh>
<v t="felix.20230715191150.1"><vh>@file src/test/leoCommanderFileCommands.test.ts</vh></v>
<v t="felix.20230805122326.1"><vh>@file src/test/leoGotoCommands.test.ts</vh></v>
<v t="felix.20230715191134.1"><vh>@file src/test/leoEditCommands.test.ts</vh></v>
<v t="felix.20230715191137.1"><vh>@file src/test/leoEditFileCommands.test.ts</vh></v>
<v t="felix.20230531185455.1"><vh>@file src/test/leoOutlineCommands.test.ts</vh></v>
</v>
<v t="felix.20230715185809.1"><vh>unittest core</vh>
<v t="felix.20220129200448.1"><vh>@file src/test/leoApp.test.ts</vh></v>
<v t="felix.20220129003133.1"><vh>@file src/test/leoAtFile.test.ts</vh></v>
<v t="felix.20220129002752.1"><vh>@file src/test/leoCommands.test.ts</vh></v>
<v t="felix.20230723005339.1"><vh>@file src/test/leoCompare.test.ts</vh></v>
<v t="felix.20220129003431.1"><vh>@file src/test/leoConfig.test.ts</vh></v>
<v t="felix.20220129003154.1"><vh>@file src/test/leoExternalFiles.test.ts</vh></v>
<v t="felix.20220129003044.1"><vh>@file src/test/leoFileCommands.test.ts</vh></v>
<v t="felix.20220129003458.1"><vh>@file src/test/leoFind.test.ts</vh></v>
<v t="felix.20230528193401.1"><vh>@file src/test/leoFrame.test.ts</vh></v>
<v t="felix.20220129002458.1"><vh>@file src/test/leoGlobals.test.ts</vh></v>
<v t="felix.20220129003526.1"><vh>@file src/test/leoImport.test.ts</vh></v>
<v t="felix.20220129002948.1"><vh>@file src/test/leoNodes.test.ts</vh></v>
<v t="felix.20230528205401.1"><vh>@file src/test/leoPersistence.test.ts</vh></v>
<v t="felix.20230528205401.2"><vh>@file src/test/leoRst.test.ts</vh></v>
<v t="felix.20220129003553.1"><vh>@file src/test/leoShadow.test.ts</vh></v>
<v t="felix.20220129003013.1"><vh>@file src/test/leoUndo.test.ts</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.

</t>
<t tx="ekr.20201209145358.1"></t>
<t tx="felix.20200719025231.24">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {

    if (
        p_event.affectsConfiguration(Constants.CONFIG_NAME)
        // ||
        // p_event.affectsConfiguration('editor.fontSize') ||
        // p_event.affectsConfiguration('window.zoomLevel')
    ) {
        void this.config.setLeoJsSettingsPromise.then(
            () =&gt; {
                this.config.buildFromSavedSettings();
                void this.leoSettingsWebview.changedConfiguration();
                if (
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.INVERT_NODES) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_EDIT) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_ADD) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_MARK) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_CLONE) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_COPY)
                ) {
                    this.configTreeRefresh();
                }
                if (this.config.showUnlOnStatusBar &amp;&amp; this.leoStates.fileOpenedReady &amp;&amp; this._leoStatusBar) {
                    this._leoStatusBar.show();
                }
                if (!this.config.showUnlOnStatusBar &amp;&amp; this._leoStatusBar) {
                    this._leoStatusBar.hide();
                }
                if (p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.LEO_ID)) {
                    void this.setIdSetting(this.config.leoID);
                }
            }
        );
    }

    // also check if workbench.editor.enablePreview
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // Check For specific vscode settings needed for leojs
    // Leave a delay for multiple possible forced changes at startup
    setTimeout(() =&gt; {
        this.config.checkEnablePreview();
        this.config.checkCloseEmptyGroups();
        this.config.checkBodyWrap();
    }, 1500);
}

</t>
<t tx="felix.20201208214250.2"></t>
<t tx="felix.20201208214319.1">@language md
@tabwidth -4
# ![LeoEditor](https://raw.githubusercontent.com/boltex/leojs/master/resources/leoapp.png) Literate Editor with Outline

LeoJS is a javascript implementation of the Leo Editor.

_If you find LeoJS useful, please consider [**sponsoring**](https://boltex.github.io/) it. Also please [write a review](https://marketplace.visualstudio.com/items?itemName=boltex.leojs#review-details 'Write a review') or [star it on GitHub](https://github.com/boltex/leojs 'Star it on GitHub')_

## Literate Programming with _Directed Acyclic Graphs_ ([dag](https://en.wikipedia.org/wiki/Directed_acyclic_graph))

### Break down your code into a structured outline that generates or parses back your source files

&gt; Leo is a fundamentally different way of using and organizing data, programs and scripts.  
&gt; **[📺 Introduction Video](https://www.youtube.com/watch?v=j0eo7SlnnSY)**

# Web-Based Development

LeoJS can be run as a web extension on [VSCode for the web](https://code.visualstudio.com/docs/remote/codespaces#_browserbased-editor). It can edit Leo documents, _.leo, .leojs and .db_, and work with your files directly inside online repositories such as on GitHub and Azure Repos.

## Press the '.' period key from your github repository

To access this browser-based editor, you can go to your repo on github.com and press the _period_&amp;nbsp;&amp;nbsp;"**.**"&amp;nbsp;&amp;nbsp;key.

This **[📺 Demonstration Video](https://www.youtube.com/watch?v=M_mKXSbVGdE)** demonstrates this feature and many use-cases about working in an online repository with LeoJS and VSCode for the web.

&gt; The web extension version of LeoJS cannot open local files: Use the regular desktop LeoJS version to edit local Leo files and projects.

# Features

-   UI controls such as a **Leo Outline** in the explorer view, and as a standalone sidebar, **body pane**, **opened documents selector** along with a **Log Window** [output channel](https://code.visualstudio.com/api/extension-capabilities/common-capabilities#output-channel).
-   **Detached Body Panes**, independent of the selected node, can be opened with the 'Open Aside' command.
-   Keybindings that match those of the Leo editor, including arrow keys behavior for outline keyboard navigation. (Can be turned off with the **'Leo Tree Browsing'** option setting)
-   **Derived files change detection**. See [External Files](#derive-external-files-) below for more details
-   **Scriptable in Javascript and Typescript**. All commands and scripts have easy access to outline structure via a simple Javascript API
-   **'@button' panel** for [creating your own commands with @buttons](https://leo-editor.github.io/leo-editor/tutorial-tips.html#use-button-nodes)
-   **Find panel** that reacts to Leo's typical keybindings, Ctrl+F, F2, F3... when focus is in the outline or body pane
-   **Nav and Tag panel** search controls are integrated in the Find panel
-   **Undo History panel**, showing all actions and allowing going back, or forward, to any undo states.

## Demo videos

-   **[📺 Introduction](https://www.youtube.com/watch?v=j0eo7SlnnSY)**
-   **[📺 Features](https://www.youtube.com/watch?v=M_mKXSbVGdE)**

# Leo Commands

LeoJS offers an extensive set of integrated commands, accessible through a variety of interfaces — toolbar buttons, dedicated menus, and intuitive keybindings. Those commands are also discoverable via the Visual Studio Code Command Palette. (accessible through F1 or Ctrl+Shift+P)

## Context-Aware Keybindings

The keybinding architecture is designed to be context-aware. When your focus is within the LeoJS Body or Outline pane, LeoJS-specific keybindings take precedence. Shift your focus outside these panes, and Visual Studio Code's native keybindings resume control.

## The Minibuffer

For those familiar with Leo, the 'minibuffer' serves as the nerve center for command execution. Access it through Alt+X and use the complete set of Leo's commands!

# Keybindings

Listed here are the most useful commands and their keyboard shortcuts.

| Outline Commands |                                                                  |
| :--------------- | :--------------------------------------------------------------- |
| Undo / Redo      | `Ctrl + Z` &amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp; `Ctrl + Shift + Z`          |
| Insert Node      | `Ctrl + I` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift + Insert`         |
| Insert Child     | `Ctrl + Insert`                                                  |
| Edit Headline    | `Ctrl + H`                                                       |
| Mark / Unmark    | `Ctrl + M`                                                       |
| Copy Node        | `Ctrl + Shift + C`                                               |
| Cut Node         | `Ctrl + Shift + X`                                               |
| Paste Node       | `Ctrl + Shift + V`                                               |
| Delete Node      | `Ctrl + Shift + Backspace` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Delete` |
| Clone Node       | `Ctrl + Backquote`                                               |
| Promote / Demote | `Ctrl + {` &amp;nbsp;&amp;nbsp;_and_&amp;nbsp;&amp;nbsp; `Ctrl + }`              |

| Moving Nodes       |                                                                 |
| :----------------- | :-------------------------------------------------------------- |
| Move Outline Up    | `Ctrl + U` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Up`    |
| Move Outline Down  | `Ctrl + D` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Down`  |
| Move Outline Left  | `Ctrl + L` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Left`  |
| Move Outline Right | `Ctrl + R` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Right` |

_Move-Outline commands need the `Alt` key modifier only when focus is on body pane._

| Changing Focus                  |                                                   |
| :------------------------------ | :------------------------------------------------ |
| Toggle Outline/Body             | `Ctrl + T`                                        |
| Focus on Outline                | `Alt + T`                                         |
| Focus on Body (in any pane)     | `Alt + D` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Ctrl + G` |
| Focus on Body (in Outline pane) | `Tab` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Enter`        |

| Common Operations   |                    |
| :------------------ | :----------------- |
| Contract All        | `Alt + -`          |
| Sort Siblings       | `Alt + A`          |
| Start Search        | `Ctrl + F`         |
| Quick Find Selected | `Ctrl + Shift + F` |
| Find Next           | `F3`               |
| Find Previous       | `F2`               |
| Replace             | `Ctrl + =`         |
| Replace then Find   | `Ctrl + -`         |
| Extract             | `Ctrl + Shift + D` |
| Extract Names       | `Ctrl + Shift + N` |
| Execute Script      | `Ctrl + B`         |
| Minibuffer Palette  | `Alt + X`          |

| Tree Navigation          |                                                              |
| :----------------------- | :----------------------------------------------------------- |
| Show the LeoJS View      | `Ctrl+Shift+L`                                               |
| Go Anywhere              | `Ctrl+P`                                                     |
| Go To First Visible Node | `Home` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + Home`             |
| Go To Last Visible Node  | `End` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + End`               |
| Tree page up/down        | `PgUp / pgDn`                                                |
| Go To Next Clone         | `Alt + N`                                                    |
| Browse Tree              | `Arrow Keys` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + Arrow Keys` |
| Go To Global Line        | `Alt + G`                                                    |

_With the **'Leo Tree Browsing'** setting enabled by default, the arrows, home, end, pageUp/Down keys will change the outline's selection directly. Using tree navigation shortcuts from the body pane (with the `Alt` key modifier) will place focus in the outline._

| File Commands       |                    |
| :------------------ | :----------------- |
| Save Leo Document   | `Ctrl + S`         |
| New Leo Document    | `Ctrl + N`         |
| Open Leo Document   | `Ctrl + O`         |
| Cycle Next Document | `Ctrl + Tab`       |
| Write File Nodes    | `Ctrl + Shift + W` |
| Write Dirty Files   | `Ctrl + Shift + Q` |

---

# External Files

Use either of the **Save Leo Document**, **Write File Nodes** or **Write Dirty Files** commands to derive external files for any type of **@file** nodes.

| @\&lt;file\&gt; Kind | Sentinels | @others | .leo Data | Write Only |
| :------------- | :-------: | :-----: | :-------: | :--------: |
| @asis          |    ❌     |   ❌    |    ✔️     |     ✔️     |
| @auto          |    ❌     |   ✔️    |    ❌     |     ❌     |
| @clean         |    ❌     |   ✔️    |    ✔️     |     ❌     |
| @edit          |    ❌     |   ❌    |    ❌     |     ❌     |
| @file          |    ✔️     |   ✔️    |    ❌     |     ❌     |
| @nosent        |    ❌     |   ✔️    |    ✔️     |     ✔️     |

Leo will detect external file changes, and will ask to either **refresh from disk** or **ignore the changes**.

![Derive files](https://raw.githubusercontent.com/boltex/leojs/master/resources/derived-file.gif)

# Extension Settings

### Open the command palette `Ctrl+Shift+P` and start typing `LeoJS settings` to access its _welcome &amp; settings_ screen

&gt; _(Changes are auto-saved to the user's profile after 0.5 seconds)_

-   Control the visibility of the outline pane in the explorer view.
-   Decide how and when to refresh and synchronize content when external files are modified.
-   Show additional icons on outline nodes (Move, delete, mark, copy, paste...)
-   Choose to either focus on the body pane, or keep focus in the outline when a node is selected.

![Settings](https://raw.githubusercontent.com/boltex/leojs/master/resources/welcome-settings.png)

# Navigating a Leo Document

Arrow keys, home/end, page up/down are used for basic navigation. But in order to **find and goto specific nodes directly**, use the methods described below:

### Goto Anywhere Command

In vscode, the **`Ctrl+P`** shortcut allows you to switch to any project file, but **when the focus is in one of Leo's panels**, the **`Ctrl+P`** keybinding allows you to switch to a node directly by typing (part of) it's headline.

![Goto Anywhere](https://raw.githubusercontent.com/boltex/leojs/master/resources/goto-anywhere.gif)

## Find Panel

With the focus in Leo's outline or body pane, Hit **`Ctrl+F`** to open the Find tab of the _find panel_.

![Find Panel](https://raw.githubusercontent.com/boltex/leojs/master/resources/new-find-panel.png)

Enter your search pattern directly in the **\&lt;find pattern here\&gt;** field. Press **`Enter`** to find the first match starting from your current position.

Hitting **`F3`** repeatedly will find the subsequent matches. (**`F2`** for previous matches)

Using the Nav tab of the _find panel_, (**`Ctrl+Shift+F`** to accesss directly) you can type your search pattern in the **Nav** field instead to see all results appear below. This will show the headlines as you type.

![Find Panel](https://raw.githubusercontent.com/boltex/leojs/master/resources/new-nav-panel-2.png)

Press **`Enter`** to freeze the results and show results also found in **body text of any node**. This will add a snowflake icon ❄️ to the **Nav** field.

![Find Panel](https://raw.githubusercontent.com/boltex/leojs/master/resources/new-nav-panel-3.png)

If you check the **Tag** option, the **Nav** field is then used to find nodes by their tag 🏷 _ua_ (user attribute).

# Undo Panel

&gt; In LeoJS, the undo functionality is a multi-tiered system that segregates structural outline changes from text changes within the body pane. The Undo Panel captures outline alterations as individual 'Undo Beads', independent from VS Code's native text undo states. When focus resides in the body pane, the Undo keybinding triggers VS Code's text-specific undo action. However, once the focus shifts, or a new node is selected, all concurrent text changes coalesce into a single 'Undo Bead' within the Undo Panel. These 'Undo Beads' can then be manipulated either through the Undo Panel or by keybindings, provided the focus is explicitly set on the outline pane. This dual-layer undo architecture enables precise control over both code and structural modifications.

Use the undo / redo icons above the outline or above the undo pane itself. You can also right-click on an undo step to directly switch to that specific state!

![Undo pane](https://raw.githubusercontent.com/boltex/leojs/master/resources/undo-pane.gif)

# Issues

Common issues are listed below. See the repository's [Issues Page](https://github.com/boltex/leojs/issues) to submit issues.

### Linux Keybindings

If you're experiencing trouble with the keyboard shortcuts for
the 'Clone Node' or the 'Promote' and 'Demote' commands,
set **"keyboard.dispatch": "keyCode"** in your vscode settings and restart vscode.
See [Troubleshoot Linux Keybindings](https://github.com/microsoft/vscode/wiki/Keybinding-Issues#troubleshoot-linux-keybindings)
for more information.

### Keybindings Conflicts Resolution

If you have a keybinding conflict for a command that you would like **not** to be resolved by Leo when the focus is on the body pane,
add **`&amp;&amp; resourceScheme != 'leojs'`** to the keybinding's "_when_" condition. (Use **`Ctrl+K Ctrl+S`** in vscode to open the Keyboards Shortcuts panel)

### Move Outline Keyboard Commands

For some users, the **`Alt+[Arrow Keys]`**, **`Ctrl+D`** and **`Ctrl+T`** keybinding are already assigned.

To help with this conflict, tree-browsing, outline-move keyboard commands, and switch focus command will only trigger
with the additional condition of having no text selection in the editor.

So select at least one character to use the previously assigned original keyboard commands, while focus is in the body pane.

&gt; Refer to the [issue tracker](https://github.com/boltex/leojs/issues) page to learn more about the known issues, or to contribute with additional information if you encounter some yourself.

If you would like to modify and build this project yourself, see [CONTRIBUTING.md](./CONTRIBUTING.md) for how to get started.

# Acknowledgments

See Leo, the Literate Editor with Outline, at [leo-editor.github.io/leo-editor](https://leo-editor.github.io/leo-editor/)
or on [github](https://github.com/leo-editor/leo-editor).

### _Thanks to_

-   [Edward K. Ream](https://github.com/edreamleo) creator of the [Leo Editor](https://leo-editor.github.io/leo-editor/)
-   [Eric Amodio](https://github.com/eamodio) for the [welcome screen templates](https://github.com/eamodio/vscode-gitlens/tree/master/src/webviews)
-   [Vitalije Milošević](https://github.com/vitalije) for his contributions and support
-   [Arjan Mossel](https://github.com/ar-jan) for his suggestions and ideas
-   [Thomas Passin](https://github.com/tbpassin) for his contributions and support
-   [Viktor](https://github.com/ranvik14) for his contributions and support
-   [Gaurami](https://github.com/ATikhonov2) for his suggestions, bug reports and support
-   [Kevin Henderson](https://github.com/kghenderson) for his suggestions and support
-   [Ville M. Vainio](https://github.com/vivainio) for his Nav tab original concept
-   [Jacob M. Peck](https://github.com/gatesphere) for his Tags tab original concept
-   [Matt Wilkie](https://github.com/maphew) for his contributions and support

## 🤍 To sponsor, donate or contribute see my [user page 🦁](https://boltex.github.io/)
</t>
<t tx="felix.20201208214322.1">import * as vscode from 'vscode';
import initSqlJs from '../sqlite/sql-wasm-debug';

import * as GitAPI from './git';
import * as GitBaseAPI from './git-base';

import { Constants } from './constants';
import * as path from 'path';
import * as utils from "./utils";
import * as g from './core/leoGlobals';
import { LeoApp, LoadManager } from './core/leoApp';
import { RemoteHubApi } from './remote-hub';
import { SqlJsStatic } from 'sql.js';
process.hrtime = require('browser-process-hrtime'); // Overwrite 'hrtime' of process

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208214506.1">@language md
@tabwidth -4
# Change Log

@others
</t>
<t tx="felix.20201208215619.1">// this method is called when your extension is deactivated
export async function deactivate(): Promise&lt;unknown&gt; {
    if (g.app) {
        for (const c of g.app.commanders()) {
            if (c.exists) {
                await g.app.closeLeoWindow(c.frame, undefined, true);
            }
        }
        // sys.exit(0)
        console.log('leojs extension has been deactivated.');
        return undefined;
    } else {
        console.log('no g.app');
    }
}

</t>
<t tx="felix.20201208223553.1">import * as vscode from 'vscode';
import { Constants } from "./constants";
import { Icon } from './types';
import { LeoUI } from './leoUI';
import * as g from './core/leoGlobals';
import { Position } from './core/leoNodes';

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20201208224407.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { Icon } from "./types";
import { Position } from "./core/leoNodes";

// String and other types/structures helper functions, along with common vscode API calls

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208224407.10">/**
 * * Returns milliseconds between the p_start process.hrtime tuple and p_end (or current call to process.hrtime)
 * @param p_start starting process.hrtime to subtract from p_end or current immediate time
 * @param p_end optional end process.hrtime (or immediate time)
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number], p_end?: [number, number]): number {
    if (!p_end) {
        p_end = process.hrtime();
    }
    const w_secs = p_end[0] - p_start[0];
    const w_nanosecs = p_end[1] - p_start[1];

    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201208224407.11">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20201208224407.12">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: Position, p_newHasBody: boolean): boolean {
    // hasBody can be undefined so force boolean.
    if (!p_node.isDirty() || (!!p_node.bodyString().length === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20201208224407.14">/**
* Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
* @param p_str leo node gnx strings are used to build Uri
* @returns A vscode 'Uri' object
*/
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20201208224407.15">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // For now, just remove the '/' before the path string
    return p_uri.path.substring(1);
}

</t>
<t tx="felix.20201208224407.16">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'leoReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20201208224407.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20201208224407.4">/**
 * * Performs the actual addition into workspaceState context
 * @param p_context Needed to get to vscode workspace storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the workspace storage modification is done
 */
export function addFileToWorkspace(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.workspaceState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.workspaceState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.workspaceState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.workspaceState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201208224407.5">/**
 * * Removes file entry from workspaceState context
 * @param p_context Needed to get to vscode workspace storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the workspace storage modification is done
  */
export function removeFileFromWorkspace(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.workspaceState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.workspaceState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.workspaceState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201208224407.6">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {

            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
        };
    });
}

</t>
<t tx="felix.20201208224407.7">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20201208224407.8">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON_RCLICK),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON_RCLICK)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="felix.20201208224703.1">@language md
@tabwidth -4
# How to install and run the development version

Thanks for trying out the development version of Leojs! :sunglasses: Contributions and pull requests are more than welcome!

## Introduction

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

## Development Version Installation

Make sure you have Node.js and Git installed, then clone the sources and run `npm install` in a terminal to install the remaining development dependencies.

![run extension](https://raw.githubusercontent.com/boltex/leojs/master/resources/run-extension.png)

You can then run the **Run Extension** target, as shown above, in the **Debug View**.

## Web extension version

See [VSCode for the web](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for usage example

## Running Development version as a web extension

&gt; For exact information on this procedure, see [Test your web extension](https://code.visualstudio.com/api/extension-guides/web-extensions#test-your-web-extension-in-vscode.dev).

To try out running as a web extension on vscode.dev, use the following commands:

First, you'll need to [install mkcert](https://github.com/FiloSottile/mkcert#installation).

Then, generate the localhost.pem and localhost-key.pem files into a location you won't lose them (for example $HOME/certs):

```
$ mkdir -p $HOME/certs
$ cd $HOME/certs
$ mkcert -install
$ mkcert localhost
```

Then, from your extension's path, start an HTTP server by running

```
$ npx serve --cors -l 5000 --ssl-cert $HOME/certs/localhost.pem --ssl-key $HOME/certs/localhost-key.pem
```

Finally, open vscode.dev pointing to a github repo, similar to: `https://vscode.dev/github/boltex/testleojs1` and run **Developer: Install Web Extension...** from the Command Palette and paste `https://localhost:5000`

&gt; NOTE: To 'sideload' an extension in order to test it, you have to use VScode for the web from an adress starting with 'vscode.dev' and not 'github.dev' E.g. at https://vscode.dev/github/boltex/testleojs1 not FROM https://github.dev/boltex/testleojs1

# Converting from Python to Typescript

## Useful tricks and common pitfalls

### Raw String

Raw String (prefixed with an 'r') do not exist in js. Except for regex defined with slashes.

Those regex defined with slashes are equivalent to raw strings being compiled into a regex in python.

If raw strings are needed for strings OTHER THAN regex, then the have to be escaped. (\\r, \\n, etc.)

This applies for regular strings and multiline strings.

### Multiline string

Multiline strings can be made with back-ticks "`" .

### Regex 'match' methods

The regexp 'match' method exists in python, but it only matches at the start of the string.

This implies that when the 'match' method is used in js, a caret "^" has to be prefixed onto the regex to match at the start of the string.

### Regex 'end-of-line' and 'm' switch

If a regex uses the '\$' character to match an end-of-line, it needs the 'm' switch if the tested string has '\n' at the end. (is considered multiline)

No need for 'm' switch for a '\$' match if the tested string has no newlines at all.

### For 'in/of' loops

A "for in" loop in python loops over the values which is equivalent to a "for of" loop in js.

Although legal in js, it is NOT equivalent: A "for in" loop in js loops over the keys, not the values.

### Arrays of strings from **spitlines** VS **split('\n')**

Splitlines outputs one less entry if the last one was an empty string!
</t>
<t tx="felix.20201209011931.1">export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;Position&gt; {
    private _onDidChangeTreeData: vscode.EventEmitter&lt;Position | undefined&gt; = new vscode.EventEmitter&lt;Position | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;Position | undefined&gt; = this._onDidChangeTreeData.event;

    public treeId: number = 0; // Starting salt for generated tree node Ids

    @others
}

</t>
<t tx="felix.20201209011931.2">constructor(
    private _icons: Icon[],
    private _leoUI: LeoUI
) {
}

</t>
<t tx="felix.20201209011931.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201209011931.4">public getTreeItem(element: Position): Thenable&lt;LeoOutlineNode&gt; | LeoOutlineNode {

    const w_ui = this._leoUI;

    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (element.hasChildren()) {
        w_collapse = element.isExpanded() ? vscode.TreeItemCollapsibleState.Expanded : vscode.TreeItemCollapsibleState.Collapsed;
    }
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (element.isMarked()) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (element.isAnyAtFileNode()) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (element.isCloned()) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (element._isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    const w_icon: number =
        (+(w_ui.config.invertNodeContrast !== !!element.isDirty()) &lt;&lt; 3) |
        (+element.isCloned() &lt;&lt; 2) |
        (+element.isMarked() &lt;&lt; 1) |
        +element.v.hasBody();

    const w_u = (element.v.u &amp;&amp; Object.keys(element.v.u).length) ? element.v.u : false;
    let desc: string = "";
    // * some smaller grayed-out text accompanying the main label
    if (w_u) {
        const w_uLength = Object.keys(w_u).length;
        if (w_uLength) {
            desc = "\u{1F4CE} (" + w_uLength + ")";
            if (w_u.__node_tags) {
                w_contextValue += Constants.CONTEXT_FLAGS.NODE_TAGS;
                if (w_uLength === 1) {
                    // was only tag, so reset it
                    desc = "";
                } else {
                    desc = desc + " "; // add space
                }
                desc = desc + "\u{1F3F7} (" + Object.keys(w_u.__node_tags).length + ")";
            }
        }
    } else {
        // desc = "id:" + this.id; // ! debug test
        // desc = "gnx:" + this.gnx; // ! debug test
    }

    let w_isSelected = false;
    if (element.__eq__(g.app.windowList[w_ui.frameIndex].c.p)) {
        w_isSelected = true;
    }

    let w_hl: [number, number] = [0, 0];
    if (w_isSelected &amp;&amp; w_ui.findFocusTree) {
        if (w_ui.findHeadlinePosition?.__eq__(element)) {
            w_hl = w_ui.findHeadlineRange;
        }
    }

    const w_leoNode = new LeoOutlineNode(
        { label: element.h, highlights: [w_hl] },
        w_collapse,
        element, // Position
        desc,
        this._icons[w_icon],
        this._buildId(element, w_collapse),
        w_contextValue
    );
    // Check if its the selected node and call signal it to the UI
    if (w_isSelected) {
        w_ui.gotSelectedNode(element);
    }
    // Build a LeoNode (a vscode tree node) from the Position
    return w_leoNode;
}

</t>
<t tx="felix.20201209011931.5">public getChildren(element?: Position): Position[] {
    if (!this._leoUI.leoStates.fileOpenedReady) {
        return [];
    }
    if (element) {
        return [...element.children()];
    } else {
        if (g.app.windowList[this._leoUI.frameIndex]) {
            // Currently Selected Document's Commander
            const w_c = g.app.windowList[this._leoUI.frameIndex].c;
            if (w_c.hoistStack.length) {
                // HOISTED: Topmost hoisted node starts the outline as single root 'child'
                const w_rootPosition = w_c.hoistStack[w_c.hoistStack.length - 1].p;
                w_rootPosition._isRoot = true;
                return [w_rootPosition];
            } else {
                // NOT HOISTED: Normal list of root nodes
                const w_rootNodes = [...w_c.all_Root_Children()];
                if (w_rootNodes.length === 1) {
                    // Exactly one: prevent hoisting on SINGLE top node
                    w_rootNodes[0]._isRoot = true;
                }
                return w_rootNodes;
            }
        } else {
            return []; // Attempted to access un-existent frame
        }
    }
}

</t>
<t tx="felix.20201209011931.6">public getParent(element: Position): vscode.ProviderResult&lt;Position&gt; {
    if (element) {
        const p_parent = element.parent();
        const w_c = g.app.windowList[this._leoUI.frameIndex].c;
        if (w_c.hoistStack &amp;&amp; w_c.hoistStack.length) {
            const topHoistPos = w_c.hoistStack[w_c.hoistStack.length - 1].p;
            if (element.__eq__(topHoistPos) || p_parent.__eq__(topHoistPos)) {
                return undefined;
            }
        }
        if (p_parent.v) {
            return p_parent;
        } else {
            return undefined;
        }
    }
    return undefined;
}

</t>
<t tx="felix.20201214150149.1">/**
 * Entry point for Leo in Javascript. 
 * @returns Leo’s leo.core.leoGlobals containing many useful functions, including g.es.
 */
export async function activate(p_context: vscode.ExtensionContext): Promise&lt;typeof g&gt; {

    /*
        * Original Leo startup *

        g.app = leoApp.LeoApp()
        g.app.loadManager = leoApp.LoadManager()
        g.app.loadManager.load(fileName, pymacs)
    */

    (g.extensionContext as vscode.ExtensionContext) = p_context; // Useful for accessing workspace storage or other utilities.
    (g.extensionUri as vscode.Uri) = p_context.extensionUri; // Useful for accessing files in extension package itself.

    const w_leojsExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leojsVersion = w_leojsExtension.packageJSON.version;
    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);

    // * Close remaining Leo Bodies and help panels restored by vscode from last session.
    await utils.closeLeoTextEditors();
    await utils.closeLeoHelpPanels();

    // * Show a welcome screen on version updates, then start the actual extension.
    void showWelcomeIfNewer(w_leojsVersion, w_previousVersion)
        .then(() =&gt; {
            void p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leojsVersion);
        });

    if (!g.app) {
        (g.app as LeoApp) = new LeoApp();

        const gitExtension = vscode.extensions.getExtension&lt;GitAPI.GitExtension&gt;('vscode.git');
        if (gitExtension) {
            await gitExtension.activate();
            try {
                (g.gitAPI as GitAPI.API) = gitExtension.exports.getAPI(1);
            } catch (e) {
                console.log("LEOJS ERROR : GIT EXTENSION NOT INSTALLED !");
            }
        } else {
            // console.log("LEOJS ERROR : GIT EXTENSION NOT AVAILABLE !");
        }

        const gitBaseExtension = vscode.extensions.getExtension&lt;GitBaseAPI.GitBaseExtension&gt;('vscode.git-base');
        if (gitBaseExtension) {
            await gitBaseExtension.activate();
            try {
                (g.gitBaseAPI as GitBaseAPI.API) = gitBaseExtension.exports.getAPI(1);
              } catch (e) {
                console.log("LEOJS ERROR : GIT_BASE EXTENSION NOT INSTALLED !");
            }
        } else {
            // console.log("LEOJS ERROR : GIT_BASE EXTENSION NOT AVAILABLE !");
        }

        const extension = vscode.extensions.getExtension&lt;RemoteHubApi&gt;('ms-vscode.remote-repositories')
            ?? vscode.extensions.getExtension&lt;RemoteHubApi&gt;('GitHub.remoteHub')
            ?? vscode.extensions.getExtension&lt;RemoteHubApi&gt;('GitHub.remoteHub-insiders');

        if (extension == null) {
            // console.log("LEOJS ERROR : GIT_REMOTE EXTENSION NOT AVAILABLE !");
        }
        if (extension) {
            const api = extension.isActive ? extension.exports : await extension.activate();
            (g.remoteHubAPI as RemoteHubApi) = api;
        }

        // console.log('SQL start');
        const sqliteBits = await vscode.workspace.fs.readFile(
            vscode.Uri.joinPath(p_context.extensionUri, 'sqlite', 'sql-wasm-debug.wasm')
        );

        (g.SQL as SqlJsStatic) = await initSqlJs(undefined, sqliteBits);;

    } else {
        void vscode.window.showWarningMessage("g.app leojs application instance already exists!");
    }

    p_context.subscriptions.push(
        vscode.workspace.onDidChangeWorkspaceFolders((p_event =&gt; setScheme(p_event, p_context)))
    );

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders.length) {
        (g.workspaceUri as vscode.Uri) = vscode.workspace.workspaceFolders[0].uri;
    }

    if (!g.isBrowser) {
        await runLeo(p_context);
    } else {
        // Web Browser Extension: Check for type of workspace opened first
        if (g.workspaceUri) {

            if (!vscode.workspace.fs.isWritableFileSystem(g.workspaceUri.scheme)) {
                // NOTE : ! THIS RETURNS FALSE POSITIVES ! 
                console.log('NOT WRITABLE WORKSPACE: FALSE POSITIVE?');
            }

            // Check if not file scheme : only virtual workspaces are suported if g.isBrowser is true.
            if (g.workspaceUri.scheme !== 'file') {
                await runLeo(p_context);
            } else {
                // Is local filesystem
                void vscode.window.showInformationMessage(
                    "LeoJS in browser supports remote virtual filesystems: Local Filesystem requires desktop VSCode application: ", 
                    "More Info"
                ).then(selection =&gt; {
                    if (selection === "More Info") {
                        vscode.env.openExternal(
                            vscode.Uri.parse('https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project')
                        ).then(() =&gt; { }, (e) =&gt; {
                            console.error('LEOJS: Could not open external vscode help URL in browser.', e);
                        });
                    }
                });
                console.log('NOT started because no remote workspace yet');
                void setStartupDoneContext(true);
                return g;
            }
        } else {
            console.log('NOT started because no remote workspace yet');
            void setStartupDoneContext(true);
        }

    }
    return g;
}

</t>
<t tx="felix.20201214150149.10">[CMD.INSERT, (p_node: Position) =&gt; p_leoUI.insertNode(p_node, true, false)],
[CMD.INSERT_SELECTION, () =&gt; p_leoUI.insertNode(U, false, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; p_leoUI.insertNode(U, true, false)],

[CMD.INSERT_CHILD, (p_node: Position) =&gt; p_leoUI.insertNode(p_node, true, true)],
[CMD.INSERT_CHILD_SELECTION, () =&gt; p_leoUI.insertNode(U, false, true)],
[CMD.INSERT_CHILD_SELECTION_FO, () =&gt; p_leoUI.insertNode(U, true, true)],

[CMD.CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.PROMOTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PROMOTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.PROMOTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.DEMOTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.DEMOTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.DEMOTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.SORT_CHILDREN, () =&gt; p_leoUI.command(LEOCMD.SORT_CHILDREN, { refreshType: REFRESH_TREE, finalFocus: Focus.Body, keepSelection: true })],
[CMD.SORT_SIBLING, () =&gt; p_leoUI.command(LEOCMD.SORT_SIBLINGS, { refreshType: REFRESH_TREE, finalFocus: Focus.Body, keepSelection: true })],
[CMD.SORT_SIBLING_FO, () =&gt; p_leoUI.command(LEOCMD.SORT_SIBLINGS, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],

</t>
<t tx="felix.20201214150149.11">[CMD.MARK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MARK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MARK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.UNMARK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.UNMARK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.UNMARK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.UNMARK_ALL, () =&gt; p_leoUI.command(LEOCMD.UNMARK_ALL, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.12">[CMD.EXTRACT, () =&gt; p_leoUI.command(LEOCMD.EXTRACT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.EXTRACT_NAMES, () =&gt; p_leoUI.command(LEOCMD.EXTRACT_NAMES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

</t>
<t tx="felix.20201214150149.13">[CMD.MOVE_DOWN, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_DOWN_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_LEFT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_LEFT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_RIGHT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_UP, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_UP_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.14">[CMD.REDO, () =&gt; p_leoUI.command(LEOCMD.REDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.REDO_FO, () =&gt; p_leoUI.command(LEOCMD.REDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.UNDO, () =&gt; p_leoUI.command(LEOCMD.UNDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.UNDO_FO, () =&gt; p_leoUI.command(LEOCMD.UNDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.REVERT_TO_UNDO, (p_undo: LeoUndoNode) =&gt; p_leoUI.revertToUndo(p_undo)],

</t>
<t tx="felix.20201214150149.15">[CMD.SHOW_WELCOME, () =&gt; p_leoUI.showSettings()],
[CMD.SHOW_SETTINGS, () =&gt; p_leoUI.showSettings()],
[CMD.SHOW_OUTLINE, () =&gt; p_leoUI.showOutline(true)], // Also focuses on outline
[CMD.SHOW_LOG, () =&gt; p_leoUI.showLogPane()],
[CMD.SHOW_BODY, () =&gt; p_leoUI.showBody(false, undefined)], // Also focuses on body
</t>
<t tx="felix.20201214150149.16">[CMD.COPY_MARKED, () =&gt; p_leoUI.command(LEOCMD.COPY_MARKED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DIFF_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.DIFF_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MARK_CHANGED_ITEMS, () =&gt; p_leoUI.command(LEOCMD.MARK_CHANGED_ITEMS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MARK_SUBHEADS, () =&gt; p_leoUI.command(LEOCMD.MARK_SUBHEADS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.CLONE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.CLONE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DELETE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.DELETE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MOVE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.MOVE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.17">[CMD.CLONE_FIND_TAG, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_TAG, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.CLONE_FIND_PARENTS, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_PARENTS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.CLONE_FIND_ALL, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_ALL_FLATTENED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CLONE_FIND_MARKED, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_MARKED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_FLATTENED_MARKED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.SET_FIND_EVERYWHERE_OPTION, () =&gt; p_leoUI.command(LEOCMD.SET_FIND_EVERYWHERE_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.SET_FIND_NODE_ONLY_OPTION, () =&gt; p_leoUI.command(LEOCMD.SET_FIND_NODE_ONLY_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.SET_FIND_FILE_ONLY_OPTION, () =&gt; p_leoUI.command(LEOCMD.SET_FIND_FILE_ONLY_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, () =&gt; p_leoUI.command(LEOCMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

[CMD.TOGGLE_FIND_IGNORE_CASE_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_IGNORE_CASE_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_MARK_CHANGES_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_MARK_CHANGES_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_MARK_FINDS_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_MARK_FINDS_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_REGEXP_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_REGEXP_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_WORD_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_WORD_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_SEARCH_BODY_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_SEARCH_BODY_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

[CMD.SET_BODY_WRAP_SETTINGS, () =&gt; p_leoUI.config.setBodyWrap()],
</t>
<t tx="felix.20201214150149.2">@others
</t>
<t tx="felix.20201214150149.3">[CMD.EXECUTE, () =&gt; p_leoUI.command(LEOCMD.EXECUTE_SCRIPT, { refreshType: REFRESH_ALL, finalFocus: Focus.NoChange })],

[CMD.SHORT_GNX_UNL_TO_CLIPBOARD, () =&gt; p_leoUI.unlToClipboard("shortGnx")], // Not referenced in package.json
[CMD.FULL_GNX_UNL_TO_CLIPBOARD, () =&gt; p_leoUI.unlToClipboard("fullGnx")], // Not referenced in package.json
[CMD.SHORT_LEGACY_UNL_TO_CLIPBOARD, () =&gt; p_leoUI.unlToClipboard("shortLegacy")], // Not referenced in package.json
[CMD.FULL_LEGACY_UNL_TO_CLIPBOARD, () =&gt; p_leoUI.unlToClipboard("fullLegacy")], // Not referenced in package.json

[CMD.STATUS_BAR, () =&gt; p_leoUI.statusBar()], // Not referenced in package.json
[CMD.MINIBUFFER, () =&gt; p_leoUI.minibuffer()], // Is referenced in package.json
[CMD.SET_LEO_ID, () =&gt; p_leoUI.setLeoIDCommand()],
[CMD.HANDLE_UNL, (p_arg: { unl: string }) =&gt; p_leoUI.handleUnl(p_arg)],

[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; p_leoUI.clickAtButton(p_node)], // Not referenced in package.json
[CMD.GOTO_SCRIPT, (p_node: LeoButtonNode) =&gt; p_leoUI.gotoScript(p_node)],
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; p_leoUI.removeAtButton(p_node)],

</t>
<t tx="felix.20201214150149.4">[CMD.CLOSE_FILE, () =&gt; p_leoUI.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; p_leoUI.newLeoFile()],
[CMD.OPEN_FILE, (p_uri?: vscode.Uri) =&gt; p_leoUI.openLeoFile(p_uri)],
[CMD.REVERT, () =&gt; p_leoUI.command(LEOCMD.REVERT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

[CMD.SAVE_AS_FILE, () =&gt; p_leoUI.saveAsLeoFile()],
[CMD.SAVE_AS_LEOJS, () =&gt; p_leoUI.saveAsLeoJsFile()],
[CMD.SAVE_FILE, () =&gt; p_leoUI.saveLeoFile()],
[CMD.SAVE_FILE_FO, () =&gt; p_leoUI.saveLeoFile(true)],

[CMD.SWITCH_FILE, () =&gt; p_leoUI.switchLeoFile()],
[CMD.RECENT_FILES, () =&gt; p_leoUI.showRecentLeoFiles()],

[CMD.WRITE_AT_FILE_NODES, () =&gt; p_leoUI.command(LEOCMD.WRITE_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.WRITE_AT_FILE_NODES_FO, () =&gt; p_leoUI.command(LEOCMD.WRITE_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.WRITE_DIRTY_AT_FILE_NODES, () =&gt; p_leoUI.command(LEOCMD.WRITE_DIRTY_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.WRITE_DIRTY_AT_FILE_NODES_FO, () =&gt; p_leoUI.command(LEOCMD.WRITE_DIRTY_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.SET_OPENED_FILE, (p_index: number) =&gt; p_leoUI.selectOpenedLeoDocument(p_index, true)],

[CMD.REFRESH_FROM_DISK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.GIT_DIFF, () =&gt; p_leoUI.command(LEOCMD.GIT_DIFF, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

[CMD.TAB_CYCLE_NEXT, () =&gt; p_leoUI.tabCycle()],

</t>
<t tx="felix.20201214150149.5">[CMD.HEADLINE, (p_node: Position) =&gt; p_leoUI.editHeadline(p_node, true)],
[CMD.HEADLINE_SELECTION, () =&gt; p_leoUI.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; p_leoUI.editHeadline(U, true)],

</t>
<t tx="felix.20201214150149.6">// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.COPY_PNODE, { node: p_node, refreshType: NO_REFRESH, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.CUT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.DELETE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PASTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PASTE_CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],

// cut/copy/paste/delete current selection (self.commander.p)
[CMD.COPY_SELECTION, () =&gt; p_leoUI.command(LEOCMD.COPY_PNODE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.CUT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.CUT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DELETE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.DELETE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.PASTE_AS_TEMPLATE, () =&gt; p_leoUI.command(LEOCMD.PASTE_AS_TEMPLATE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.PASTE_CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.PASTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PASTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.SET_UA, () =&gt; p_leoUI.command(LEOCMD.SET_UA, { refreshType: REFRESH_TREE, finalFocus: Focus.NoChange })],

</t>
<t tx="felix.20201214150149.7">// Called by nodes in the tree when selected either by mouse, or with enter
[CMD.SELECT_NODE, (p_outlineNode: LeoOutlineNode) =&gt; p_leoUI.selectTreeNode(p_outlineNode.position, false)], // Select is NOT a Position!
[CMD.OPEN_ASIDE, (p_position?: Position) =&gt; p_leoUI.openAside(p_position)],

[CMD.CONTRACT_ALL, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.CONTRACT_ALL_FO, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.CONTRACT_OR_GO_LEFT, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_OR_GO_LEFT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.EXPAND_AND_GO_RIGHT, () =&gt; p_leoUI.command(LEOCMD.EXPAND_AND_GO_RIGHT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

</t>
<t tx="felix.20201214150149.8">[CMD.GOTO_NEXT_CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body, isNavigation: true })],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

[CMD.GOTO_NEXT_MARKED, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_MARKED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_FIRST_SIBLING, () =&gt; p_leoUI.command(LEOCMD.GOTO_FIRST_SIBLING, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_LAST_SIBLING, () =&gt; p_leoUI.command(LEOCMD.GOTO_LAST_SIBLING, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_FIRST_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_FIRST_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_LAST_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_LAST_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_PREV_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

[CMD.PAGE_UP, () =&gt; p_leoUI.command(LEOCMD.PAGE_UP, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.PAGE_DOWN, () =&gt; p_leoUI.command(LEOCMD.PAGE_DOWN, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

</t>
<t tx="felix.20201214150149.9">[CMD.DEHOIST, () =&gt; p_leoUI.command(LEOCMD.DEHOIST, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.DEHOIST_FO, () =&gt; p_leoUI.command(LEOCMD.DEHOIST, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.HOIST, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.HOIST_SELECTION, () =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.HOIST_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.CHAPTER_NEXT, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_NEXT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.CHAPTER_BACK, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_BACK, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.CHAPTER_MAIN, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_MAIN, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CHAPTER_SELECT, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_SELECT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

</t>
<t tx="felix.20201214151326.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151326.10">/**
 * All commands this expansion exposes to the user via GUI/keybindings in package.json
 */
public static COMMANDS = {
    // Access to the Settings/Welcome Webview
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    STATUS_BAR: Constants.NAME + ".statusBar", // Status Bar Click Command
    // Leo Documents
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    REVERT: Constants.NAME + ".revert",
    CLEAR_RECENT_FILES: Constants.NAME + ".clearRecentFiles",
    // Import Export Commands
    IMPORT_ANY_FILE: Constants.NAME + ".importAnyFile",
    READ_FILE_INTO_NODE: Constants.NAME + ".readFileIntoNode",
    EXPORT_HEADLINES: Constants.NAME + ".exportHeadlines",
    FLATTEN_OUTLINE: Constants.NAME + ".flattenOutline",
    OUTLINE_TO_CWEB: Constants.NAME + ".outlineToCweb",
    OUTLINE_TO_NOWEB: Constants.NAME + ".outlineToNoweb",
    REMOVE_SENTINELS: Constants.NAME + ".removeSentinels",
    WEAVE: Constants.NAME + ".weave",
    WRITE_FILE_FROM_NODE: Constants.NAME + ".writeFileFromNode",
    // Leo Document Files
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile",
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline",
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    SAVE_AS_LEOJS: Constants.NAME + ".saveAsLeoJsFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    SET_LEO_ID: Constants.NAME + ".setLeoID",
    HANDLE_UNL: Constants.NAME + ".handleUnl",
    SHORT_GNX_UNL_TO_CLIPBOARD: Constants.NAME + ".shortGnxUnlToClipboard",
    FULL_GNX_UNL_TO_CLIPBOARD: Constants.NAME + ".fullGnxUnlToClipboard",
    SHORT_LEGACY_UNL_TO_CLIPBOARD: Constants.NAME + "shortLegacyUnlToClipboard",
    FULL_LEGACY_UNL_TO_CLIPBOARD: Constants.NAME + "fullLegacyUnlToClipboard",
    GIT_DIFF: Constants.NAME + ".gitDiff",
    TAB_CYCLE_NEXT: Constants.NAME + ".tabCycleNext",
    WRITE_AT_FILE_NODES: Constants.NAME + ".writeAtFileNodes",
    WRITE_AT_FILE_NODES_FO: Constants.NAME + ".writeAtFileNodesFromOutline",
    WRITE_DIRTY_AT_FILE_NODES: Constants.NAME + ".writeDirtyAtFileNodes",
    WRITE_DIRTY_AT_FILE_NODES_FO: Constants.NAME + ".writeDirtyAtFileNodesFromOutline",
    // At-buttons
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    GOTO_SCRIPT: Constants.NAME + ".gotoScript",
    // Outline Node User Interaction
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside", // Opens aside a body pane locked to this gnx &amp; commander.
    // Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_FIRST_SIBLING: Constants.NAME + ".gotoFirstSibling",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    REVERT_TO_UNDO: Constants.NAME + ".revertToUndo",
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection",
    SORT_CHILDREN_FO: Constants.NAME + ".sortChildrenSelectionFromOutline",
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    PREV_NODE: Constants.NAME + ".prev",
    PREV_NODE_FO: Constants.NAME + ".prevFromOutline",
    NEXT_NODE: Constants.NAME + ".next",
    NEXT_NODE_FO: Constants.NAME + ".nextFromOutline",
    // Commands from tree panel buttons or context: focus on OUTLINE
    SET_UA: Constants.NAME + ".setUa",
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    PASTE_AS_TEMPLATE: Constants.NAME + ".pasteAsTemplate",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    INSERT_CHILD: Constants.NAME + ".insertChildNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version
    INSERT_CHILD_SELECTION: Constants.NAME + ".insertChildNodeSelection", // Can be interrupted
    INSERT_CHILD_SELECTION_INTERRUPT: Constants.NAME + ".insertChildNodeSelectionInterrupt", // Can be interrupted
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // Commands from keyboard, while focus on OUTLINE (no need for COPY_SELECTION)
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    INSERT_CHILD_SELECTION_FO: Constants.NAME + ".insertChildNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    CHAPTER_NEXT: Constants.NAME + ".chapterNext",
    CHAPTER_BACK: Constants.NAME + ".chapterBack",
    CHAPTER_MAIN: Constants.NAME + ".chapterMain",
    CHAPTER_SELECT: Constants.NAME + ".chapterSelect",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",

    FIND_QUICK: Constants.NAME + ".findQuick",
    FIND_QUICK_SELECTED: Constants.NAME + ".findQuickSelected",
    FIND_QUICK_TIMELINE: Constants.NAME + ".findQuickTimeline",
    FIND_QUICK_CHANGED: Constants.NAME + ".findQuickChanged",
    FIND_QUICK_HISTORY: Constants.NAME + ".history",
    FIND_QUICK_MARKED: Constants.NAME + ".markedList",
    FIND_QUICK_GO_ANYWHERE: Constants.NAME + ".goAnywhere",
    GOTO_NAV_ENTRY: Constants.NAME + ".gotoNav",

    GOTO_NAV_PREV: Constants.NAME + ".gotoNavPrev",
    GOTO_NAV_NEXT: Constants.NAME + ".gotoNavNext",
    GOTO_NAV_FIRST: Constants.NAME + ".gotoNavFirst",
    GOTO_NAV_LAST: Constants.NAME + ".gotoNavLast",

    START_SEARCH: Constants.NAME + ".startSearch",
    SEARCH_BACKWARD: Constants.NAME + ".searchBackward",
    RE_SEARCH: Constants.NAME + ".reSearch",
    RE_SEARCH_BACKWARD: Constants.NAME + ".reSearchBackward",
    WORD_SEARCH: Constants.NAME + ".wordSearch",
    WORD_SEARCH_BACKWARD: Constants.NAME + ".wordSearchBackward",
    FIND_ALL: Constants.NAME + ".findAll",
    FIND_NEXT: Constants.NAME + ".findNext",
    FIND_NEXT_FO: Constants.NAME + ".findNextFromOutline",
    FIND_PREVIOUS: Constants.NAME + ".findPrevious",
    FIND_PREVIOUS_FO: Constants.NAME + ".findPreviousFromOutline",
    FIND_DEF: Constants.NAME + ".findDef",
    REPLACE: Constants.NAME + ".replace",
    REPLACE_FO: Constants.NAME + ".replaceFromOutline",
    REPLACE_THEN_FIND: Constants.NAME + ".replaceThenFind",
    REPLACE_THEN_FIND_FO: Constants.NAME + ".replaceThenFindFromOutline",
    REPLACE_ALL: Constants.NAME + ".replaceAll",

    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_TAG: Constants.NAME + ".cloneFindTag",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",

    CLONE_FIND_PARENTS: Constants.NAME + ".cloneFindParents",
    GOTO_GLOBAL_LINE: Constants.NAME + ".gotoGlobalLine",
    TAG_CHILDREN: Constants.NAME + ".tagChildren",
    TAG_NODE: Constants.NAME + ".tagNode",
    REMOVE_TAG: Constants.NAME + ".removeTag",
    REMOVE_TAGS: Constants.NAME + ".removeTags",
    SET_FIND_EVERYWHERE_OPTION: Constants.NAME + ".setFindEverywhereOption",
    SET_FIND_NODE_ONLY_OPTION: Constants.NAME + ".setFindNodeOnlyOption",
    SET_FIND_FILE_ONLY_OPTION: Constants.NAME + ".setFindFileOnlyOption",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: Constants.NAME + ".setFindSuboutlineOnlyOption",
    TOGGLE_FIND_IGNORE_CASE_OPTION: Constants.NAME + ".toggleFindIgnoreCaseOption",
    TOGGLE_FIND_MARK_CHANGES_OPTION: Constants.NAME + ".toggleFindMarkChangesOption",
    TOGGLE_FIND_MARK_FINDS_OPTION: Constants.NAME + ".toggleFindMarkFindsOption",
    TOGGLE_FIND_REGEXP_OPTION: Constants.NAME + ".toggleFindRegexpOption",
    TOGGLE_FIND_WORD_OPTION: Constants.NAME + ".toggleFindWordOption",
    TOGGLE_FIND_SEARCH_BODY_OPTION: Constants.NAME + ".toggleFindSearchBodyOption",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: Constants.NAME + ".toggleFindSearchHeadlineOption",
    SET_BODY_WRAP_SETTINGS: Constants.NAME + ".setBodyWrapSettings",
    SET_ENABLE_PREVIEW: Constants.NAME + ".setEnablePreview",
    CLEAR_CLOSE_EMPTY_GROUPS: Constants.NAME + ".clearCloseEmptyGroups",
};

</t>
<t tx="felix.20201214151326.11">/**
 * Leo command names that are called from vscode's gui/menu/buttons/keybindings triggers
 */
public static LEO_COMMANDS = {

    // * File Commands
    // NEW: 'new', // newLeoFile used instead
    // OPEN_OUTLINE: 'open_outline', // openLeoFile used instead
    WRITE_AT_FILE_NODES: 'write-at-file-nodes',
    WRITE_DIRTY_AT_FILE_NODES: 'write-dirty-at-file-nodes',
    REVERT: 'revert',
    // * More Commands
    GOTO_GLOBAL_LINE: "!goto_global_line", // USE LEOJS INSTEAD OF UI
    SET_UA: 'set-ua',

    // * Import Export
    IMPORT_ANY_FILE: "import-file",
    READ_FILE_INTO_NODE: "read-file-into-node",

    EXPORT_HEADLINES: "export-headlines",
    FLATTEN_OUTLINE: "flatten-outline",
    OUTLINE_TO_CWEB: "outline-to-cweb",
    OUTLINE_TO_NOWEB: "outline-to-noweb",
    REMOVE_SENTINELS: "remove-sentinels",
    WEAVE: "weave",
    WRITE_FILE_FROM_NODE: "write-file-from-node",

    // * Search operations
    START_SEARCH: "start-search",
    FIND_ALL: "find-all",
    // FIND_NEXT: "!find_next",
    // FIND_PREVIOUS: "!find_previous",
    FIND_DEF: "find-def",
    // REPLACE: "!replace",
    // REPLACE_THEN_FIND: "!replace_then_find",
    REPLACE_ALL: "change-all",

    SET_FIND_EVERYWHERE_OPTION: "set-find-everywhere",
    SET_FIND_NODE_ONLY_OPTION: "set-find-node-only",
    SET_FIND_FILE_ONLY_OPTION: "set-find-file-only",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: "set-find-suboutline-only",
    TOGGLE_FIND_IGNORE_CASE_OPTION: "toggle-find-ignore-case-option",
    TOGGLE_FIND_MARK_CHANGES_OPTION: "toggle-find-mark-changes-option",
    TOGGLE_FIND_MARK_FINDS_OPTION: "toggle-find-mark-finds-option",
    TOGGLE_FIND_REGEXP_OPTION: "toggle-find-regex-option",
    TOGGLE_FIND_WORD_OPTION: "toggle-find-word-option",
    TOGGLE_FIND_SEARCH_BODY_OPTION: "toggle-find-in-body-option",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: "toggle-find-in-headline-option",

    SEARCH_BACKWARD: "search-backward",
    RE_SEARCH: "re-search",
    RE_SEARCH_BACKWARD: "re-search-backward",
    WORD_SEARCH: "word-search",
    WORD_SEARCH_BACKWARD: "word-search-backward",

    TAG_NODE: "tag-node",
    TAG_CHILDREN: "tag-children",
    REMOVE_TAG: "remove-tag",
    REMOVE_ALL_TAGS: "remove-all-tags",

    // * Undo Operations
    UNDO: "undo",
    REDO: "redo",
    // * Tree Building
    EXECUTE_SCRIPT: "execute-script",
    REFRESH_FROM_DISK: "refresh-from-disk",
    GIT_DIFF: "git-diff",
    // * Outline from body text
    EXTRACT: "extract",
    EXTRACT_NAMES: "extract-names",
    // * Hoist Operations
    HOIST_PNODE: "hoist",
    DEHOIST: "de-hoist",
    CHAPTER_NEXT: "chapter-next",
    CHAPTER_BACK: "chapter-back",
    CHAPTER_SELECT: "chapter-select",
    CHAPTER_MAIN: "chapter-select-main",
    // * History Navigation
    GOTO_PREV_HISTORY: "goto-prev-history-node",
    GOTO_NEXT_HISTORY: "goto-next-history-node",
    // * Goto &amp; Folding
    PAGE_UP: "tree-page-up",
    PAGE_DOWN: "tree-page-down",
    GOTO_FIRST_VISIBLE: "goto-first-visible-node",
    GOTO_LAST_VISIBLE: "goto-last-visible-node",
    GOTO_FIRST_SIBLING: "goto-first-sibling",
    GOTO_LAST_SIBLING: "goto-last-sibling",
    GOTO_NEXT_VISIBLE: "goto-next-visible",
    GOTO_PREV_VISIBLE: "goto-prev-visible",
    GOTO_NEXT_MARKED: "goto-next-marked",
    // GOTO_PREV_MARKED: "goto-prev-marked", // ! Not in Leo's menu nor LeoJS package.json.
    GOTO_NEXT_CLONE: "goto-next-clone",
    CONTRACT_OR_GO_LEFT: "contract-or-go-left",
    EXPAND_AND_GO_RIGHT: "expand-and-go-right",
    CONTRACT_ALL: "contract-all",
    // * Mark Operations
    TOGGLE_MARK: "toggle-mark",
    COPY_MARKED: "copy-marked-nodes",
    DIFF_MARKED_NODES: "diff-marked-nodes",
    MARK_CHANGED_ITEMS: "mark-changed-items",
    MARK_SUBHEADS: "mark-subheads",
    UNMARK_ALL: "unmark-all",
    CLONE_MARKED_NODES: "clone-marked-nodes",
    DELETE_MARKED_NODES: "delete-marked-nodes",
    MOVE_MARKED_NODES: "move-marked-nodes",
    // * Clipboard Operations
    COPY_PNODE: "copy-node",
    CUT_PNODE: "cut-node",
    PASTE_PNODE: "async-paste-node",
    PASTE_CLONE_PNODE: "async-paste-retaining-clones",
    PASTE_AS_TEMPLATE: "async-paste-as-template",
    // * Outline Editing
    DELETE_PNODE: "delete-node",
    MOVE_PNODE_DOWN: "move-outline-down",
    MOVE_PNODE_LEFT: "move-outline-left",
    MOVE_PNODE_RIGHT: "move-outline-right",
    MOVE_PNODE_UP: "move-outline-up",
    INSERT_PNODE: "insert-node",
    INSERT_CHILD_PNODE: "insert-child",
    CLONE_PNODE: "clone-node",
    // * Marshalling Operations
    PROMOTE_PNODE: "promote",
    DEMOTE_PNODE: "demote",
    SORT_CHILDREN: "sort-children",
    SORT_SIBLINGS: "sort-siblings",
    // * Clone-find functionality

    CLONE_FIND_ALL_FLATTENED: "cff",

    CLONE_FIND_FLATTENED_MARKED: "cffm",
    CLONE_FIND_TAG: "cft",
    CLONE_FIND_ALL: "cfa",
    CLONE_FIND_MARKED: "cfam",
    CLONE_FIND_PARENTS: "clone-find-parents",
};

</t>
<t tx="felix.20201214151326.2">/**
 * Text and numeric constants used throughout leojs
 */
export class Constants {

    /**
     * Identity of account that can publish extensions to the Visual Studio Code Marketplace. 
     */
    public static PUBLISHER: string = "boltex";

    /**
     * The name of the extension - should be all lowercase with no spaces.
     */
    @others
}
</t>
<t tx="felix.20201214151326.3">public static NAME: string = "leojs";

public static TREEVIEW_ID: string = "leojsOutline";
public static TREEVIEW_EXPLORER_ID: string = "leojsOutlineExplorer";

public static DOCUMENTS_ID: string = "leojsDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leojsDocumentsExplorer";

public static BUTTONS_ID: string = "leojsButtons";
public static BUTTONS_EXPLORER_ID: string = "leojsButtonsExplorer";

public static FIND_ID: string = "leojsFindPanel";
public static FIND_EXPLORER_ID: string = "leojsFindPanelExplorer";

public static GOTO_ID: string = "leojsGotoPanel";
public static GOTO_EXPLORER_ID: string = "leojsGotoPanelExplorer";

public static UNDOS_ID: string = "leojsUndos";
public static UNDOS_EXPLORER_ID: string = "leojsUndosExplorer";

public static VERSION_STATE_KEY: string = "leojsVersion";

public static FILE_EXTENSION: string = "leo";
public static DB_FILE_EXTENSION: string = "db";
public static JS_FILE_EXTENSION: string = "leojs";

public static LEO_LANGUAGE_PREFIX: string = "leojsbody."; // all lowercase.
public static LEO_WRAP_SUFFIX: string = ".wrap"; // all lowercase.

public static URI_LEOJS_SCHEME: string = "leojs";
public static URI_LEOJS_DETACHED_SCHEME: string = "leojsDetached";
public static URI_FILE_SCHEME: string = "file";
public static URI_UNTITLED_SCHEME: string = 'untitled';
public static OUTPUT_CHANNEL_LANGUAGE: string = 'Log';
public static URI_SCHEME_HEADER: string = "leojs:/";
public static URI_SCHEME_DETACHED_HEADER: string = "leojsDetached:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files"; // Meant for all 3 leo, db and leojs.
public static UNTITLED_FILE_NAME: string = "untitled";
public static URI_HELP_SCHEME: string = "helpPanel";
public static URI_HELP_FILENAME: string = "LeoJS Help";
public static RECENT_FILES_KEY: string = "leojsRecentFiles";
public static LAST_FILES_KEY: string = "leojsLastFiles";

public static CLEANUP_DEBOUNCE_DELAY: number = 40;
public static DETACHED_LANGUAGE_DELAY: number = 250;
public static REFRESH_DEBOUNCE_DELAY: number = 50;
public static STATES_DEBOUNCE_DELAY: number = 60;
public static TITLE_DEBOUNCE_DELAY: number = 20;
public static BUTTONS_DEBOUNCE_DELAY: number = 160;
public static DOCUMENTS_DEBOUNCE_DELAY: number = 80;
public static UNDOS_DEBOUNCE_DELAY: number = 140;
public static UNDOS_REVEAL_DEBOUNCE_DELAY: number = 50;
public static GOTO_DEBOUNCE_DELAY: number = 50;
public static BODY_STATES_DEBOUNCE_DELAY: number = 120;

public static CONFIG_NAME: string = "leojs";
public static CONFIG_WORKBENCH_ENABLED_PREVIEW: string = "workbench.editor.enablePreview";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

</t>
<t tx="felix.20201214151326.4">/**
 * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_PARENT: "resources/light/parent.svg",
    ICON_DARK_PARENT: "resources/dark/parent.svg",
    ICON_LIGHT_NODE: "resources/light/node.svg",
    ICON_DARK_NODE: "resources/dark/node.svg",
    ICON_LIGHT_BODY: "resources/light/body.svg",
    ICON_DARK_BODY: "resources/dark/body.svg",
    ICON_LIGHT_TAG: "resources/light/tag.svg",
    ICON_DARK_TAG: "resources/dark/tag.svg",

    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",

    ICON_LIGHT_UNDO_ACTIVE: "resources/light/undo.svg",
    ICON_DARK_UNDO_ACTIVE: "resources/dark/undo.svg",
    ICON_LIGHT_UNDO: "resources/dark/undo.svg",
    ICON_DARK_UNDO: "resources/light/undo.svg",
    ICON_LIGHT_REDO_ACTIVE: "resources/light/redo.svg",
    ICON_DARK_REDO_ACTIVE: "resources/dark/redo.svg",
    ICON_LIGHT_REDO: "resources/dark/redo.svg",
    ICON_DARK_REDO: "resources/light/redo.svg",

    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_RCLICK: "resources/light/button-rclick.svg",
    ICON_DARK_BUTTON_RCLICK: "resources/dark/button-rclick.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",

    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    SVG_SHEME: "data",
    SVG_OPEN: 'image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"&gt;',
    SVG_CLOSE: "&lt;/svg&gt;",
    STATUSBAR_INDICATOR: "$(link) ", // WITH TRAILING SPACE!
    QUICK_OPEN_LEO_COMMANDS: "&gt;leojs: ",
    EXPLORER_TREEVIEW_PREFIX: "LEOJS ",
    TREEVIEW_TITLE: "OUTLINE",
    BODY_TITLE: "LEOJS BODY",
    LOG_PANE_TITLE: "LeoJS Log Window",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20201214151326.5">/**
 * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "from selected node",
    SCRIPT_BUTTON_TOOLTIP:
        "Creates a new button with the presently selected node.\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing a script. e.g. \"g.es(p.h)\"\n" +
        "2.  Press 'Script Button' to create a new button.\n" +
        "3.  Select another node on which to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    SAVE_DIALOG_LABEL: "Save Leo File",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOJS: "Open this Leojs file?",
    OPEN_RECENT_FILE: "Open Recent Leojs File",
    RIGHT_CLICK_TO_OPEN: "Right-click to open with leojs",
    FILE_ALREADY_OPENED: "Leojs file already opened",

    CLEARED_RECENT: "Cleared recent files list",
    CHOOSE_OPENED_FILE: "Select an opened Leojs File",
    FILE_NOT_OPENED: "No files opened.",

    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    PROMPT_INSERT_CHILD: "Insert Child",
    DEFAULT_HEADLINE: "New Headline",

    TITLE_GOTO_GLOBAL_LINE: "Goto global line", // TODO : REMOVE IF NOT USED
    PLACEHOLDER_GOTO_GLOBAL_LINE: "#", // TODO : REMOVE IF NOT USED
    PROMPT_GOTO_GLOBAL_LINE: "Line number", // TODO : REMOVE IF NOT USED

    REPLACE_TITLE: "Replace with",
    REPLACE_PROMPT: "Type text to replace with and press enter.",
    REPLACE_PLACEHOLDER: "Replace pattern here",

    SEARCH_TITLE: "Search for",
    SEARCH_PROMPT: "Type text to search for and press enter.",
    SEARCH_PLACEHOLDER: "Find pattern here",

    INT_SEARCH_TITLE: "Search",
    INT_SEARCH_PROMPT: "'Enter' to search",
    INT_SEARCH_BACKWARD: " Backward", // Leading space intended
    INT_SEARCH_REGEXP: "Regexp ", // Trailing space intended
    INT_SEARCH_WORD: "Word ", // Trailing space intended

    SEARCH_NOT_FOUND: "Not found",
    FIND_PATTERN_HERE: "&lt;find pattern here&gt;",

    TAGS_CHARACTERS_ERROR: "Cannot add tags containing any of these characters: &amp;|^-",
    NO_TAGS_ON_NODE: "No tags on node: ", // Trailing space intended

    TITLE_TAG_CHILDREN: "Tag Children",
    TITLE_REMOVE_TAG: "Remove Tag",
    TITLE_TAG_NODE: "Tag Node",
    PLACEHOLDER_TAG: "&lt;tag&gt;",
    PROMPT_TAG: "Enter a tag name",

    TITLE_FIND_TAG: "Find Tag", // TODO remove if used directly in leoFind.ts
    PLACEHOLDER_CLONE_FIND_TAG: "&lt;tag&gt;", // TODO remove if used directly in leoFind.ts
    PROMPT_CLONE_FIND_TAG: "Enter a tag name",// TODO remove if used directly in leoFind.ts

    CLOSE_ERROR: "Cannot close: No files opened.",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    CHOOSE_BUTTON: "Choose @button or @rclick",
    SEARCH_POSITION_BY_HEADLINE: "Search positions by headline",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    SELECT_CHAPTER_PROMPT: "Select chapter",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "Leo is busy! ", // with voluntary trailing space

    LANGUAGE_NOT_SUPPORTED: " language coloring not yet supported.", // with leading space
    MINIBUFFER_BUTTON_START: "@button-",
    MINIBUFFER_RCLICK_START: "@rclick-",
    MINIBUFFER_SCRIPT_BUTTON: "script-button",
    MINIBUFFER_DEL_SCRIPT_BUTTON: "delete-script-",
    MINIBUFFER_DEL_BUTTON_START: "delete-@button-",
    MINIBUFFER_COMMAND_START: "@command-",
    MINIBUFFER_USER_DEFINED: "User defined command.",
    MINIBUFFER_BUTTON: "$(run) @button",
    MINIBUFFER_RCLICK: "$(chevron-right) @rclick",
    MINIBUFFER_COMMAND: "$(zap) @command",
    MINIBUFFER_BAD_COMMAND: "$(error) Not Available",
    MINIBUFFER_HISTORY_LABEL: "Minibuffer History",
    MINIBUFFER_HISTORY_DESC: "Choose from last run commands...",

    BODY_WRAP_RECOMMEND: "'leojsbody' wordWrap settings are recommended (some currently missing)",
    BODY_WRAP_SET: "'leojsbody' wordWrap settings were set",
    FIX_IT: "Fix it",
    ENABLE_PREVIEW_SET: "'Enable Preview' setting was set",
    ENABLE_PREVIEW_RECOMMEND: "'Enable Preview' setting is recommended (currently disabled)",
    CLOSE_EMPTY_CLEARED: "'Close Empty Groups' setting was cleared",
    CLOSE_EMPTY_RECOMMEND: "'Close Empty Groups' setting is NOT recommended!",
    SET_LEO_ID_MESSAGE: "Leo ID not found. Please enter an id that identifies you uniquely.",
    GET_LEO_ID_PROMPT: "Please enter an id that identifies you uniquely.\n(Letters and numbers only, and at least 3 characters in length)",
    ENTER_LEO_ID: "Enter Leo id"
};

</t>
<t tx="felix.20201214151326.6">/**
 * * Strings used in 'at-button' panel display in LeoButtonNode
 */
public static BUTTON_STRINGS = {
    NULL_WIDGET: "nullButtonWidget",
    SCRIPT_BUTTON: "script-button",
    ADD_BUTTON: "leojsButtonAdd",
    NORMAL_BUTTON: "leojsButtonNode"
};

</t>
<t tx="felix.20201214151326.7">/**
 * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20201214151326.8">/**
 * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    LEO_STARTUP_DONE: "leojsStartupDone",
    LEO_OPENING_FILE: "leojsOpeningFile",
    LEO_ID_UNSET: "leojsIdUnset",
    LEO_READY: "leojsReady", // Extension activated and classes created and ready
    TREE_OPENED: "leojsTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leojsTreeTitled", // Tree is a Leo file and not a new untitled document

    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leojsChanged",
    LEO_CAN_UNDO: "leojsCanUndo",
    LEO_CAN_REDO: "leojsCanRedo",
    LEO_CAN_BACK: "leojsCanGoBack",
    LEO_CAN_NEXT: "leojsCanGoNext",
    LEO_CAN_DEMOTE: "leojsCanDemote",
    LEO_CAN_PROMOTE: "leojsCanPromote",
    LEO_CAN_DEHOIST: "leojsCanDehoist",
    LEO_CAN_HOIST: "leojsCanHoist", // isNotRoot equivalent, Computed by hand
    LEO_TOP_HOIST_CHAPTER: "leojsTopHoistChapter",
    LEO_EDIT_HEADLINE: "leojsEditHeadline",

    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leojsMarked", // no need for unmarked here, use !leojsMarked
    SELECTED_CLONE: "leojsCloned",
    SELECTED_DIRTY: "leojsDirty",
    SELECTED_EMPTY: "leojsEmpty",
    SELECTED_CHILD: "leojsChild", // Has children
    SELECTED_ATFILE: "LeojsAtFile", // Can be refreshed

    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leojsObjectSelected", // keybindings "On": Outline or body has focus

    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leojsNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leojsNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leojsNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leojsNodeCloned",
    NODE_ROOT: "leojsNodeRoot",
    NODE_NOT_ROOT: "leojsNodeNotRoot",
    NODE_TAGS: "leojsNodeTags",

    // Flags for undo nodes 
    UNDO_BEAD: "leojsUndoNode",
    NOT_UNDO_BEAD: "leojsNoUndoNode",

    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leojsDocumentSelectedTitled",
    DOCUMENT_TITLED: "leojsDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leojsDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leojsDocumentUntitled",

    // Flags for focus context
    FOCUS_FIND: "leojsFindFocus",

    // Context flags that are mapped 'directly' onto leojs config settings
    // * PREFIXED WITH 'leojs' *
    LEO_TREE_BROWSE: Constants.NAME + Constants.CONFIG_NAMES.LEO_TREE_BROWSE[0].toUpperCase() + Constants.CONFIG_NAMES.LEO_TREE_BROWSE.slice(1), // Force ar'jan's suggestion of Leo's tree behavior override
    TREE_IN_EXPLORER: Constants.NAME + Constants.CONFIG_NAMES.TREE_IN_EXPLORER[0].toUpperCase() + Constants.CONFIG_NAMES.TREE_IN_EXPLORER.slice(1), // Leo outline also in the explorer view
    SHOW_EDIT: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EDIT[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EDIT.slice(1),              // Hover Icons on outline nodes
    SHOW_ADD: Constants.NAME + Constants.CONFIG_NAMES.SHOW_ADD[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_ADD.slice(1),                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.NAME + Constants.CONFIG_NAMES.SHOW_MARK[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_MARK.slice(1),               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.NAME + Constants.CONFIG_NAMES.SHOW_CLONE[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_CLONE.slice(1),             // Hover Icons on outline nodes
    SHOW_COPY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_COPY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_COPY.slice(1),               // Hover Icons on outline nodes

    // SHOW_EDITION_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EDITION_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EDITION_BODY.slice(1),
    // SHOW_CLIPBOARD_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY.slice(1),
    // SHOW_PROMOTE_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY.slice(1),
    // SHOW_EXECUTE_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY.slice(1),
    // SHOW_EXTRACT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY.slice(1),
    // SHOW_IMPORT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_IMPORT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_IMPORT_BODY.slice(1),
    // SHOW_REFRESH_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_REFRESH_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_REFRESH_BODY.slice(1),
    // SHOW_HOIST_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_HOIST_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_HOIST_BODY.slice(1),
    // SHOW_MARK_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_MARK_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_MARK_BODY.slice(1),
    // SHOW_SORT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_SORT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_SORT_BODY.slice(1)
};

</t>
<t tx="felix.20201214151326.9">/**
 * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20201214151419.1">import * as vscode from "vscode";
import { Icon, LeoButton } from "./types";
import { Constants } from "./constants";
import { LeoStates } from "./leoStates";
import * as g from './core/leoGlobals';
import { RClick } from "./core/mod_scripting";
import { nullButtonWidget } from "./core/leoFrame";

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20201214151419.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _icons: Icon[],
    ) { }

    @others
}

</t>
<t tx="felix.20201214151419.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201214151419.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20201214151419.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {
    const w_children: LeoButtonNode[] = [];
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element) {

        const c = g.app.windowList[g.app.gui.frameIndex].c;

        let d: nullButtonWidget[];
        if (c &amp;&amp; c.theScriptingController) {
            d = c.theScriptingController.buttonsArray || [];
        } else {
            d = [];
        }

        const buttons = [];

        let i_but = 0;
        for (const but of d) {
            let rclickList: RClick[] = [];

            if (but.rclicks) {
                rclickList = but.rclicks;
            }

            const entry: LeoButton = {
                name: but.text,
                index: i_but,
                rclicks: rclickList,
            };

            buttons.push(entry);
            i_but += 1;
        }


        buttons.forEach(p_button =&gt; {
            w_children.push(new LeoButtonNode(p_button, this._icons));
        });


    }
    return Promise.resolve(w_children); // Defaults to an empty list of children
}

</t>
<t tx="felix.20201214151419.6">public getParent(element: LeoButtonNode): vscode.ProviderResult&lt;LeoButtonNode&gt; | null {
    // Buttons are just a list, as such, entries are always child of root so return null
    return null;
}

</t>
<t tx="felix.20201214151425.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;
    public rclicks: RClick[];

    // is the special 'add' button used to create button from a given node's script
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _buttonIcons: Icon[], // pointer to global array of node icons
    ) {
        super(button.name);

        this._isAdd = this.button.name === Constants.BUTTON_STRINGS.SCRIPT_BUTTON;

        this.rclicks = button.rclicks ? button.rclicks : [];
        this.contextValue = this._isAdd ? Constants.BUTTON_STRINGS.ADD_BUTTON : Constants.BUTTON_STRINGS.NORMAL_BUTTON;

    }

    @others
}

</t>
<t tx="felix.20201214151425.3">// @ts-ignore
public get iconPath(): Icon {
    return this._buttonIcons[this._isAdd ? 2 : this.rclicks.length ? 1 : 0];
}

</t>
<t tx="felix.20201214151425.4">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to index to prevent accidental duplicates
    return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20201214151425.5">// @ts-ignore
public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20201214151425.6">// @ts-ignore
public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20201214151429.1">import * as vscode from "vscode";
import { LeoUI } from './leoUI';
import { LeoStates } from "./leoStates";
import { Constants } from "./constants";
import * as utils from "./utils";
import * as g from './core/leoGlobals';
import { Commands } from "./core/leoCommands";
import { LeoFrame } from "./core/leoFrame";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151429.2">/**
 * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoFrame&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoFrame | undefined&gt; = new vscode.EventEmitter&lt;LeoFrame | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoFrame | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _leoUI: LeoUI,
    ) { }

    @others
}

</t>
<t tx="felix.20201214151429.3">/**
 * Refresh the whole Leo Document panel
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201214151429.4">public getTreeItem(element: LeoFrame): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return new LeoDocumentNode(element, this._leoUI,);
}

</t>
<t tx="felix.20201214151429.5">public getChildren(element?: LeoFrame): LeoFrame[] {
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element) {
        return g.app.windowList;
    } else {
        return []; // Should not happen!
    }
}

</t>
<t tx="felix.20201214151429.6">public getParent(element: LeoFrame): vscode.ProviderResult&lt;LeoFrame&gt; {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return undefined;
}

</t>
<t tx="felix.20201214151434.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    constructor(
        public frame: LeoFrame,
        private _leoUI: LeoUI,
    ) {
        super(frame.c.fileName() ? utils.getFileFromPath(frame.c.fileName()) : Constants.UNTITLED_FILE_NAME);

        const c: Commands = frame.c;
        const filename = c.fileName();
        const isNamed: boolean = !!filename;
        this.label = isNamed ? utils.getFileFromPath(filename) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = isNamed ? filename : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [g.app.windowList.indexOf(frame)]
        };

        if (frame === g.app.windowList[this._leoUI.frameIndex]) {
            // If this was created as a selected node, make sure it's selected
            this._leoUI.setDocumentSelection(frame);
            this.contextValue = isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }

        this.id = `d${g.app.windowList.indexOf(frame)}f${c.fileName()}c${c.changed.toString()}`;
        this.iconPath = this._leoUI.documentIcons[c.changed ? 1 : 0];
    }

}
</t>
<t tx="felix.20201214151447.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { LeoUI } from "./leoUI";
import { Constants } from "./constants";
import { LeoPackageStates } from "./types";
import { Position } from "./core/leoNodes";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151447.10">/**
 * Current selection allows promote command
 */
private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20201214151447.11">/**
 * Currently selected can de-hoist state
 */
private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20201214151447.12"></t>
<t tx="felix.20201214151447.13">// * 'states' flags about current selection, for visibility and commands availability
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20201214151447.14">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20201214151447.15">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20201214151447.16">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20201214151447.17">private _leoChild: boolean = false;
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20201214151447.18">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20201214151447.19">// * Special is-root 'state' flag about current selection, for visibility and commands availability
private _leoRoot: boolean = false;
get leoRoot(): boolean {
    return this._leoRoot;
}
set leoRoot(p_value: boolean) {
    this._leoRoot = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_HOIST, !p_value);
}

</t>
<t tx="felix.20201214151447.2">/**
 * * Global states service
 * Holds state flags used to restrict command availability and icon visibility
 * Changes UI by changing vscode's context variables
 */
export class LeoStates {

    public qLastContextChange: Thenable&lt;unknown&gt;; // Promise that the last state change is applied

    @others
}
</t>
<t tx="felix.20201214151447.20">constructor(
    private _context: vscode.ExtensionContext,
    private _leoJs: LeoUI
) {
    this.qLastContextChange = Promise.resolve(); // Temporary.
}

</t>
<t tx="felix.20201214151447.21">public setSelectedNodeFlags(p_node: Position): void {
    this.leoMarked = p_node.isMarked();
    this.leoCloned = p_node.isCloned();
    this.leoDirty = p_node.isDirty();
    this.leoEmpty = !p_node.v.hasBody();
    this.leoChild = p_node.hasChildren();
    this.leoAtFile = p_node.isAtFileNode();
    this.leoRoot = p_node._isRoot;
}

</t>
<t tx="felix.20201214151447.22">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoChanged = p_states.changed;
    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;
    this.leoCanGoBack = p_states.canGoBack;
    this.leoCanGoNext = p_states.canGoNext;
    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;
    this.leoCanDehoist = p_states.canDehoist;
    this.leoRoot = !p_states.canHoist;
    this.leoTopHoistChapter = p_states.topIsChapter;
}
</t>
<t tx="felix.20201214151447.3"></t>
<t tx="felix.20201214151447.4">/**
 * A Leo file is opened
 */
private _fileOpenedReady: boolean = false; // Sets context flag along with treeview title
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.5">/**
 * Currently opened Leo file path and name, empty string if new unsaved file.
 */
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {
    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.6">/**
 * Currently opened commander is dirty
 */
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    if (this._leoChanged !== p_value) {
        // Refresh Documents Panel
        // ? Needed?
        this._leoJs.refreshDocumentsPane();
    }
    this._leoChanged = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.7">/**
 * Undo operation available state
 */
private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20201214151447.8">/**
 * Redo operation available state
 */
private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20201214151447.9">/**
 * Current selection allows demote command
 */
private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20201214151451.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoUI } from "./leoUI";
import * as g from './core/leoGlobals';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151451.2">/**
 * * Statusbar indicator controller service
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the defult from config
    private _tooltip: string = ""; // Markdown string built by _buildToolTip from a given headeline

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoJs: LeoUI
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._context.subscriptions.push(this._leoStatusBarItem); // Disposable 

        this._leoStatusBarItem.command = Constants.COMMANDS.STATUS_BAR;
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR;

        const w_mdToolTip = new vscode.MarkdownString();

        w_mdToolTip.value = "";

        w_mdToolTip.isTrusted = true;
        w_mdToolTip.supportThemeIcons = true;

        this._leoStatusBarItem.tooltip = w_mdToolTip;

        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20201214151451.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20201214151451.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20201214151451.5">/**
 * * Sets string to replace default from config &amp; refresh it
 * @p_string string to be displayed on Leo's status bar space.
 * @param p_debounceDelay Optional, in milliseconds
 * 
 */
public setString(p_string: string, p_debounceDelay?: number): void {
    if (this._string === p_string) {
        return; // cancel
    }
    this._string = p_string;
    this._updateLeoObjectIndicatorDebounced(p_debounceDelay || 0);
}
</t>
<t tx="felix.20201214151451.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20201214151451.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR + this._string;
    (this._leoStatusBarItem.tooltip as vscode.MarkdownString).value = this._tooltip;
}

</t>
<t tx="felix.20201214154816.1">import * as vscode from "vscode";
import { Position } from "./core/leoNodes";
import { RClick } from "./core/mod_scripting";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214154816.10">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string | vscode.Uri;
    dark: string | vscode.Uri;
}

</t>
<t tx="felix.20201214154816.11">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    "initialFile": string;
    "title": string;
    "message": string;
    "filetypes": string[];
    "defaultExtension": string;
}

</t>
<t tx="felix.20201214154816.12">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    "ask": string;
    "message": string;
    "yes_all": boolean;
    "no_all": boolean;
}

</t>
<t tx="felix.20201214154816.13">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    "warn": string;
    "message": string;
}

</t>
<t tx="felix.20201214154816.14">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    "message": string;
}

</t>
<t tx="felix.20201214154816.15">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20201214154816.16">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20201214154816.17">/**
 * * Used by the minibuffer command pallette
 */
export interface MinibufferCommand extends vscode.QuickPickItem {
    func: string;
}
</t>
<t tx="felix.20201214154816.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // Re-use the old treeId with "NoReveal" for the selected node.
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20201214154816.4">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    excludeDetached?: boolean; // Body needs refresh EXCLUDE DETACHED

    scroll?: boolean; // Body needs to set and reveal text selection

    states?: boolean; // Currently opened tree view states needs refresh:
    // changed, canUndo, canRedo, canGoBack, canGoNext, canDemote, canPromote, 
    // canHoist, canDehoist, inChapter, topHoistChapter

    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
    goto?: boolean; // Goto pane needs refresh
}

</t>
<t tx="felix.20201214154816.7">/**
 * * General state flags for UI representation and controls visibility.
 */
export interface LeoPackageStates {
    changed: boolean; // Leo document has changed (is dirty)
    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'
    canGoBack: boolean; // Has history
    canGoNext: boolean; // Has used goBack at least once
    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted
    canDehoist: boolean; // Leo Document is currently hoisted and can be de-hoisted
    canHoist: boolean; // Selected node is not the first top node already root
    topIsChapter: boolean; // Top of the hoisted outline is an @chapter node
}

</t>
<t tx="felix.20201214154816.8">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20201214154816.9">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider
 */
export interface LeoButton {
    name: string;
    index: number;
    rclicks?: RClick[];
}

</t>
<t tx="felix.20201214194144.1">import * as vscode from "vscode";
import * as showdown from "showdown";
import { DebouncedFunc, debounce } from "lodash";

import * as utils from "./utils";
import * as commandBindings from "./commandBindings";
import { Constants } from "./constants";
import {
    RevealType,
    Icon,
    ReqRefresh,
    LeoPackageStates,
    ConfigSetting,
    LeoSearchSettings,
    Focus,
    BodySelectionInfo,
    CommandOptions,
    LeoGotoNavKey,
    LeoGuiFindTabManagerSettings,
    ChooseDocumentItem,
    LeoDocument,
    ChooseRClickItem,
    UnlType
} from "./types";

import { Config } from "./config";
import { LeoOutlineProvider } from './leoOutline';
import { LeoButtonNode, LeoButtonsProvider } from "./leoButtons";
import { LeoDocumentsProvider } from "./leoDocuments";
import { LeoStates } from "./leoStates";
import { LeoBodyProvider } from "./leoBody";
import { LeoUndoNode, LeoUndosProvider } from "./leoUndos";
import { LeoStatusBar } from "./leoStatusBar";

import * as g from './core/leoGlobals';
import { Commands } from "./core/leoCommands";
import { Position, VNode } from "./core/leoNodes";
import { LeoGotoNode, LeoGotoProvider } from "./leoGoto";
import { LeoFrame, StringTextWrapper } from "./core/leoFrame";
import { LeoFindPanelProvider } from "./leoFindPanelWebview";
import { LeoSettingsProvider } from "./leoSettingsWebview";
import { LeoFind } from "./core/leoFind";
import { NullGui } from "./core/leoGui";
import { StringFindTabManager } from "./core/findTabManager";
import { QuickSearchController } from "./core/quicksearch";
import { IdleTime } from "./core/idle_time";
import { RClick } from "./core/mod_scripting";
import { HelpPanel } from "./helpPanel";
import { UnlProvider } from "./unlProvider";
import { LeoBodyDetachedProvider } from "./leoBodyDetached";
import { Undoer } from "./core/leoUndo";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214194144.2">constructor(guiName = 'vscodeGui', private _context: vscode.ExtensionContext) {
    super(guiName);
    this.isNullGui = false;

    this.idleTimeClass = IdleTime;

    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);

    // * Set required vscode configs if needed
    this.config.checkEnablePreview(true);
    this.config.checkCloseEmptyGroups(true);
    this.config.removeOldBodyWrap();
    this.config.checkBodyWrap(true);

    // * also check workbench.editor.enablePreview
    this.config.buildFromSavedSettings();
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.undoIcons = utils.buildUndoIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);
    this.gotoIcons = utils.buildGotoIconPaths(_context);

    // * Debounced refresh flags and UI parts, along with language &amp; wrap, when operation(s) are done executing
    this.checkClosedTabs = debounce(
        this._checkClosedTabs,
        Constants.CLEANUP_DEBOUNCE_DELAY
    );
    this.refreshCommanderDetachedLanguage = debounce(
        this._refreshCommanderDetachedLanguage,
        Constants.DETACHED_LANGUAGE_DELAY
    );
    this.getStates = debounce(
        this._triggerGetStates,
        Constants.STATES_DEBOUNCE_DELAY
    );
    this.setTreeViewTitle = debounce(
        this._setTreeViewTitle,
        Constants.TITLE_DEBOUNCE_DELAY
    );
    this.refreshDocumentsPane = debounce(
        this._refreshDocumentsPane,
        Constants.DOCUMENTS_DEBOUNCE_DELAY
    );
    this.refreshButtonsPane = debounce(
        this._refreshButtonsPane,
        Constants.BUTTONS_DEBOUNCE_DELAY
    );
    this.refreshGotoPane = debounce(
        this._refreshGotoPane,
        Constants.GOTO_DEBOUNCE_DELAY
    );
    this.refreshUndoPane = debounce(
        this._refreshUndoPane,
        Constants.UNDOS_DEBOUNCE_DELAY
    );
    this.setUndoSelection = debounce(
        this._setUndoSelection,
        Constants.UNDOS_REVEAL_DEBOUNCE_DELAY
    );
    this.launchRefresh = debounce(
        this._launchRefresh,
        Constants.REFRESH_DEBOUNCE_DELAY
    );

    // * Create a single data provider for both outline trees, Leo view and Explorer view
    this._leoTreeProvider = new LeoOutlineProvider(this.nodeIcons, this);

    this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    this._context.subscriptions.push(
        this._leoTreeView,
        this._leoTreeView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeView))),
        this._leoTreeView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeView))),
        this._leoTreeView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, false)))
    );

    this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    this._context.subscriptions.push(
        this._leoTreeExView,
        this._leoTreeExView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeExView))),
        this._leoTreeExView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeExView))),
        this._leoTreeExView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, true)))
    );

    if (this.config.treeInExplorer) {
        this._lastTreeView = this._leoTreeExView;
    } else {
        this._lastTreeView = this._leoTreeView;
    }

    // * Help panel helper
    this.showdownConverter = new showdown.Converter();

    // * Configuration / Welcome webview
    this.leoSettingsWebview = new LeoSettingsProvider(this._context, this);
}

</t>
<t tx="felix.20201214194144.3"></t>
<t tx="felix.20201214194144.4"></t>
<t tx="felix.20201214194144.5"></t>
<t tx="felix.20201214194144.6"></t>
<t tx="felix.20201214194144.7"></t>
<t tx="felix.20201214194144.8"></t>
<t tx="felix.20201214195752.1">/**
 * Creates and manages instances of the UI elements along with their events
 */
export class LeoUI extends NullGui {
    // * State flags
    public leoStates: LeoStates;
    public verbose: boolean = true;
    public trace: boolean = false; //true;

    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE; // VScode's outline pane title: Might need to be re-set when switching visibility
    private _hasShownContextOpenMessage: boolean = false;

    // * Help Panel
    public helpPanelText = '# LeoJS Help Panel\n\nDocumentation given by \'help\' commands is shown here.\n\nUse Alt+X to open the minibuffer and type \'help\'';
    public helpDocumentPaneProvider!: HelpPanel;

    // * UNL link provider
    public linkProvider!: UnlProvider;

    // * Timers
    public refreshTimer: [number, number] | undefined; // until the selected node is found - even if already started refresh
    public lastRefreshTimer: [number, number] | undefined; // until the selected node is found - refreshed even if not found
    public commandRefreshTimer: [number, number] | undefined; // until the selected node is found -  keep if starting a new command already pending
    public lastCommandRefreshTimer: [number, number] | undefined; // until the selected node is found - refreshed if starting a new command
    public commandTimer: [number, number] | undefined; // until the command done - keep if starting a new one already pending
    public lastCommandTimer: [number, number] | undefined; // until the command done - refreshed if starting a new one

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, and leoNode for inverted contrast

    // * Icon Paths (Singleton static arrays)
    public nodeIcons: Icon[] = [];
    public undoIcons: Icon[] = [];
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];
    public gotoIcons: Icon[] = [];

    // * Refresh Cycle
    private _refreshType: ReqRefresh = {}; // Flags for commands to require parts of UI to refresh
    private _revealType: RevealType = RevealType.NoReveal; // Type of reveal for the selected node (when refreshing outline)
    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing.
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    public finalFocus: Focus = Focus.NoChange; // Set in _setupRefresh : Last command issued had focus on outline, as opposed to the body
    public showBodyIfClosed: boolean = false;
    public showOutlineIfClosed: boolean = false;
    public refreshPreserveRange = false; // this makes the next refresh cycle preserve the "findFocusTree" flag once.

    private __refreshNode: Position | undefined; // Set in _setupRefresh : Last command issued a specific node to reveal
    private _lastRefreshNodeTS: number = 0;
    get _refreshNode(): Position | undefined {
        return this.__refreshNode;
    }
    set _refreshNode(p_ap: Position | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this.__refreshNode = p_ap;
        this._lastRefreshNodeTS = utils.performanceNow();
    }

    // * Outline Pane
    private _leoTreeProvider!: LeoOutlineProvider; // TreeDataProvider single instance
    private _leoTreeView!: vscode.TreeView&lt;Position&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExView!: vscode.TreeView&lt;Position&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastTreeView!: vscode.TreeView&lt;Position&gt;; // Last visible treeview
    private _pendingReveal: Thenable&lt;void&gt; | undefined;
    private _nextRevealParams: {
        tree: vscode.TreeView&lt;Position&gt;, element: Position, options?: {
            select?: boolean;
            focus?: boolean;
            expand?: boolean | number;
        }
    } | undefined;

    private _revealNodeRetriedRefreshOutline: boolean = false; // USED IN _refreshOutline and _revealNode

    private _lastSelectedNode: Position | undefined;
    private _lastSelectedNodeTS: number = 0;
    get lastSelectedNode(): Position | undefined {
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_ap: Position | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this._lastSelectedNode = p_ap;
        this._lastSelectedNodeTS = utils.performanceNow();
    }

    // * Find panel
    private _leoFindPanelProvider!: vscode.WebviewViewProvider;
    private _findPanelWebviewView: vscode.WebviewView | undefined;
    private _findPanelWebviewExplorerView: vscode.WebviewView | undefined;
    private _lastFindView: vscode.WebviewView | undefined;  // ? Maybe unused ?
    private _findNeedsFocus: number = 0; // 0 none, 1 find, 2 nav
    private _lastSettingsUsed: LeoSearchSettings | undefined; // Last settings loaded / saved for current document
    public findFocusTree = false;
    public findHeadlineRange: [number, number] = [0, 0];
    public findHeadlinePosition: Position | undefined;

    // * Help Panel
    public showdownConverter: showdown.Converter;
    private _helpPanel: vscode.WebviewPanel | undefined;

    // * Interactive Find Input
    private _interactiveSearchInputBox: vscode.InputBox | undefined;
    private _interactiveSearchOptions: {
        search: string,
        replace: string,
        word: boolean,
        regex: boolean,
        backward: boolean
    } = {
            search: "",
            replace: "",
            word: false,
            regex: false,
            backward: false
        };

    // * Reveal Timers
    private _gotSelectedNodeBodyTimer: undefined | NodeJS.Timeout;
    private _gotSelectedNodeRevealTimer: undefined | NodeJS.Timeout;
    private _showBodySwitchBodyTimer: undefined | NodeJS.Timeout;
    private _leoDocumentsRevealTimer: undefined | NodeJS.Timeout;

    // * Reveal Promises
    private _documentPaneReveal: Thenable&lt;void&gt; | undefined;
    private _undoPaneReveal: Thenable&lt;void&gt; | undefined;

    // * Documents Pane
    private _leoDocumentsProvider!: LeoDocumentsProvider;
    private _leoDocuments!: vscode.TreeView&lt;LeoFrame&gt;;
    private _leoDocumentsExplorer!: vscode.TreeView&lt;LeoFrame&gt;;
    private _lastLeoDocuments: vscode.TreeView&lt;LeoFrame&gt; | undefined;

    // * Goto nav panel
    public leoGotoProvider!: LeoGotoProvider;
    // private _leoGoto!: vscode.TreeView&lt;LeoGotoNode&gt;;
    // private _leoGotoExplorer!: vscode.TreeView&lt;LeoGotoNode&gt;;
    // public lastGotoContent: LeoGotoNode[] = [];

    // * '@button' pane
    private _leoButtonsProvider!: LeoButtonsProvider;
    private _leoButtons!: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer!: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _rclickSelected: number[] = [];
    private _lastLeoButtons: vscode.TreeView&lt;LeoButtonNode&gt; | undefined;

    // * Undos pane
    private _leoUndosProvider!: LeoUndosProvider;
    private _leoUndos!: vscode.TreeView&lt;LeoUndoNode&gt;;
    private _leoUndosShown = false;
    private _leoUndosExplorer!: vscode.TreeView&lt;LeoUndoNode&gt;;
    private _leoUndosExplorerShown = false;
    private _lastLeoUndos: vscode.TreeView&lt;LeoUndoNode&gt; | undefined;

    // * Body pane
    private _changedBodyWithMirrorDetached: string | undefined = undefined; // "id/gnx" string as true
    private _changedDetachedWithMirrorBody: string | undefined = undefined; // "id/gnx" string as true
    private _bodyFileSystemStarted: boolean = false;
    private _detachedFileSystemStarted: boolean = false;
    private _bodyEnablePreview: boolean = true;
    private _leoFileSystem!: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _leoDetachedFileSystem!: LeoBodyDetachedProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    public bodyDetachedTextDocument: vscode.TextDocument | undefined; // Last active detached body.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _languageFlagged: string[] = [];

    private _bodyPreviewMode: boolean = true;

    private _editorTouched: boolean = false; // Flag for applying editor changes to body when 'icon' state change and 'undo' back to untouched

    private _bodyStatesTimer: NodeJS.Timeout | undefined;

    private _bodyUri: vscode.Uri = utils.strToLeoUri("");
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setNewBodyUriTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * Selection &amp; scroll
    private _selectionDirty: boolean = false; // Flag set when cursor selection is changed
    private _selectionGnx: string = ''; // Packaged into 'BodySelectionInfo' structures, sent to Leo
    private _selection: vscode.Selection | undefined; // also packaged into 'BodySelectionInfo'
    private _scrollDirty: boolean = false; // Flag set when cursor selection is changed
    private _scrollGnx: string = '';
    private _scroll: vscode.Range | undefined;

    // * Settings / Welcome webview
    public leoSettingsWebview: LeoSettingsProvider;

    // * Log Pane
    private _leoLogPane: vscode.OutputChannel | undefined;

    // * Status Bar
    private _leoStatusBar: LeoStatusBar | undefined;

    // * Edit/Insert Headline Input Box System made with 'createInputBox'.
    private _hib: undefined | vscode.InputBox;
    private _hibResolve: undefined | ((value: string | PromiseLike&lt;string | undefined&gt; | undefined) =&gt; void);
    private _onDidHideResolve: undefined | ((value: PromiseLike&lt;void&gt; | undefined) =&gt; void);
    private _hibLastValue: undefined | string;
    private _hibInterrupted = false;
    private _hibDisposables: vscode.Disposable[] = [];

    // * Timing
    private _needLastSelectedRefresh = false; // USED IN showBody
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged
    private _bodyLastChangedDocumentSaved: boolean = true; // don't use 'isDirty' of the document!

    // * Debounced method used to check for closed detached/body tabs
    public checkClosedTabs: (() =&gt; void);

    // * Debounced method used to refresh language of the active commander's detached bodies 
    public refreshCommanderDetachedLanguage: (() =&gt; void);

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void);

    // * Debounced method used to set the outline tree title
    public setTreeViewTitle: (() =&gt; void);

    // * Debounced method used to get opened Leo Files for the documents pane
    public refreshDocumentsPane: (() =&gt; void);

    // * Debounced method used to get content of the at-buttons pane
    public refreshButtonsPane: (() =&gt; void);

    // * Debounced method used to get content of the goto pane
    public refreshGotoPane: (() =&gt; void);

    // * Debounced method used to get content of the undos pane
    public refreshUndoPane: (() =&gt; void);

    // * Debounced method used to set focused element of the undos pane
    public setUndoSelection: ((p_node: LeoUndoNode) =&gt; void);

    // * Debounced method for refreshing the UI
    public launchRefresh: DebouncedFunc&lt;() =&gt; Promise&lt;unknown&gt;&gt;;

    @others
}

</t>
<t tx="felix.20201214202058.1">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {

    const c = g.app.windowList[this.frameIndex].c;

    if (this._refreshType.states) {
        this._refreshType.states = false;
        const p = c.p;
        if (this._leoStatusBar &amp;&amp; p &amp;&amp; p.v) {
            const unl = c.frame.computeStatusUnl(p);
            this._leoStatusBar.setString(unl);
            this._leoStatusBar.setTooltip(p.h);
        }
        let w_canHoist = true;
        let w_topIsChapter = false;
        if (c.hoistStack.length) {
            const w_ph = c.hoistStack[c.hoistStack.length - 1].p;
            w_topIsChapter = w_ph.h.startsWith('@chapter ');
            if (p.__eq__(w_ph)) {
                // p is already the hoisted node
                w_canHoist = false;
            }
        } else {
            // not hoisted, was it the single top child of the real root?
            if (c.rootPosition()!.__eq__(p) &amp;&amp; c.hiddenRootNode.children.length === 1) {
                w_canHoist = false;
            }
        }
        const w_states: LeoPackageStates = {
            changed: c.changed, // Document has changed (is dirty)
            canUndo: c.canUndo(), // Document can undo the last operation done
            canRedo: c.canRedo(), // Document can redo the last operation 'undone'
            canGoBack: c.nodeHistory.beadPointer &gt; 0,
            canGoNext: c.nodeHistory.beadPointer + 1 &lt; c.nodeHistory.beadList.length,
            canDemote: c.canDemote(), // Selected node can have its siblings demoted
            canPromote: c.canPromote(), // Selected node can have its children promoted
            canDehoist: c.canDehoist(), // Document is currently hoisted and can be de-hoisted
            canHoist: w_canHoist,
            topIsChapter: w_topIsChapter
            // 
        };
        this.leoStates.setLeoStateFlags(w_states);
        this.refreshUndoPane();
    }
    // Set leoChanged and leoOpenedFilename
    this.leoStates.leoChanged = c.changed;
    this.leoStates.leoOpenedFileName = c.fileName();

    this.refreshBodyStates(); // Set language and wrap states, if different.

    if (this._refreshType.documents) {
        this._refreshType.documents = false;
        this.refreshDocumentsPane();
    }
    if (this._refreshType.goto) {
        this._refreshType.goto = false;
        this.refreshGotoPane();
    }
    if (this._refreshType.buttons) {
        this._refreshType.buttons = false;
        this.refreshButtonsPane();
    }
}

</t>
<t tx="felix.20201214202118.1">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public showOutline(p_focusOutline?: boolean): void {
    const c = g.app.windowList[this.frameIndex].c;
    this.safeReveal(this._lastTreeView, c.p, {
        select: true,
        focus: !!p_focusOutline
    }).then(
        () =&gt; { }, // Ok
        (p_error) =&gt; {
            console.log('showOutline could not reveal');
        }
    );
}

</t>
<t tx="felix.20201214202123.1">/**
 * * Public method exposed as 'refreshDocumentsPane' setter/getter to refresh the documents pane
 * Document Panel May be refreshed by other services (states service, ...)
 */
private _refreshDocumentsPane(): void {
    this._leoDocumentsProvider.refreshTreeRoot();
    this.checkConfirmBeforeClose();
}

</t>
<t tx="felix.20201214202625.1">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private async _onChangeCollapsedState(p_event: vscode.TreeViewExpansionEvent&lt;Position&gt;, p_expand: boolean, p_treeView: vscode.TreeView&lt;Position&gt;): Promise&lt;unknown&gt; {

    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo.
    await this.triggerBodySave(true); // Get any modifications from the editor into the Leo's body model
    if (p_treeView.selection.length &amp;&amp; p_treeView.selection[0] &amp;&amp; p_treeView.selection[0].__eq__(p_event.element)) {
        // * This happens if the tree selection is the same as the expanded/collapsed node: Just have Leo do the same
        // pass
    } else {
        // * This part only happens if the user clicked on the arrow without trying to select the node
        if (this.config.leoTreeBrowse) {
            // * This part only happens if the user clicked on the arrow without trying to select the node
            void this._revealNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
            void this.selectTreeNode(p_event.element, true); // not waiting for a .then(...) so not to add any lag
        }
    }

    // * vscode will update its tree by itself, but we need to change Leo's model of its outline
    if (p_expand) {
        return p_event.element.expand();
    } else {
        return p_event.element.contract();
    }
}

</t>
<t tx="felix.20201214202627.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (!this.leoStates.leoReady || !this.leoStates.leojsStartupDone || !this.leoStates.fileOpenedReady) {
        return;
    }
    if (p_event.visible) {
        this._lastTreeView = p_explorerView ? this._leoTreeExView : this._leoTreeView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        if (this.leoStates.fileOpenedReady) {
            this.loadSearchSettings();
        }
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20201214202631.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._lastLeoDocuments = p_explorerView ? this._leoDocumentsExplorer : this._leoDocuments;
        this.refreshDocumentsPane(); // List may not have changed, but it's selection may have
    }
}

</t>
<t tx="felix.20201214202634.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._lastLeoButtons = p_explorerView ? this._leoButtonsExplorer : this._leoButtons;
    }
}

</t>
<t tx="felix.20201214202749.1">/**
 * * Called by UI when the user selects in the tree (click or 'open aside' through context menu)
 * @param p_node is the position node selected in the tree
 * @param p_internalCall Flag used to indicate the selection is forced, and NOT originating from user interaction
 * @param p_aside Flag to force opening the body "Aside", i.e. when the selection was made from choosing "Open Aside"
 * @returns thenable for reveal to finish or select position to finish
 */
public async selectTreeNode(
    p_node: Position,
    p_internalCall?: boolean,
    // p_aside?: boolean
    // // p_reveal?: boolean, p_aside?: boolean
): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true); // Needed for self-selection to avoid 'cant save file is newer...'

    const c = p_node.v.context;

    g.doHook("headclick1", { c: c, p: p_node, v: p_node });

    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    // if (
    //     p_aside &amp;&amp;
    //     c.positionExists(p_node) &amp;&amp;
    //     !p_node.__eq__(this.lastSelectedNode)
    // ) {
    //     void this._revealNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    // }

    this.showBodyIfClosed = true;

    this.leoStates.setSelectedNodeFlags(p_node);

    // const w_showBodyKeepFocus = p_aside
    //     ? this.config.treeKeepFocusWhenAside
    //     : this.config.treeKeepFocus;

    // * Check if having already this exact node position selected : Just show the body and exit
    // (other tree nodes with same gnx may have different syntax language coloring because of parents lineage)
    if (p_node.__eq__(this.lastSelectedNode)) {
        this._locateOpenedBody(p_node.gnx); // LOCATE NEW GNX
        g.doHook("headclick2", { c: c, p: p_node, v: p_node });
        // MAYBE DETACHED BODY CHANGED THAT CONTENT!
        // only if NOT watched (otherwise would have already been opened and altered by detached modification)
        if (!this._leoFileSystem.watchedBodiesGnx.includes(p_node.gnx)) {
            this._leoFileSystem.setNewBodyUriTime(utils.strToLeoUri(p_node.gnx));
        }

        return this.showBody(false, this.config.treeKeepFocus).catch((p_error) =&gt; {
            return Promise.resolve(); // intercept cancellation as success: next one is going to replace anyways.
        });
        // Voluntary exit
    }

    // * Set selected node in Leo
    c.selectPosition(p_node);

    if (!p_internalCall) {
        if (this.findFocusTree) {
            // had a range but now refresh from other than find/replace
            // So make sure tree is also refreshed.
            this.findFocusTree = false;
            this.setupRefresh(
                Focus.Outline,
                {
                    tree: true,
                    body: true,
                    // documents: false,
                    // buttons: false,
                    // states: false,
                }
            );
            g.doHook("headclick2", { c: c, p: p_node, v: p_node });
            return this._launchRefresh();
        }
        this._refreshType.states = true;
        this.getStates();
    }
    g.doHook("headclick2", { c: c, p: p_node, v: p_node });
    // * Apply the node to the body text without waiting for the selection promise to resolve
    return this._tryApplyNodeToBody(p_node, false, this.config.treeKeepFocus);

}

</t>
<t tx="felix.20201214202755.1">/**
 * Leo Command
 * @param p_cmd Command name string
 * @param p_options: CommandOptions for the command
 */
public async command(
    p_cmd: string,
    p_options: CommandOptions
): Promise&lt;unknown&gt; {
    this.lastCommandTimer = process.hrtime();
    if (this.commandTimer === undefined) {
        this.commandTimer = this.lastCommandTimer;
    }
    this.lastCommandRefreshTimer = this.lastCommandTimer;
    if (this.commandRefreshTimer === undefined) {
        this.commandRefreshTimer = this.lastCommandTimer;
    }

    await this.triggerBodySave(true);

    if (p_options.isNavigation) {
        // If any navigation command is used from outline or command palette: show body.
        this.showBodyIfClosed = true;
        // If alt+arrow is used to navigate: SHOW and leave focus on outline.
        this.showOutlineIfClosed = true;

        if (p_options.refreshType.body) {
            // If this is a navigation command, dont refresh DETACHED
            p_options.refreshType.excludeDetached = true;
        }
    }

    const c = g.app.windowList[this.frameIndex].c;
    this.setupRefresh(p_options.finalFocus, p_options.refreshType);

    let value: any = undefined;
    const p = p_options.node ? p_options.node : c.p;

    let w_offset = 0;
    if (p_options.keepSelection) {
        if (Constants.OLD_POS_OFFSETS.DELETE.includes(p_cmd)) {
            w_offset = -1;
        } else if (Constants.OLD_POS_OFFSETS.ADD.includes(p_cmd)) {
            w_offset = 1;
        }
    }

    try {
        if (p.__eq__(c.p)) {
            value = c.doCommandByName(p_cmd); // no need for re-selection
        } else {
            const old_p = c.p;
            c.selectPosition(p);
            value = c.doCommandByName(p_cmd);
            if (p_options.keepSelection) {
                if (value &amp;&amp; value.then) {
                    void (value as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
                        if (c.positionExists(old_p)) {
                            c.selectPosition(old_p);
                        } else {
                            old_p._childIndex = old_p._childIndex + w_offset;
                            if (c.positionExists(old_p)) {
                                c.selectPosition(old_p);
                            }
                        }
                    });
                } else {
                    if (c.positionExists(old_p)) {
                        c.selectPosition(old_p);
                    } else {
                        old_p._childIndex = old_p._childIndex + w_offset;
                        if (c.positionExists(old_p)) {
                            c.selectPosition(old_p);
                        }
                    }
                }
            }
        }
    } catch (e) {
        void vscode.window.showErrorMessage("LeoUI Error: " + e);
    }

    if (this.trace) {
        if (this.lastCommandTimer) {
            console.log('lastCommandTimer', utils.getDurationMs(this.lastCommandTimer));
        }
    }

    this.lastCommandTimer = undefined;

    if (value &amp;&amp; value.then) {
        void (value as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
            void this.launchRefresh();
        });
        return value;
    } else {
        void this.launchRefresh();
        return Promise.resolve(value); // value may be a promise but it will resolve all at once.
    }

}

</t>
<t tx="felix.20201214202757.1">/**
 * Opens quickPick minibuffer pallette to choose from all commands in this file's Thenable
 * @returns Promise from the command resolving - or resolve with undefined if cancelled
 */
public async minibuffer(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const c = g.app.windowList[this.frameIndex].c;
    const commands: vscode.QuickPickItem[] = [];
    const cDict = c.commandsDict;
    for (let key in cDict) {
        const command = cDict[key];
        // Going to get replaced. Don't take those that begin with 'async-'
        const w_name = (command as any).__name__ || '';
        if (!w_name.startsWith('async-')) {
            commands.push({
                label: key,
                detail: (command as any).__doc__
            });
        }
    }

    const w_noDetails: vscode.QuickPickItem[] = [];
    const stash_button: string[] = [];
    const stash_rclick: string[] = [];
    const stash_command: string[] = [];

    for (const w_com of commands) {
        if (
            !w_com.detail &amp;&amp; !(
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START) ||
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START) ||
                w_com.label === Constants.USER_MESSAGES.MINIBUFFER_SCRIPT_BUTTON ||
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_DEL_SCRIPT_BUTTON) ||
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_DEL_BUTTON_START) ||
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START)
            )
        ) {
            w_noDetails.push(w_com);
        }

        if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START)) {
            stash_button.push(w_com.label);
        }
        if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START)) {
            stash_rclick.push(w_com.label);
        }
        if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START)) {
            stash_command.push(w_com.label);
        }
    }

    for (const p_command of w_noDetails) {
        if (stash_button.includes(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START + p_command.label)) {
            p_command.description = Constants.USER_MESSAGES.MINIBUFFER_BUTTON;
        }
        if (stash_rclick.includes(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START + p_command.label)) {
            p_command.description = Constants.USER_MESSAGES.MINIBUFFER_RCLICK;
        }
        if (stash_command.includes(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START + p_command.label)) {
            p_command.description = Constants.USER_MESSAGES.MINIBUFFER_COMMAND;
        }
        p_command.description = p_command.description ? p_command.description : Constants.USER_MESSAGES.MINIBUFFER_USER_DEFINED;
    }

    const w_withDetails = commands.filter(p_command =&gt; !!p_command.detail);

    // Only sort 'regular' Leo commands, leaving custom commands at the top
    w_withDetails.sort((a, b) =&gt; {
        return a.label &lt; b.label ? -1 : (a.label === b.label ? 0 : 1);
    });

    const w_choices: vscode.QuickPickItem[] = [];

    if (c.commandHistory.length) {
        w_choices.push(Constants.MINIBUFFER_QUICK_PICK);
    }

    // Finish minibuffer list
    if (w_noDetails.length) {
        w_choices.push(...w_noDetails);
    }

    // Separator above real commands, if needed...
    if (w_noDetails.length || c.commandHistory.length) {
        w_choices.push({
            label: "", kind: vscode.QuickPickItemKind.Separator
        });
    }

    w_choices.push(...w_withDetails);

    const w_disposables: vscode.Disposable[] = [];

    const q_minibufferQuickPick: Promise&lt;vscode.QuickPickItem | undefined&gt; = new Promise((resolve, reject) =&gt; {
        const quickPick = vscode.window.createQuickPick();
        quickPick.items = w_choices;
        quickPick.placeholder = Constants.USER_MESSAGES.MINIBUFFER_PROMPT;
        quickPick.matchOnDetail = true;

        w_disposables.push(
            quickPick.onDidChangeSelection(selection =&gt; {
                if (selection[0]) {
                    resolve(selection[0]);
                    quickPick.hide();
                }
            }),
            quickPick.onDidAccept(accepted =&gt; {
                if (/^\d+$/.test(quickPick.value)) {
                    // * Was an integer
                    this.setupRefresh(Focus.Body,
                        {
                            tree: true,
                            body: true,
                            documents: false,
                            buttons: false,
                            states: true
                        }
                    );
                    // not awaited
                    c.editCommands.gotoGlobalLine(Number(quickPick.value)).then(() =&gt; {
                        void this.launchRefresh();
                    }, () =&gt; {
                        // pass
                    });
                    resolve(undefined);
                    quickPick.hide();
                }
            }),
            quickPick.onDidChangeValue(changed =&gt; {
                if (/^\d+$/.test(changed)) {
                    if (quickPick.items.length) {
                        quickPick.items = [];
                    }
                } else if (quickPick.items !== w_choices) {
                    quickPick.items = w_choices;
                }
            }),
            quickPick.onDidHide(() =&gt; {
                resolve(undefined);
            }),
            quickPick
        );
        quickPick.show();

    });

    const w_picked: vscode.QuickPickItem | undefined = await q_minibufferQuickPick;

    w_disposables.forEach(d =&gt; d.dispose());

    // First, check for undo-history list being requested
    if (w_picked &amp;&amp; w_picked.label === Constants.USER_MESSAGES.MINIBUFFER_HISTORY_LABEL) {
        return this._showMinibufferHistory(w_choices);
    }
    if (w_picked) {
        return this._doMinibufferCommand(w_picked);
    }
}

</t>
<t tx="felix.20201214202759.1">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_prompt Optional prompt, to override the default 'edit headline' prompt. (for insert-* commands usage)
 * @returns Thenable that resolves when done
 */
public async editHeadline(p_node?: Position, p_fromOutline?: boolean, p_prompt?: string): Promise&lt;Position&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const u = c.undoer;
    const w_p: Position = p_node || c.p;

    if (this._hib &amp;&amp; this._hib.enabled) {
        return Promise.resolve(w_p); // DO NOT REACT IF ALREADY EDITING A HEADLINE! 
    }

    await this.triggerBodySave(true);

    let w_finalFocus: Focus = p_fromOutline ? Focus.Outline : Focus.Body; // Use w_fromOutline for where we intend to leave focus when done with the insert

    this.setupRefresh(
        w_finalFocus,
        { tree: true, states: true }
    );

    const w_headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: w_p.h,  // preset input pop up
        valueSelection: undefined,
        prompt: p_prompt || Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE,
    };
    let p_newHeadline = await this._showHeadlineInputBox(w_headlineInputOptions);

    if ((p_newHeadline || p_newHeadline === "") &amp;&amp; p_newHeadline !== "\n") {
        let w_truncated = false;
        if (p_newHeadline.indexOf("\n") &gt;= 0) {
            p_newHeadline = p_newHeadline.split("\n")[0];
            w_truncated = true;
        }
        if (p_newHeadline.length &gt; 1000) {
            p_newHeadline = p_newHeadline.substring(0, 1000);
            w_truncated = true;
        }

        if (p_newHeadline &amp;&amp; w_p &amp;&amp; w_p.h !== p_newHeadline) {
            if (w_truncated) {
                void vscode.window.showInformationMessage("Truncating headline");
            }

            const undoData = u.beforeChangeHeadline(w_p);
            c.setHeadString(w_p, p_newHeadline); // Set v.h *after* calling the undoer's before method.
            if (!c.changed) {
                c.setChanged();
            }
            u.afterChangeHeadline(w_p, 'Edit Headline', undoData);
            void this.launchRefresh();
        }

    } else {
        if (p_fromOutline) {
            this.showOutline(true);
        }
    }
    if (this._onDidHideResolve) {
        this._onDidHideResolve(undefined);
        this._onDidHideResolve = undefined;
    }
    return w_p;
}

</t>
<t tx="felix.20201214202800.1">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_asChild Insert as child instead of as sibling
 * @returns Thenable that resolves when done
 */
public async insertNode(p_node: Position | undefined, p_fromOutline: boolean, p_asChild: boolean): Promise&lt;unknown&gt; {

    let w_hadHib = false;
    if (this._hib &amp;&amp; this._hib.enabled) {
        w_hadHib = true;
    }

    if (!this.isOutlineVisible()) {
        p_fromOutline = false;
    }

    let w_finalFocus: Focus = p_fromOutline ? Focus.Outline : Focus.Body; // Use w_fromOutline for where we intend to leave focus when done with the insert
    if (w_hadHib) {
        this._focusInterrupt = true; // this will affect next refresh by triggerbodysave, not the refresh of this pass
    }

    await this.triggerBodySave(true);

    // * if node has child and is expanded: turn p_asChild to true!
    const w_headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: Constants.USER_MESSAGES.DEFAULT_HEADLINE,
        valueSelection: undefined,
        prompt: p_asChild ? Constants.USER_MESSAGES.PROMPT_INSERT_CHILD : Constants.USER_MESSAGES.PROMPT_INSERT_NODE
    };

    if (w_hadHib &amp;&amp; !this.isOutlineVisible()) {
        await new Promise((p_resolve, p_reject) =&gt; {
            setTimeout(() =&gt; {
                p_resolve(undefined);
            }, 60);
        });
    }

    const p_newHeadline = await this._showHeadlineInputBox(w_headlineInputOptions);

    if (this._hibInterrupted) {
        w_finalFocus = Focus.NoChange;
        this._hibInterrupted = false;
    }

    this.lastCommandTimer = process.hrtime();
    if (this.commandTimer === undefined) {
        this.commandTimer = this.lastCommandTimer;
    }
    this.lastCommandRefreshTimer = this.lastCommandTimer;
    if (this.commandRefreshTimer === undefined) {
        this.commandRefreshTimer = this.lastCommandTimer;
    }

    const c = g.app.windowList[this.frameIndex].c;

    let value: any = undefined;
    const p = p_node ? p_node : c.p;

    const w_refreshType: ReqRefresh = { documents: true, buttons: true, states: true };
    if (!this.isOutlineVisible()) {

    }
    if (this.isOutlineVisible()) {
        w_refreshType.tree = true;
    } else {
        w_refreshType.body = true;
    }

    if (p.__eq__(c.p)) {
        w_refreshType.body = true;
        this.setupRefresh(w_finalFocus, w_refreshType);
        this._insertAndSetHeadline(p_newHeadline, p_asChild); // no need for re-selection
    } else {
        const old_p = c.p;  // c.p is old already selected
        c.selectPosition(p); // p is now the new one to be operated on
        this._insertAndSetHeadline(p_newHeadline, p_asChild);
        // Only if 'keep' old position was needed (specified with a p_node parameter), and old_p still exists
        if (!!p_node &amp;&amp; c.positionExists(old_p)) {
            // no need to refresh body
            this.setupRefresh(w_finalFocus, w_refreshType);
            c.selectPosition(old_p);
        } else {
            old_p._childIndex = old_p._childIndex + 1;
            if (!!p_node &amp;&amp; c.positionExists(old_p)) {
                // no need to refresh body
                this.setupRefresh(w_finalFocus, w_refreshType);
                c.selectPosition(old_p);
            } else {
                w_refreshType.body = true;
                this.setupRefresh(w_finalFocus, w_refreshType);
            }
        }
    }
    if (this.trace) {
        if (this.lastCommandTimer) {
            console.log('lastCommandTimer', utils.getDurationMs(this.lastCommandTimer));
        }
    }
    this.lastCommandTimer = undefined;

    if (this._onDidHideResolve) {
        this._onDidHideResolve(undefined);
        this._onDidHideResolve = undefined;
    } else {
        // pass
    }
    void this.launchRefresh();

    return value;

}

</t>
<t tx="felix.20201214205159.1">@language json
@tabwidth -2
{
  "name": "leojs",
  "displayName": "Leo Editor for Visual Studio Code",
  "description": "LeoJS — The literate editor with outline javaScript implementation",
  "version": "0.2.15",
  "publisher": "boltex",
  "author": {
    "name": "Félix Malboeuf"
  },
  "sponsor": {
    "url": "https://boltex.github.io/"
  },
  "license": "SEE LICENSE IN LICENSE",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leojs"
  },
  "engines": {
    "vscode": "^1.86.0"
  },
  "keywords": [
    "leo",
    "tree",
    "outline",
    "editor",
    "literate"
  ],
  "categories": [
    "Other"
  ],
  "galleryBanner": {
    "color": "#f7e6c6",
    "theme": "light"
  },
  "preview": true,
  "activationEvents": [
    "onStartupFinished"
  ],
  "qna": false,
  "main": "./dist/extension-node",
  "browser": "./dist/extension-web",
  "icon": "resources/leoapp256px.png",
  "contributes": {
    &lt;&lt; contributes &gt;&gt;
  },
  "scripts": {
    &lt;&lt; scripts &gt;&gt;
  },
  "devDependencies": {
    &lt;&lt; devDependencies &gt;&gt;
  },
  "dependencies": {
    &lt;&lt; dependencies &gt;&gt;
  },
  "gitCommit": "ab1fca4",
  "gitBranch": "devel",
  "gitDate": "2024-07-11 20:40:45 -0400"
}
</t>
<t tx="felix.20201214205159.10">{
  "command": "leojs.openLeoFile",
  "title": "Open with LeoJS",
  "category": "Leojs",
  "enablement": "leojsReady",
  "icon": "$(leojs-folder)"
},
{
  "command": "leojs.revert",
  "category": "Leojs",
  "enablement": "leojsReady &amp;&amp; leojsTreeOpened &amp;&amp; leojsTreeTitled",
  "shortTitle": "Revert Leo outline to last saved contents",
  "title": "Revert"
},
{
  "command": "leojs.recentLeoFiles",
  "title": "Recent Files",
  "category": "Leojs",
  "enablement": "leojsReady",
  "icon": "$(leojs-open-recent)"
},
{
  "command": "leojs.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leojs",
  "enablement": "leojsReady &amp;&amp; leojsTreeOpened",
  "icon": "$(leojs-switch)"
},
{
  "command": "leojs.newLeoFile",
  "title": "New Leo File",
  "category": "Leojs",
  "enablement": "leojsReady",
  "icon": "$(leojs-new-file)"
},
{
  "command": "leojs.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-close)"
},
{
  "command": "leojs.saveLeoFile",
  "category": "Leojs",
  "title": "Save Leo File",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-save)"
},
{
  "command": "leojs.saveLeoFileFromOutline",
  "category": "Leojs",
  "title": "Save Leo File",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-save)"
},
{
  "command": "leojs.saveAsLeoFile",
  "category": "Leojs",
  "title": "Save Leo File as...",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-save-as)"
},
{
  "command": "leojs.saveAsLeoJsFile",
  "category": "Leojs",
  "title": "Save a copy as leojs File...",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-save-as-leojs)"
},
{
  "command": "leojs.refreshFromDisk",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened &amp;&amp; leojsTreeTitled",
  "icon": "$(leojs-refresh)"
},
{
  "command": "leojs.refreshFromDiskSelection",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened &amp;&amp; LeojsAtFile &amp;&amp; leojsTreeTitled",
  "icon": "$(leojs-refresh)"
},
{
  "command": "leojs.refreshFromDiskSelectionFromOutline",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened &amp;&amp; LeojsAtFile &amp;&amp; leojsTreeTitled",
  "icon": "$(leojs-refresh)"
},
{
  "command": "leojs.writeAtFileNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write @&lt;file&gt; Nodes",
  "icon": "$(leojs-write-at-file-nodes)"
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write @&lt;file&gt; Nodes",
  "icon": "$(leojs-write-at-file-nodes)"
},
{
  "command": "leojs.writeDirtyAtFileNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write Dirty @&lt;file&gt; Nodes",
  "icon": "$(leojs-write-dirty-at-file-nodes)"
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write Dirty @&lt;file&gt; Nodes",
  "icon": "$(leojs-write-dirty-at-file-nodes)"
},
{
  "command": "leojs.gitDiff",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Git Diff"
},
{
  "command": "leojs.tabCycleNext",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Tab Cycle Next"
},
</t>
<t tx="felix.20201214205159.11">{
  "command": "leojs.openAside",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Open Aside"
},
{
  "command": "leojs.contractAll",
  "category": "Leojs",
  "title": "Contract All",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-collapse)"
},
{
  "command": "leojs.contractAllFromOutline",
  "category": "Leojs",
  "title": "Contract All",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-collapse)"
},
{
  "command": "leojs.prev",
  "category": "Leojs",
  "title": "Prev",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanGoBack",
  "icon": "$(leojs-prev)"
},
{
  "command": "leojs.prevFromOutline",
  "category": "Leojs",
  "title": "Prev",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanGoBack",
  "icon": "$(leojs-prev)"
},
{
  "command": "leojs.next",
  "category": "Leojs",
  "title": "Next",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanGoNext",
  "icon": "$(leojs-next)"
},
{
  "command": "leojs.nextFromOutline",
  "category": "Leojs",
  "title": "Next",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanGoNext",
  "icon": "$(leojs-next)"
},
</t>
<t tx="felix.20201214205159.12">{
  "command": "leojs.editHeadline",
  "category": "Leojs",
  "title": "Edit Headline",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-edit)"
},
{
  "command": "leojs.editSelectedHeadline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Edit Headline",
  "icon": "$(leojs-edit)"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Edit Headline",
  "icon": "$(leojs-edit)"
},
</t>
<t tx="felix.20201214205159.13">{
  "command": "leojs.mark",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark",
  "icon": "$(leojs-mark)"
},
{
  "command": "leojs.markSelection",
  "category": "Leojs",
  "title": "Mark",
  "enablement": "leojsTreeOpened &amp;&amp; !leojsMarked",
  "icon": "$(leojs-mark)"
},
{
  "command": "leojs.markSelectionFromOutline",
  "category": "Leojs",
  "title": "Mark",
  "enablement": "leojsTreeOpened &amp;&amp; !leojsMarked",
  "icon": "$(leojs-mark)"
},
{
  "command": "leojs.unmark",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-unmark)"
},
{
  "command": "leojs.unmarkSelection",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened &amp;&amp; leojsMarked",
  "icon": "$(leojs-unmark)"
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened &amp;&amp; leojsMarked",
  "icon": "$(leojs-unmark)"
},
{
  "command": "leojs.unmarkAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Unmark All"
},
{
  "command": "leojs.copyMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Copy Marked"
},
{
  "command": "leojs.diffMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Diff Marked Nodes"
},
{
  "command": "leojs.markChangedItems",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark Changed Items"
},
{
  "command": "leojs.markSubheads",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark Subheads"
},
{
  "command": "leojs.cloneMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Clone Marked Nodes"
},
{
  "command": "leojs.deleteMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Delete Marked Nodes"
},
{
  "command": "leojs.moveMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Marked Nodes"
},
</t>
<t tx="felix.20201214205159.14">{
  "command": "leojs.copyNode",
  "category": "Leojs",
  "title": "Copy Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-clipboard)"
},
{
  "command": "leojs.copyNodeSelection",
  "category": "Leojs",
  "title": "Copy Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-clipboard)"
},
{
  "command": "leojs.cutNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Cut Node",
  "icon": "$(leojs-cut)"
},
{
  "command": "leojs.cutNodeSelection",
  "category": "Leojs",
  "title": "Cut Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-cut)"
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Cut Node",
  "icon": "$(leojs-cut)"
},
{
  "command": "leojs.pasteNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node",
  "icon": "$(leojs-paste)"
},
{
  "command": "leojs.pasteNodeAtSelection",
  "category": "Leojs",
  "title": "Paste Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-paste)"
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node",
  "icon": "$(leojs-paste)"
},
{
  "command": "leojs.pasteNodeAsClone",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node as Clone",
  "icon": "$(leojs-paste-clone)"
},
{
  "command": "leojs.pasteNodeAsCloneAtSelection",
  "category": "Leojs",
  "title": "Paste Node as Clone",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-paste-clone)"
},
{
  "command": "leojs.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node as Clone",
  "icon": "$(leojs-paste-clone)"
},
{
  "command": "leojs.pasteAsTemplate",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node as template"
},
{
  "command": "leojs.delete",
  "category": "Leojs",
  "title": "Delete",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-close)"
},
{
  "command": "leojs.deleteSelection",
  "category": "Leojs",
  "title": "Delete Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-delete)"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Delete Node",
  "icon": "$(leojs-delete)"
},
{
  "command": "leojs.setUa",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Set uA"
},
</t>
<t tx="felix.20201214205159.15">{
  "command": "leojs.extract",
  "category": "Leojs",
  "title": "Extract",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-extract)"
},
{
  "command": "leojs.extractNames",
  "category": "Leojs",
  "title": "Extract Names",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-extract-name)"
},
</t>
<t tx="felix.20201214205159.16">{
  "command": "leojs.moveOutlineDown",
  "category": "Leojs",
  "title": "Move Outline Down",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-arrow-down)"
},
{
  "command": "leojs.moveOutlineDownSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Down",
  "icon": "$(leojs-arrow-down)"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Down",
  "icon": "$(leojs-arrow-down)"
},
{
  "command": "leojs.moveOutlineLeft",
  "category": "Leojs",
  "title": "Move Outline Left",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-arrow-left)"
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Left",
  "icon": "$(leojs-arrow-left)"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Left",
  "icon": "$(leojs-arrow-left)"
},
{
  "command": "leojs.moveOutlineRight",
  "category": "Leojs",
  "title": "Move Outline Right",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-arrow-right)"
},
{
  "command": "leojs.moveOutlineRightSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Right",
  "icon": "$(leojs-arrow-right)"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Right",
  "icon": "$(leojs-arrow-right)"
},
{
  "command": "leojs.moveOutlineUp",
  "category": "Leojs",
  "title": "Move Outline Up",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-arrow-up)"
},
{
  "command": "leojs.moveOutlineUpSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Up",
  "icon": "$(leojs-arrow-up)"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Up",
  "icon": "$(leojs-arrow-up)"
},
</t>
<t tx="felix.20201214205159.17">{
  "command": "leojs.insertNode",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-plus)"
},
{
  "command": "leojs.insertChildNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Insert Child",
  "icon": "$(leojs-insert-child)"
},
{
  "command": "leojs.insertNodeSelection",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-plus)"
},
{
  "command": "leojs.insertChildNodeSelection",
  "category": "Leojs",
  "title": "Insert Child",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-insert-child)"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-plus)"
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Insert Child",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-insert-child)"
},
{
  "command": "leojs.cloneNode",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-link)"
},
{
  "command": "leojs.cloneNodeSelection",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-link)"
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-link)"
},
{
  "command": "leojs.promote",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-promote)"
},
{
  "command": "leojs.promoteSelection",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanPromote",
  "icon": "$(leojs-promote)"
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanPromote",
  "icon": "$(leojs-promote)"
},
{
  "command": "leojs.demote",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-demote)"
},
{
  "command": "leojs.demoteSelection",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanDemote",
  "icon": "$(leojs-demote)"
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanDemote",
  "icon": "$(leojs-demote)"
},
{
  "command": "leojs.sortChildrenSelection",
  "category": "Leojs",
  "title": "Sort Children",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "icon": "$(leojs-sort-children)"
},
{
  "command": "leojs.sortChildrenSelectionFromOutline",
  "category": "Leojs",
  "title": "Sort Children",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "icon": "$(leojs-sort-children)"
},
{
  "command": "leojs.sortSiblingsSelection",
  "category": "Leojs",
  "title": "Sort Siblings",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-sort-siblings)"
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "category": "Leojs",
  "title": "Sort Siblings",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-sort-siblings)"
},
</t>
<t tx="felix.20201214205159.18">{
  "command": "leojs.gotoFirstVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto First Visible"
},
{
  "command": "leojs.gotoLastVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Last Visible"
},
{
  "command": "leojs.pageUp",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Page Up"
},
{
  "command": "leojs.pageDown",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Page Down"
},
{
  "command": "leojs.gotoFirstSibling",
  "category": "leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto First Sibling"
},
{
  "command": "leojs.gotoLastSibling",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Last Sibling"
},
{
  "command": "leojs.gotoNextVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Visible"
},
{
  "command": "leojs.gotoPrevVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Prev Visible"
},
{
  "command": "leojs.contractOrGoLeft",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Contract Or Go Left"
},
{
  "command": "leojs.expandAndGoRight",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Expand And Go Right"
},
{
  "command": "leojs.gotoNextMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Marked"
},
{
  "command": "leojs.gotoNextClone",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Clone"
},
{
  "command": "leojs.gotoNextCloneSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Clone"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Clone"
},
</t>
<t tx="felix.20201214205159.2">@others
</t>
<t tx="felix.20201214205159.20">{
  "command": "leojs.undo",
  "category": "Leojs",
  "title": "Undo",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanUndo",
  "icon": "$(leojs-undo)"
},
{
  "command": "leojs.undoFromOutline",
  "category": "Leojs",
  "title": "Undo",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanUndo",
  "icon": "$(leojs-undo)"
},
{
  "command": "leojs.redo",
  "category": "Leojs",
  "title": "Redo",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanRedo",
  "icon": "$(leojs-redo)"
},
{
  "command": "leojs.redoFromOutline",
  "category": "Leojs",
  "title": "Redo",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanRedo",
  "icon": "$(leojs-redo)"
},
{
  "command": "leojs.revertToUndo",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Revert to Undo State"
},
</t>
<t tx="felix.20201214205159.23">"menus": {
  @others
},
</t>
<t tx="felix.20201214205159.24">"commandPalette": [
  @others
],
</t>
<t tx="felix.20201214205159.3">"viewsContainers": {
  "activitybar": [
    {
      "id": "leojsView",
      "title": "Leojs",
      "icon": "$(leojs-icon-leo-fill)"
    }
  ]
},
</t>
<t tx="felix.20201214205159.4">"views": {
  "explorer": [
    {
      "id": "leojsOutlineExplorer",
      "name": "Leojs Outline",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer",
      "visibility": "visible"
    },
    {
      "type": "webview",
      "id": "leojsFindPanelExplorer",
      "contextualTitle": "Leojs",
      "name": "Leojs Find",
      "title": "Leojs Find",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsDocumentsExplorer",
      "name": "Leojs Documents",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsUndosExplorer",
      "name": "Leojs Undo History",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsButtonsExplorer",
      "name": "Leojs Buttons",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    }
  ],
  "leojsView": [
    {
      "id": "leojsOutline",
      "contextualTitle": "Leojs",
      "name": "Outline",
      "visibility": "visible"
    },
    {
      "type": "webview",
      "contextualTitle": "Leojs",
      "id": "leojsFindPanel",
      "name": "Find",
      "title": "Find",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsDocuments",
      "contextualTitle": "Leojs",
      "name": "Documents",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsUndos",
      "contextualTitle": "Leojs",
      "name": "Undo History",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsButtons",
      "contextualTitle": "Leojs",
      "name": "Buttons",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    }
  ]
},
</t>
<t tx="felix.20201214205159.42">{
  "command": "leojs.clickButton",
  "when": "false"
},
{
  "command": "leojs.gotoScript",
  "when": "false"
},
{
  "command": "leojs.removeButton",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.44">{
  "command": "leojs.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leojs.refreshFromDisk",
  "when": "false"
},
{
  "command": "leojs.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "when": "false"
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
</t>
<t tx="felix.20201214205159.45">  "when": "false"
},
{
  "command": "leojs.contractAllFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.46">{
  "command": "leojs.editHeadline",
  "when": "false"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.47">{
  "command": "leojs.mark",
  "when": "false"
},
{
  "command": "leojs.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.unmark",
  "when": "false"
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.48">{
  "command": "leojs.copyNode",
  "when": "false"
},
{
  "command": "leojs.cutNode",
  "when": "false"
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.pasteNode",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.delete",
  "when": "false"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.49">{
  "command": "leojs.moveOutlineDown",
  "when": "false"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineRight",
  "when": "false"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineUp",
  "when": "false"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.5">"viewsWelcome": [
  {
    "view": "leojsOutline",
    "contents": "Starting up leojs...",
    "when": "!leojsReady &amp;&amp; !leojsStartupDone"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "Starting up leojs...",
    "when": "!leojsReady &amp;&amp; !leojsStartupDone"
  },
  {
    "view": "leojsOutline",
    "contents": "Opening file...",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened &amp;&amp; leojsStartupDone &amp;&amp; leojsOpeningFile"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "Opening file...",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened &amp;&amp; leojsStartupDone &amp;&amp; leojsOpeningFile"
  },
  {
    "view": "leojsOutline",
    "contents": "Open a remote repository to enable LeoJS\n[Open Remote Repository](command:remoteHub.openRepository)\nSee [Opening a project](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for more info.",
    "when": "!leojsReady &amp;&amp; leojsStartupDone &amp;&amp; !leojsIdUnset"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "Open a remote repository to enable LeoJS\n[Open Remote Repository](command:remoteHub.openRepository)\nSee [Opening a project](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for more info.",
    "when": "!leojsReady &amp;&amp; leojsStartupDone &amp;&amp; !leojsIdUnset"
  },
  {
    "view": "leojsOutline",
    "contents": "Choose your LeoID to start\n[Enter an id](command:leojs.setLeoID)",
    "when": "!leojsReady &amp;&amp; leojsStartupDone &amp;&amp; leojsIdUnset"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "Choose your LeoID to start\n[Enter an id](command:leojs.setLeoID)",
    "when": "!leojsReady &amp;&amp; leojsStartupDone &amp;&amp; leojsIdUnset"
  },
  {
    "view": "leojsOutline",
    "contents": "[Open Leo File](command:leojs.openLeoFile)\n[Create Leo File](command:leojs.newLeoFile)\n[Recent Leo Files](command:leojs.recentLeoFiles)\nView LeoJS [configuration settings](command:leojs.showSettingsPage)",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened &amp;&amp; leojsStartupDone &amp;&amp; !leojsOpeningFile"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "[Open Leo File](command:leojs.openLeoFile)\n[Create Leo File](command:leojs.newLeoFile)\n[Recent Leo Files](command:leojs.recentLeoFiles)\nView LeoJS [configuration settings](command:leojs.showSettingsPage)",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened &amp;&amp; leojsStartupDone &amp;&amp; !leojsOpeningFile"
  },
  {
    "view": "leojsDocuments",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsDocumentsExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsButtons",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsButtonsExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsButtons",
    "contents": "There are no @buttons in this outline",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsButtonsExplorer",
    "contents": "There are no @buttons in this outline",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsUndos",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsUndosExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsUndos",
    "contents": "Can't undo",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsUndosExplorer",
    "contents": "Can't undo",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  }
],
</t>
<t tx="felix.20201214205159.50">{
  "command": "leojs.insertNode",
  "when": "false"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.insertChildNode",
  "when": "false"
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.cloneNode",
  "when": "false"
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.promote",
  "when": "false"
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.demote",
  "when": "false"
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.sortChildrenSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.51">{
  "command": "leojs.gotoNextClone",
  "when": "false"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leojs.gotoLastVisible",
  "when": "false"
},
{
  "command": "leojs.gotoFirstSibling",
  "when": "false"
},
{
  "command": "leojs.gotoLastSibling",
  "when": "false"
},
{
  "command": "leojs.gotoNextVisible",
  "when": "false"
},
{
  "command": "leojs.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leojs.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leojs.expandAndGoRight",
  "when": "false"
},
{
  "command": "leojs.pageUp",
  "when": "false"
},
{
  "command": "leojs.pageDown",
  "when": "false"
},
{
  "command": "leojs.gotoNavPrev",
  "when": "false"
},
{
  "command": "leojs.gotoNavNext",
  "when": "false"
},
{
  "command": "leojs.gotoNavFirst",
  "when": "false"
},
{
  "command": "leojs.gotoNavLast",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.52">{
  "command": "leojs.hoistNode",
  "when": "false"
},
{
  "command": "leojs.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.53">{
  "command": "leojs.undoFromOutline",
  "when": "false"
},
{
  "command": "leojs.redoFromOutline",
  "when": "false"
},
{
  "command": "leojs.revertToUndo",
  "when": "false"
}
</t>
<t tx="felix.20201214205159.54">"explorer/context": [
  {
    "command": "leojs.openLeoFile",
    "when": "resourceExtname == .leo || resourceExtname == .leojs",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20201214205159.55">"view/title": [
  {
    "command": "leojs.showSettingsPage",
    "when": "view =~ /^leojsDocuments|^leojsButtons/ &amp;&amp; leojsReady",
    "group": "navigation@9"
  },
  {
    "command": "leojs.showLogPane",
    "when": "view =~ /^leojsDocuments|^leojsButtons/ &amp;&amp; leojsReady",
    "group": "navigation@9"
  },
  {
    "command": "leojs.recentLeoFiles",
    "when": "view =~ /^leojsDocuments/ &amp;&amp; leojsReady",
    "group": "navigation@8"
  },
  {
    "command": "leojs.recentLeoFiles",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsReady &amp;&amp; !leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findQuickSelected",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findQuickTimeline",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findQuickChanged",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.history",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.markedList",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.openLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsReady",
    "group": "navigation@1"
  },
  {
    "command": "leojs.newLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsReady",
    "group": "navigation@1"
  },
  {
    "command": "leojs.saveLeoFileFromOutline",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.saveAsLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; !leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.saveAsLeoJsFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; !leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.prevFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leojs.nextFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leojs.undoFromOutline",
    "when": "view =~ /^leojsOutline|^leojsUndo/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.redoFromOutline",
    "when": "view =~ /^leojsOutline|^leojsUndo/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.deHoistFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened &amp;&amp; !leojsTopHoistChapter",
    "group": "navigation@7"
  },
  {
    "command": "leojs.chapterMain",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened &amp;&amp; leojsTopHoistChapter",
    "group": "navigation@7"
  },
  {
    "command": "leojs.hoistSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leojs.chapterBack",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterNext",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterSelect",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterMain",
    "when": "view =~ /^leojsFindPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.promoteSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leojs.demoteSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@10"
  },
  {
    "command": "leojs.contractAllFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@11"
  }
],
</t>
<t tx="felix.20201214205159.56">"view/item/context": [
  @others
],
</t>
<t tx="felix.20201214205159.57">{
  "command": "leojs.editHeadline",
  "when": "config.leojs.showEditOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@1"
},
</t>
<t tx="felix.20201214205159.58">{
  "command": "leojs.insertNode",
  "when": "config.leojs.showAddOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@2"
},
</t>
<t tx="felix.20201214205159.6">"commands": [
  @others
],
</t>
<t tx="felix.20201214205159.60">{
  "command": "leojs.copyNode",
  "when": "config.leojs.showCopyOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@4"
},
{
  "command": "leojs.cloneNode",
  "when": "config.leojs.showCloneOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@4"
},
</t>
<t tx="felix.20201214205159.61">{
  "command": "leojs.mark",
  "when": "config.leojs.showMarkOnNodes &amp;&amp; viewItem =~ /^leojsNodeUnmarked/",
  "group": "inline@5"
},
{
  "command": "leojs.unmark",
  "when": "config.leojs.showMarkOnNodes &amp;&amp; viewItem =~ /^leojsNodeMarked/",
  "group": "inline@5"
},
</t>
<t tx="felix.20201214205159.62">{
  "command": "leojs.openAside",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext1@1"
},
</t>
<t tx="felix.20201214205159.63">{
  "command": "leojs.hoistNode",
  "when": "viewItem =~ /leojsNodeNotRoot/",
  "group": "leojsNodeContext1@2"
},
{
  "command": "leojs.deHoist",
  "when": "leojsCanDehoist &amp;&amp; viewItem =~ /leojsNodeRoot/",
  "group": "leojsNodeContext1@2"
},
</t>
<t tx="felix.20201214205159.64">{
  "command": "leojs.refreshFromDisk",
  "when": "viewItem =~ /leojsNodeAtFile/",
  "group": "leojsNodeContext1@3"
},
</t>
<t tx="felix.20201214205159.65">{
  "command": "leojs.mark",
  "when": "viewItem =~ /^leojsNodeUnmarked/",
  "group": "leojsNodeContext2@1"
},
{
  "command": "leojs.unmark",
  "when": "viewItem =~ /^leojsNodeMarked/",
  "group": "leojsNodeContext2@1"
},
</t>
<t tx="felix.20201214205159.66">{
  "command": "leojs.copyNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@5"
},
{
  "command": "leojs.cutNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@6"
},
{
  "command": "leojs.pasteNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@7"
},
{
  "command": "leojs.pasteNodeAsClone",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@8"
},
{
  "command": "leojs.delete",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@9"
},
{
  "command": "leojs.insertNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext3@1"
},
{
  "command": "leojs.cloneNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext3@2"
},
{
  "command": "leojs.gotoNextClone",
  "when": "viewItem =~ /leojsNodeCloned/",
  "group": "leojsNodeContext3@3"
},
</t>
<t tx="felix.20201214205159.67">"keybindings": [
  @others
],
</t>
<t tx="felix.20201214205159.68">{
  "command": "leojs.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.minibuffer",
  "key": "alt+x",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20201214205159.69">{
  "command": "leojs.showOutline",
  "key": "alt+t",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/ || leojsFindFocus || focusedView =~ /^leojsUndos|^leojsFindPanel|^leojsDocuments|^leojsButtons/"
},
{
  "command": "leojs.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/"
},
{
  "command": "leojs.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.showBody",
  "key": "alt+d",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojsDetached || leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.showBody",
  "key": "ctrl+g",
  "mac": "cmd+g",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojsDetached || leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.showBody",
  "key": "tab",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsButtons|^leojsUndos/"
},
{
  "command": "leojs.showBody",
  "key": "enter",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.70">{
  "command": "leojs.tabCycleNext",
  "key": "ctrl+tab",
  "mac": "cmd+tab",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/"
},
{
  "command": "leojs.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/"
},
{
  "command": "leojs.newLeoFile",
  "key": "ctrl+n",
  "mac": "cmd+n",
  "when": "leojsEditHeadline || editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/ || leojsFindFocus || sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.openLeoFile",
  "key": "ctrl+o",
  "mac": "cmd+o",
  "when": "leojsEditHeadline || editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/ || leojsFindFocus || sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.writeAtFileNodes",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/"
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.writeDirtyAtFileNodes",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/"
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
</t>
<t tx="felix.20201214205159.71">{
  "command": "leojs.contractAll",
  "key": "alt+-",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leojs/"
},
{
  "command": "leojs.contractAllFromOutline",
  "key": "alt+-",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
</t>
<t tx="felix.20201214205159.72">{
  "command": "leojs.editSelectedHeadline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsButtons|^leojsUndos/"
},
</t>
<t tx="felix.20201214205159.73">{
  "command": "leojs.markSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsTreeOpened &amp;&amp; !leojsMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.markSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsEditHeadline &amp;&amp; !leojsMarked || leojsFindFocus &amp;&amp; !leojsMarked || leojsTreeOpened &amp;&amp; !leojsMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.unmarkSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsTreeOpened &amp;&amp; leojsMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsEditHeadline &amp;&amp; leojsMarked || leojsFindFocus &amp;&amp; leojsMarked || leojsTreeOpened &amp;&amp; leojsMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
</t>
<t tx="felix.20201214205159.74">{
  "command": "leojs.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd+shift+n",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20201214205159.75">{
  "command": "leojs.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "shift+down",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "shift+left",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "shift+right",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "shift+up",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.76">{
  "command": "leojs.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.insertNodeSelection",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "insert",
  "mac": "insert",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertChildNodeSelection",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.cloneNodeSelection",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsFindPanel/"
},
</t>
<t tx="felix.20201214205159.77">{
  "command": "leojs.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsFindPanel/"
},
{
  "command": "leojs.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsFindPanel/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsFindPanel/"
},
{
  "command": "leojs.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "key": "delete",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.78">{
  "command": "leojs.gotoFirstVisible",
  "key": "alt+home",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoLastVisible",
  "key": "alt+end",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoFirstVisible",
  "key": "home",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoLastVisible",
  "key": "end",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.pageUp",
  "key": "pageup",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.pageDown",
  "key": "pagedown",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsFindPanel/"
},
{
  "command": "leojs.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoNextVisible",
  "key": "down",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsEditHeadline || config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNextVisible",
  "key": "alt+down",
  "when": "leojsTreeOpened &amp;&amp; leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoPrevVisible",
  "key": "up",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsEditHeadline || config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoPrevVisible",
  "key": "alt+up",
  "when": "leojsTreeOpened &amp;&amp; leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.contractOrGoLeft",
  "key": "left",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.contractOrGoLeft",
  "key": "alt+left",
  "when": "leojsTreeOpened &amp;&amp; leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.expandAndGoRight",
  "key": "right",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.expandAndGoRight",
  "key": "alt+right",
  "when": "leojsTreeOpened &amp;&amp; leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20201214205159.79">"cleanup": "node ./cleanup.js",
"vscode:prepublish": "npm run package",
"compile": "webpack",
"compile-web": "webpack",
"open-in-browser": "node ./prepare.js &amp;&amp; vscode-test-web --browserType=chromium --extensionDevelopmentPath=. &amp;&amp; node ./cleanup.js",
"watch": "webpack --watch",
"watch-web": "webpack --watch",
"package": "webpack --mode production --devtool hidden-source-map",
"package-web": "webpack --mode production --devtool hidden-source-map",
"compile-tests": "tsc -p . --outDir out",
"watch-tests": "tsc -p . -w --outDir out",
"pretest": "npm run compile-tests &amp;&amp; npm run compile &amp;&amp; npm run lint",
"lint": "eslint src --ext ts",
"test": "node ./out/test/runTest.js",
"test-web": "node ./prepare.js &amp;&amp; vscode-test-web --extensionDevelopmentPath=. --extensionTestsPath=dist/test/suite/index-web.js &amp;&amp; node ./cleanup.js"
</t>
<t tx="felix.20201214205159.8">{
  "command": "leojs.executeScript",
  "category": "Leojs",
  "title": "Execute Script",
  "enablement": "leojsTreeOpened",
  "icon": "$(play)"
},
{
  "command": "leojs.minibuffer",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Minibuffer"
},
{
  "command": "leojs.clickButton",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Click Button",
  "icon": "$(play)"
},
{
  "command": "leojs.gotoScript",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Script"
},
{
  "command": "leojs.removeButton",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Button"
},
</t>
<t tx="felix.20201214205159.80">"@types/debounce": "^1.2.0",
"@types/difflib": "^0.2.1",
"@types/elementtree": "^0.1.1",
"@types/glob": "^7.2.0",
"@types/lodash": "^4.14.177",
"@types/md5": "^2.3.1",
"@types/mocha": "^9.1.0",
"@types/node": "16.x",
"@types/pako": "^2.0.0",
"@types/safe-json-stringify": "^1.1.2",
"@types/showdown": "^2.0.6",
"@types/sql.js": "^1.4.4",
"@types/uuid": "^9.0.7",
"@types/vscode": "^1.86.0",
"@types/webpack-env": "^1.16.3",
"@typescript-eslint/eslint-plugin": "^5.16.0",
"@typescript-eslint/parser": "^5.16.0",
"@vscode/test-electron": "^2.0.3",
"@vscode/test-web": "^0.0.50",
"assert": "^2.0.0",
"buffer": "^6.0.3",
"eslint": "^8.11.0",
"glob": "^7.2.0",
"mocha": "^9.1.3",
"process": "^0.11.10",
"terser-webpack-plugin": "^5.3.1",
"ts-loader": "^9.2.6",
"typescript": "^4.9.5",
"webpack": "^5.70.0",
"webpack-cli": "^4.9.2",
"webpack-shell-plugin-next": "^2.2.2"
</t>
<t tx="felix.20201214205159.81">"binascii": "^0.0.2",
"bowser": "^2.11.0",
"browser-process-hrtime": "^1.0.0",
"console-browserify": "^1.2.0",
"crypto-browserify": "^3.12.0",
"csvtojson": "^2.0.10",
"date-format-lite": "^17.7.0",
"dayjs": "^1.11.3",
"dayjs-plugin-utc": "^0.1.2",
"difflib": "^0.2.4",
"elementtree": "^0.1.7",
"jszip": "^3.10.1",
"ksuid": "^3.0.0",
"lodash": "^4.17.21",
"md5": "^2.3.0",
"os-browserify": "^0.3.0",
"pako": "^2.1.0",
"path-browserify": "^1.0.1",
"showdown": "^2.1.0",
"stream": "^0.0.2"
</t>
<t tx="felix.20201214205159.9">{
  "command": "leojs.showSettingsPage",
  "title": "Open Leojs Settings",
  "category": "Leojs",
  "icon": "$(leojs-gear)"
},
{
  "command": "leojs.showWelcomePage",
  "title": "Welcome",
  "category": "Leojs"
},
{
  "command": "leojs.setLeoID",
  "category": "Leojs",
  "enablement": "!leojsReady",
  "title": "Set Leo ID"
},
{
  "command": "leojs.showBody",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus to Body"
},
{
  "command": "leojs.showOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus to Tree"
},
{
  "command": "leojs.showLogPane",
  "category": "Leojs",
  "title": "Show Log Pane",
  "enablement": "leojsReady",
  "icon": "$(leojs-show-log)"
},
</t>
<t tx="felix.20201214211742.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was clicked
 * @returns Promises that resolves when done
 */
public async clickAtButton(p_node: LeoButtonNode): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const c = g.app.windowList[g.app.gui.frameIndex].c;
    const d = c.theScriptingController.buttonsArray;
    const button = d[p_node.button.index];
    let result: any;
    if (p_node.rclicks.length) {
        // Has rclicks so show menu to choose
        this._rclickSelected = [];
        let w_rclick: number[] | undefined;
        const p_picked = await this._handleRClicks(p_node.rclicks, p_node.button.name);

        if (
            p_picked
        ) {
            // Check if only one in this._rclickSelected and is zero: normal press
            if (this._rclickSelected.length === 1 &amp;&amp; this._rclickSelected[0] === 0) {
                // Normal 'top' button, not one of it's child rclicks.
            } else {
                // One of its child 'rclick', so decrement first one, and send this._rclickSelected as array of choices
                this._rclickSelected[0] = this._rclickSelected[0] - 1;
                w_rclick = this._rclickSelected;
            }

            try {
                let w_rclickChosen: RClick | undefined;

                if (w_rclick &amp;&amp; button.rclicks) {
                    // Had w_rclick setup so it's a child rclick, not the recular 'top' button.
                    let toChooseFrom: RClick[] = button.rclicks;
                    for (const i_rc of w_rclick) {
                        w_rclickChosen = toChooseFrom[i_rc];
                        toChooseFrom = w_rclickChosen.children;
                    }
                    if (w_rclickChosen) {
                        result = c.theScriptingController.executeScriptFromButton(button, '', w_rclickChosen.position, '');
                    }
                } else {
                    // Normal 'top' button.
                    result = await Promise.resolve(button.command());
                }

            } catch (e: any) {
                void vscode.window.showErrorMessage("LEOJS: LeoUI clickAtButton Error: " + e.toString());
            }

        } else {
            // Escaped so  just return, no 'setupRefresh' nor 'launchRefresh'!
            return Promise.resolve();
        }

    } else {
        // no rclicks nor menus, so just call the button's command.
        result = await Promise.resolve(button.command());
    }

    this.setupRefresh(Focus.NoChange, {
        tree: true,
        body: true,
        documents: true,
        buttons: true,
        states: true
    });

    void this.launchRefresh();
    return result;

}

</t>
<t tx="felix.20201214211744.1">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was chosen to remove
 * @returns Thenable that resolves when done
 */
public async removeAtButton(p_node: LeoButtonNode): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const tag: string = 'remove_button';
    const index = p_node.button.index;
    const c = g.app.windowList[g.app.gui.frameIndex].c;
    const d = c.theScriptingController.buttonsArray;
    const butWidget = d[index];
    if (butWidget) {
        try {
            d.splice(index, 1);
        } catch (e) {
            g.es_exception(e);
        }
    } else {
        console.log(`LEOJS : ERROR ${tag}: button ${String(index)} does not exist`);
    }
    this.setupRefresh(Focus.NoChange, { buttons: true });
    return this.launchRefresh();

}

</t>
<t tx="felix.20201214211830.1">/**
* * Close an opened Leo file
* @returns the promise started after it's done closing the Leo document
*/
public async closeLeoFile(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);

    this.setupRefresh(Focus.Body, {
        tree: true,
        body: true,
        goto: true,
        documents: true,
        buttons: true,
        states: true
    });

    const c = g.app.windowList[this.frameIndex].c;
    await c.close();
    void this.launchRefresh(); // start to refresh first
    return this.loadSearchSettings();
}

</t>
<t tx="felix.20201214211832.1">/**
 * * Sets up the call to the 'open-outline' command and its possible file url parameter.
 * @param p_leoFileUri optional uri for specifying a file, if missing, a dialog will open
 * @returns A promise that resolves when done trying to open the file
 */
public async openLeoFile(p_uri?: vscode.Uri): Promise&lt;unknown&gt; {

    if (p_uri) {
        if (!!p_uri.toJSON &amp;&amp; !!p_uri.fsPath &amp;&amp; p_uri.fsPath.trim()) {
            // valid: pass!
        } else {
            p_uri = undefined; // clear uri
        }
    }

    if (!this.leoStates.fileOpenedReady) {
        // override with given argument
        let fileName: string;

        // make sure it's a real uri because vscode may send selected
        // node from other tree that has this command in title

        if (p_uri &amp;&amp; p_uri?.fsPath?.trim() &amp;&amp; g.app.loadManager) {
            fileName = p_uri.fsPath;
        } else {
            fileName = await this.runOpenFileDialog(
                undefined,
                "Open",
                [
                    ["Leo files", "*.leo *.leojs *.db"],
                    ["Python files", "*.py"],
                    ["All files", "*"]
                ],
                g.defaultLeoFileExtension(),
            );
        }
        if (fileName &amp;&amp; g.app.loadManager) {
            await utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, true);
            await g.app.loadManager.loadLocalFile(fileName, this);
            this.showBodyIfClosed = true;
            this.showOutlineIfClosed = true;
            this.setupRefresh(this.finalFocus, {
                tree: true,
                body: true,
                goto: true,
                states: true,
                documents: true,
                buttons: true
            });
            void this.launchRefresh();
            setTimeout(() =&gt; {
                void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, false);
            }, 60);
        } else {
            return Promise.resolve();
        }
    } else {
        await this.triggerBodySave(true);
        const c = g.app.windowList[this.frameIndex].c;
        await utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, true);
        await c.open_outline(p_uri);
        this.showBodyIfClosed = true;
        this.showOutlineIfClosed = true;
        this.setupRefresh(this.finalFocus, {
            tree: true,
            body: true,
            goto: true,
            states: true,
            documents: true,
            buttons: true
        });
        setTimeout(() =&gt; {
            void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, false);
        }, 60);
        void this.launchRefresh();
    }
    return this.loadSearchSettings();
}

</t>
<t tx="felix.20201214211834.1">/**
 * * Shows the recent Leo files list, choosing one will open it
 * @returns A promise that resolves when the a file is finally opened, rejected otherwise
 */
public async showRecentLeoFiles(): Promise&lt;unknown&gt; {

    // if shown, chosen and opened
    let w_recentFiles: string[] = g.app.recentFilesManager.recentFiles;
    w_recentFiles = w_recentFiles.filter(str =&gt; str.trim() !== "");

    let q_chooseFile: Thenable&lt;string | undefined&gt;;
    if (w_recentFiles.length) {
        q_chooseFile = vscode.window.showQuickPick(w_recentFiles, {
            placeHolder: Constants.USER_MESSAGES.OPEN_RECENT_FILE,
        });
    } else {
        // No file to list
        return vscode.window.showInformationMessage('Recent files list empty');
    }
    const w_result = await q_chooseFile;
    if (w_result) {
        return this.openLeoFile(vscode.Uri.file(w_result));
    } else {
        // Canceled
        return Promise.resolve(undefined);
    }

}

</t>
<t tx="felix.20201214211835.1">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results.
 */
public async saveAsLeoFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        {
            tree: true,
            states: true,
            documents: true
        }
    );

    await c.saveAs();
    void this.launchRefresh();
    return;
}

</t>
<t tx="felix.20201214211836.1">/**
 * * Invokes the commander.save() command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns Promise that resolves when the save command is done
 */
public async saveLeoFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    await c.save();

    // ON THE WEB THE SAVE DOES NOT FINISH BEFORE INTERUPTING OTHER COMMANDS!
    setTimeout(() =&gt; {
        this.setupRefresh(
            p_fromOutline ? Focus.Outline : Focus.Body,
            {
                tree: true,
                states: true,
                documents: true
            }
        );
        void this.launchRefresh();
    });

    return Promise.resolve();
}

</t>
<t tx="felix.20201214211837.1">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly selected document
 */
public async switchLeoFile(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);

    const w_entries: ChooseDocumentItem[] = []; // Entries to offer as choices.
    let w_index: number = 0;
    const w_files: LeoDocument[] = g.app.windowList.map((p_frame) =&gt; {
        const s = p_frame.c.fileName();
        const w_filename = s ? utils.getFileFromPath(s) : Constants.UNTITLED_FILE_NAME;
        return {
            name: w_filename,
            index: w_index++,
            changed: p_frame.c.isChanged(),
            selected: g.app.windowList[this.frameIndex] === p_frame,
        };
    });
    w_index = 0; // reset w_index
    let w_chosenDocument: ChooseDocumentItem | undefined;
    if (w_files &amp;&amp; w_files.length) {
        w_files.forEach(function (p_filePath: LeoDocument) {
            w_entries.push({
                label: w_index.toString(),
                description: p_filePath.name
                    ? p_filePath.name
                    : Constants.UNTITLED_FILE_NAME,
                value: w_index,
                alwaysShow: true,
            });
            w_index++;
        });
        const w_pickOptions: vscode.QuickPickOptions = {
            matchOnDescription: true,
            placeHolder: Constants.USER_MESSAGES.CHOOSE_OPENED_FILE,
        };
        w_chosenDocument = await vscode.window.showQuickPick(w_entries, w_pickOptions);
    } else {
        // "No opened documents"
        return Promise.resolve(undefined);
    }
    if (w_chosenDocument) {
        return Promise.resolve(this.selectOpenedLeoDocument(w_chosenDocument.value));
    } else {
        // Canceled
        return Promise.resolve(undefined);
    }

}

</t>
<t tx="felix.20201214211839.1">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 * @param p_index position of the opened Leo document in the document array
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly opened document
 */
public async selectOpenedLeoDocument(p_index: number, p_fromOutline?: boolean): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    this.frameIndex = p_index;
    // Like we just opened or made a new file
    if (g.app.windowList.length) {
        this.setupRefresh(
            this.finalFocus,
            {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true,
                goto: true

            }
        );
        void this.launchRefresh();
        this.loadSearchSettings();
    } else {
        void this.launchRefresh();
        console.log('Select Opened Leo File Error');
        return Promise.reject('Select Opened Leo File Error');
    }

}

</t>
<t tx="felix.20201214233119.1">/**
 * General 'Leo is ready' state, equivalent to leoBridgeReady in leoInteg
 */
private _leoReady: boolean = false;
get leoReady(): boolean {
    return this._leoReady;
}
set leoReady(p_value: boolean) {
    this._leoReady = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_READY, p_value);
}

</t>
<t tx="felix.20201222013904.1">/**
 * * Refreshes the outline. A reveal type can be passed along to specify the reveal type for the selected node
 * @param p_incrementTreeId Make all node id's be 'new' by incrementing the treeId prefix of the id's.
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_incrementTreeId: boolean, p_revealType?: RevealType): void {
    if (p_incrementTreeId) {
        this._leoTreeProvider.incTreeId();
    }
    if (p_revealType !== undefined &amp;&amp; p_revealType.valueOf() &gt;= this._revealType.valueOf()) { // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    try {
        if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            this.showOutlineIfClosed = false;
            // Force showing last used Leo outline first
            let w_viewName: string;
            if (this._lastTreeView === this._leoTreeExView) {
                w_viewName = Constants.TREEVIEW_EXPLORER_ID;
            } else {
                w_viewName = Constants.TREEVIEW_ID;
            }
            vscode.commands.executeCommand(w_viewName + ".focus").then(
                () =&gt; {
                    this._revealNodeRetriedRefreshOutline = false;
                    this._leoTreeProvider.refreshTreeRoot();
                },
                (p_reason) =&gt; {
                    // Reveal failed: retry once.
                    console.log('_refreshOutline could not reveal. Rejected reason: ', p_reason);
                    this._leoTreeProvider.refreshTreeRoot();
                }
            );

        } else {
            this.showOutlineIfClosed = false;
            // was visible, just refresh
            this._leoTreeProvider.refreshTreeRoot();
        }
    } catch (error) {
        // Also retry once on error
        console.log('_refreshOutline could not reveal. Catch Error: ', error);
        this._leoTreeProvider.refreshTreeRoot();
    }
}

</t>
<t tx="felix.20201227014627.1">/**
 * * Launches refresh for UI components and context states (Debounced)
 */
public async _launchRefresh(): Promise&lt;unknown&gt; {

    this._refreshDetachedBodies();

    if (!this.refreshPreserveRange) {
        if (this.findFocusTree) {
            // had a range but now refresh from other than find/replace
            // So make sure tree is also refreshed.
            this._refreshType.tree = true;
        }
        // Clear no matter what.
        this.findFocusTree = false;
    } else {
        this.refreshPreserveRange = false; // preserved once, now cleared.
    }

    // check states for having at least a document opened
    if (this.leoStates.leoReady &amp;&amp; this.leoStates.fileOpenedReady) {
        // Had some opened
        if (!g.app.windowList.length) {
            return this._setupNoOpenedLeoDocument(); // All closed now!
        }
    }

    // Maybe first refresh after opening
    if (this.leoStates.leoReady &amp;&amp; !this.leoStates.fileOpenedReady) {
        // Was all closed
        if (g.app.windowList.length) {
            this._setupOpenedLeoDocument();
            // Has a commander opened, but wait for UI!
            await this.leoStates.qLastContextChange;
        } else {
            // First time starting: not even an untitled nor workbook.leo
            return;
        }
    }

    // Consider last command finished since the refresh cycle is starting
    if (this.trace) {
        if (this.commandTimer !== undefined) {
            console.log('commandTimer', utils.getDurationMs(this.commandTimer));
        }
    }
    this.commandTimer = undefined;

    // Start reset-timer capture, if has been reset.
    this.lastRefreshTimer = process.hrtime();
    if (this.refreshTimer === undefined) {
        this.refreshTimer = this.lastRefreshTimer;
    }

    let w_revealType: RevealType;
    if (this.finalFocus.valueOf() === Focus.Outline) {
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        w_revealType = RevealType.RevealSelect;
    }

    const c = g.app.windowList[this.frameIndex].c;
    this._refreshNode = c.p;

    if (
        this._refreshNode &amp;&amp;
        this._refreshType.body &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty
    ) {
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        // Do this only if gnx is different from what is coming from Leo in this refresh cycle.
        const w_lastChangedDocGnx = utils.leoUriToStr(this._bodyLastChangedDocument.uri);
        if (
            this._refreshNode.gnx !== w_lastChangedDocGnx &amp;&amp; !this._bodyLastChangedDocumentSaved
        ) {
            void this._bodyLastChangedDocument.save(); // Voluntarily save to 'clean' any pending body (no await)
            this._bodyLastChangedDocumentSaved = true;
        }
        if (this._refreshNode.gnx === w_lastChangedDocGnx) {
            this._leoFileSystem.preventSaveToLeo = true;
            await this._bodyLastChangedDocument.save(); // SAME GNX : so wait for it! (await)
        }
    }

    // * _focusInterrupt insertNode Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }

    const w_showBodyNoFocus: boolean = this.finalFocus.valueOf() !== Focus.Body;

    // console.log('showBodyIfClosed', this.showBodyIfClosed);// 
    // console.log('showOutlineIfClosed', this.showOutlineIfClosed);// 
    // console.log('explorer visible', this._leoTreeExView.visible);// 
    // console.log('visible', this._leoTreeView.visible); // 
    // console.log('this._refreshType.tree', this._refreshType.tree);
    // console.log('this._refreshType.body', this._refreshType.body); //

    // * Force refresh tree when body update required for 'navigation/insert node' commands
    if (
        this.showBodyIfClosed &amp;&amp;
        this.showOutlineIfClosed &amp;&amp;
        !this.isOutlineVisible() &amp;&amp;
        this._refreshType.body
    ) {
        // console.log('HAD TO ADJUST!');
        this._refreshType.tree = true;
    }

    // * Either the whole tree refreshes, or a single tree node is revealed when just navigating
    if (this._refreshType.tree) {
        this._refreshType.tree = false;
        this._refreshType.node = false; // Also clears node
        if (!this.isOutlineVisible() &amp;&amp; !this.showOutlineIfClosed &amp;&amp; this._refreshType.body) {
            // wont get 'gotSelectedNode so show body!
            this._refreshType.body = false;
            void this._tryApplyNodeToBody(this._refreshNode || this.lastSelectedNode!, false, w_showBodyNoFocus);
        } else if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            let w_treeName;
            if (this._lastTreeView === this._leoTreeExView) {
                w_treeName = Constants.TREEVIEW_EXPLORER_ID;
            } else {
                w_treeName = Constants.TREEVIEW_ID;
            }
            // Reveal will trigger a native outline refresh
            this._leoTreeProvider.incTreeId();
            this._revealType = w_revealType;
            void vscode.commands.executeCommand(w_treeName + '.focus');

            // } else if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            //     const c = g.app.windowList[this.frameIndex].c;
            //     this._lastTreeView.reveal(c.p, { select: true });
            // } else {
            //     this._refreshOutline(true, w_revealType);
            // }

        } else {
            this._refreshOutline(true, w_revealType);
        }
    } else if (this._refreshType.node &amp;&amp; this._refreshNode) {
        // * Force single node "refresh" by revealing it, instead of "refreshing" it
        this._refreshType.node = false;
        this.leoStates.setSelectedNodeFlags(this._refreshNode);
        let w_showOutline = this.isOutlineVisible();
        if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            this.showOutlineIfClosed = false;
            w_showOutline = true;
        }
        void this._revealNode(
            this._refreshNode,
            {
                select: true,
                focus: w_showOutline
            }
        );
        if (this._refreshType.body) {
            // * if no outline visible, just update body pane as needed
            if (!this.isOutlineVisible()) {
                this._refreshType.body = false;
                void this._tryApplyNodeToBody(this._refreshNode, false, w_showBodyNoFocus);
            }
        }
    } else if (this._refreshType.body) {
        this._refreshType.body = false;
        void this._tryApplyNodeToBody(this._refreshNode || this.lastSelectedNode!, false, w_showBodyNoFocus);
    }

    // * DEBUG INFO

    // console.log('***********************finished refresh');
    // console.log('**** c.config should be lowercase: ', c.config.new_leo_file_encoding);
    // // @ts-expect-error
    // console.log('**** g.app.config should be uppercase: ', g.app.config.new_leo_file_encoding);
    // console.log('**** c.collapse_on_lt_arrow :', c.collapse_on_lt_arrow);
    // console.log('**** c.collapse_nodes_after_move :', c.collapse_nodes_after_move);
    // console.log('**** c.sparse_move: ', c.sparse_move);

    // getStates will check if documents, buttons and states flags are set and refresh accordingly
    return this.getStates();
}

</t>
<t tx="felix.20201227155008.1">/**
 * * Setup global refresh options
 * @param p_finalFocus Flag for focus to be placed in outline
 * @param p_refreshType Refresh flags for each UI part
*/
public setupRefresh(p_finalFocus: Focus, p_refreshType?: ReqRefresh, p_preserveRange?: boolean): void {
    if (p_preserveRange) {
        this.refreshPreserveRange = true; // Will be cleared after a refresh cycle.
    }
    // Set final "focus-placement" EITHER true or false
    this.finalFocus = p_finalFocus;

    if (p_refreshType) {
        // Set all properties WITHOUT clearing others.
        Object.assign(this._refreshType, p_refreshType);
    }
}

</t>
<t tx="felix.20201227230901.1">/**
 * * Setup UI for having no opened Leo documents
 */
private _setupNoOpenedLeoDocument(): void {
    // Close ALL detached bodies.
    const w_foundTabs: Set&lt;vscode.Tab&gt; = new Set();
    const w_foundUri: Set&lt;vscode.Uri&gt; = new Set();
    for (const p_tabGroup of vscode.window.tabGroups.all) {
        for (const p_tab of p_tabGroup.tabs) {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME
            ) {
                w_foundTabs.add(p_tab);
                w_foundUri.add((p_tab.input as vscode.TabInputText).uri);
            }
        }
    }
    if (w_foundTabs.size) {
        void vscode.window.tabGroups.close([...w_foundTabs], true);
        for (const w_uri of w_foundUri) {
            void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_uri);
        }
    }
    this._nextRevealParams = undefined;
    void this.checkConfirmBeforeClose();
    this._leoStatusBar?.hide();
    this.leoStates.fileOpenedReady = false;
    this._bodyTextDocument = undefined;
    this.bodyDetachedTextDocument = undefined;
    this.lastSelectedNode = undefined;
    this._refreshOutline(false, RevealType.NoReveal);
    this.refreshDocumentsPane();
    this.refreshButtonsPane();
    this.refreshUndoPane();
    void this.closeBody();
}

</t>
<t tx="felix.20201227230912.1">/**
 * * A Leo file was opened: setup UI accordingly.
 * @param p_openFileResult Returned info about currently opened and editing document
 */
private _setupOpenedLeoDocument(): void {
    this._needLastSelectedRefresh = true;

    const c = g.app.windowList[this.frameIndex].c;
    this.leoStates.leoOpenedFileName = c.fileName();
    this.leoStates.leoChanged = c.changed;

    // * Startup flag
    if (!this.leoStates.leoIdUnset &amp;&amp; g.app.leoID !== 'None') {
        this.leoStates.fileOpenedReady = true;
    }

    this._revealType = RevealType.RevealSelect; // For initial outline 'visible' event

    this.showBodyIfClosed = true;
    this.showOutlineIfClosed = true;
    this.setupRefresh(
        Focus.Body, // Original Leo seems to open itself with focus in body.
        {
            tree: true,
            body: true,
            states: true,
            buttons: true,
            documents: true,
            goto: true
        },
    );

    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEOJS_SCHEME,
                this._leoFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._bodyFileSystemStarted = true;
    }
    if (!this._detachedFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEOJS_DETACHED_SCHEME,
                this._leoDetachedFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._detachedFileSystemStarted = true;
    }

    this.loadSearchSettings();
    if (this.config.showUnlOnStatusBar &amp;&amp; !this.leoStates.leoIdUnset &amp;&amp; g.app.leoID !== 'None') {
        this._leoStatusBar?.show();
    }
}

</t>
<t tx="felix.20201229025520.1">/**
 * * Handle selected node being created for the outline
 * @param p_node Position that was just created and detected as selected node
 */
public gotSelectedNode(p_node: Position): void {

    const w_focusTree = (this._revealType.valueOf() &gt;= RevealType.RevealSelectFocus.valueOf());
    const w_last = this.lastSelectedNode;

    if (
        !w_focusTree &amp;&amp;
        this._refreshType.scroll &amp;&amp;
        w_last &amp;&amp;
        w_last.__eq__(p_node) &amp;&amp; // utils.isApEqual(w_last, p_node) &amp;&amp;
        this._lastTreeView &amp;&amp;
        this._lastTreeView.visible

    ) {
        this.safeReveal(this._lastTreeView, p_node, {
            select: true,
            focus: false
        }).then(
            () =&gt; {
                //ok
            },
            () =&gt; {
                // 
                console.log('gotSelectedNode scroll mode reveal error catched');
            }
        );
        // ! MINIMAL TIMEOUT REQUIRED ! WHY ?? (works so leave)
        if (this._gotSelectedNodeBodyTimer) {
            clearTimeout(this._gotSelectedNodeBodyTimer);
        }
        this._gotSelectedNodeBodyTimer = setTimeout(() =&gt; {
            // SAME with scroll information specified
            void this.showBody(false, this.finalFocus.valueOf() !== Focus.Body);
        }, 25);
    } else {

        if (this._revealType) {
            if (this._gotSelectedNodeRevealTimer) {
                clearTimeout(this._gotSelectedNodeRevealTimer);
            }
            this._gotSelectedNodeRevealTimer = setTimeout(() =&gt; {
                this.safeReveal(this._lastTreeView, p_node, {
                    select: true,
                    focus: w_focusTree
                }).then(() =&gt; {
                    // ok
                    if (this.trace) {
                        if (this.refreshTimer) {
                            console.log('refreshTimer', utils.getDurationMs(this.refreshTimer));
                        }
                        if (this.lastRefreshTimer) {
                            console.log('lastRefreshTimer', utils.getDurationMs(this.lastRefreshTimer));
                        }
                        if (this.commandRefreshTimer) {
                            console.log('commandRefreshTimer', utils.getDurationMs(this.commandRefreshTimer));
                        }
                        if (this.lastCommandRefreshTimer) {
                            console.log('lastCommandRefreshTimer', utils.getDurationMs(this.lastCommandRefreshTimer));
                        }
                    }
                    this.refreshTimer = undefined;
                    this.lastRefreshTimer = undefined;
                    this.commandRefreshTimer = undefined;
                    this.lastCommandRefreshTimer = undefined;
                }, (p_reason) =&gt; {
                    // Reveal failed. Retry refreshOutline once
                    this._refreshOutline(true, RevealType.RevealSelect);
                });
                // Done, so reset reveal type 'flag'
                this._revealType = RevealType.NoReveal;
            }, 0);
        }

        // Apply node to body pane
        let w_showBodyNoFocus: boolean = this.finalFocus.valueOf() !== Focus.Body; // Will preserve focus where it is without forcing into the body pane if true
        if (this._focusInterrupt) {
            this._focusInterrupt = false;
            w_showBodyNoFocus = true;
        }
        if (!w_last || this._needLastSelectedRefresh) {
            // lastSelectedNode will be set in _tryApplyNodeToBody !
            this._needLastSelectedRefresh = false;
        }

        if (this._bodyTextDocument &amp;&amp;
            !this._bodyTextDocument.isClosed &amp;&amp; // IS OPENED
            !this._refreshType.body &amp;&amp; // NO NEED TO REFRESH BODY !
            this._locateOpenedBody(p_node.gnx) // DID LOCATE NEW GNX =&gt; ALREADY SHOWN!
        ) {
            // * Just make sure body selection is considered done.
            this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context
            this._preventShowBody = false; // in case it was a config-changed-refresh
        } else {
            // * Actually run the normal 'APPLY NODE TO BODY' to show or switch
            void this._tryApplyNodeToBody(p_node, false, w_showBodyNoFocus);
        }

        // Set context flags
        this.leoStates.setSelectedNodeFlags(p_node);
    }

    // Get 'c' before timeout for proper c that was refreshed.
    const c = g.app.windowList[this.frameIndex].c;

    // Do in a timeout to let rest of tree refresh.
    setTimeout(() =&gt; {
        g.doHook('after-redraw-outline', { c: c });
    }, 0);
}

</t>
<t tx="felix.20210102000055.1"># This file contains almost all of LeoJS sources.

# See the "About this file" node for important notes.
</t>
<t tx="felix.20210102000100.1"></t>
<t tx="felix.20210110210346.1">@language typescript
@tabwidth -4

// ambient module declaration for https://www.npmjs.com/package/date-format-lite
declare module "date-format-lite" { }

// date-format-lite augments built-in Date
interface Date {
    format: (format?: string) =&gt; string;
    masks: { default: string };
}
</t>
<t tx="felix.20211002194716.1"></t>
<t tx="felix.20211003223641.1">/**
 * * Builds a unique Id from gnx and stack, plus collapsed state,
 * for vscode to distinguish the collapsed state.
 */
private _buildId(p_position: Position, p_collapsed: number): string {
    // concatenate gnx, stacks gnx's, and collapsible state number.
    // (vscode uses id for collapsible state)
    let w_stringId = this.treeId.toString() +
        p_position.v.gnx + p_position.childIndex().toString() +
        p_position.stack.map(p_stackEntry =&gt; p_stackEntry[0].gnx + p_stackEntry[1].toString()).join("");
    // NOT NEEDED -&gt; p_collapsed.toString(); // Added Uniqueness: VSCode's collapsible state in id
    return w_stringId;
}

</t>
<t tx="felix.20211003233639.1">/**
 * * Force uniqueness of ids generated for nodes in the  next tree refresh
 */
public incTreeId(): void {
    this.treeId++;
}

</t>
<t tx="felix.20211006225245.1">"configuration": {
  "title": "LeoJS Leo Editor",
  "properties": {
    "leojs.checkForChangeExternalFiles": {
      "scope": "application",
      "default": "none",
      "type": "string",
      "description": "Set default for checking changes to external files",
      "enum": [
        "none",
        "force-check",
        "force-ignore"
      ],
      "enumDescriptions": [
        "Default from Leo's config",
        "Check for changes",
        "Ignore all changes"
      ]
    },
    "leojs.defaultReloadIgnore": {
      "scope": "application",
      "default": "none",
      "type": "string",
      "description": "Set default for derived files so that they reload, or ignore, when changes are detected",
      "enum": [
        "none",
        "yes-all",
        "no-all"
      ],
      "enumDescriptions": [
        "Choose each time",
        "Reload All",
        "Ignore All"
      ]
    },
    "leojs.sessionPerWorkspace": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Keeps one session of files to open per workspace. Setting to false will keep a single session of files to reopen for all instances."
    },
    "leojs.leoTreeBrowse": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
    },
    "leojs.treeKeepFocus": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
    },
    "leojs.treeKeepFocusWhenAside": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Specifies whether to keep focus in the outline when opening a detached body pane on the side"
    },
    "leojs.goAnywhereShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables Leo's 'Go Anywhere' to replace 'Go to file' with the Ctrl+P keyboard shortcut when focus in in outline or body"
    },
    "leojs.collapseAllShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables the Alt+'-' keyboard shortcut for collapsing all folders in the Explorer View"
    },
    "leojs.activityViewShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables the Ctrl+Shift+L keyboard shortcut for showing the LeoJS view"
    },
    "leojs.treeInExplorer": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Shows the outline tree in the explorer view"
    },
    "leojs.showEditOnNodes": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Shows 'Edit Headline' button on tree nodes"
    },
    "leojs.showAddOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Insert' button on tree nodes"
    },
    "leojs.showMarkOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Mark/Unmark' buttons on tree nodes"
    },
    "leojs.showCloneOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Clone' button on tree nodes"
    },
    "leojs.showCopyOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Copy' button on tree nodes"
    },
    "leojs.invertNodeContrast": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
    },
    "leojs.leoID": {
      "scope": "application",
      "default": "",
      "type": "string",
      "description": "Used to uniquely identify nodes - Defaults to the OS/Environment user name",
      "pattern": "(^$|^[a-zA-Z0-9]*$)",
      "patternErrorMessage": "Your id should contain only letters and numbers, and must contain at least 3 characters."
    },
    "leojs.showUnlOnStatusBar": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Displays an UNL indicator on the status bar"
    }
  }
},
</t>
<t tx="felix.20211007213344.1">import * as vscode from "vscode";
import { ConfigMembers, ConfigSetting } from "./types";
import { Constants } from "./constants";
import { LeoUI } from "./leoUI";
import * as g from './core/leoGlobals';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20211007213344.10">/**
 * * Check if the workbench.editor.enablePreview flag is set
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkEnablePreview(p_forced?: boolean): void {
    let w_result: any = true;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("enablePreview")!.globalValue === undefined) {
        w_result = w_setting.inspect("enablePreview")!.defaultValue;
    } else {
        w_result = w_setting.inspect("enablePreview")!.globalValue;
    }
    if (w_result === false) {
        if (p_forced) {
            void this.setEnablePreview();
            void vscode.window.showInformationMessage(Constants.USER_MESSAGES.ENABLE_PREVIEW_SET);
        } else {
            void vscode.window.showWarningMessage(
                Constants.USER_MESSAGES.ENABLE_PREVIEW_RECOMMEND,
                Constants.USER_MESSAGES.FIX_IT
            ).then(p_chosenButton =&gt; {
                if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                    void vscode.commands.executeCommand(Constants.COMMANDS.SET_ENABLE_PREVIEW);
                    void vscode.window.showInformationMessage(Constants.USER_MESSAGES.ENABLE_PREVIEW_SET);
                }
            });
        }
    }
}

</t>
<t tx="felix.20211007213344.11">/**
 * * Check if the 'workbench.editor.closeEmptyGroups' setting is false
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkCloseEmptyGroups(p_forced?: boolean): void {
    let w_result: any = false;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("closeEmptyGroups")!.globalValue === undefined) {
        w_result = w_setting.inspect("closeEmptyGroups")!.defaultValue;
    } else {
        w_result = w_setting.inspect("closeEmptyGroups")!.globalValue;
    }
    if (w_result === true) {
        if (p_forced) {
            void this.clearCloseEmptyGroups();
            void vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_EMPTY_CLEARED);
        } else {
            void vscode.window.showWarningMessage(
                Constants.USER_MESSAGES.CLOSE_EMPTY_RECOMMEND,
                Constants.USER_MESSAGES.FIX_IT
            ).then(p_chosenButton =&gt; {
                if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                    void vscode.commands.executeCommand(Constants.COMMANDS.CLEAR_CLOSE_EMPTY_GROUPS);
                    void vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_EMPTY_CLEARED);
                }
            });
        }
    }
}

</t>
<t tx="felix.20211007213344.13">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    // Shorthand pointers for readability
    const GET = vscode.workspace.getConfiguration;
    const NAME = Constants.CONFIG_NAME;
    const NAMES = Constants.CONFIG_NAMES;
    const DEFAULTS = Constants.CONFIG_DEFAULTS;
    const FLAGS = Constants.CONTEXT_FLAGS;

    if (this._isBusySettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        this.checkForChangeExternalFiles = GET(NAME).get(NAMES.CHECK_FOR_CHANGE_EXTERNAL_FILES, DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES);
        this.defaultReloadIgnore = GET(NAME).get(NAMES.DEFAULT_RELOAD_IGNORE, DEFAULTS.DEFAULT_RELOAD_IGNORE);
        this.sessionPerWorkspace = GET(NAME).get(NAMES.SESSION_PER_WORKSPACE, DEFAULTS.SESSION_PER_WORKSPACE);
        this.leoTreeBrowse = GET(NAME).get(NAMES.LEO_TREE_BROWSE, DEFAULTS.LEO_TREE_BROWSE);
        this.treeKeepFocus = GET(NAME).get(NAMES.TREE_KEEP_FOCUS, DEFAULTS.TREE_KEEP_FOCUS);
        this.treeKeepFocusWhenAside = GET(NAME).get(NAMES.TREE_KEEP_FOCUS_WHEN_ASIDE, DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE);

        this.collapseAllShortcut = GET(NAME).get(NAMES.COLLAPSE_ALL_SHORTCUT, DEFAULTS.COLLAPSE_ALL_SHORTCUT);
        this.activityViewShortcut = GET(NAME).get(NAMES.ACTIVITY_VIEW_SHORTCUT, DEFAULTS.ACTIVITY_VIEW_SHORTCUT);
        this.goAnywhereShortcut = GET(NAME).get(NAMES.GO_ANYWHERE_SHORTCUT, DEFAULTS.GO_ANYWHERE_SHORTCUT);

        this.showUnlOnStatusBar = GET(NAME).get(NAMES.SHOW_UNL_ON_STATUSBAR, DEFAULTS.SHOW_UNL_ON_STATUSBAR);
        // this.statusBarString = GET(NAME).get(NAMES.STATUSBAR_STRING, DEFAULTS.STATUSBAR_STRING);
        // if (this.statusBarString.length &gt; 8) {
        //     this.statusBarString = DEFAULTS.STATUSBAR_STRING;
        // }
        // this.statusBarColor = GET(NAME).get(NAMES.STATUSBAR_COLOR, DEFAULTS.STATUSBAR_COLOR);
        // if (!utils.isHexColor(this.statusBarColor)) {
        //     this.statusBarColor = DEFAULTS.STATUSBAR_COLOR;
        // }
        this.treeInExplorer = GET(NAME).get(NAMES.TREE_IN_EXPLORER, DEFAULTS.TREE_IN_EXPLORER);
        this.showEditOnNodes = GET(NAME).get(NAMES.SHOW_EDIT, DEFAULTS.SHOW_EDIT);
        this.showAddOnNodes = GET(NAME).get(NAMES.SHOW_ADD, DEFAULTS.SHOW_ADD);
        this.showMarkOnNodes = GET(NAME).get(NAMES.SHOW_MARK, DEFAULTS.SHOW_MARK);
        this.showCloneOnNodes = GET(NAME).get(NAMES.SHOW_CLONE, DEFAULTS.SHOW_CLONE);
        this.showCopyOnNodes = GET(NAME).get(NAMES.SHOW_COPY, DEFAULTS.SHOW_COPY);

        // this.showArrowsOnNodes = GET(NAME).get(NAMES.SHOW_ARROWS, DEFAULTS.SHOW_ARROWS);

        // this.showEditionOnBody = GET(NAME).get(NAMES.SHOW_EDITION_BODY, DEFAULTS.SHOW_EDITION_BODY);
        // this.showClipboardOnBody = GET(NAME).get(NAMES.SHOW_CLIPBOARD_BODY, DEFAULTS.SHOW_CLIPBOARD_BODY);
        // this.showPromoteOnBody = GET(NAME).get(NAMES.SHOW_PROMOTE_BODY, DEFAULTS.SHOW_PROMOTE_BODY);
        // this.showExecuteOnBody = GET(NAME).get(NAMES.SHOW_EXECUTE_BODY, DEFAULTS.SHOW_EXECUTE_BODY);
        // this.showExtractOnBody = GET(NAME).get(NAMES.SHOW_EXTRACT_BODY, DEFAULTS.SHOW_EXTRACT_BODY);
        // this.showImportOnBody = GET(NAME).get(NAMES.SHOW_IMPORT_BODY, DEFAULTS.SHOW_IMPORT_BODY);
        // this.showRefreshOnBody = GET(NAME).get(NAMES.SHOW_REFRESH_BODY, DEFAULTS.SHOW_REFRESH_BODY);
        // this.showHoistOnBody = GET(NAME).get(NAMES.SHOW_HOIST_BODY, DEFAULTS.SHOW_HOIST_BODY);
        // this.showMarkOnBody = GET(NAME).get(NAMES.SHOW_MARK_BODY, DEFAULTS.SHOW_MARK_BODY);
        // this.showSortOnBody = GET(NAME).get(NAMES.SHOW_SORT_BODY, DEFAULTS.SHOW_SORT_BODY);

        this.invertNodeContrast = GET(NAME).get(NAMES.INVERT_NODES, DEFAULTS.INVERT_NODES);
        this.leoID = GET(NAME).get(NAMES.LEO_ID, DEFAULTS.LEO_ID);

    }
}

</t>
<t tx="felix.20211007213344.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {

    // Config settings used on Leo's side
    public checkForChangeExternalFiles: string = Constants.CONFIG_DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES;
    public defaultReloadIgnore: string = Constants.CONFIG_DEFAULTS.DEFAULT_RELOAD_IGNORE;

    // Config settings used on vscode's side
    public sessionPerWorkspace: boolean = Constants.CONFIG_DEFAULTS.SESSION_PER_WORKSPACE; // Used as Context Flag
    public leoTreeBrowse: boolean = Constants.CONFIG_DEFAULTS.LEO_TREE_BROWSE; // Used as Context Flag
    public treeKeepFocus: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS;
    public treeKeepFocusWhenAside: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE;

    public collapseAllShortcut: boolean = Constants.CONFIG_DEFAULTS.COLLAPSE_ALL_SHORTCUT;
    public activityViewShortcut: boolean = Constants.CONFIG_DEFAULTS.ACTIVITY_VIEW_SHORTCUT;
    public goAnywhereShortcut: boolean = Constants.CONFIG_DEFAULTS.GO_ANYWHERE_SHORTCUT;

    public showUnlOnStatusBar: boolean = Constants.CONFIG_DEFAULTS.SHOW_UNL_ON_STATUSBAR;
    public treeInExplorer: boolean = Constants.CONFIG_DEFAULTS.TREE_IN_EXPLORER; // Used as Context Flag
    public showEditOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDIT; // Used as Context Flag

    public showAddOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ADD; // Used as Context Flag
    public showMarkOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK; // Used as Context Flag
    public showCloneOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLONE; // Used as Context Flag
    public showCopyOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_COPY; // Used as Context Flag

    // public showEditionOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDITION_BODY; // Used as Context Flag
    // public showClipboardOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLIPBOARD_BODY; // Used as Context Flag
    // public showPromoteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_PROMOTE_BODY; // Used as Context Flag
    // public showExecuteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXECUTE_BODY; // Used as Context Flag
    // public showExtractOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXTRACT_BODY; // Used as Context Flag
    // public showImportOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_IMPORT_BODY; // Used as Context Flag
    // public showRefreshOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_REFRESH_BODY; // Used as Context Flag
    // public showHoistOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_HOIST_BODY; // Used as Context Flag
    // public showMarkOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK_BODY; // Used as Context Flag
    // public showSortOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_SORT_BODY; // Used as Context Flag

    public invertNodeContrast: boolean = Constants.CONFIG_DEFAULTS.INVERT_NODES;
    public leoID: string = Constants.CONFIG_DEFAULTS.LEO_ID;

    public setLeoJsSettingsPromise: Promise&lt;unknown&gt; = Promise.resolve();

    private _isBusySettingConfig: boolean = false;

    private _confirmOffValue: string;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoUI: LeoUI
    ) {
        if (g.isBrowser) {
            this._confirmOffValue = 'keyboardOnly';
        } else {
            this._confirmOffValue = 'never';
        }
    }

    @others
}
</t>
<t tx="felix.20211007213344.3">/**
 * * Get actual 'live' Leojs configuration
 * @returns An object with config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,
        defaultReloadIgnore: this.defaultReloadIgnore,
        sessionPerWorkspace: this.sessionPerWorkspace, // Used as Context Flag
        leoTreeBrowse: this.leoTreeBrowse, // Used as Context Flag
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,

        collapseAllShortcut: this.collapseAllShortcut,
        activityViewShortcut: this.activityViewShortcut,
        goAnywhereShortcut: this.goAnywhereShortcut,

        showUnlOnStatusBar: this.showUnlOnStatusBar,
        treeInExplorer: this.treeInExplorer, // Used as Context Flag
        showEditOnNodes: this.showEditOnNodes, // Used as Context Flag
        showAddOnNodes: this.showAddOnNodes, // Used as Context Flag
        showMarkOnNodes: this.showMarkOnNodes, // Used as Context Flag
        showCloneOnNodes: this.showCloneOnNodes, // Used as Context Flag
        showCopyOnNodes: this.showCopyOnNodes, // Used as Context Flag

        // showEditionOnBody: this.showEditionOnBody, // Used as Context Flag
        // showClipboardOnBody: this.showClipboardOnBody, // Used as Context Flag
        // showPromoteOnBody: this.showPromoteOnBody, // Used as Context Flag
        // showExecuteOnBody: this.showExecuteOnBody, // Used as Context Flag
        // showExtractOnBody: this.showExtractOnBody, // Used as Context Flag
        // showImportOnBody: this.showImportOnBody, // Used as Context Flag
        // showRefreshOnBody: this.showRefreshOnBody, // Used as Context Flag
        // showHoistOnBody: this.showHoistOnBody, // Used as Context Flag
        // showMarkOnBody: this.showMarkOnBody, // Used as Context Flag
        // showSortOnBody: this.showSortOnBody, // Used as Context Flag

        invertNodeContrast: this.invertNodeContrast,
        leoID: this.leoID
    };
}

</t>
<t tx="felix.20211007213344.5">/**
 * * Apply changes to the expansion config settings and save them in user settings.
 * @param p_changes is an array of codes and values to be changed
 * @returns a promise that resolves upon completion
 */
public setLeojsSettings(p_changes: ConfigSetting[]): Promise&lt;unknown&gt; {
    this._isBusySettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        // tslint:disable-next-line: strict-comparisons
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // Set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
        } else {
            // Set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
        }
    });

    this.setLeoJsSettingsPromise = Promise.all(w_promises);
    return this.setLeoJsSettingsPromise.then(() =&gt; {
        this._isBusySettingConfig = false;
        this.buildFromSavedSettings();
        return Promise.resolve();
    });

}

</t>
<t tx="felix.20211007213344.7">/**
 * * Set the workbench.editor.enablePreview vscode setting
 */
public setEnablePreview(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("enablePreview", true, true);
}

</t>
<t tx="felix.20211007213344.8">/**
 * * Clears the workbench.editor.closeEmptyGroups vscode setting
 */
public clearCloseEmptyGroups(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("closeEmptyGroups", false, true);
}

</t>
<t tx="felix.20211007213900.1">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    sessionPerWorkspace: boolean;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;

    collapseAllShortcut: boolean;
    activityViewShortcut: boolean;
    goAnywhereShortcut: boolean;

    showUnlOnStatusBar: boolean,
    // statusBarString: string;
    // statusBarColor: string;

    treeInExplorer: boolean;
    showEditOnNodes: boolean;
    // showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;

    // showEditionOnBody: boolean; // clone delete insert(s)
    // showClipboardOnBody: boolean; // cut copy paste(s)
    // showPromoteOnBody: boolean; // promote demote
    // showExecuteOnBody: boolean; // extract(s)
    // showExtractOnBody: boolean;
    // showImportOnBody: boolean;
    // showRefreshOnBody: boolean;
    // showHoistOnBody: boolean;
    // showMarkOnBody: boolean;
    // showSortOnBody: boolean;

    invertNodeContrast: boolean;
    leoID: string;
}

</t>
<t tx="felix.20211007213909.1">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20211007214102.1">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG_NAMES = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    SESSION_PER_WORKSPACE: "sessionPerWorkspace",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",

    COLLAPSE_ALL_SHORTCUT: "collapseAllShortcut",
    ACTIVITY_VIEW_SHORTCUT: "ActivityViewShortcut",
    GO_ANYWHERE_SHORTCUT: "goAnywhereShortcut",

    SHOW_UNL_ON_STATUSBAR: "showUnlOnStatusBar",
    // SHOW_EDITION_BODY: "showEditionOnBody",
    // SHOW_CLIPBOARD_BODY: "showClipboardOnBody",
    // SHOW_PROMOTE_BODY: "showPromoteOnBody",
    // SHOW_EXECUTE_BODY: "showExecuteOnBody",
    // SHOW_EXTRACT_BODY: "showExtractOnBody",
    // SHOW_IMPORT_BODY: "showImportOnBody",
    // SHOW_REFRESH_BODY: "showRefreshOnBody",
    // SHOW_HOIST_BODY: "showHoistOnBody",
    // SHOW_MARK_BODY: "showMarkOnBody",
    // SHOW_SORT_BODY: "showSortOnBody",

    INVERT_NODES: "invertNodeContrast",
    LEO_ID: "leoID"
};

</t>
<t tx="felix.20211007214110.1">/**
 * * Configuration Defaults used in config.ts
 * Used when setting itself and getting parameters from vscode
 */
public static CONFIG_DEFAULTS = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "none",  // Used in leoBridge scrip,
    DEFAULT_RELOAD_IGNORE: "none", // Used in leoBridge scrip,
    SESSION_PER_WORKSPACE: true,
    LEO_TREE_BROWSE: true,
    TREE_KEEP_FOCUS: true,
    TREE_KEEP_FOCUS_WHEN_ASIDE: false,

    COLLAPSE_ALL_SHORTCUT: true,
    ACTIVITY_VIEW_SHORTCUT: true,
    GO_ANYWHERE_SHORTCUT: true,

    SHOW_UNL_ON_STATUSBAR: true,

    TREE_IN_EXPLORER: true,
    SHOW_EDIT: true,
    SHOW_ADD: false,
    SHOW_MARK: false,
    SHOW_CLONE: false,
    SHOW_COPY: false,

    // SHOW_EDITION_BODY: true,
    // SHOW_CLIPBOARD_BODY: true,
    // SHOW_PROMOTE_BODY: true,
    // SHOW_EXECUTE_BODY: true,
    // SHOW_EXTRACT_BODY: true,
    // SHOW_IMPORT_BODY: true,
    // SHOW_REFRESH_BODY: true,
    // SHOW_HOIST_BODY: true,
    // SHOW_MARK_BODY: true,
    // SHOW_SORT_BODY: true,

    INVERT_NODES: false,
    LEO_ID: ""
};

</t>
<t tx="felix.20211007214455.1">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="felix.20211007232334.1">/**
 * * Refresh tree for 'node hover icons' to show up properly after changing their settings
 */
public configTreeRefresh(): void {
    if (this.leoStates.fileOpenedReady) {
        this._preventShowBody = true;
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20211008004139.1">/**
 * * Find panel controls ids
 */
public static FIND_INPUTS_IDS = {
    FIND_TEXT: "findText",
    REPLACE_TEXT: "replaceText",
    ENTIRE_OUTLINE: "entireOutline",
    FILE_ONLY: "fileOnly",
    NODE_ONLY: "nodeOnly",
    SUBOUTLINE_ONLY: "subOutlineOnly",
    IGNORE_CASE: "ignoreCase",
    MARK_CHANGES: "markChanges",
    MARK_FINDS: "markFinds",
    REG_EXP: "regExp",
    WHOLE_WORD: "wholeWord",
    SEARCH_BODY: "searchBody",
    SEARCH_HEADLINE: "searchHeadline"
};

</t>
<t tx="felix.20211010192923.1">import * as vscode from "vscode";
import * as utils from "./utils";
import * as path from 'path';
import { BodyTimeInfo } from "./types";
import { LeoUI } from "./leoUI";
import * as g from './core/leoGlobals';
import { Constants } from "./constants";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20211010192923.10">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('------ Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20211010192923.11">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    if (this.preventSaveToLeo) {
        this.preventSaveToLeo = false;
    } else {
        void this._leoUi.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    }

    const w_gnx = utils.leoUriToStr(p_uri);
    if (!this._openedBodiesInfo[w_gnx]) {
        console.error("LeoJS: Tried to save body other than selected node's body", w_gnx);
    }
    this._setOpenedBodyTime(w_gnx);
    if (w_gnx === this._lastGnx) {
        this._lastBodyLength = p_content.byteLength;
    }
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20211010192923.12">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('Called rename on ', p_oldUri.fsPath, p_newUri.fsPath); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20211010192923.13">public delete(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesInfo[w_gnx]) {
        delete this._openedBodiesInfo[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20211010192923.14">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20211010192923.15">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20211010192923.2">/**
 * * Body panes implementation as a file system using "leojsDetached" as a scheme identifier
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastBodyLength: number = 0; // length of last file read
    // * List of currently VISIBLE opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    public watchedBodiesGnx: string[] = [];

    // * List of gnx open in tab(s) (from tryApplyNodeToBody / switchBody and fs.delete)
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    private _lastBodyTimeGnx: string = "";

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being watched by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoUi: LeoUI) { }

    @others
}
</t>
<t tx="felix.20211010192923.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setNewBodyUriTime(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._lastBodyTimeGnx = w_gnx;
    this._setOpenedBodyTime(w_gnx);
}

</t>
<t tx="felix.20211010192923.4">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {

    this._setOpenedBodyTime(p_gnx);

    if (!this.watchedBodiesGnx.includes(p_gnx)) {
        return; // Document is not being watched (closed tab or non-visible non-dirty tab)
    }
    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    }]);
}

</t>
<t tx="felix.20211010192923.6">public watch(p_resource: vscode.Uri, p_options: { readonly recursive: boolean; readonly excludes: readonly string[] }): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this.watchedBodiesGnx.includes(w_gnx)) {
        this.watchedBodiesGnx.push(w_gnx); // add gnx
    }
    // else already in list
    return new vscode.Disposable(() =&gt; {
        const w_position = this.watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this.watchedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20211010192923.7">public stat(p_uri: vscode.Uri): vscode.FileStat {
    if (this._leoUi.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        if (p_uri.fsPath.length === 1) {

            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
            // SPECIAL CASE -----------------------------------------------
        } else if (w_gnx === this._lastGnx &amp;&amp; this._openedBodiesInfo[this._lastGnx]) {
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._lastBodyLength
            };
            // ------------------------------------------------------------
        } else if (this._openedBodiesInfo[w_gnx]) {
            const c = g.app.windowList[this._leoUi.frameIndex].c;
            const w_v = c.fileCommands.gnxDict[w_gnx];
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[w_gnx].ctime,
                mtime: this._openedBodiesInfo[w_gnx].mtime,
                size: Buffer.byteLength(w_v.b, 'utf8') // w_v.b.length
            };
        }
    }
    // throw vscode.FileSystemError.FileNotFound();
    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
    return { type: vscode.FileType.File, ctime: 0, mtime: 0, size: 0 };
}

</t>
<t tx="felix.20211010192923.8">public readFile(p_uri: vscode.Uri): Uint8Array {
    if (this._leoUi.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            // * should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
            // if (!this._openedBodiesInfo[w_gnx]) {
            //     console.warn('readFile: ERROR File not in _openedBodiesInfo! gnx: ', w_gnx);
            // }
            const c = g.app.windowList[this._leoUi.frameIndex].c;
            const w_v = c.fileCommands.gnxDict[w_gnx];

            if (w_v) {
                this._lastGnx = w_gnx;
                this._lastBodyData = w_v.b;
                const w_buffer: Uint8Array = Buffer.from(this._lastBodyData);
                this._lastBodyLength = w_buffer.byteLength;
                return w_buffer;
            } else {
                this._leoUi.fullRefresh();
                if (this._lastGnx === w_gnx) {
                    // was last gnx of closed file about to be switched to new document selected
                    return Buffer.from(this._lastBodyData);
                }
                console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                return Buffer.from("");
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20211010192923.9">public readDirectory(p_uri: vscode.Uri): [string, vscode.FileType][] {
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._lastBodyTimeGnx, vscode.FileType.File]);
        return w_directory;
    } else {
        throw vscode.FileSystemError.FileNotFound(p_uri);
    }
}

</t>
<t tx="felix.20211010221959.1">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
    lastBodyLength?: number;
}

</t>
<t tx="felix.20211012233514.1">/**
 * * Asks for .leojs file name and path, then saves the JSON Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results.
 */
public async saveAsLeoJsFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        {
            tree: true,
            states: true,
            documents: true
        }
    );

    // ! THIS WOULD DO A 'SAVE TO' INSTEAD OF 'SAVE AS' !
    // await c.save_as_leojs();

    // * DO THIS INSTEAD !
    let fileName = await g.app.gui.runSaveFileDialog(
        c,
        'Save As JSON (.leojs)',
        [['Leo JSON files', '*.leojs']],
        '.leojs'
    );
    if (!fileName) {
        return;
    }
    if (!fileName.endsWith('.leojs')) {
        fileName = `${fileName}.leojs`;
    }
    await c.save(fileName);

    void this.launchRefresh();
    return;
}

</t>
<t tx="felix.20211024012523.1">/**
 * Returns clipboard content
*/
public getTextFromClipboard(): string {
    return this.clipboardContents;
}

</t>
<t tx="felix.20211024012536.1"></t>
<t tx="felix.20211030165058.1"></t>
<t tx="felix.20211117232843.1">{
  "command": "leojs.undoFromOutline",
  "key": "ctrl+z",
  "mac": "cmd+z",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.redoFromOutline",
  "key": "ctrl+shift+z",
  "mac": "cmd+shift+z",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/"
},
</t>
<t tx="felix.20211119001637.1">"resourceLabelFormatters": [
  {
    "scheme": "leojs",
    "formatting": {
      "label": "LeoJS: Body",
      "separator": "/",
      "workspaceSuffix": "",
      "workspaceTooltip": "LeoJS Body Pane"
    }
  },
  {
    "scheme": "leojsDetached",
    "formatting": {
      "label": "LeoJS: Detached",
      "separator": "/",
      "workspaceSuffix": "",
      "workspaceTooltip": "LeoJS Detached Body Pane"
    }
  }
]
</t>
<t tx="felix.20211122205011.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoStates } from "./leoStates";
import * as g from './core/leoGlobals';
import { Icon } from "./types";
import { LeoUI } from "./leoUI";

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20211122205031.1">/**
 * * Undo beads shown as a list with this TreeDataProvider implementation
 */
export class LeoUndosProvider implements vscode.TreeDataProvider&lt;LeoUndoNode&gt; {

    private _beadId = 0;

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoUndoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoUndoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoUndoNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _leoUI: LeoUI,
        private _icons: Icon[],
    ) { }

    @others
}

</t>
<t tx="felix.20211122212823.1">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoUndoNode extends vscode.TreeItem {

    constructor(
        public label: string,
        public description: string,
        public id: string,
        public contextValue: string,
        public beadIndex: number,
        public iconPath?: Icon
    ) {
        super(label);
    }

    @others
}

</t>
<t tx="felix.20211122213012.1">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20211122213023.1">public getTreeItem(element: LeoUndoNode): Thenable&lt;LeoUndoNode&gt; | LeoUndoNode {
    return element;
}

</t>
<t tx="felix.20211122213037.1">public getParent(element: LeoUndoNode): vscode.ProviderResult&lt;LeoUndoNode&gt; {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return undefined;
}

</t>
<t tx="felix.20211122214230.1">public getChildren(element?: LeoUndoNode): LeoUndoNode[] {
    const w_children: LeoUndoNode[] = [];
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element &amp;&amp; g.app.windowList.length) {
        const c = g.app.windowList[this._leoUI.frameIndex].c;
        const undoer = c.undoer;

        if (undoer.beads.length) {

            let w_foundNode: LeoUndoNode | undefined;
            let i: number = 0;
            let w_defaultIcon = 1;

            undoer.beads.forEach(p_bead =&gt; {
                let w_description: string = "";
                let w_undoFlag: boolean = false;
                let w_icon = w_defaultIcon;
                if (i === undoer.bead) {
                    w_description = "Undo";
                    w_undoFlag = true;
                    w_icon = 0;
                    w_defaultIcon = 2;
                }
                if (i === undoer.bead + 1) {
                    w_description = "Redo";
                    w_icon = 2;
                    w_defaultIcon = 3;
                    if (!w_foundNode) {
                        w_undoFlag = true; // Passed all nodes until 'redo', no undo found.
                    }
                }
                const w_node = new LeoUndoNode(
                    p_bead.undoType || "unknown",
                    w_description,
                    (this._beadId++).toString(),
                    Constants.CONTEXT_FLAGS.UNDO_BEAD,
                    i - undoer.bead,
                    this._icons[w_icon]
                );
                w_children.push(w_node);
                if (w_undoFlag) {
                    w_foundNode = w_node;
                }
                i++;
            });
            if (w_foundNode) {
                this._leoUI.setUndoSelection(w_foundNode);
            }
        } else {
            const w_node = new LeoUndoNode(
                "Unchanged",
                "",
                (this._beadId++).toString(),
                Constants.CONTEXT_FLAGS.NOT_UNDO_BEAD,
                0,
                undefined
            );
            w_children.push(w_node);
        }

    }
    return w_children; // Defaults to an empty list of children
}

</t>
<t tx="felix.20211122230343.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onUndosTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_event.visible) {
        const lastLeoUndos = p_explorerView ? this._leoUndosExplorer : this._leoUndos;
        const undosShown = p_explorerView ? this._leoUndosExplorerShown : this._leoUndosShown;

        this._lastLeoUndos = lastLeoUndos;
        if (undosShown) {
            this._leoUndosProvider.refreshTreeRoot(); // Already shown, will redraw but not re-select
        }

        if (p_explorerView) {
            this._leoUndosExplorerShown = true;
        } else {
            this._leoUndosShown = true;
        }
    }
}

</t>
<t tx="felix.20211124223735.1">/**
 * * Refreshes the undo pane
 */
private _refreshUndoPane(): void {
    this._leoUndosProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20211201001847.1">export class LeoOutlineNode extends vscode.TreeItem {

    constructor(
        public label: vscode.TreeItemLabel, // Node headline
        public collapsibleState: vscode.TreeItemCollapsibleState,
        public position: Position, // Pointer/reference for leo's node position
        public description: string,
        public iconPath: Icon,
        public id: string,
        public contextValue: string // For contextual menu on each node (not the global 'selected node' flag!)
    ) {
        super(label, collapsibleState);
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            // using 'this' as LeoOutlineNode instead of position, to match 'openToTheSide' paramter
            arguments: [this]
        };
    }

}
</t>
<t tx="felix.20211204144931.1"></t>
<t tx="felix.20211204144931.2">/**
 * * Validate headline edit input box if active, or, Save body to the Leo app if its dirty.
 *   That is, only if a change has been made to the body 'document' so far
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean, p_fromFocusChange?: boolean): Thenable&lt;unknown&gt; {

    // * Check if headline edit input box is active. Validate it with current value.
    if (!p_fromFocusChange &amp;&amp; this._hib &amp;&amp; this._hib.enabled) {
        this._hibInterrupted = true;
        this._hib.enabled = false;
        this._hibLastValue = this._hib.value;
        this._hib.hide();
        if (this._onDidHideResolve) {
            console.error('IN triggerBodySave AND _onDidHideResolve PROMISE ALREADY EXISTS!');
        }
        const w_resolveAfterEditHeadline = new Promise&lt;void&gt;((p_resolve, p_reject) =&gt; {
            this._onDidHideResolve = p_resolve;
        });
        return w_resolveAfterEditHeadline;
    }

    // * Save any 'detached' dirty panels to leo
    for (const doc of vscode.workspace.textDocuments) {
        if (!doc.isClosed &amp;&amp; doc.isDirty &amp;&amp; doc.uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME) {
            void this._bodySaveDocument(doc, p_forcedVsCodeSave);
        }
    }

    // * Save body to Leo if a change has been made to the body 'document' so far
    let q_savePromise: Thenable&lt;boolean&gt;;
    if (
        this._bodyLastChangedDocument &amp;&amp;
        (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
        !this._bodyLastChangedDocumentSaved
    ) {
        // * Is dirty and unsaved, so proper save is in order
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        this._bodyLastChangedDocumentSaved = true;
        this._editorTouched = false;
        q_savePromise = this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else if (
        p_forcedVsCodeSave &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        this._bodyLastChangedDocumentSaved
    ) {
        // * Had 'forcedVsCodeSave' and isDirty only, so just clean up dirty VSCODE document flag.
        this._bodySaveSelection(); // just save selection if it's changed
        q_savePromise = this._bodyLastChangedDocument.save(); // ! USED INTENTIONALLY: This trims trailing spaces
    } else {
        this._bodyLastChangedDocumentSaved = true;
        this._bodySaveSelection();  // just save selection if it's changed
        q_savePromise = Promise.resolve(true);
    }

    return q_savePromise.then((p_result) =&gt; {
        return p_result;
    }, (p_reason) =&gt; {
        console.log('BodySave rejected :', p_reason);
        return false;
    });
}

</t>
<t tx="felix.20211204144931.3">/**
 * Saves the cursor position along with the text selection range and scroll position
 * of the last body, or detached body pane, that had its cursor info set in this._selection, etc.
 */
private _bodySaveSelection(): void {

    if (!this._selectionDirty || !this._selection) {
        return;
    }
    // Prepare scroll data separately

    let scroll: number;
    if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
        scroll = this._scroll?.start.line || 0;
    } else {
        scroll = 0;
    }

    let gnx: string | undefined;
    let c: Commands | undefined;
    let id: string;

    if (!this._selectionGnx.includes('/')) {
        c = g.app.windowList[this.frameIndex].c;
        gnx = this._selectionGnx;
    } else {
        [id, gnx] = this._selectionGnx.split('/');
        for (const w_f of g.app.windowList) {
            if (w_f.c.id.toString() === id) {
                c = w_f.c;
                break;
            }
        }
    }

    const start = {
        line: this._selection.start.line || 0,
        col: this._selection.start.character || 0,
    };
    const end = {
        line: this._selection.end.line || 0,
        col: this._selection.end.character || 0,
    };
    const active = {
        line: this._selection.active.line || 0,
        col: this._selection.active.character || 0,
    };
    if (!c || !gnx) {
        return;
    }
    let p: Position | undefined;
    if (c.p.gnx === gnx) {
        p = c.p;
    } else {
        // find p.
        for (let p_p of c.all_positions()) {
            if (p_p.v.gnx === gnx) {
                p = p_p;
                break;
            }
        }
    }
    if (!p) {
        return;
    }

    // - "ap":     An archived position for position p.
    // - "start":  The start of the selection.
    // - "end":    The end of the selection.
    // - "active": The insert point. Must be either start or end.
    // - "scroll": An optional scroll position.

    const v = p.v;
    const wrapper = c.frame.body.wrapper;
    const insert = g.convertRowColToPythonIndex(v.b, active['line'], active['col']);
    const startSel = g.convertRowColToPythonIndex(v.b, start['line'], start['col']);
    const endSel = g.convertRowColToPythonIndex(v.b, end['line'], end['col']);

    // If it's the currently selected node set the wrapper's states too
    if (p.__eq__(c.p)) {
        wrapper.setSelectionRange(startSel, endSel, insert);
        wrapper.setYScrollPosition(scroll);
    }
    // Always set vnode attrs.
    v.scrollBarSpot = scroll;
    v.insertSpot = insert;
    v.selectionStart = startSel &lt; endSel ? startSel : endSel;
    v.selectionLength = Math.abs(startSel - endSel);

    this._scrollDirty = false;
    this._selectionDirty = false;

}

</t>
<t tx="felix.20211204144931.4">/**
 * * Sets new body (or detached body) text on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDocument(
    p_document: vscode.TextDocument,
    p_forcedVsCodeSave?: boolean
): Thenable&lt;boolean&gt; {
    if (p_document) {

        // const c = g.app.windowList[this.frameIndex].c;
        // const u = c.undoer;
        // const wrapper = c.frame.body.wrapper;
        // const w_gnx = utils.leoUriToStr(p_document.uri);
        const body = p_document.getText().replace(/\r\n/g, "\n"); // new body text

        let id: string = ""; // STARTS FALSY
        let c: Commands | undefined;
        let u: Undoer | undefined;
        let wrapper: StringTextWrapper | undefined;
        let w_gnx: string | undefined;
        let w_v: VNode | undefined;

        if (p_document.uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME) {
            // detached body
            id = p_document.uri.path.split("/")[1];
            // find commander
            for (const w_frame of g.app.windowList) {
                if (w_frame.c.id.toString() === id) {
                    c = w_frame.c;
                    break;
                }
            }
            if (c) {
                u = c.undoer;
                wrapper = c.frame.body.wrapper;
                w_gnx = p_document.uri.path.split("/")[2];
                w_v = c.fileCommands.gnxDict[w_gnx];
            }
        } else {
            // regular body
            c = g.app.windowList[this.frameIndex].c;
            u = c.undoer;
            wrapper = c.frame.body.wrapper;
            w_gnx = utils.leoUriToStr(p_document.uri);
            w_v = c.fileCommands.gnxDict[w_gnx];
        }

        if (c &amp;&amp; w_v &amp;&amp; w_gnx &amp;&amp; wrapper &amp;&amp; u) {

            if (body !== w_v.b &amp;&amp; !g.doHook("bodykey1", { c: c, v: w_v })) {
                // if different, replace body and set dirty
                let w_p: Position | undefined;
                if (c.p.gnx === w_v.gnx) {
                    // same gnx so it's the same position for saving the new body pane text.
                    w_p = c.p;
                } else {
                    // find p.
                    for (let p of c.all_positions()) {
                        if (p.v.gnx === w_gnx) {
                            w_p = p;
                            break;
                        }
                    }
                }
                if (w_p) {
                    // ok we got a valid p.
                    const bunch = u.beforeChangeNodeContents(w_p);
                    w_p.v.setBodyString(body);
                    u.afterChangeNodeContents(w_p, "Body Text", bunch);
                    // Set in wrapper too if same gnx
                    if (c.p.__eq__(w_p)) {
                        wrapper.setAllText(body);
                    }
                    if (!c.isChanged()) {
                        c.setChanged();
                    }
                    if (!w_p.v.isDirty()) {
                        w_p.setDirty();
                    }
                    // this.clearHeadlineSelection();
                }
                g.doHook("bodykey2", { c: c, v: w_v });
            }

        } else {
            console.error("ERROR SAVING BODY FROM VSCODE TO LEOJS");
            if (p_forcedVsCodeSave) {
                return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
            }
            return Promise.resolve(false); // EARLY EXIT
        }

        // save the cursor selection, supports both body and detached bodies
        this._bodySaveSelection();

        if (!id) {
            // if NOT detached
            this._refreshType.states = true;
            this.getStates();
        }

        if (p_forcedVsCodeSave) {
            return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
        }

        return Promise.resolve(p_document.isDirty);
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20211204144931.5">/**
 * * Sets new body text on leo's side before vscode closes itself if body is dirty
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDeactivate(
    p_document: vscode.TextDocument
): Thenable&lt;unknown&gt; {
    const w_gnx = utils.leoUriToStr(p_document.uri);
    const c = g.app.windowList[this.frameIndex].c;
    const w_v = c.fileCommands.gnxDict[w_gnx];
    if (w_v) {
        w_v.b = p_document.getText().replace(/\r\n/g, "\n");
    }

    return Promise.resolve(true);
}

</t>
<t tx="felix.20211204181418.1">/**
 * * Perform insert and rename commands
 */
private _insertAndSetHeadline(p_name?: string, p_asChild?: boolean): any {
    const LEOCMD = Constants.LEO_COMMANDS;
    const w_command = p_asChild ? LEOCMD.INSERT_CHILD_PNODE : LEOCMD.INSERT_PNODE;
    const c = g.app.windowList[this.frameIndex].c;
    const u = c.undoer;
    let value: any = c.doCommandByName(w_command);
    if (!p_name) {
        return value;
    }
    const undoData = u.beforeChangeHeadline(c.p);
    c.setHeadString(c.p, p_name);  // Set v.h *after* calling the undoer's before method.
    if (!c.changed) {
        c.setChanged();
    }
    u.afterChangeHeadline(c.p, 'Edit Headline', undoData);
    return value;
}

</t>
<t tx="felix.20211212205241.1">/**
 * Replaces the system's clipboard with the given string
 * @param p_string actual string content to go onto the clipboard
 * @returns a promise that resolves when the string is put on the clipboard
 */
public replaceClipboardWith(s: string): Thenable&lt;string&gt; {
    this.clipboardContents = s; // also set immediate clipboard string
    return vscode.env.clipboard.writeText(s).then(() =&gt; { return s; });
}

</t>
<t tx="felix.20220103203600.1">/**
 * Asynchronous clipboards getter
 * Get the system's clipboard contents and returns a promise
 * Also puts it in the global clipboardContents variable
 * @returns a promise of the clipboard string content
 */
public asyncGetTextFromClipboard(): Thenable&lt;string&gt; {
    return vscode.env.clipboard.readText().then((s) =&gt; {
        // also set immediate clipboard string for possible future read
        this.clipboardContents = s;
        return this.getTextFromClipboard();
    });
}

</t>
<t tx="felix.20220103222715.1">/**
 * * Overridden 'good' minibuffer command name strings
 */
public static MINIBUFFER_OVERRIDDEN_NAMES: { [key: string]: string } = {
    'paste-node': 'async-paste-node',
    'paste-retaining-clones': 'async-paste-retaining-clones',
    'paste-as-template': 'async-paste-as-template',
    'insert-child': 'async-insert-child',
    'insert-node': 'async-insert-node',
    'insert-as-first-child': 'async-insert-as-first-child',
    'insert-as-last-child': 'async-insert-as-last-child',
    'insert-node-before': 'async-insert-node-before',
};

</t>
<t tx="felix.20220107223824.1">public runOpenFileDialog(
    c: Commands | undefined,
    title: string,
    filetypes: [string, string][],
    defaultExtension: string,
    startpath?: string
): Thenable&lt;string&gt; {
    // convert to { [name: string]: string[] } typing
    const types: { [name: string]: string[] } = utils.convertLeoFiletypes(filetypes);
    return vscode.window.showOpenDialog(
        {
            title: title,
            canSelectMany: false,
            filters: types
        }
    ).then((p_uris) =&gt; {
        const names: string[] = [];
        if (p_uris &amp;&amp; p_uris.length) {
            p_uris.forEach(w_uri =&gt; {
                names.push(w_uri.fsPath);
            });
        }
        let fileName = g.os_path_fix_drive(names.length ? names[0] : "");
        fileName = g.os_path_normslashes(fileName);
        return fileName;
    });
}

</t>
<t tx="felix.20220108211750.1">public runAskOkDialog(
    c: Commands | undefined,
    title: string,
    message: string,
    text = "Ok"
): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage(
        title,
        {
            modal: true,
            detail: message
        });
}

</t>
<t tx="felix.20220108211806.1">public runSaveFileDialog(
    c: Commands | undefined,
    title: string,
    filetypes: [string, string][],
    defaultExtension: string,
): Thenable&lt;string&gt; {
    // convert to { [name: string]: string[] } typing
    const types: { [name: string]: string[] } = utils.convertLeoFiletypes(filetypes);
    return vscode.window.showSaveDialog(
        {
            title: title,
            filters: types
        }
    ).then((p_uri) =&gt; {
        if (p_uri) {
            let fileName = g.os_path_fix_drive(p_uri.fsPath);
            fileName = g.os_path_normslashes(fileName);
            return fileName;
        } else {
            return "";
        }
    });
}

</t>
<t tx="felix.20220109180351.1">/**
 * Convert Leo's internal filetype descriptions array
 * to vscode's option format for open/save dialogs.
 */
export function convertLeoFiletypes(p_filetypes: [string, string][]): { [name: string]: string[] } {
    /*
        from :
            [
                ["", ""],
                ["Leo files", "*.leo *.db"]
            ],

        to :
        {
            'Images': ['png', 'jpg']
            'TypeScript': ['ts', 'tsx']
        }

    */
    const w_types: { [name: string]: string[] } = {};
    p_filetypes.forEach(type =&gt; {
        w_types[type[0]] = type[1].split(" ").map((p_entry) =&gt; {
            return p_entry.startsWith("*.") ? p_entry.substring(2) : p_entry;
        });
    });
    return w_types;
}
</t>
<t tx="felix.20220109220155.1">public runAskYesNoDialog(
    c: Commands | undefined,
    title: string,
    message: string,
    yes_all = false,
    no_all = false,

): Thenable&lt;string&gt; {
    const w_choices = [
        Constants.USER_MESSAGES.YES,
        Constants.USER_MESSAGES.NO
        // Note: Already shows a 'cancel' !
    ];
    if (yes_all) {
        w_choices.push(Constants.USER_MESSAGES.YES_ALL,);
    }
    if (no_all) {
        w_choices.push(Constants.USER_MESSAGES.NO_ALL,);
    }

    return vscode.window
        .showInformationMessage(
            title,
            {
                modal: true,
                detail: message
            },
            ...w_choices
        )
        .then((answer) =&gt; {
            if (answer === Constants.USER_MESSAGES.YES) {
                return Constants.USER_MESSAGES.YES.toLowerCase();
            } else if (answer === Constants.USER_MESSAGES.NO) {
                return Constants.USER_MESSAGES.NO.toLowerCase();
            } else if (answer === Constants.USER_MESSAGES.YES_ALL) {
                return "yes-all";
            } else { // (answer === Constants.USER_MESSAGES.NO_ALL)
                return "no-all";
            }
        });
}

</t>
<t tx="felix.20220128232146.1"></t>
<t tx="felix.20220131234257.1">/**
 * * Sets the leoID setting for immediate use, and in next activation
 */
public setIdSetting(p_leoID: string): Promise&lt;unknown&gt; {
    const w_changes: ConfigSetting[] = [{
        code: "leoID",
        value: p_leoID
    }];
    if (p_leoID.trim().length &gt;= 3 &amp;&amp; utils.isAlphaNumeric(p_leoID)) {
        // OK not empty
        if (g.app.leoID !== p_leoID) {
            g.app.leoID = p_leoID;
            void g.app.setIDFile();
            g.blue('leoID=' + p_leoID);
        }

        if (g.app.nodeIndices) {
            g.app.nodeIndices.userId = p_leoID;
        }
        // If LeoJS had finish its startup without valid LeoID, set ready flags!
        if (!this.leoStates.leoReady &amp;&amp; this.leoStates.leojsStartupDone &amp;&amp; this.leoStates.leoIdUnset) {
            if (g.app.leoID &amp;&amp; g.app.leoID !== 'None') {
                void this.showLogPane();
                this.leoStates.leoIdUnset = false;
                this.leoStates.leoReady = true;
                if (g.app.windowList.length) {
                    if (this.config.showUnlOnStatusBar) {
                        this._leoStatusBar?.show();
                    }
                    this.leoStates.fileOpenedReady = true;
                    this.fullRefresh();
                }
            } else {
                void vscode.window.showWarningMessage("'None' is a reserved LeoID, please choose another one.");
            }
        }
    } else if (!p_leoID.trim()) {
        // empty, go back to default
        if (g.app.nodeIndices &amp;&amp; g.app.nodeIndices.defaultId) {
            g.app.leoID = g.app.nodeIndices.defaultId;
            g.app.nodeIndices.userId = g.app.nodeIndices.defaultId;
        }
    }

    if (this.config.leoID !== p_leoID) {
        return this.config.setLeojsSettings(w_changes);
    }
    return Promise.resolve();
}

</t>
<t tx="felix.20220131235418.1">/**
 * * Returns the leoID from the leojs settings
 */
public getIdFromSetting(): string {
    return this.config.leoID;
}

</t>
<t tx="felix.20220201194319.1">/**
 * * Command to get the LeoID from dialog, save it to user settings.
 * Start leojs if the ID is valid, and not already started.
 */
public setLeoIDCommand(): Thenable&lt;unknown&gt; {
    return g.IDDialog().then((p_id) =&gt; {
        p_id = p_id.trim();
        p_id = g.app.cleanLeoID(p_id, '');
        if (p_id &amp;&amp; p_id.length &gt;= 3 &amp;&amp; utils.isAlphaNumeric(p_id)) {
            // valid id: set in config settings
            return this.setIdSetting(p_id);
        } else {
            // Canceled or invalid: (re)warn user.
            this.showLeoIDMessage();
        }
    });
}

</t>
<t tx="felix.20220201195806.1">export function isAlphaNumeric(str: string): boolean {
    let code: number;
    let i: number;
    let len: number;
    for (i = 0, len = str.length; i &lt; len; i++) {
        code = str.charCodeAt(i);
        if (!(code &gt; 47 &amp;&amp; code &lt; 58) &amp;&amp; // numeric (0-9)
            !(code &gt; 64 &amp;&amp; code &lt; 91) &amp;&amp; // upper alpha (A-Z)
            !(code &gt; 96 &amp;&amp; code &lt; 123) // lower alpha (a-z)
        ) {
            return false;
        }
    }
    return true;
};
</t>
<t tx="felix.20220201225503.1">public ensure_commander_visible(c: Commands): void {
    this.showBodyIfClosed = true;
    this.showOutlineIfClosed = true;
}

</t>
<t tx="felix.20220201230041.1">/**
 * Show info window about requiring leoID to start
 * and a button to perform the 'set leoID' command.
 */
public showLeoIDMessage(): void {
    void vscode.window.showInformationMessage(
        Constants.USER_MESSAGES.SET_LEO_ID_MESSAGE,
        { modal: true, detail: Constants.USER_MESSAGES.GET_LEO_ID_PROMPT },
        Constants.USER_MESSAGES.ENTER_LEO_ID
    ).then(p_chosenButton =&gt; {
        if (p_chosenButton === Constants.USER_MESSAGES.ENTER_LEO_ID) {
            void vscode.commands.executeCommand(Constants.COMMANDS.SET_LEO_ID);
        }
    });
}

</t>
<t tx="felix.20220201235548.1">/**
 * * Set all remaining local objects, set ready flag(s) and refresh all panels
 */
public finishStartup(): void {

    if (g.app.windowList[this.frameIndex]) {
        g.app.windowList[this.frameIndex].startupWindow = true;
    }

    this.linkProvider = new UnlProvider();
    this._context.subscriptions.push(
        vscode.languages.registerDocumentLinkProvider(
            [
                { scheme: Constants.URI_FILE_SCHEME },
                { scheme: Constants.URI_UNTITLED_SCHEME },
                { scheme: Constants.URI_LEOJS_SCHEME },
                { scheme: Constants.URI_LEOJS_DETACHED_SCHEME },
                { language: Constants.OUTPUT_CHANNEL_LANGUAGE }
            ],
            this.linkProvider
        )
    );

    // * Register a content provider for the help text panel
    this.helpDocumentPaneProvider = new HelpPanel(this);
    this._context.subscriptions.push(vscode.workspace.registerTextDocumentContentProvider(Constants.URI_HELP_SCHEME, this.helpDocumentPaneProvider));
    setTimeout(() =&gt; {
        this.helpDocumentPaneProvider.update(vscode.Uri.parse(Constants.URI_HELP_SCHEME + ":" + Constants.URI_HELP_FILENAME));
    }, 250);

    // * Create Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this.leoStates, this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._context.subscriptions.push(
        this._leoDocuments,
        this._leoDocuments.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._context.subscriptions.push(
        this._leoDocumentsExplorer,
        this._leoDocumentsExplorer.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoDocuments = this._leoDocumentsExplorer;

    // * Create '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this.leoStates, this.buttonIcons);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._context.subscriptions.push(
        this._leoButtons,
        this._leoButtons.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._context.subscriptions.push(
        this._leoButtonsExplorer,
        this._leoButtonsExplorer.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoButtons = this._leoButtonsExplorer;

    // * Create goto Treeview Providers and tree views
    this.leoGotoProvider = new LeoGotoProvider(this);

    // * Create Undos Treeview Providers and tree views
    this._leoUndosProvider = new LeoUndosProvider(this.leoStates, this, this.undoIcons);
    this._leoUndos = vscode.window.createTreeView(Constants.UNDOS_ID, { showCollapseAll: false, treeDataProvider: this._leoUndosProvider });
    this._context.subscriptions.push(
        this._leoUndos,
        this._leoUndos.onDidChangeVisibility((p_event =&gt; this._onUndosTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoUndosExplorer = vscode.window.createTreeView(Constants.UNDOS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoUndosProvider });
    this._context.subscriptions.push(
        this._leoUndosExplorer,
        this._leoUndosExplorer.onDidChangeVisibility((p_event =&gt; this._onUndosTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoUndos = this._leoUndosExplorer;

    // * Create Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);
    this._leoDetachedFileSystem = new LeoBodyDetachedProvider(this);

    this._bodyMainSelectionColumn = 1;

    // * Create Status bar Entry
    this._leoStatusBar = new LeoStatusBar(this._context, this);

    // * Leo Find Panel
    this._leoFindPanelProvider = new LeoFindPanelProvider(
        this._context.extensionUri,
        this._context,
        this
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        ),
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_EXPLORER_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );

    // * 'onDid' event detections. All pushed as disposables in context.subscription.
    this._context.subscriptions.push(

        vscode.window.tabGroups.onDidChangeTabGroups((p_tabGroupEvent) =&gt;
            this._onTabGroupsChanged(p_tabGroupEvent)
        ),
        vscode.window.tabGroups.onDidChangeTabs((p_tabEvent) =&gt;
            this._onTabsChanged(p_tabEvent)
        ),

        // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
        vscode.window.onDidChangeActiveTextEditor((p_editor) =&gt;
            this._onActiveEditorChanged(p_editor)
        ),

        // * React to change in selection, cursor position and scroll position
        vscode.window.onDidChangeTextEditorSelection((p_event) =&gt;
            this._onChangeEditorSelection(p_event)
        ),
        vscode.window.onDidChangeTextEditorVisibleRanges((p_event) =&gt;
            this._onChangeEditorScroll(p_event)
        ),

        // * Triggers when a different text editor/vscode window changed focus or visibility, or dragged
        // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
        vscode.window.onDidChangeTextEditorViewColumn((p_columnChangeEvent) =&gt;
            this._changedTextEditorViewColumn(p_columnChangeEvent)
        ), // Also triggers after drag and drop
        vscode.window.onDidChangeVisibleTextEditors((p_editors) =&gt;
            this._changedVisibleTextEditors(p_editors)
        ), // Window.visibleTextEditors changed
        vscode.window.onDidChangeWindowState((p_windowState) =&gt;
            this._changedWindowState(p_windowState)
        ), // Focus state of the current window changes

        // * React when TYPING and changing body pane
        vscode.workspace.onDidChangeTextDocument((p_textDocumentChange) =&gt;
            this._onDocumentChanged(p_textDocumentChange)
        ),

        // * React to configuration settings events
        vscode.workspace.onDidChangeConfiguration((p_configChange) =&gt;
            this._onChangeConfiguration(p_configChange)
        ),

        // * React to opening of any file in vscode
        vscode.workspace.onDidOpenTextDocument((p_document) =&gt;
            this._onDidOpenTextDocument(p_document)
        )
    );
    if (g.app.windowList.length) {
        this._setupOpenedLeoDocument();// this sets this.leoStates.fileOpenedReady
    } else {
        this._setupNoOpenedLeoDocument(); // All closed now!
    }

    if (g.app.leoID &amp;&amp; g.app.leoID !== 'None') {
        void this.showLogPane();
        this.leoStates.leoIdUnset = false;
        this.leoStates.leoReady = true;
    } else {
        this.leoStates.leoIdUnset = true; // Block most UI &amp; commands until 'setLeoIDCommand' succeeds.
    }
    this.leoStates.leojsStartupDone = true;

}

</t>
<t tx="felix.20220417155704.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { Position } from "./core/leoNodes";
import { LeoButtonNode } from "./leoButtons";
import { LeoGotoNode } from "./leoGoto";
import { LeoOutlineNode } from "./leoOutline";
import { LeoUI } from "./leoUI";
import { LeoUndoNode } from "./leoUndos";
import { ReqRefresh, Focus, LeoGotoNavKey } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20220417155732.1">/**
 * * Make all command/key bindings 
 */
export function makeAllBindings(p_leoUI: LeoUI, p_context: vscode.ExtensionContext): void {
    // Shortcut pointers for readability
    const U = undefined;
    const CMD = Constants.COMMANDS;
    const LEOCMD = Constants.LEO_COMMANDS;

    const NO_REFRESH: ReqRefresh = {};
    const REFRESH_NODE_BODY: ReqRefresh = {
        node: true, // Reveal the returned 'selected position' without changes to the tree
        body: true, // Goto/select another node needs the body pane refreshed
        states: true
    };
    const REFRESH_TREE: ReqRefresh = {
        tree: true,
        states: true
    };
    const REFRESH_TREE_BODY: ReqRefresh = {
        tree: true,
        body: true,
        states: true
    };
    const REFRESH_ALL: ReqRefresh = {
        tree: true,
        body: true,
        states: true,
        documents: true,
        buttons: true
    };

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        &lt;&lt; Define entries for all commands &gt;&gt;
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });
}

</t>
<t tx="felix.20220417215549.1">/**
 * Make all key and commands bindings
 */
public makeAllBindings(): void {
    commandBindings.makeAllBindings(this, this._context);
}

</t>
<t tx="felix.20220505215916.1"></t>
<t tx="felix.20220505215916.2">/**
 * Opens the Nav tab and focus on nav text input
 */
public findQuick(p_string?: string, p_forceEnter?: boolean): Thenable&lt;unknown&gt; {
    void this.triggerBodySave(true);
    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    return vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        const w_message: { [key: string]: string | boolean } = { type: 'selectNav' };
        if (p_string &amp;&amp; p_string.trim()) {
            w_message["text"] = p_string.trim();
        }
        if (p_forceEnter) {
            w_message["forceEnter"] = true;
        }
        if (w_panel) {
            void w_panel.webview.postMessage(w_message);
        } else {
            setTimeout(() =&gt; {
                let w_panel: vscode.WebviewView | undefined;
                if (this._lastTreeView === this._leoTreeExView) {
                    w_panel = this._findPanelWebviewExplorerView;
                } else {
                    w_panel = this._findPanelWebviewView;
                }
                void w_panel?.webview.postMessage(w_message);
            }, 290);
        }
    });
}

</t>
<t tx="felix.20220505215916.3">/**
 * Opens the Nav tab with the selected text as the search string
 */
public findQuickSelected(): Thenable&lt;unknown&gt; {
    if (vscode.window.activeTextEditor) {
        const editor = vscode.window.activeTextEditor;
        const selection = editor.selection;
        if (!selection.isEmpty) {
            const text = editor.document.getText(selection).replace(/\r\n/g, "\n");
            return this.findQuick(text, true);
        }
    }
    return this.findQuick("", true);
}

</t>
<t tx="felix.20220505215916.4">/**
 * Lists all nodes in reversed gnx order, newest to oldest
 */
public findQuickTimeline(): Thenable&lt;unknown&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;
    scon.qsc_sort_by_gnx();
    this.leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane(); // Finish by opening and focussing nav pane
}

</t>
<t tx="felix.20220505215916.5">/**
 * Lists all nodes that are changed (aka "dirty") since last save.
 */
public findQuickChanged(): Thenable&lt;unknown&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;
    scon.qsc_find_changed();
    this.leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane(); // Finish by opening and focussing nav pane
}

</t>
<t tx="felix.20220505215916.6">/**
 * Lists nodes from c.nodeHistory.
 */
public findQuickHistory(): Thenable&lt;unknown&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;
    scon.qsc_get_history();
    this.leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane(); // Finish by opening and focussing nav pane
}

</t>
<t tx="felix.20220505215916.7">/**
 * List all marked nodes.
 */
public findQuickMarked(p_preserveFocus?: boolean): Thenable&lt;unknown&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;
    scon.qsc_show_marked();
    this.leoGotoProvider.refreshTreeRoot();
    // if (p_preserveFocus &amp;&amp; (this._leoGoto.visible || this._leoGotoExplorer.visible)) {
    //     return Promise.resolve();
    // }
    if (
        p_preserveFocus &amp;&amp; (
            (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) ||
            (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible)
        )
    ) {
        return Promise.resolve();
    }
    return this.showGotoPane(); // Finish by opening and focussing nav pane
}

</t>
<t tx="felix.20220505215916.8">/**
 * Opens goto and focus in depending on passed options
 */
public showGotoPane(p_options?: { preserveFocus?: boolean }): Thenable&lt;unknown&gt; {
    void this.triggerBodySave(true);

    // if (this._lastTreeView === this._leoTreeExView) {
    //     w_panel = Constants.GOTO_EXPLORER_ID;
    // } else {
    //     w_panel = Constants.GOTO_ID;
    // }

    // void vscode.commands.executeCommand(w_panel + '.focus', p_options);

    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    // this._findNeedsFocus = 2;
    // setTimeout(() =&gt; {
    //     this._findNeedsFocus = 0;
    // }, 250);
    return vscode.commands.executeCommand(w_panelID + '.focus', p_options).then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        const w_message: { [key: string]: string } = { type: 'showGoto' };
        if (w_panel) {
            void w_panel.webview.postMessage(w_message);
        } else {
            setTimeout(() =&gt; {
                let w_panel: vscode.WebviewView | undefined;
                if (this._lastTreeView === this._leoTreeExView) {
                    w_panel = this._findPanelWebviewExplorerView;
                } else {
                    w_panel = this._findPanelWebviewView;
                }
                void w_panel?.webview.postMessage(w_message);
            }, 290);
        }
    });

}

</t>
<t tx="felix.20220505215916.9">/**
 * * Handles a click (selection) of a nav panel node: Sends 'goto' command to server.
 */
public async gotoNavEntry(p_node: LeoGotoNode): Promise&lt;unknown&gt; {
    if (!p_node) {
        console.log('ERROR NO NODE TO SHOW IN GOTO PANE!');
        return;
    }

    await this.triggerBodySave(true);
    this.leoGotoProvider.resetSelectedNode(p_node); // Inform controller of last index chosen
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;

    if (p_node.entryType === 'tag') {
        // * For when the nav input IS CLEARED : GOTO PANE LISTS ALL TAGS!
        // The node clicked was one of the tags, pre-fill the nac search with this tag and open find pane
        let w_string: string = p_node.label as string;

        let w_panelID = '';
        let w_panel: vscode.WebviewView | undefined;
        if (this._lastTreeView === this._leoTreeExView) {
            w_panelID = Constants.FIND_EXPLORER_ID;
            w_panel = this._findPanelWebviewExplorerView;
        } else {
            w_panelID = Constants.FIND_ID;
            w_panel = this._findPanelWebviewView;
        }
        await vscode.commands.executeCommand(w_panelID + '.focus');

        if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
            w_panel = this._findPanelWebviewView;
        } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
            w_panel = this._findPanelWebviewExplorerView;
        }

        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        const w_message: { [key: string]: string; } = { type: 'selectNav' };
        if (w_string &amp;&amp; w_string.trim()) {
            w_message["text"] = w_string.trim();
        }
        await w_panel!.webview.postMessage(w_message);
        // Do search

        setTimeout(() =&gt; {
            const inp = scon.navText;
            if (scon.isTag) {
                scon.qsc_find_tags(inp);
            } else {
                scon.qsc_search(inp);
            }
            this.leoGotoProvider.refreshTreeRoot();
            void this.showGotoPane({ preserveFocus: true }); // show but dont change focus
        }, 10);

    } else if (p_node.entryType !== 'generic' &amp;&amp; p_node.entryType !== 'parent') {
        // Other and not a tag so just locate the entry in either body or outline
        // const p_navEntryResult = await this.sendAction(
        //     Constants.LEOBRIDGE.GOTO_NAV_ENTRY,
        //     { key: p_node.key }
        // );

        const it = p_node.key;
        scon.onSelectItem(it);

        let w_focus = this._get_focus();

        if (!w_focus) {
            return vscode.window.showInformationMessage('Not found');
        } else {
            let w_revealTarget = Focus.Body;
            w_focus = w_focus.toLowerCase();

            if (w_focus.includes('tree') || w_focus.includes('head')) {
                // tree
                w_revealTarget = Focus.Outline;
                this.showOutlineIfClosed = true;
            } else {
                this.showBodyIfClosed = true;
            }

            this.setupRefresh(
                // ! KEEP FOCUS ON GOTO PANE !
                Focus.Goto,
                {
                    tree: true,
                    body: true,
                    scroll: w_revealTarget === Focus.Body,
                    // documents: false,
                    // buttons: false,
                    states: true,
                }
            );
            return this.launchRefresh();
        }
    }

}

</t>
<t tx="felix.20220505215924.1"></t>
<t tx="felix.20220505215924.12">/**
 * * Set search setting in the search webview
 * @param p_id string id of the setting name
 */
public setSearchSetting(p_id: string): void {
    if (this._findPanelWebviewExplorerView) {
        void this._findPanelWebviewExplorerView!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
    }
    if (this._findPanelWebviewView) {
        void this._findPanelWebviewView!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
    }
}

</t>
<t tx="felix.20220505215924.13">/**
 * * Gets the search settings from Leo, and applies them to the find panel webviews
 */
public loadSearchSettings(): void {

    if (!g.app.windowList.length || !g.app.windowList[this.frameIndex]) {
        return;
    }
    const c = g.app.windowList[this.frameIndex].c;
    const scon = c.quicksearchController;
    const leoISettings = c.findCommands.ftm.get_settings();
    const w_settings: LeoSearchSettings = {
        // Nav options
        navText: scon.navText,
        showParents: scon.showParents,
        isTag: scon.isTag,
        searchOptions: scon.searchOptions,
        //Find/change strings...
        findText: leoISettings.find_text,
        replaceText: leoISettings.change_text,
        // Find options...
        ignoreCase: leoISettings.ignore_case,
        markChanges: leoISettings.mark_changes,
        markFinds: leoISettings.mark_finds,
        wholeWord: leoISettings.whole_word,
        regExp: leoISettings.pattern_match,
        searchHeadline: leoISettings.search_headline,
        searchBody: leoISettings.search_body,
        // 0, 1 or 2 for outline, sub-outline, or node.
        searchScope:
            0 +
            (leoISettings.suboutline_only ? 1 : 0) +
            (leoISettings.node_only ? 2 : 0) +
            (leoISettings.file_only ? 3 : 0),
    };
    if (w_settings.searchScope &gt; 2) {
        console.error('searchScope SHOULD BE 0, 1, 2 only: ', w_settings.searchScope);
    }
    this._lastSettingsUsed = w_settings;
    if (this._findPanelWebviewExplorerView) {
        void this._findPanelWebviewExplorerView.webview.postMessage({
            type: 'setSettings',
            value: w_settings,
        });
    }
    if (this._findPanelWebviewView) {
        void this._findPanelWebviewView.webview.postMessage({
            type: 'setSettings',
            value: w_settings,
        });
    }

}

</t>
<t tx="felix.20220505215924.14">/**
 * * Send the settings to Leo implementation
 * @param p_settings the search settings to be set in Leo implementation to affect next results
 * @returns
 */
public saveSearchSettings(p_settings: LeoSearchSettings): Thenable&lt;unknown&gt; {

    if (!g.app.windowList.length || !g.app.windowList[this.frameIndex]) {
        return Promise.resolve();
    }

    this._lastSettingsUsed = p_settings;
    // convert to LeoGuiFindTabManagerSettings
    const searchSettings: LeoGuiFindTabManagerSettings = {
        // Nav settings
        is_tag: p_settings.isTag,
        nav_text: p_settings.navText,
        show_parents: p_settings.showParents,
        search_options: p_settings.searchOptions,
        // Find/change strings...
        find_text: p_settings.findText,
        change_text: p_settings.replaceText,
        // Find options...
        ignore_case: p_settings.ignoreCase,
        mark_changes: p_settings.markChanges,
        mark_finds: p_settings.markFinds,
        node_only: !!(p_settings.searchScope === 2),
        file_only: !!(p_settings.searchScope === 3),
        pattern_match: p_settings.regExp,
        search_body: p_settings.searchBody,
        search_headline: p_settings.searchHeadline,
        suboutline_only: !!(p_settings.searchScope === 1),
        whole_word: p_settings.wholeWord,
    };

    // Sets search options. Init widgets and ivars from param.searchSettings
    const c = g.app.windowList[this.frameIndex].c;
    const scon = c.quicksearchController;
    const find = c.findCommands;
    const ftm = c.findCommands.ftm;

    // * Try to set the search settings
    // nav settings
    scon.navText = searchSettings.nav_text;
    scon.showParents = searchSettings.show_parents;
    scon.isTag = searchSettings.is_tag;
    scon.searchOptions = searchSettings.search_options;

    // Find/change text boxes.
    const table: [string, string, string][] = [
        ['find_findbox', 'find_text', ''],
        ['find_replacebox', 'change_text', ''],
    ];
    for (let [widget_ivar, setting_name, w_default] of table) {
        const w = ftm[widget_ivar as keyof StringFindTabManager]; // getattr(ftm, widget_ivar)
        const s = searchSettings[setting_name as keyof LeoGuiFindTabManagerSettings] || w_default;
        w.clear();
        w.insert(s);
    }

    // Check boxes.
    const table2: [string, string][] = [
        ['ignore_case', 'check_box_ignore_case'],
        ['mark_changes', 'check_box_mark_changes'],
        ['mark_finds', 'check_box_mark_finds'],
        ['pattern_match', 'check_box_regexp'],
        ['search_body', 'check_box_search_body'],
        ['search_headline', 'check_box_search_headline'],
        ['whole_word', 'check_box_whole_word'],
    ];
    for (let [setting_name, widget_ivar] of table2) {
        const w = ftm[widget_ivar as keyof StringFindTabManager]; // getattr(ftm, widget_ivar)
        const val = searchSettings[setting_name as keyof LeoGuiFindTabManagerSettings];
        (find as any)[setting_name as keyof LeoFind] = val;
        if (val !== w.isChecked()) {
            w.toggle();
        }
    }

    // Radio buttons
    const table3: [string, string, string][] = [
        ['node_only', 'node_only', 'radio_button_node_only'],
        ['file_only', 'file_only', 'radio_button_file_only'],
        ['entire_outline', "", 'radio_button_entire_outline'],
        ['suboutline_only', 'suboutline_only', 'radio_button_suboutline_only'],
    ];
    for (let [setting_name, ivar, widget_ivar] of table3) {
        const w = ftm[widget_ivar as keyof StringFindTabManager]; // getattr(ftm, widget_ivar)
        const val = searchSettings[setting_name as keyof LeoGuiFindTabManagerSettings] || false;

        if (ivar) {
            // assert hasattr(find, setting_name), setting_name

            // setattr(find, setting_name, val)
            (find as any)[setting_name as keyof LeoFind] = val;

            if (val !== w.isChecked()) {
                w.toggle();
            }
        }
    }

    // Ensure one radio button is set.
    const w = ftm.radio_button_entire_outline;
    const nodeOnly = searchSettings.node_only || false;
    const fileOnly = searchSettings.file_only || false;
    const suboutlineOnly = searchSettings.suboutline_only || false;

    if (!nodeOnly &amp;&amp; !suboutlineOnly &amp;&amp; !fileOnly) {
        find.entire_outline = true;
        if (!w.isChecked()) {
            w.toggle();
        }
    } else {
        find.entire_outline = false;
        if (w.isChecked()) {
            w.toggle();
        }
    }

    return Promise.resolve();
}

</t>
<t tx="felix.20220505215924.2">/**
 * * Handles an enter press in the 'nav pattern' input
 */
public async navEnter(): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;

    const inp = scon.navText;
    if (scon.isTag) {
        scon.qsc_find_tags(inp);
    } else {
        scon.qsc_search(inp);
    }

    return this.showNavResults();

}

</t>
<t tx="felix.20220505215924.3">/**
 * * Handles a debounced text change in the nav pattern input box
 */
public async navTextChange(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;

    const inp = scon.navText;
    if (scon.isTag) {
        scon.qsc_find_tags(inp);
    } else {
        const exp = inp.replace(/ /g, '*');
        scon.qsc_background_search(exp);
    }
    return this.showNavResults();
}

</t>
<t tx="felix.20220505215924.4">/**
 * * Opens the find panel and selects all &amp; focuses on the find field.
 */
public startSearch(): void {

    void this.triggerBodySave(true);

    // already instantiated &amp; shown ?
    let w_panel: vscode.WebviewView | undefined;

    if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
        w_panel = this._findPanelWebviewView;
    } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
        w_panel = this._findPanelWebviewExplorerView;
    }

    if (w_panel) {
        // ALREADY VISIBLE FIND PANEL
        this._findNeedsFocus = 0;
        void w_panel.webview.postMessage({ type: 'selectFind' });
        return;
    }

    this._findNeedsFocus = 1;
    setTimeout(() =&gt; {
        this._findNeedsFocus = 0;
    }, 250);
    let w_panelID = '';
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
    } else {
        w_panelID = Constants.FIND_ID;
    }
    void vscode.commands.executeCommand(w_panelID + '.focus');


}

</t>
<t tx="felix.20220505215924.7">/**
 * * Find next / previous commands
 * @param p_fromOutline
 * @param p_reverse
 * @returns Promise that resolves when the "launch refresh" is started
 */
public async find(p_fromOutline: boolean, p_reverse: boolean): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    let found;
    let focus;

    const c = g.app.windowList[this.frameIndex].c;
    const fc = c.findCommands;
    let p: Position | undefined = c.p;

    const fromOutline = p_fromOutline;
    const fromBody = !fromOutline;

    let w = this.get_focus(c);
    focus = this.widget_name(w);

    const inOutline = (focus.includes("tree")) || (focus.includes("head"));
    const inBody = !inOutline;

    if (fromOutline &amp;&amp; inBody) {
        fc.in_headline = true;
    } else if (fromBody &amp;&amp; inOutline) {
        fc.in_headline = false;
        c.bodyWantsFocus();
        c.bodyWantsFocusNow();
    }

    let pos, newpos, settings;
    settings = fc.ftm.get_settings();
    if (p_reverse) {
        [p, pos, newpos] = fc.do_find_prev(settings);
    } else {
        [p, pos, newpos] = fc.do_find_next(settings);
    }

    w = this.get_focus(c); // get focus again after the operation
    focus = this.widget_name(w);
    found = p &amp;&amp; p.__bool__();

    this.findFocusTree = false; // Reset flag for headline range

    if (!found || !focus) {
        return vscode.window.showInformationMessage('Not found');
    } else {
        let w_finalFocus = Focus.Body;
        const w_focus = focus.toLowerCase();
        if (w_focus.includes('tree') || w_focus.includes('head')) {
            // tree
            w_finalFocus = Focus.Outline;
            this.showOutlineIfClosed = true;
            // * SETUP HEADLINE RANGE
            this.findFocusTree = true;
            this.findHeadlineRange = [w.sel[0], w.sel[1]];
            this.findHeadlinePosition = c.p;
        } else {
            this.showBodyIfClosed = true;
        }
        const w_scroll = (found &amp;&amp; w_finalFocus === Focus.Body) || undefined;

        this.setupRefresh(
            w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
            {
                tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
                body: true,
                scroll: w_scroll,
                // documents: false,
                // buttons: false,
                states: true,
            },
            this.findFocusTree
        );
        return this.launchRefresh();
    }
}

</t>
<t tx="felix.20220505215924.9">/**
 * * Replace / Replace-Then-Find commands
 * @param p_fromOutline
 * @param p_thenFind
 * @returns Promise that resolves when the "launch refresh" is started
 */
public async replace(p_fromOutline?: boolean, p_thenFind?: boolean): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    let found;
    let focus;

    const c = g.app.windowList[this.frameIndex].c;
    const fc = c.findCommands;

    const fromOutline = p_fromOutline;
    const fromBody = !fromOutline;

    let w = this.get_focus(c);
    focus = this.widget_name(w);

    const inOutline = (focus.includes("tree")) || (focus.includes("head"));
    const inBody = !inOutline;

    if (fromOutline &amp;&amp; inBody) {
        fc.in_headline = true;
    } else if (fromBody &amp;&amp; inOutline) {
        fc.in_headline = false;
        c.bodyWantsFocus();
        c.bodyWantsFocusNow();
    }

    found = false;

    const settings = fc.ftm.get_settings();
    fc.init_ivars_from_settings(settings); // ? Needed for fc.change_selection

    fc.check_args('replace');
    if (p_thenFind) {
        found = fc.do_change_then_find(settings);
    } else {
        fc.change_selection(c.p);
        found = true;
    }

    w = this.get_focus(c); // get focus again after the operation
    focus = this.widget_name(w);

    this.findFocusTree = false; // Reset flag for headline range

    if (!found || !focus) {
        void vscode.window.showInformationMessage('Not found'); // Flag not found/replaced!
    }
    if (focus) {
        let w_finalFocus = Focus.Body;
        const w_focus = focus.toLowerCase();
        if (w_focus.includes('tree') || w_focus.includes('head')) {
            // tree
            w_finalFocus = Focus.Outline;
            this.showOutlineIfClosed = true;
            // * SETUP HEADLINE RANGE
            this.findFocusTree = true;
            this.findHeadlineRange = [w.sel[0], w.sel[1]];
            this.findHeadlinePosition = c.p;
        } else {
            this.showBodyIfClosed = true;
        }
        const w_scroll = (found &amp;&amp; w_finalFocus === Focus.Body) || undefined;

        this.setupRefresh(
            w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
            {
                tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
                body: true,
                scroll: w_scroll,
                // documents: false,
                // buttons: false,
                states: true,
            },
            this.findFocusTree
        );
        return this.launchRefresh();
    }

}

</t>
<t tx="felix.20220505220527.1">export type TGotoTypes = "tag" | "headline" | "body" | "parent" | "generic";

</t>
<t tx="felix.20220505220532.1">export interface LeoGoto {
    key: number; // id from python
    h: string;
    t: TGotoTypes;
}

</t>
<t tx="felix.20220505220537.1">/**
 * * Enum type for the search scope radio buttons of the find panel.
 */
export const enum LeoSearchScope {
    entireOutline = 0,
    subOutlineOnly,
    nodeOnly,
    fileOnly
}

</t>
<t tx="felix.20220505220544.1">/**
 * * Search settings structure for use with the 'find' webview
 */
export interface LeoSearchSettings {
    // Nav options
    navText: string;
    isTag: boolean;
    showParents: boolean;
    searchOptions: number;
    // Find/change strings...
    findText: string;  // find_text
    replaceText: string; // change_text
    // Find options...
    wholeWord: boolean;
    ignoreCase: boolean;
    regExp: boolean;
    markFinds: boolean;
    markChanges: boolean;
    searchHeadline: boolean;
    searchBody: boolean;
    searchScope: LeoSearchScope; // 0, 1 or 2 for outline, sub-outline, or node.
}

</t>
<t tx="felix.20220505220550.1">/**
 * * Leo's GUI search settings internal structure
 */
export interface LeoGuiFindTabManagerSettings {
    // Nav options
    nav_text: string;
    is_tag: boolean;
    show_parents: boolean;
    search_options: number;
    //Find/change strings...
    find_text: string,
    change_text: string,
    // Find options...
    ignore_case: boolean,
    mark_changes: boolean,
    mark_finds: boolean,
    node_only: boolean,
    file_only: boolean,
    pattern_match: boolean,
    search_body: boolean,
    search_headline: boolean,
    suboutline_only: boolean,
    whole_word: boolean
}

</t>
<t tx="felix.20220505220619.1">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20220505220626.1">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20220505220630.1">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    // ! TEST scroll as single number only (for Leo vertical scroll value)
    scroll: number;
    // scroll: {
    //     start: BodyPosition;
    //     end: BodyPosition;
    // }
    insert: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20220505220706.1">/**
 * * Used to select a button's rclick by index
 */
export interface ChooseRClickItem extends vscode.QuickPickItem {
    index: number;
    rclick?: RClick;
}

</t>
<t tx="felix.20220505221929.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as g from './core/leoGlobals';
import { QuickSearchController } from "./core/quicksearch";
import { LeoUI } from "./leoUI";
import { Icon, LeoGoto, LeoGotoNavKey, TGotoTypes } from "./types";
import * as utils from "./utils";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20220505222045.1">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoGotoProvider implements vscode.TreeDataProvider&lt;LeoGotoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoGotoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoGotoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoGotoNode | undefined&gt; = this._onDidChangeTreeData.event;

    private _lastGotoView: vscode.TreeView&lt;LeoGotoNode&gt; | undefined;

    public nodeList: LeoGotoNode[] = []; // Node list kept here.
    private _viewSwitch: boolean = false;

    public selectedNodeIndex: number = 0;
    public isSelected = false;

    constructor(private _leoUI: LeoUI) {
        this.onDidChangeTreeData(() =&gt; {
            this.getChildren(); // THIS KEEPS THE DATA UP TO DATE
            this._leoUI.setGotoContent();
        }, this);
    }

    public getLastGotoView(): vscode.TreeView&lt;LeoGotoNode&gt; | undefined {
        return this._lastGotoView;
    }

    public resetSelectedNode(p_node?: LeoGotoNode): void {
        this.selectedNodeIndex = 0;
        this.isSelected = false;
        if (p_node) {
            const w_found = this.nodeList.indexOf(p_node);
            if (w_found &gt;= 0) {
                this.selectedNodeIndex = w_found;
                this.isSelected = true;
                return;
            }
        }
    }

    public async navigateNavEntry(p_nav: LeoGotoNavKey): Promise&lt;void&gt; {
        if (!this.nodeList.length) {
            this.selectedNodeIndex = 0;
            this.isSelected = false;
            return;
        }
        switch (p_nav.valueOf()) {
            case LeoGotoNavKey.first:
                this.selectedNodeIndex = 0;
                this.isSelected = true;
                break;

            case LeoGotoNavKey.last:
                this.selectedNodeIndex = this.nodeList.length - 1;
                this.isSelected = true;
                break;

            case LeoGotoNavKey.next:
                if (this.selectedNodeIndex &lt; this.nodeList.length - 1) {
                    this.selectedNodeIndex += 1;
                    this.isSelected = true;
                }
                break;

            case LeoGotoNavKey.prev:
                if (this.selectedNodeIndex &gt; 0) {
                    this.selectedNodeIndex -= 1;
                    this.isSelected = true;
                }
                break;
        }
        // Check if array long enough!
        if (!this.nodeList[this.selectedNodeIndex]) {
            this.selectedNodeIndex = 0;
            this.isSelected = true;
            return; // Cancel
        }
        const node = this.nodeList[this.selectedNodeIndex];
        await this._leoUI.gotoNavEntry(node);
        this._leoUI.revealGotoNavEntry(this.selectedNodeIndex);
        // await this._lastGotoView?.reveal(node, {
        //     select: true,
        //     focus: true
        // });
    }

    /**
     * * Refresh the whole outline
     */
    public refreshTreeRoot(): void {
        this.nodeList = [];
        this.selectedNodeIndex = 0;
        this.isSelected = false;
        this._onDidChangeTreeData.fire(undefined);
    }

    public getTreeItem(element: LeoGotoNode): LeoGotoNode {
        return element;
    }

    public getChildren(element?: LeoGotoNode): LeoGotoNode[] {
        // if called with element, or not ready, give back empty array as there won't be any children
        if (this._leoUI.leoStates.fileOpenedReady &amp;&amp; !element) {

            // WAS JUST A VIEW SWITCH:
            if (this._viewSwitch) {
                this._viewSwitch = false;
                setTimeout(() =&gt; {
                    if (this.nodeList.length &amp;&amp; (this.selectedNodeIndex + 1) &lt;= this.nodeList.length) {

                        this._leoUI.revealGotoNavEntry(this.selectedNodeIndex, true);

                        // void this._lastGotoView?.reveal(this.nodeList[this._selectedNodeIndex], {
                        //     select: true,
                        //     focus: false
                        // }).then(() =&gt; { }, () =&gt; {
                        //     console.log('Reveal failed for goto panel switching detected.');
                        // });
                    }
                }, 0);
                return this.nodeList; // Make sure the nodes are valid (give back)
            }

            const c = g.app.windowList[this._leoUI.frameIndex].c;
            const scon: QuickSearchController = c.quicksearchController;

            const result: { [key: string]: any } = {};

            const navlist: LeoGoto[] = [];
            for (let k = 0; k &lt; scon.its.length; k++) {
                navlist.push(
                    {
                        "key": k,
                        "h": scon.its[k][0]["label"],
                        "t": scon.its[k][0]["type"] as TGotoTypes
                    }
                );
            }

            result["navList"] = navlist;
            result["messages"] = scon.lw;
            result["navText"] = scon.navText;
            result["navOptions"] = { "isTag": scon.isTag, "showParents": scon.showParents };

            this.nodeList = [];
            if (result &amp;&amp; result.navList) {

                const w_navList: LeoGoto[] = result.navList;
                if (w_navList &amp;&amp; w_navList.length) {
                    w_navList.forEach((p_goto: LeoGoto) =&gt; {
                        const w_newNode = new LeoGotoNode(this._leoUI, p_goto, result.navOptions!);
                        this.nodeList.push(w_newNode);
                    });
                }
                return this.nodeList;
            } else {
                return [];
            }

        } else {
            return []; // Defaults to an empty list of children
        }
    }

    public getParent(element: LeoGotoNode): LeoGotoNode | null {
        // Leo documents are just a list, as such, entries are always child of root, so return null
        return null;
    }

}
</t>
<t tx="felix.20220505222101.1">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoGotoNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public entryType: TGotoTypes;
    private _id: string;
    private _description: string | boolean;
    private _headline: string;
    private _iconIndex: number; // default to tag
    private _leoUI: LeoUI;
    public key: number; // id from python
    public leoPaneLabel: string;

    constructor(
        p_leoUI: LeoUI,
        p_gotoEntry: LeoGoto,
        p_navOptions: { isTag: boolean, showParents: boolean },

    ) {
        let w_spacing = "";
        if (p_navOptions.showParents &amp;&amp; !p_navOptions.isTag) {
            w_spacing = "    ";
        }
        let w_label = "";
        if (["tag", "headline"].includes(p_gotoEntry.t)) {
            w_label = w_spacing + p_gotoEntry.h;
        }
        super(w_label);
        this.leoPaneLabel = "";
        if (["tag", "headline"].includes(p_gotoEntry.t)) {
            this.leoPaneLabel = p_gotoEntry.h;
        }
        // Setup this instance
        this._leoUI = p_leoUI;
        this._id = utils.getUniqueId();
        this.entryType = p_gotoEntry.t;
        this.key = p_gotoEntry.key;
        this._headline = p_gotoEntry.h.trim();

        this._description = false;
        if (this.entryType === 'body') {
            this._iconIndex = 2;
            if (p_navOptions.showParents) {
                this._description = "    " + this._headline;
            } else {
                this._description = "  " + this._headline;
            }
            this.leoPaneLabel = this._headline;
        } else if (this.entryType === 'parent') {
            this._iconIndex = 0;
            this._description = this._headline.trim();
            this.leoPaneLabel = this._description;
        } else if (this.entryType === 'generic') {
            this._iconIndex = 4;
            this._description = this._headline;
            this.leoPaneLabel = this._description;
        } else if (this.entryType === 'headline') {
            this._iconIndex = 1;
        } else {
            this._iconIndex = 3; // tag
        }

        this.command = {
            command: Constants.COMMANDS.GOTO_NAV_ENTRY,
            title: '',
            arguments: [this]
        };

    }

    // @ts-ignore
    public get tooltip(): string {
        if (this.entryType !== "generic") {
            return this.entryType.charAt(0).toUpperCase() + this.entryType.slice(1);
        }
        return this._headline;
    }

    // @ts-ignore
    public get description(): string | boolean {
        return this._description;
    }

    // @ts-ignore
    public get iconPath(): Icon | vscode.ThemeIcon | string | undefined {
        if (this._iconIndex &lt; 4) {
            return this._leoUI.gotoIcons[this._iconIndex];
        }
        // else return undefined for generic text without icon
        return undefined;
    }

    // @ts-ignore
    public get id(): string {
        // Add prefix and suffix salt to numeric index to prevent accidental duplicates
        // Should be unique when refreshed
        return "g" + this._id + "o";
    }

}
</t>
<t tx="felix.20220505225023.1">/**
 * * Get new uniqueID
 */
export function getUniqueId(): string {
    const id = uniqueId++;
    return id.toString();
}

</t>
<t tx="felix.20220505225030.1">/**
 * * Unique numeric Id
 */
var uniqueId: number = 0;

</t>
<t tx="felix.20220505225236.1">/**
 * * Build all possible strings for the goto panel
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the goto anywhere tree view
 */
export function buildGotoIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_PARENT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_PARENT)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_NODE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_NODE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BODY),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BODY)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_TAG),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_TAG)
        }
    ];
}

</t>
<t tx="felix.20220508201944.1">/**
 * Redo operation available state
 */
private _leoCanGoBack: boolean = false;
get leoCanGoBack(): boolean {
    return this._leoCanGoBack;
}
set leoCanGoBack(p_value: boolean) {
    this._leoCanGoBack = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_BACK, p_value);
}

</t>
<t tx="felix.20220508201944.2">/**
 * Redo operation available state
 */
private _leoCanGoNext: boolean = false;
get leoCanGoNext(): boolean {
    return this._leoCanGoNext;
}
set leoCanGoNext(p_value: boolean) {
    this._leoCanGoNext = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_NEXT, p_value);
}

</t>
<t tx="felix.20220516005841.1">public runAskYesNoCancelDialog(
    c: Commands | undefined,
    title: string,
    message: string,
    yesMessage = Constants.USER_MESSAGES.YES,
    noMessage = Constants.USER_MESSAGES.NO,
    yesToAllMessage = "",
    defaultButton = Constants.USER_MESSAGES.YES,
    cancelMessage = ""
): Thenable&lt;string&gt; {
    const w_choices = [
        yesMessage,
        noMessage,
        // Note: Already shows a 'cancel' !
    ];
    if (yesToAllMessage) {
        w_choices.push(yesToAllMessage);
    }
    if (cancelMessage) {
        w_choices.push(cancelMessage);
    }

    return vscode.window
        .showInformationMessage(
            title,
            {
                modal: true,
                detail: message
            },
            ...w_choices
            // Note: Already shows a 'cancel' !
        )
        .then((answer) =&gt; {
            if (answer === yesMessage) {
                return 'yes';
            } else if (answer === noMessage) {
                return 'no';
            } else if (answer === yesToAllMessage) {
                return 'yes-to-all';
            } else if (answer === cancelMessage) {
                return 'cancel';
            } else {
                return 'cancel'; // undefined will yield this 'cancel'.
            }
        });
}

</t>
<t tx="felix.20220517002104.1">/**
* * Creates a new Leo file
* @returns the promise started after it's done creating the frame and commander
*/
public async newLeoFile(): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    this.showBodyIfClosed = true;
    this.showOutlineIfClosed = true;

    this.setupRefresh(Focus.NoChange, {
        tree: true,
        body: true,
        goto: true,
        documents: true,
        buttons: true,
        states: true
    });

    if (!this.leoStates.fileOpenedReady) {
        if (g.app.loadManager) {
            await g.app.loadManager.openEmptyLeoFile(this);
        }
    } else {
        await utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, true);
        await this.triggerBodySave(true);
        const c = g.app.windowList[this.frameIndex].c;
        await c.new(this);
        setTimeout(() =&gt; {
            void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, false);
        }, 60);
    }
    this.loadSearchSettings();
    return this.launchRefresh();
}

</t>
<t tx="felix.20220517202245.1">{
  "command": "leojs.saveLeoFileFromOutline",
  "when": "viewItem =~ /^leojsDocumentSelectedTitled/",
  "group": "inline@1"
},
{
  "command": "leojs.saveAsLeoFile",
  "when": "viewItem =~ /^leojsDocumentSelected/",
  "group": "inline@1"
},
{
  "command": "leojs.saveAsLeoJsFile",
  "when": "viewItem =~ /^leojsDocumentSelectedUntitled/",
  "group": "inline@1"
},
{
  "command": "leojs.closeLeoFile",
  "when": "viewItem =~ /^leojsDocumentSelected/",
  "group": "inline@2"
},
{
  "command": "leojs.revert",
  "when": "viewItem =~ /^leojsDocumentSelected/",
  "group": "leojsDocumentContext1@1"
},
</t>
<t tx="felix.20220517203332.1">{
  "command": "leojs.clickButton",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsButtonNode|^leojsButtonAdd/",
  "group": "inline@1"
},
{
  "command": "leojs.removeButton",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsButtonNode/",
  "group": "leojsButtonContext1@1"
},
{
  "command": "leojs.gotoScript",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsButtonNode/",
  "group": "leojsButtonContext1@2"
},
</t>
<t tx="felix.20220517212706.1">/**
 * * Show input window to select
 */
private async _handleRClicks(p_rclicks: RClick[], topLevelName?: string): Promise&lt;ChooseRClickItem | undefined&gt; {
    const w_choices: ChooseRClickItem[] = [];
    let w_index = 0;
    if (topLevelName) {
        w_choices.push(
            { label: topLevelName, picked: true, alwaysShow: true, index: w_index++ }
        );
    }
    w_choices.push(
        ...p_rclicks.map((p_rclick): ChooseRClickItem =&gt; { return { label: p_rclick.position.h, index: w_index++, rclick: p_rclick }; })
    );
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.CHOOSE_BUTTON
    };
    const w_picked = await vscode.window.showQuickPick(w_choices, w_options);
    if (w_picked) {
        this._rclickSelected.push(w_picked.index);
        if (topLevelName &amp;&amp; w_picked.index === 0) {
            return Promise.resolve(w_picked);
        }
        if (w_picked.rclick &amp;&amp; w_picked.rclick.children &amp;&amp; w_picked.rclick.children.length) {
            return this._handleRClicks(w_picked.rclick.children);
        } else {
            return Promise.resolve(w_picked);
        }
    }
    return Promise.resolve(undefined);
}

</t>
<t tx="felix.20220517212718.1">/**
 * * Finds and goes to the script of an at-button. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was right-clicked
 * @returns the launchRefresh promise started after it's done finding the node
 */
public async gotoScript(p_node: LeoButtonNode): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const tag = 'goto_script';
    const index = p_node.button.index;
    const old_c = g.app.windowList[g.app.gui.frameIndex].c;
    const d = old_c.theScriptingController.buttonsArray;
    const butWidget = d[index];

    if (butWidget) {

        try {
            const gnx: string = butWidget.command.gnx;
            let new_c = old_c;
            const w_result = await old_c.theScriptingController.open_gnx(old_c, gnx);
            let p: Position | undefined; // Replace YourPType with actual type

            if (w_result[0] &amp;&amp; w_result[1]) {
                p = w_result[1];
                new_c = w_result[0];
            } else {
                new_c = old_c;
            }

            g.app.gui.frameIndex = 0;
            for (const w_f of g.app.windowList) {
                if (w_f.c === new_c) {
                    break;
                }
                g.app.gui.frameIndex++;
            }
            // g.app.gui.frameIndex now points to the selected Commander.

            if (p) {
                new_c.selectPosition(p);
                this.setupRefresh(
                    Focus.Outline,
                    {
                        tree: true,
                        body: true,
                        documents: true,
                        states: true,
                        buttons: true,
                    }
                );
                return this.launchRefresh();
            } else {
                throw new Error(`${tag}: not found ${gnx}`);
            }

        } catch (e) {
            g.es_exception(e);
        }

    }
    return Promise.resolve(false);

}

</t>
<t tx="felix.20220519232002.1">public resolveTreeItem(item: LeoOutlineNode, element: Position, token: vscode.CancellationToken): vscode.ProviderResult&lt;LeoOutlineNode&gt; {
    if (element.v.u) {
        const w_u = element.v.u;
        const w_uaLength = Object.keys(w_u).length;
        if (w_uaLength) {
            if (w_uaLength === 1 &amp;&amp; w_u.__node_tags &amp;&amp; w_u.__node_tags.length) {
                // list tags instead
                item.tooltip = item.label.label + "\n\u{1F3F7} " + w_u.__node_tags.join('\n\u{1F3F7} ');
            } else {
                item.tooltip = item.label.label + "\n" +
                    JSON.stringify(w_u, undefined, 2);
            }
            return item;
        }
    }
    item.tooltip = item.label.label; // * Fallsback to whole headline as tooltip
    return item;
}

</t>
<t tx="felix.20220520011951.1">public resolveTreeItem(item: LeoUndoNode, element: LeoUndoNode, token: vscode.CancellationToken): vscode.ProviderResult&lt;LeoUndoNode&gt; {
    if (item.contextValue === Constants.CONTEXT_FLAGS.UNDO_BEAD) {
        item.tooltip = "Undo Bead #" + item.beadIndex;
    }
    return item;
}
</t>
<t tx="felix.20220523140004.1">async function runLeo(p_context: vscode.ExtensionContext) {
    const w_start = process.hrtime(); // For calculating total startup time duration
    g.app.loadManager = new LoadManager(p_context);
    await g.app.loadManager.load();
    console.log(`leojs startup launched in ${utils.getDurationMs(w_start)} ms`);
}

</t>
<t tx="felix.20220523151725.1">function setScheme(p_event: vscode.WorkspaceFoldersChangeEvent, p_context: vscode.ExtensionContext) {
    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders.length) {

        (g.workspaceUri as vscode.Uri) = vscode.workspace.workspaceFolders[0].uri;

        console.log('WORKSPACE CHANGE DETECTED! length ' + vscode.workspace.workspaceFolders.length);
        console.log('is Writable Filesystem: ', vscode.workspace.fs.isWritableFileSystem(g.workspaceUri.scheme));

        // not started yet? 
        if (!g.app.loadManager &amp;&amp; g.isBrowser) {
            // Check if not file scheme : only virtual workspaces are suported if g.isBrowser is true.
            if (g.workspaceUri.scheme !== 'file') {
                void runLeo(p_context);
            } else {
                // Is local filesystem
                void vscode.window.showInformationMessage("LeoJS in browser supports remote virtual filesystems: Local Filesystem requires desktop VSCode application: ", "More Info").then(selection =&gt; {
                    if (selection === "More Info") {
                        vscode.env.openExternal(
                            vscode.Uri.parse('https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project')
                        ).then(() =&gt; { }, (e) =&gt; {
                            console.error('LEOJS: Could not open external vscode help URL in browser.', e);
                        });
                    }
                });
                console.log('NOT started because no remote workspace yet');
                void setStartupDoneContext(true);
                return;
            }
        }
    } else {
        console.log('TODO : HANDLE WORKSPACE CHANGE DETECTED! but no workspace');
        void setStartupDoneContext(true);
    }
}

</t>
<t tx="felix.20220613164517.1">public runAboutLeoDialog(
    c: Commands | undefined,
    version: string,
    theCopyright: string,
    url: string,
    email: string
): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage(
        version,
        {
            modal: true,
            detail: theCopyright
        });
}

</t>
<t tx="felix.20220725004247.1">/**
 * * Sets the outline pane top bar string message or refreshes with existing title if no title passed
 * @param p_title new string to replace the current title
 */
private _setTreeViewTitle(p_title?: string): void {
    const w_changed = this.leoStates.fileOpenedReady &amp;&amp; this.leoStates.leoOpenedFileName &amp;&amp; this.leoStates.leoChanged ? "*" : "";
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    let w_title = this._currentOutlineTitle + w_changed;
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    if (this._leoTreeView &amp;&amp; w_title !== this._leoTreeView.title) {
        this._leoTreeView.title = w_title;
    }
    w_title = Constants.GUI.EXPLORER_TREEVIEW_PREFIX + w_title;
    if (this._leoTreeExView &amp;&amp; w_title !== this._leoTreeExView.title) {
        this._leoTreeExView.title = w_title;
    }
    this.refreshDesc();
}

</t>
<t tx="felix.20220917013425.1">[CMD.SET_ENABLE_PREVIEW, () =&gt; p_leoUI.config.setEnablePreview()],
[CMD.CLEAR_CLOSE_EMPTY_GROUPS, () =&gt; p_leoUI.config.clearCloseEmptyGroups()],

</t>
<t tx="felix.20220918234128.1">"languages": [
  {
    "id": "leojsbody.plain",
    "aliases": [
      "Leo Body Plain",
      "leojsbody"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.plain.language-configuration.json"
  },
  {
    "id": "leojsbody.plain.wrap",
    "aliases": [
      "Leo Body Plain",
      "leojsbody"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.plain.language-configuration.json"
  },
  {
    "id": "leojsbody.julia",
    "aliases": [
      "Leo Body Julia",
      "leojsbody.julia"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.julia.language-configuration.json"
  },
  {
    "id": "leojsbody.julia.wrap",
    "aliases": [
      "Leo Body Julia",
      "leojsbody.julia"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.julia.language-configuration.json"
  },
  {
    "id": "leojsbody.batch",
    "aliases": [
      "Leo Body Batch",
      "leojsbody.batch"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.batch.language-configuration.json"
  },
  {
    "id": "leojsbody.batch.wrap",
    "aliases": [
      "Leo Body Batch",
      "leojsbody.batch"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.batch.language-configuration.json"
  },
  {
    "id": "leojsbody.shell",
    "aliases": [
      "Leo Body Shell",
      "leojsbody.shell"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.shell.language-configuration.json"
  },
  {
    "id": "leojsbody.shell.wrap",
    "aliases": [
      "Leo Body Shell",
      "leojsbody.shell"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.shell.language-configuration.json"
  },
  {
    "id": "leojsbody.python",
    "aliases": [
      "Leo Body Python",
      "leojsbody.python"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.python.language-configuration.json"
  },
  {
    "id": "leojsbody.python.wrap",
    "aliases": [
      "Leo Body Python",
      "leojsbody.python"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.python.language-configuration.json"
  },
  {
    "id": "leojsbody.typescript",
    "aliases": [
      "Leo Body Typescript",
      "leojsbody.typescript"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.typescript.language-configuration.json"
  },
  {
    "id": "leojsbody.typescript.wrap",
    "aliases": [
      "Leo Body Typescript",
      "leojsbody.typescript"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.typescript.language-configuration.json"
  },
  {
    "id": "leojsbody.javascript",
    "aliases": [
      "Leo Body Javascript",
      "leojsbody.javascript"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.javascript.language-configuration.json"
  },
  {
    "id": "leojsbody.javascript.wrap",
    "aliases": [
      "Leo Body Javascript",
      "leojsbody.javascript"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.javascript.language-configuration.json"
  },
  {
    "id": "leojsbody.c",
    "aliases": [
      "Leo Body c",
      "leojsbody.c"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.c.language-configuration.json"
  },
  {
    "id": "leojsbody.c.wrap",
    "aliases": [
      "Leo Body c",
      "leojsbody.c"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.c.language-configuration.json"
  },
  {
    "id": "leojsbody.cpp",
    "aliases": [
      "Leo Body C++",
      "leojsbody.cpp"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.cpp.language-configuration.json"
  },
  {
    "id": "leojsbody.cpp.wrap",
    "aliases": [
      "Leo Body C++",
      "leojsbody.cpp"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.cpp.language-configuration.json"
  },
  {
    "id": "leojsbody.css",
    "aliases": [
      "Leo Body CSS",
      "leojsbody.css"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.css.language-configuration.json"
  },
  {
    "id": "leojsbody.css.wrap",
    "aliases": [
      "Leo Body CSS",
      "leojsbody.css"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.css.language-configuration.json"
  },
  {
    "id": "leojsbody.fortran",
    "aliases": [
      "Leo Body Fortran",
      "leojsbody.fortran"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.fortran.language-configuration.json"
  },
  {
    "id": "leojsbody.fortran.wrap",
    "aliases": [
      "Leo Body Fortran",
      "leojsbody.fortran"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.fortran.language-configuration.json"
  },
  {
    "id": "leojsbody.fortran90",
    "aliases": [
      "Leo Body Fortran90",
      "leojsbody.fortran90"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.fortran.language-configuration.json"
  },
  {
    "id": "leojsbody.fortran90.wrap",
    "aliases": [
      "Leo Body Fortran90",
      "leojsbody.fortran90"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.fortran.language-configuration.json"
  },
  {
    "id": "leojsbody.html",
    "aliases": [
      "Leo Body HTML",
      "leojsbody.html"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.html.language-configuration.json"
  },
  {
    "id": "leojsbody.html.wrap",
    "aliases": [
      "Leo Body HTML",
      "leojsbody.html"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.html.language-configuration.json"
  },
  {
    "id": "leojsbody.java",
    "aliases": [
      "Leo Body Java",
      "leojsbody.java"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.java.language-configuration.json"
  },
  {
    "id": "leojsbody.java.wrap",
    "aliases": [
      "Leo Body Java",
      "leojsbody.java"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.java.language-configuration.json"
  },
  {
    "id": "leojsbody.json",
    "aliases": [
      "Leo Body Json",
      "leojsbody.json"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.json.language-configuration.json"
  },
  {
    "id": "leojsbody.json.wrap",
    "aliases": [
      "Leo Body Json",
      "leojsbody.json"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.json.language-configuration.json"
  },
  {
    "id": "leojsbody.markdown",
    "aliases": [
      "Leo Body Markdown",
      "leojsbody.markdown"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.markdown.language-configuration.json"
  },
  {
    "id": "leojsbody.markdown.wrap",
    "aliases": [
      "Leo Body Markdown",
      "leojsbody.markdown"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.markdown.language-configuration.json"
  },
  {
    "id": "leojsbody.php",
    "aliases": [
      "Leo Body PHP",
      "leojsbody.php"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.php.language-configuration.json"
  },
  {
    "id": "leojsbody.php.wrap",
    "aliases": [
      "Leo Body PHP",
      "leojsbody.php"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.php.language-configuration.json"
  },
  {
    "id": "leojsbody.restructuredtext",
    "aliases": [
      "Leo Body reStructuredText",
      "leojsbody.restructuredtext"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.rst.language-configuration.json"
  },
  {
    "id": "leojsbody.restructuredtext.wrap",
    "aliases": [
      "Leo Body reStructuredText",
      "leojsbody.restructuredtext"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.rst.language-configuration.json"
  },
  {
    "id": "leojsbody.rust",
    "aliases": [
      "Leo Body Rust",
      "leojsbody.rust"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.rust.language-configuration.json"
  },
  {
    "id": "leojsbody.rust.wrap",
    "aliases": [
      "Leo Body Rust",
      "leojsbody.rust"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.rust.language-configuration.json"
  },
  {
    "id": "leojsbody.xml",
    "aliases": [
      "Leo Body XML",
      "leojsbody.xml"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.xml.language-configuration.json"
  },
  {
    "id": "leojsbody.xml.wrap",
    "aliases": [
      "Leo Body XML",
      "leojsbody.xml"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leojsbody.xml.language-configuration.json"
  }
],
</t>
<t tx="felix.20220918234147.1">"grammars": [
  {
    "language": "leojsbody.plain",
    "scopeName": "source.leojsbody.plain",
    "path": "./syntaxes/leojsbody.plain.tmLanguage.json"
  },
  {
    "language": "leojsbody.plain.wrap",
    "scopeName": "source.leojsbody.plain",
    "path": "./syntaxes/leojsbody.plain.tmLanguage.json"
  },
  {
    "language": "leojsbody.julia",
    "scopeName": "source.leojsbody.julia",
    "path": "./syntaxes/leojsbody.julia.tmLanguage.json"
  },
  {
    "language": "leojsbody.julia.wrap",
    "scopeName": "source.leojsbody.julia",
    "path": "./syntaxes/leojsbody.julia.tmLanguage.json"
  },
  {
    "language": "leojsbody.batch",
    "scopeName": "source.leojsbody.batch",
    "path": "./syntaxes/leojsbody.batch.tmLanguage.json"
  },
  {
    "language": "leojsbody.batch.wrap",
    "scopeName": "source.leojsbody.batch",
    "path": "./syntaxes/leojsbody.batch.tmLanguage.json"
  },
  {
    "language": "leojsbody.shell",
    "scopeName": "source.leojsbody.shell",
    "path": "./syntaxes/leojsbody.shell.tmLanguage.json"
  },
  {
    "language": "leojsbody.shell.wrap",
    "scopeName": "source.leojsbody.shell",
    "path": "./syntaxes/leojsbody.shell.tmLanguage.json"
  },
  {
    "language": "leojsbody.python",
    "scopeName": "source.leojsbody.python",
    "path": "./syntaxes/leojsbody.python.tmLanguage.json"
  },
  {
    "language": "leojsbody.python.wrap",
    "scopeName": "source.leojsbody.python",
    "path": "./syntaxes/leojsbody.python.tmLanguage.json"
  },
  {
    "language": "leojsbody.typescript",
    "scopeName": "source.leojsbody.typescript",
    "path": "./syntaxes/leojsbody.typescript.tmLanguage.json"
  },
  {
    "language": "leojsbody.typescript.wrap",
    "scopeName": "source.leojsbody.typescript",
    "path": "./syntaxes/leojsbody.typescript.tmLanguage.json"
  },
  {
    "language": "leojsbody.javascript",
    "scopeName": "source.leojsbody.javascript",
    "path": "./syntaxes/leojsbody.javascript.tmLanguage.json"
  },
  {
    "language": "leojsbody.javascript.wrap",
    "scopeName": "source.leojsbody.javascript",
    "path": "./syntaxes/leojsbody.javascript.tmLanguage.json"
  },
  {
    "language": "leojsbody.c",
    "scopeName": "source.leojsbody.c",
    "path": "./syntaxes/leojsbody.c.tmLanguage.json"
  },
  {
    "language": "leojsbody.c.wrap",
    "scopeName": "source.leojsbody.c",
    "path": "./syntaxes/leojsbody.c.tmLanguage.json"
  },
  {
    "language": "leojsbody.cpp",
    "scopeName": "source.leojsbody.cpp",
    "path": "./syntaxes/leojsbody.cpp.tmLanguage.json"
  },
  {
    "language": "leojsbody.cpp.wrap",
    "scopeName": "source.leojsbody.cpp",
    "path": "./syntaxes/leojsbody.cpp.tmLanguage.json"
  },
  {
    "language": "leojsbody.css",
    "scopeName": "source.leojsbody.css",
    "path": "./syntaxes/leojsbody.css.tmLanguage.json"
  },
  {
    "language": "leojsbody.css.wrap",
    "scopeName": "source.leojsbody.css",
    "path": "./syntaxes/leojsbody.css.tmLanguage.json"
  },
  {
    "language": "leojsbody.fortran",
    "scopeName": "source.leojsbody.fortran",
    "path": "./syntaxes/leojsbody.fortran.tmLanguage.json"
  },
  {
    "language": "leojsbody.fortran.wrap",
    "scopeName": "source.leojsbody.fortran",
    "path": "./syntaxes/leojsbody.fortran.tmLanguage.json"
  },
  {
    "language": "leojsbody.fortran90",
    "scopeName": "source.leojsbody.fortran90",
    "path": "./syntaxes/leojsbody.fortran90.tmLanguage.json"
  },
  {
    "language": "leojsbody.fortran90.wrap",
    "scopeName": "source.leojsbody.fortran90",
    "path": "./syntaxes/leojsbody.fortran90.tmLanguage.json"
  },
  {
    "language": "leojsbody.html",
    "scopeName": "source.leojsbody.html",
    "path": "./syntaxes/leojsbody.html.tmLanguage.json"
  },
  {
    "language": "leojsbody.html.wrap",
    "scopeName": "source.leojsbody.html",
    "path": "./syntaxes/leojsbody.html.tmLanguage.json"
  },
  {
    "language": "leojsbody.java",
    "scopeName": "source.leojsbody.java",
    "path": "./syntaxes/leojsbody.java.tmLanguage.json"
  },
  {
    "language": "leojsbody.java.wrap",
    "scopeName": "source.leojsbody.java",
    "path": "./syntaxes/leojsbody.java.tmLanguage.json"
  },
  {
    "language": "leojsbody.json",
    "scopeName": "source.leojsbody.json",
    "path": "./syntaxes/leojsbody.json.tmLanguage.json"
  },
  {
    "language": "leojsbody.json.wrap",
    "scopeName": "source.leojsbody.json",
    "path": "./syntaxes/leojsbody.json.tmLanguage.json"
  },
  {
    "language": "leojsbody.markdown",
    "scopeName": "source.leojsbody.markdown",
    "path": "./syntaxes/leojsbody.markdown.tmLanguage.json"
  },
  {
    "language": "leojsbody.markdown.wrap",
    "scopeName": "source.leojsbody.markdown",
    "path": "./syntaxes/leojsbody.markdown.tmLanguage.json"
  },
  {
    "language": "leojsbody.php",
    "scopeName": "source.leojsbody.php",
    "path": "./syntaxes/leojsbody.php.tmLanguage.json"
  },
  {
    "language": "leojsbody.php.wrap",
    "scopeName": "source.leojsbody.php",
    "path": "./syntaxes/leojsbody.php.tmLanguage.json"
  },
  {
    "language": "leojsbody.restructuredtext",
    "scopeName": "source.leojsbody.restructuredtext",
    "path": "./syntaxes/leojsbody.rst.tmLanguage.json"
  },
  {
    "language": "leojsbody.restructuredtext.wrap",
    "scopeName": "source.leojsbody.restructuredtext",
    "path": "./syntaxes/leojsbody.rst.tmLanguage.json"
  },
  {
    "language": "leojsbody.rust",
    "scopeName": "source.leojsbody.rust",
    "path": "./syntaxes/leojsbody.rust.tmLanguage.json"
  },
  {
    "language": "leojsbody.rust.wrap",
    "scopeName": "source.leojsbody.rust",
    "path": "./syntaxes/leojsbody.rust.tmLanguage.json"
  },
  {
    "language": "leojsbody.xml",
    "scopeName": "source.leojsbody.xml",
    "path": "./syntaxes/leojsbody.xml.tmLanguage.json"
  },
  {
    "language": "leojsbody.xml.wrap",
    "scopeName": "source.leojsbody.xml",
    "path": "./syntaxes/leojsbody.xml.tmLanguage.json"
  },
  {
    "injectTo": [
      "source.leojsbody.batch",
      "source.leojsbody.c",
      "source.leojsbody.cpp",
      "source.leojsbody.css",
      "source.leojsbody.fortran",
      "source.leojsbody.fortran90",
      "source.leojsbody.html",
      "source.leojsbody.java",
      "source.leojsbody.javascript",
      "source.leojsbody.json",
      "source.leojsbody.julia",
      "source.leojsbody.markdown",
      "source.leojsbody.php",
      "source.leojsbody.plain",
      "source.leojsbody.python",
      "source.leojsbody.restructuredtext",
      "source.leojsbody.rust",
      "source.leojsbody.shell",
      "source.leojsbody.typescript",
      "source.leojsbody.xml",
      "source.leojsbody.batch.wrap",
      "source.leojsbody.c.wrap",
      "source.leojsbody.cpp.wrap",
      "source.leojsbody.css.wrap",
      "source.leojsbody.fortran.wrap",
      "source.leojsbody.fortran90.wrap",
      "source.leojsbody.html.wrap",
      "source.leojsbody.java.wrap",
      "source.leojsbody.javascript.wrap",
      "source.leojsbody.json.wrap",
      "source.leojsbody.julia.wrap",
      "source.leojsbody.markdown.wrap",
      "source.leojsbody.php.wrap",
      "source.leojsbody.plain.wrap",
      "source.leojsbody.python.wrap",
      "source.leojsbody.restructuredtext.wrap",
      "source.leojsbody.rust.wrap",
      "source.leojsbody.shell.wrap",
      "source.leojsbody.typescript.wrap",
      "source.leojsbody.xml.wrap"
    ],
    "path": "./syntaxes/leojsbody.tmLanguage.json",
    "scopeName": "leojs.injection"
  }
],
</t>
<t tx="felix.20220918234152.1">"snippets": [
  {
    "language": "leojsbody.c",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leojsbody.c.wrap",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leojsbody.cpp",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leojsbody.cpp.wrap",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leojsbody.fortran90",
    "path": "./snippets/fortran90.code-snippets"
  },
  {
    "language": "leojsbody.fortran90.wrap",
    "path": "./snippets/fortran90.code-snippets"
  },
  {
    "language": "leojsbody.javascript",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leojsbody.javascript.wrap",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leojsbody.typescript",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leojsbody.typescript.wrap",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leojsbody.java",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leojsbody.java.wrap",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leojsbody.php",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leojsbody.php.wrap",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leojsbody.markdown",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leojsbody.markdown.wrap",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leojsbody.restructuredtext",
    "path": "./snippets/restructuredtext.code-snippets"
  },
  {
    "language": "leojsbody.restructuredtext.wrap",
    "path": "./snippets/restructuredtext.code-snippets"
  },
  {
    "language": "leojsbody.rust",
    "path": "./snippets/rust.code-snippets"
  },
  {
    "language": "leojsbody.rust.wrap",
    "path": "./snippets/rust.code-snippets"
  }
],
</t>
<t tx="felix.20220920001018.1"></t>
<t tx="felix.20220920001018.2">/**
 * * Adds a message string to LeoJS log pane.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    if (this._leoLogPane) {
        this._leoLogPane.appendLine(p_message);
    } else {
        g.logBuffer.push(p_message);
    }
}

</t>
<t tx="felix.20220920001018.3">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(p_focus?: boolean): Thenable&lt;unknown&gt; {
    if (this._leoLogPane) {
        this._leoLogPane.show(!p_focus); // use flag to preserve focus
        return Promise.resolve(true);
    } else {
        // * Log pane instantiation
        this._leoLogPane = vscode.window.createOutputChannel(Constants.GUI.LOG_PANE_TITLE);
        this._context.subscriptions.push(this._leoLogPane);
        if (g.logBuffer.length) {
            const buffer = g.logBuffer;
            while (buffer.length &gt; 0) {
                // Pop the bottom one and append it
                g.es_print(buffer.shift()!);
            }
        }
        this._leoLogPane.show(!p_focus);
        return Promise.resolve(undefined); // if cancelled
    }
}

</t>
<t tx="felix.20220920001202.1">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    if (this._leoLogPane) {
        this._leoLogPane.hide();
    }
}

</t>
<t tx="felix.20220922000450.1"></t>
<t tx="felix.20220922000450.10">
/**
 * * Closes any body pane opened in this vscode window instance
 * @returns a promise that resolves when the file is closed and removed from recently opened list
 */
public closeBody(): Thenable&lt;any&gt; {

    const w_foundTabs: vscode.Tab[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        w_foundTabs.forEach((p_tab) =&gt; {
            if (p_tab.input) {

                void vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                void vscode.workspace.applyEdit(w_edit);
            }
        });
    } else {
        q_closedTabs = Promise.resolve(true);

    }

    let q_closedBody;
    if (this.bodyUri) {
        q_closedBody = vscode.commands.executeCommand(
            'vscode.removeFromRecentlyOpened',
            this.bodyUri
        );
    } else {
        q_closedBody = Promise.resolve(true);
    }

    return Promise.all([q_closedTabs, q_closedBody]);
}

</t>
<t tx="felix.20220922000450.11">/**
 * * cleanupBody closes all remaining body pane to shut down this vscode window
 * @returns a promise that resolves when done saving and closing
 */
public cleanupBody(): Thenable&lt;any&gt; {
    let q_save: Thenable&lt;any&gt;;
    //
    if (this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        utils.leoUriToStr(this.bodyUri) === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
    ) {
        q_save = this._bodySaveDeactivate(this._bodyLastChangedDocument);
    } else {
        q_save = Promise.resolve(true);
    }

    // Adding log in the chain of events
    let q_edit: Thenable&lt;boolean&gt;;
    if (this.bodyUri) {
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(this.bodyUri, { ignoreIfNotExists: true });
        q_edit = vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            return true;
        }, () =&gt; {
            return false;
        });
    } else {
        q_edit = Promise.resolve(true);
    }
    Promise.all([q_save, q_edit])
        .then(() =&gt; {
            return this.closeBody();
        }, () =&gt; {
            return true;
        });

    return q_save;
}

</t>
<t tx="felix.20220922000450.12">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preventTakingFocus flag that when true will stop the editor from taking focus once opened
 * @returns a promise of an editor, or void if body had been changed again in the meantime.
 */
public async showBody(p_aside: boolean, p_preventTakingFocus?: boolean, p_preventReveal?: boolean): Promise&lt;vscode.TextEditor | void&gt; {
    const w_openedDocumentTS = utils.performanceNow();
    const w_openedDocumentGnx = utils.leoUriToStr(this.bodyUri);
    let q_saved: Thenable&lt;unknown&gt; | undefined;

    // First setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._refreshType.body) {
        this._refreshType.body = false;

        if (this._bodyLastChangedDocument &amp;&amp;
            !this._bodyLastChangedDocument.isClosed &amp;&amp;
            (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
            w_openedDocumentGnx === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
        ) {
            // ! FAKE SAVE to make sure body is not dirty !
            this._leoFileSystem.preventSaveToLeo = true;
            this._editorTouched = false;
            q_saved = this._bodyLastChangedDocument.save();
        }

        if (q_saved) {
            await q_saved;
            this._leoFileSystem.fireRefreshFile(w_openedDocumentGnx);
        }

    }

    // Handle 'Config was changed -&gt; refresh without showing body' and return
    // (because _tryApplyNodeToBody will always call showBody if outline refreshes with )
    if (this._preventShowBody) {
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }

    // let w_preFoundDocOpened = false;
    // let w_preFoundTabOpened = false;
    // vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
    //     p_tabGroup.tabs.forEach((p_tab) =&gt; {

    //         if (p_tab.input &amp;&amp;
    //             (p_tab.input as vscode.TabInputText).uri &amp;&amp;
    //             (p_tab.input as vscode.TabInputText).uri.fsPath === this.bodyUri.fsPath) {
    //             w_preFoundTabOpened = true;
    //             vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
    //                 if (p_textDocument.uri.fsPath === (p_tab.input as vscode.TabInputText).uri.fsPath) {
    //                     w_preFoundDocOpened = true;
    //                 }
    //             });
    //         }
    //     });
    // });


    // * Step 1 : Open the document
    const w_openedDocument = await vscode.workspace.openTextDocument(this.bodyUri);
    this._bodyLastChangedDocument = undefined;
    this._bodyLastChangedDocumentSaved = false;

    this._bodyTextDocument = w_openedDocument;
    let w_bodySel: BodySelectionInfo | undefined;
    // * Set document language along with the proper cursor position, selection range and scrolling position
    if (!this._needLastSelectedRefresh) {

        // * Get the language.
        const c = g.app.windowList[this.frameIndex].c;
        const p = c.p;
        const w_language = this._getBodyLanguage(p);

        const tempTabWidth = g.scanAllAtTabWidthDirectives(c, p);
        const w_tabWidth: number | boolean = tempTabWidth || !!tempTabWidth;

        const insert = p.v.insertSpot;
        const start = p.v.selectionStart;
        const end = p.v.selectionStart + p.v.selectionLength;
        const scroll = p.v.scrollBarSpot;

        w_bodySel = {
            "gnx": p.v.gnx,
            "scroll": scroll,
            "insert": this._row_col_pv_dict(insert, p.v.b),
            "start": this._row_col_pv_dict(start, p.v.b),
            "end": this._row_col_pv_dict(end, p.v.b)
        };
        // console.log('From p:', ` insert:${w_bodySel.insert.line}, ${w_bodySel.insert.col} start:${w_bodySel.start.line},${w_bodySel.start.col} end:${w_bodySel.end.line}, ${w_bodySel.end.col}`);

        // ! -------------------------------
        // ! TEST SELECTION GETTER OVERRIDE!
        // ! -------------------------------
        const wrapper = c.frame.body.wrapper;
        const test_insert = wrapper.getInsertPoint();
        let test_start, test_end;
        [test_start, test_end] = wrapper.getSelectionRange(true);
        // ! OVERRIDE !
        //const w_bodySel_w = {
        w_bodySel = {
            "gnx": p.v.gnx,
            "scroll": scroll,
            "insert": this._row_col_wrapper_dict(test_insert, wrapper),
            "start": this._row_col_wrapper_dict(test_start, wrapper),
            "end": this._row_col_wrapper_dict(test_end, wrapper)
        };
        // console.log('From w:', ` insert:${w_bodySel_w.insert.line}, ${w_bodySel_w.insert.col} start:${w_bodySel_w.start.line},${w_bodySel_w.start.col} end:${w_bodySel_w.end.line}, ${w_bodySel_w.end.col}`);
        // console.log('From w:', ` insert:${w_bodySel.insert.line}, ${w_bodySel.insert.col} start:${w_bodySel.start.line},${w_bodySel.start.col} end:${w_bodySel.end.line}, ${w_bodySel.end.col}`);

        let w_debugMessage = "";
        let w_needRefreshFlag = false;

        // Apply language if the selected node is still the same after all those events
        if (!w_openedDocument.isClosed) {
            // w_openedDocument still OPEN
            if (this.isTsStillValid(w_openedDocumentTS)) { // No need to check gnx of command stack){
                // command stack last node is still valid
                if (this.lastSelectedNode &amp;&amp; w_openedDocumentGnx === this.lastSelectedNode.gnx) {
                    // still same gnx as this.bodyUri
                    if (w_language !== w_openedDocument.languageId) {
                        void this._setBodyLanguage(w_openedDocument, w_language);
                    }

                } else {
                    // NOT SAME GNX!
                    w_debugMessage = "all good but not same GNX!?!";
                    w_needRefreshFlag = true;
                }

            } else {
                // NOT VALID : NEW NODE SELECTED SINCE THIS STARTED!
                w_debugMessage = "New node selected since this started!";
                w_needRefreshFlag = false;
            }

        } else {
            w_debugMessage = "w_openedDocument is CLOSED " + w_openedDocument.uri.fsPath;
            w_needRefreshFlag = false;
        }

        // * Debug Info
        // if (w_debugMessage) {
        //     console.log(w_debugMessage);
        //     console.log("w_openedDocumentGnx", w_openedDocumentGnx);
        //     console.log("this.lastSelectedNode.gnx", this.lastSelectedNode!.gnx);
        //     console.log("w_gnx", w_gnx);
        // }

        if (w_needRefreshFlag) {
            if (this._showBodySwitchBodyTimer) {
                clearTimeout(this._showBodySwitchBodyTimer);
            }
            // redo apply to body!
            this._showBodySwitchBodyTimer = setTimeout(() =&gt; {
                if (this.lastSelectedNode) {
                    void this._switchBody(false, p_preventTakingFocus);
                }
            }, 0);
            return;

        }
    }

    // Find body pane's position if already opened with same gnx 
    // Note: language still needs to be set per position
    let w_foundDocOpened = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {

            if (
                p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.fsPath === w_openedDocument.uri.fsPath
            ) {
                vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
                    if (
                        p_textDocument.uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                        p_textDocument.uri.fsPath === (p_tab.input as vscode.TabInputText).uri.fsPath
                    ) {
                        this._bodyTextDocument = p_textDocument; // vscode.workspace.openTextDocument
                        this._bodyMainSelectionColumn = p_tab.group.viewColumn;
                        if (p_preventReveal) {
                            if (p_tab.isActive) {
                                w_foundDocOpened = true;
                            }
                        } else {
                            w_foundDocOpened = true;
                        }
                    }
                });
            }
        });
    });


    if (!w_foundDocOpened &amp;&amp; p_preventReveal) {
        return; // ! HAD PREVENT REVEAL !
    }

    if (w_foundDocOpened &amp;&amp; !q_saved) {
        // Was the same and was asked to show body (and did not already had to fake-save and refresh)
        this._leoFileSystem.fireRefreshFile(w_openedDocumentGnx);
    }
    // Setup options for the preview state of the opened editor, and to choose which column it should appear
    const w_showOptions: vscode.TextDocumentShowOptions = p_aside
        ? {
            viewColumn: vscode.ViewColumn.Beside,
            preserveFocus: p_preventTakingFocus,
            preview: true, // should text document be in preview only? set false for fully opened
        }
        : {
            viewColumn: this._bodyMainSelectionColumn
                ? this._bodyMainSelectionColumn
                : 1,
            preserveFocus: p_preventTakingFocus,
            preview: true, // should text document be in preview only? set false for fully opened
        };

    // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER "await vscode.workspace.openTextDocument"
    if (
        w_openedDocument.isClosed ||
        !this.isTsStillValid(w_openedDocumentTS) // No need to check gnx

        // Should the gnx be relevant? -&gt; !this.isGnxStillValid(w_openedDocumentGnx, w_openedDocumentTS)

    ) {
        return;
    }

    // * Actually Show the body pane document in a text editor
    const q_showTextDocument = vscode.window.showTextDocument(
        this._bodyTextDocument,
        w_showOptions
    ).then(
        (p_result) =&gt; {
            this.showBodyIfClosed = false; // * BODY IS ACTUALLY SHOWN!
            return p_result;
        }
    );

    // else q_bodyStates will exist.
    if (!this._needLastSelectedRefresh) {
        void q_showTextDocument.then(
            (p_textEditor: vscode.TextEditor) =&gt; {

                // * Set text selection range
                const w_bodyTextEditor = p_textEditor;
                if (!w_bodySel) {
                    console.log("no selection in returned package from get_body_states");
                }

                const w_leoBodySel: BodySelectionInfo = w_bodySel!;

                // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER q_bodyStates &amp; q_showTextDocument
                if (
                    w_openedDocument.isClosed ||
                    !this.isTsStillValid(w_openedDocumentTS) ||
                    (this.lastSelectedNode &amp;&amp; w_leoBodySel.gnx !== this.lastSelectedNode.gnx)
                    // Should the gnx be relevant? -&gt; !this.isGnxStillValid(w_openedDocumentGnx, w_openedDocumentTS)
                ) {
                    return;
                }

                // Cursor position and selection range
                const w_activeRow: number = w_leoBodySel.insert.line;
                const w_activeCol: number = w_leoBodySel.insert.col;
                let w_anchorLine: number = w_leoBodySel.start.line;
                let w_anchorCharacter: number = w_leoBodySel.start.col;

                if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                    // Active insertion same as start selection, so use the other ones
                    w_anchorLine = w_leoBodySel.end.line;
                    w_anchorCharacter = w_leoBodySel.end.col;
                }

                const w_selection = new vscode.Selection(
                    w_anchorLine,
                    w_anchorCharacter,
                    w_activeRow,
                    w_activeCol
                );

                let w_scrollRange: vscode.Range | undefined;

                // Build scroll position from selection range.
                w_scrollRange = new vscode.Range(
                    w_activeRow,
                    w_activeCol,
                    w_activeRow,
                    w_activeCol
                );

                if (w_bodyTextEditor) {
                    // this._revealType = RevealType.NoReveal; // ! IN CASE THIS WAS STILL UP FROM SHOW_OUTLINE

                    // console.log(
                    //     'ShowBody is setting selection! anchor: ', w_selection.anchor.line, w_selection.anchor.character,
                    //     ' active: ', w_selection.active.line, w_selection.active.character
                    // );

                    w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                    if (!w_scrollRange) {
                        w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                    }

                    if (this._refreshType.scroll) {
                        this._refreshType.scroll = false;

                        // Set scroll approximation
                        w_bodyTextEditor.revealRange(w_scrollRange, vscode.TextEditorRevealType.InCenterIfOutsideViewport);
                        // ! Compensate for reveal that steals the focus.
                        if (this._refreshType.goto) {
                            this._refreshType.goto = false;
                            // let w_viewName: string;
                            // const gotoView = this.leoGotoProvider.getLastGotoView();
                            // if (gotoView &amp;&amp; gotoView.title === "Goto") {
                            //     w_viewName = Constants.GOTO_ID;
                            // } else {
                            //     w_viewName = Constants.GOTO_EXPLORER_ID;
                            // }
                            // void vscode.commands.executeCommand(w_viewName + ".focus");
                            let w_panelID = '';
                            if (this._lastTreeView === this._leoTreeExView) {
                                w_panelID = Constants.FIND_EXPLORER_ID;
                            } else {
                                w_panelID = Constants.FIND_ID;
                            }
                            void vscode.commands.executeCommand(w_panelID + '.focus');
                        }
                    }

                } else {
                    console.log("no selection in returned package from showTextDocument");
                }

            }
        );
    }

    return q_showTextDocument;
}

</t>
<t tx="felix.20220922000450.13">/**
 * * Sets vscode's body-pane editor's language
 */
private _setBodyLanguage(p_document: vscode.TextDocument, p_language: string): Thenable&lt;vscode.TextDocument&gt; {
    return vscode.languages.setTextDocumentLanguage(p_document, p_language).then(
        (p_newDocument) =&gt; { return p_newDocument; }, // ok - language found
        (p_error) =&gt; {
            let w_langName: string = p_error.toString().split('\n')[0];
            if (w_langName.length &gt; 38 &amp;&amp; w_langName.includes(Constants.LEO_LANGUAGE_PREFIX)) {
                w_langName = w_langName.substring(38);
            } else {
                w_langName = "";
            }
            if (w_langName &amp;&amp; !this._languageFlagged.includes(w_langName)) {
                this._languageFlagged.push(w_langName);
                if (w_langName.endsWith(Constants.LEO_WRAP_SUFFIX)) {
                    w_langName = w_langName.slice(0, -Constants.LEO_WRAP_SUFFIX.length);
                }
                if (w_langName.startsWith(Constants.LEO_LANGUAGE_PREFIX)) {
                    w_langName = w_langName.slice(Constants.LEO_LANGUAGE_PREFIX.length);
                }
                void vscode.window.showInformationMessage(
                    w_langName + Constants.USER_MESSAGES.LANGUAGE_NOT_SUPPORTED
                );
            } else if (!w_langName) {
                // Document was closed: refresh after a timeout cycle (should not happen!)
                setTimeout(() =&gt; {
                    this.setupRefresh(
                        this.finalFocus,
                        {
                            // tree: true,
                            body: true,
                            // documents: true,
                            // buttons: false,
                            states: true,
                        }
                    );
                    void this.launchRefresh();
                }, 0);
            }
            return p_document;
        }
    );
}

</t>
<t tx="felix.20220922000450.14">/**
 * * Refreshes body pane's applied language and, word-wrap state.
 */
public refreshBodyStates(): void {

    if (!this._bodyTextDocument ||
        this._bodyTextDocument.isClosed ||
        !this.lastSelectedNode ||
        utils.leoUriToStr(this._bodyTextDocument.uri) !== this.lastSelectedNode.gnx
    ) {
        return; // Don't waste time finding out the language!
    }

    const c = g.app.windowList[this.frameIndex].c;
    let w_language = this._getBodyLanguage(c.p);

    // Set document language only if different
    if (w_language !== this._bodyTextDocument.languageId) {
        void this._setBodyLanguage(this._bodyTextDocument, w_language);
    }

}

</t>
<t tx="felix.20220922000450.15">/**
 * * Refresh body states after a small debounced delay.
 */
public debouncedRefreshBodyStates(p_delay?: number) {

    if (!p_delay) {
        p_delay = 0;
    }

    if (this._bodyStatesTimer) {
        clearTimeout(this._bodyStatesTimer);
    }
    if (p_delay === 0) {
        if (this._bodyLastChangedDocument &amp;&amp; this.leoStates.fileOpenedReady) {
            void this._bodySaveDocument(this._bodyLastChangedDocument);
        }
        this.refreshBodyStates();
    } else {
        this._bodyStatesTimer = setTimeout(() =&gt; {
            if (this._bodyLastChangedDocument &amp;&amp; this.leoStates.fileOpenedReady) {
                void this._bodySaveDocument(this._bodyLastChangedDocument);
            }
            this.refreshBodyStates();
        }, p_delay);
    }
}

</t>
<t tx="felix.20220922000450.2">/**
 * * Makes sure the body now reflects the selected node.
 * This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_preventTakingFocus Flag used to keep focus where it was instead of forcing in body
 * @returns a text editor of the p_node parameter's gnx (As 'leo' file scheme). Or rejects if interrupted.
 */
private _tryApplyNodeToBody(
    p_node: Position,
    p_aside: boolean,
    p_preventTakingFocus: boolean,
): Thenable&lt;void | vscode.TextEditor&gt; {

    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context

    // if not first time and still opened - also not somewhat exactly opened somewhere.
    if (this._bodyTextDocument &amp;&amp;
        !this._bodyTextDocument.isClosed &amp;&amp;
        !this._locateOpenedBody(p_node.gnx) // COULD NOT LOCATE NEW GNX
    ) {
        // if needs switching by actually having different gnx
        if (utils.leoUriToStr(this.bodyUri) !== p_node.gnx) {
            // * LOCATE OLD GNX FOR PROPER COLUMN
            this._locateOpenedBody(utils.leoUriToStr(this.bodyUri));
            // Make sure any pending changes in old body are applied before switching
            return this._bodyTextDocument.save().then(() =&gt; {
                return this._switchBody(p_aside, p_preventTakingFocus);
            });
        }
    }

    // first time or no body opened
    this.bodyUri = utils.strToLeoUri(p_node.gnx);
    if (this._isBodyVisible() === 0 &amp;&amp; !this.showBodyIfClosed) {
        return Promise.resolve();
    }
    return this.showBody(p_aside, p_preventTakingFocus);
}

</t>
<t tx="felix.20220922000450.3">/**
 * * Close body pane document and change the bodyUri to this.lastSelectedNode's gnx
 * This blocks 'undos' from crossing over
 * @param p_aside From 'Open Aside'.
 * @param p_preventTakingFocus prevents forcing focus on text body.
 */
private _switchBody(
    p_aside: boolean,
    p_preventTakingFocus?: boolean
): Thenable&lt;void | vscode.TextEditor&gt; {
    const w_oldUri: vscode.Uri = this.bodyUri;
    const w_newUri: vscode.Uri = utils.strToLeoUri(this.lastSelectedNode!.gnx);
    const w_newTS = utils.performanceNow();
    const w_visibleCount = this._isBodyVisible();

    this.bodyUri = w_newUri; // New GLOBAL BODY URI

    if (w_visibleCount === 0 &amp;&amp; !this.showBodyIfClosed) {
        return Promise.resolve();
    }

    if (w_visibleCount === 1) {
        this._bodyPreviewMode = this._isBodyPreview(); // recheck in case user double clicked on title
    }

    if (this.lastSelectedNode &amp;&amp; this._bodyPreviewMode &amp;&amp; this._bodyEnablePreview &amp;&amp; w_visibleCount &lt; 2) {

        // just show in same column and delete after
        const q_showBody = this.showBody(p_aside, p_preventTakingFocus);

        if (w_oldUri.fsPath !== this.bodyUri.fsPath) {
            void q_showBody.then(() =&gt; {
                const w_tabsToCloseFound: vscode.Tab[] = [];
                let q_lastSecondSaveFound: Thenable&lt;boolean&gt; = Promise.resolve(true);
                vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
                    p_tabGroup.tabs.forEach((p_tab) =&gt; {
                        if (p_tab.input &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri.fsPath === w_oldUri.fsPath
                        ) {
                            // Make sure it's saved AGAIN!!
                            if (
                                p_tab.isDirty &amp;&amp;
                                this._bodyLastChangedDocument &amp;&amp;
                                (p_tab.input as vscode.TabInputText).uri.fsPath === this._bodyLastChangedDocument.uri.fsPath
                            ) {
                                this._leoFileSystem.preventSaveToLeo = true;
                                this._editorTouched = false;
                                q_lastSecondSaveFound = this._bodyLastChangedDocument.save();
                            }
                            w_tabsToCloseFound.push(p_tab);
                        }
                    });
                });
                if (w_tabsToCloseFound.length) {
                    void q_lastSecondSaveFound.then(() =&gt; {
                        void vscode.window.tabGroups.close(w_tabsToCloseFound, true);
                    });
                }
                // Remove from potential 'recently opened'
                void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri);

            });
        }
        return q_showBody;
    } else {
        // Close ALL LEO EDITORS first !
        const w_tabsToCloseAll: vscode.Tab[] = [];
        let q_lastSecondSaveAll: Thenable&lt;boolean&gt; = Promise.resolve(true);

        vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
            p_tabGroup.tabs.forEach((p_tab) =&gt; {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                    w_newUri.fsPath !== (p_tab.input as vscode.TabInputText).uri.fsPath // Maybe useless to check if different!
                ) {

                    if (
                        p_tab.isDirty &amp;&amp;
                        this._bodyLastChangedDocument &amp;&amp;
                        (p_tab.input as vscode.TabInputText).uri.fsPath === this._bodyLastChangedDocument.uri.fsPath
                    ) {
                        this._leoFileSystem.preventSaveToLeo = true;
                        this._editorTouched = false;
                        q_lastSecondSaveAll = this._bodyLastChangedDocument.save();
                    }

                    w_tabsToCloseAll.push(p_tab);
                }
            });
        });

        let q_closeAll: Thenable&lt;unknown&gt;;
        if (w_tabsToCloseAll.length) {
            q_closeAll = q_lastSecondSaveAll.then(() =&gt; {
                return vscode.window.tabGroups.close(w_tabsToCloseAll, true);
            });

        } else {
            q_closeAll = Promise.resolve();
        }

        // async, so don't wait for this to finish
        if (w_oldUri.fsPath !== w_newUri.fsPath) {
            void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri);
        }

        return q_closeAll.then(() =&gt; {
            this._bodyPreviewMode = true;
            // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER q_bodyStates &amp; q_showTextDocument
            if (
                // Should the gnx be relevant?  !this.isGnxStillValid(w_newGnx, w_newTS)
                !this.isTsStillValid(w_newTS)
            ) {
                return;
            }
            return this.showBody(p_aside, p_preventTakingFocus);
        });
    }
}

</t>
<t tx="felix.20220922000450.4">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 * @returns true if located and found, false otherwise
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri) === p_gnx
            ) {
                vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
                    if (
                        utils.leoUriToStr(p_textDocument.uri) === p_gnx
                    ) {
                        w_found = true;
                        this._bodyTextDocument = p_textDocument; // vscode.workspace.openTextDocument
                        this._bodyMainSelectionColumn = p_tab.group.viewColumn;
                    }
                });
            }
        });
    });
    return w_found;
}

</t>
<t tx="felix.20220922000450.5">/**
 * * Checks for all tabs if any are 'leoBody' scheme
 * @returns total found
 */
private _isBodyVisible(): number {
    let w_total = 0;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME
            ) {
                w_total++;
            }
        });
    });
    return w_total;
}

</t>
<t tx="felix.20220922000450.6">/**
 * * Checks for all tabs if any are 'leoBody' scheme
 * @returns total found
 */
private _isBodyPreview(): boolean {
    let w_isPreview: boolean = true;
    let w_found: boolean = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME
            ) {
                w_found = true;
                if (!p_tab.isPreview) {
                    w_isPreview = false;
                }
            }
        });
    });
    if (w_found) {
        return w_isPreview;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20220922000450.7">/**
 * * Checks if outline is visible
 * @returns true if either outline is visible
 */
public isOutlineVisible(): boolean {
    return this._leoTreeExView.visible || this._leoTreeView.visible;
}

</t>
<t tx="felix.20220922000450.8">/**
 * * Closes non-existing text-editor body if it doesn't match bodyUri
 * @param p_textEditor the editor to close
 * @returns promise that resolves to true if it closed tabs, false if none were found
 */
private _hideDeleteBody(p_textEditor: vscode.TextEditor): Thenable&lt;unknown&gt; {
    const w_foundTabs: vscode.Tab[] = [];
    const w_editorFsPath = p_textEditor.document.uri.fsPath;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme.startsWith(Constants.URI_LEOJS_SCHEME) &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.fsPath === w_editorFsPath
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    // * Make sure the closed/deleted body is not remembered as vscode's recent files!
    void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', p_textEditor.document.uri);

    if (w_foundTabs.length) {
        return vscode.window.tabGroups.close(w_foundTabs, true);
    }

    return Promise.resolve();
}

</t>
<t tx="felix.20220922000450.9">/**
 * * Clears the global 'Preview Mode' flag if the given editor is not in the main body column
 * @param p_editor is the editor to check for is in the same column as the main one
 */
private _checkPreviewMode(p_editor: vscode.TextEditor): void {
    // if selected gnx but in another column
    if (
        p_editor.document.uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
        p_editor.document.uri.fsPath === this.bodyUri.fsPath &amp;&amp;
        p_editor.viewColumn !== this._bodyMainSelectionColumn
    ) {
        this._bodyPreviewMode = false;
        this._bodyMainSelectionColumn = p_editor.viewColumn;
    }
}

</t>
<t tx="felix.20220922215553.1">/**
 * * Location of focus to be set when current/last command is resolved
 */
export const enum Focus {
    NoChange = 0, // Stays on goto pane, or other current panel.
    Body, // Forces body to appear, refresh leaves focus on body.
    Outline, // Forces outline to appear, refresh leaves focus on Outline.
    Goto
}

</t>
<t tx="felix.20220922235942.1">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 * @returns Thenable from the reveal tree node action, resolves directly if no tree visible
 */
private _revealNode(
    p_leoNode: Position,
    p_options?: { select?: boolean; focus?: boolean; expand?: boolean | number }
): void {
    let w_treeview: vscode.TreeView&lt;Position&gt; | undefined;
    if (this._leoTreeView.visible) {
        w_treeview = this._leoTreeView;
    }
    if (this._leoTreeExView.visible &amp;&amp; this.config.treeInExplorer) {
        w_treeview = this._leoTreeExView;
    }
    if (!w_treeview &amp;&amp; (this.showOutlineIfClosed || (p_options &amp;&amp; p_options.focus))) {
        this.showOutlineIfClosed = false;
        w_treeview = this._lastTreeView;
        if (p_options) {
            p_options.focus = true;
        } else {
            p_options = {
                focus: true,
                select: true
            };
        }
    }
    try {
        if (w_treeview) {
            this.safeReveal(w_treeview, p_leoNode, p_options).then(
                () =&gt; {
                    // ok
                    this._revealNodeRetriedRefreshOutline = false;
                },
                (p_reason) =&gt; {
                    console.log('_revealNode could not reveal. Reason: ', p_reason);

                    if (!this._revealNodeRetriedRefreshOutline) {
                        this._revealNodeRetriedRefreshOutline = true;
                        // Reveal failed. Retry refreshOutline once
                        this._refreshOutline(true, RevealType.RevealSelect);
                    }
                }
            );
        }

    } catch (p_error) {
        console.error("_revealNode error: ", p_error);
        // Retry refreshOutline once
        if (!this._revealNodeRetriedRefreshOutline) {
            this._revealNodeRetriedRefreshOutline = true;
            // Reveal failed. Retry refreshOutline once
            this._refreshOutline(true, RevealType.RevealSelect);
        }
    }
}

</t>
<t tx="felix.20220923001235.1">/**
 * * Checks timestamp only, if is still the latest lastReceivedNode
  * @param ts timestamp of last time
 */
public isTsStillValid(ts: number): boolean {

    // also test other sources, and check if command also not started to go back to original gnx
    // by checking if the test above only failed for gnx being the same
    if (
        this._refreshNode &amp;&amp;
        this._lastRefreshNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new _refreshNode is different and newer
        return false;
    }
    if (
        this.lastSelectedNode &amp;&amp;
        this._lastSelectedNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new lastSelectedNode is different and newer
        return false;
    }
    return true;
}

</t>
<t tx="felix.20220923001725.1">/**
 * * Refreshes all parts.
 * @returns Promise back from command's execution, if added on stack, undefined otherwise.
 */
public fullRefresh(p_keepFocus?: boolean): void {
    this.setupRefresh(
        p_keepFocus ? Focus.NoChange : this.finalFocus,
        {
            tree: true,
            body: true,
            states: true,
            buttons: true,
            documents: true,
            goto: true,
        }
    );
    void this.launchRefresh();
}

</t>
<t tx="felix.20220923003944.1">/**
 * * Table for converting Leo languages names for the currently opened body pane
 * Used in showBody method of leoUI.ts
 */
public static LANGUAGE_CODES: { [key: string]: string | undefined } = {
    cplusplus: 'cpp',
    md: 'markdown',
    rest: 'restructuredtext',
    rst: 'restructuredtext',
    text: 'plain'
};

</t>
<t tx="felix.20220929001102.1">/**
 * * window.performace.now browser/node crossover utility
 */
export function performanceNow(): number {
    const w_now = process.hrtime();
    const [w_secs, w_nanosecs] = w_now;
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20220930212953.1">/**
 * * Handles the opening of a file in vscode, and check if it's a Leo file to suggest opening options
 * @param p_event The opened document event passed by vscode
 */
private _onDidOpenTextDocument(p_document: vscode.TextDocument): void {
    if (
        this.leoStates.leoReady &amp;&amp;
        (
            p_document.uri.fsPath.toLowerCase().endsWith('.leo') ||
            p_document.uri.fsPath.toLowerCase().endsWith('.leojs')
        )
    ) {
        if (!this._hasShownContextOpenMessage) {
            void vscode.window.showInformationMessage(Constants.USER_MESSAGES.RIGHT_CLICK_TO_OPEN);
            this._hasShownContextOpenMessage = true;
        }
    }
}

</t>
<t tx="felix.20220930214530.1">/**
 * * Handle the change of visibility of either find panel
 * @param p_event The visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onFindViewVisibilityChanged(p_explorerView: boolean): void {
    const currentView = p_explorerView ? this._findPanelWebviewExplorerView : this._findPanelWebviewView;

    if (currentView?.visible) {
        this._lastFindView = currentView;
        this.checkForceFindFocus(false);
        this.setGotoContent();

        if (this.leoGotoProvider.isSelected) {
            this.revealGotoNavEntry(this.leoGotoProvider.selectedNodeIndex, true);
        }
    }
}

</t>
<t tx="felix.20220930214929.1">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * @param p_editor The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by LeoJS itself
 */
private _onActiveEditorChanged(
    p_editor: vscode.TextEditor | undefined,
    p_internalCall?: boolean
): void {
    if (p_editor) {
        this._hideBodiesUnknownToFileSys([p_editor]);
    }
    if (!p_internalCall) {
        void this.triggerBodySave(true, true); // Save in case edits were pending
    }
    // // set _bodyDetachedTextDocument AFTER triggerBodySave, as focus may already have been in a dirty detached body.
    // if (p_editor &amp;&amp; p_editor.document.uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME) {
    //     this.bodyDetachedTextDocument = p_editor.document; // Next triggerBodySave will apply to this newly focused one.
    // }

}

</t>
<t tx="felix.20220930214943.1">/**
 * * Moved a document to another column
 * @param p_columnChangeEvent Event describing the change of a text editor's view column
 */
public _changedTextEditorViewColumn(
    p_columnChangeEvent: vscode.TextEditorViewColumnChangeEvent
): void {
    if (p_columnChangeEvent &amp;&amp; p_columnChangeEvent.textEditor.document.uri.scheme === Constants.URI_LEOJS_SCHEME) {
        this._checkPreviewMode(p_columnChangeEvent.textEditor);
    }
    void this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20220930214948.1">/**
 * * Tabbed on another editor
 * @param p_editors text editor array (to be checked for changes in this method)
 */
public _changedVisibleTextEditors(p_editors: readonly vscode.TextEditor[]): void {
    if (p_editors &amp;&amp; p_editors.length) {
        // May be no changes - so check length
        this._hideBodiesUnknownToFileSys(p_editors);
    }
    void this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20220930214953.1">/**
 * * Whole window has been minimized/restored
 * @param p_windowState the state of the window that changed
 */
public _changedWindowState(p_windowState: vscode.WindowState): void {
    // no other action
    void this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20220930214959.1">/**
 * * Handles detection of the active editor's selection change or cursor position
 * @param p_event a change event containing the active editor's selection, if any.
 */
private _onChangeEditorSelection(p_event: vscode.TextEditorSelectionChangeEvent): void {
    if (
        p_event.textEditor.document.uri.scheme === Constants.URI_LEOJS_SCHEME ||
        p_event.textEditor.document.uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME
    ) {
        if (p_event.selections.length) {
            this._selectionDirty = true;
            this._selection = p_event.selections[0];
            this._selectionGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20220930215005.1">/**
 * * Handles detection of the active editor's scroll position changes
 * @param p_event a change event containing the active editor's visible range, if any.
 */
private _onChangeEditorScroll(p_event: vscode.TextEditorVisibleRangesChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEOJS_SCHEME ||
        p_event.textEditor.document.uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME) {
        if (p_event.visibleRanges.length) {
            this._scrollDirty = true;
            this._scroll = p_event.visibleRanges[0];
            this._scrollGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20220930215012.1">/**
 * * Handle typing, undos and read-from-file refreshes that was detected as a document change
 * @param p_textDocumentChange Text changed event passed by vscode
 */
private _onDocumentChanged(p_textDocumentChange: vscode.TextDocumentChangeEvent): void {

    if (
        p_textDocumentChange.contentChanges.length &amp;&amp;
        (p_textDocumentChange.document.uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME)
    ) {

        const [unused, id, gnx] = p_textDocumentChange.document.uri.path.split("/");
        const w_bodyText = p_textDocumentChange.document.getText().replace(/\r\n/g, "\n");
        const w_hasBody = !!w_bodyText.length;

        const w_selectedCId = g.app.windowList[this.frameIndex].c.id.toString();
        const w_sameCommander = w_selectedCId === id;
        let w_needDocRefresh = false;
        let w_alreadySaved = false;
        let w_v: VNode | undefined;

        let c: Commands | undefined; // The modified text document's body's commander.

        for (const w_frame of g.app.windowList) {
            if (w_frame.c.id.toString() === id) {
                c = w_frame.c;
                break;
            }
        }
        if (c) {
            w_v = c.fileCommands.gnxDict[gnx];
            if (this._changedBodyWithMirrorDetached || (w_v &amp;&amp; (w_bodyText === w_v.b))) {
                // WAS NOT A USER MODIFICATION?
                this._changedBodyWithMirrorDetached = undefined;
                return;
            }
        }

        this.bodyDetachedTextDocument = p_textDocumentChange.document;

        // * If body changed a line with and '@' directive refresh body states
        let w_needsRefresh = false;
        for (const p_change of p_textDocumentChange.contentChanges) {
            if (p_change.rangeLength || p_change.text.includes('@')) {
                // There may have been an @
                w_needsRefresh = true;
                break;
            }
        }

        // * Detect in active editor if current cursor line is language related, set w_needsRefresh if so.
        const w_textEditor = vscode.window.activeTextEditor;
        if (
            w_textEditor &amp;&amp; w_textEditor.selections &amp;&amp; w_textEditor.selections.length &amp;&amp;
            !w_needsRefresh &amp;&amp; p_textDocumentChange.document.uri.fsPath === w_textEditor.document.uri.fsPath
        ) {
            for (const p_selection of w_textEditor.selections) {
                if (p_selection.active.line &lt; w_textEditor.document.lineCount) {
                    // TRY TO DETECT IF LANGUAGE RESET NEEDED!
                    let w_line = w_textEditor.document.lineAt(p_selection.active.line).text;
                    if (w_line.trim().startsWith('@') || w_line.includes('language') || w_line.includes('wrap') || w_line.includes('killcolor') || w_line.includes('nocolor-node')) {
                        w_needsRefresh = true;
                        break;
                    }
                }
            }
        }

        const w_uriKey = utils.leoUriToStr(this.bodyDetachedTextDocument.uri);
        const w_node = this._leoDetachedFileSystem.openedBodiesVNodes[w_uriKey];
        const w_detachedIconChanged = !w_node.isDirty() || (!!w_node.bodyString().length === !w_hasBody);

        // If same commander, and node icon changed (or whole document was unchanged)
        if (w_sameCommander) {
            if (!this.leoStates.leoChanged || w_detachedIconChanged) {
                if (!w_alreadySaved) {
                    void this._bodySaveDocument(this.bodyDetachedTextDocument);
                    w_alreadySaved = true;
                }
                if (w_detachedIconChanged) {
                    this.findFocusTree = false;
                    // NOT incrementing this.treeID to keep ids intact
                    // NoReveal since we're keeping the same id.
                    this._refreshOutline(false, RevealType.NoReveal);
                }
            }
        } else {
            if (c &amp;&amp; !c.isChanged()) {
                w_needDocRefresh = true;
                if (!w_alreadySaved) {
                    void this._bodySaveDocument(this.bodyDetachedTextDocument);
                    w_alreadySaved = true;
                }
            }
        }

        if (w_needsRefresh) {
            if (!w_alreadySaved) {
                void this._bodySaveDocument(this.bodyDetachedTextDocument);
                w_alreadySaved = true;
            }
            // REFRESH LANGUAGE OF THIS DETACHED BODY
            const w_foundVnode = this._leoDetachedFileSystem.openedBodiesVNodes[utils.leoUriToStr(p_textDocumentChange.document.uri)];
            if (w_foundVnode) {

                const gnx = w_foundVnode.gnx;

                for (const p of w_foundVnode.context.all_unique_positions()) {
                    if (p.v.gnx === gnx) {
                        if (!w_alreadySaved) {
                            void this._bodySaveDocument(this.bodyDetachedTextDocument);
                            w_alreadySaved = true;
                        }
                        let w_language = this._getBodyLanguage(p); // !! 
                        // Set document language only if different
                        if (w_language !== this.bodyDetachedTextDocument.languageId) {
                            void this._setBodyLanguage(this.bodyDetachedTextDocument, w_language).then((p_doc) =&gt; {
                                this.bodyDetachedTextDocument = p_doc;
                            });
                        }
                        break;
                    }
                }


            } else {
                console.log('DETACHED VNODE not found when resetting language');
            }
            // REFRESH LANGUAGE OF OTHER DETACHED BODIES WITH DELAY
            this.refreshCommanderDetachedLanguage();
        }

        // * CHECK FOR BODY THAT MATCHES! set w_sameBodyTabOpened if so.
        let w_sameBodyTabOpened = false;
        for (const p_tabGroup of vscode.window.tabGroups.all) {
            for (const p_tab of p_tabGroup.tabs) {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    ((p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME)
                ) {
                    if (gnx === utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri)) {
                        w_sameBodyTabOpened = true;
                        break;
                    }
                }
            }
            if (w_sameBodyTabOpened) {
                break;
            }
        }

        // Check if exact same commander AND same gnx: BOTH THE SAME so refresh the body!
        if (w_sameCommander) {
            if (w_sameBodyTabOpened &amp;&amp; this.lastSelectedNode &amp;&amp; gnx === this.lastSelectedNode.gnx) {
                // Same commander AND same gnx  !  
                if (!w_alreadySaved) {
                    // console.log('bodySAVE DETACHED because same tab opened');
                    void this._bodySaveDocument(this.bodyDetachedTextDocument);
                    w_alreadySaved = true;
                }
                if (this._leoFileSystem.watchedBodiesGnx.includes(gnx)) {
                    // console.log("setting changedDetachedWithMirrorBody");

                    this._changedDetachedWithMirrorBody = `${id}/${gnx}`; // PREVENT DOUBLE REFRESH
                }
                // console.log('fire refresh of body');
                this._leoFileSystem.fireRefreshFile(this.lastSelectedNode.gnx);
            }
            if (w_needsRefresh) {
                this.debouncedRefreshBodyStates(50); // And maybe changed in other node of same commander!
            }

        } else if (w_needDocRefresh) {
            this.refreshDocumentsPane();
        }
        if (!this.leoStates.leoChanged &amp;&amp; w_sameCommander) {
            // also refresh document panel (icon may be dirty now)
            this.leoStates.leoChanged = true;
            this.refreshDocumentsPane();
        }

    }

    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (
        this.lastSelectedNode &amp;&amp;
        p_textDocumentChange.contentChanges.length &amp;&amp;
        p_textDocumentChange.document.uri.scheme === Constants.URI_LEOJS_SCHEME
    ) {
        // this.bodyDetachedTextDocument = undefined;
        const c = g.app.windowList[this.frameIndex].c;

        // * There was a on a Leo Body by the user OR FROM LEO REFRESH FROM FILE
        this._bodyLastChangedDocument = p_textDocumentChange.document;
        this._bodyLastChangedDocumentSaved = false;
        this._editorTouched = true; // To make sure to transfer content to Leo even if all undone
        this._bodyPreviewMode = false;
        let w_hasSameDetachedTab = false;
        let w_hasOtherDetachedTab = false;
        const c_id = c.id.toString();
        const w_lastSelNodeGnx = this.lastSelectedNode.gnx;

        // CHECK FOR DETACHED THAT MATCHES! 
        for (const p_tabGroup of vscode.window.tabGroups.all) {
            for (const p_tab of p_tabGroup.tabs) {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME
                ) {
                    const [unused, id, gnx] = (p_tab.input as vscode.TabInputText).uri.path.split("/");
                    if (id === c_id &amp;&amp; gnx === w_lastSelNodeGnx) {
                        w_hasSameDetachedTab = true;
                    } else {
                        w_hasOtherDetachedTab = true;
                    }
                }
            }
        }

        // * If icon should change then do it now (if there's no document edit pending)
        if (
            utils.leoUriToStr(p_textDocumentChange.document.uri) === w_lastSelNodeGnx
        ) {
            const w_bodyText = p_textDocumentChange.document.getText().replace(/\r\n/g, "\n");
            const w_hasBody = !!w_bodyText.length;
            const w_iconChanged = utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody) || this.findFocusTree;

            if (this._changedDetachedWithMirrorBody || (c.p &amp;&amp; c.p.__bool__() &amp;&amp; w_bodyText === c.p.b)) {
                // WAS NOT A USER MODIFICATION? (external file change, replace, replace-then-find)
                // Set proper cursor insertion point and selection range.
                this._changedDetachedWithMirrorBody = undefined;
                void this.showBody(false, true, true);
                return;
            }

            if (!this.leoStates.leoChanged || w_iconChanged || w_hasSameDetachedTab) {
                // Document pane icon needs refresh (changed) and/or outline icon changed
                void this._bodySaveDocument(p_textDocumentChange.document).then(() =&gt; {
                    if (w_hasSameDetachedTab &amp;&amp; this.lastSelectedNode) {
                        const gnxString = `${c.id}/${w_lastSelNodeGnx}`;
                        if (this._leoDetachedFileSystem.watchedBodiesGnx.includes(gnxString)) {
                            this._changedBodyWithMirrorDetached = gnxString; // PREVENT DOUBLE REFRESH
                        }
                        this._leoDetachedFileSystem.fireRefreshFile(gnxString);
                    }
                    if (w_iconChanged) {
                        this.findFocusTree = false;
                        // NOT incrementing this.treeID to keep ids intact
                        // NoReveal since we're keeping the same id.
                        this._refreshOutline(false, RevealType.NoReveal);
                    }
                });

                if (!this.leoStates.leoChanged) {
                    // also refresh document panel (icon may be dirty now)
                    this.leoStates.leoChanged = true;
                    this.refreshDocumentsPane();
                }
            }
        }

        // * If body changed a line with and '@' directive refresh body states
        let w_needsRefresh = false;
        for (const p_change of p_textDocumentChange.contentChanges) {
            if (p_change.rangeLength || p_change.text.includes('@')) {
                // There may have been an @
                w_needsRefresh = true;
                break;
            }
        }

        const w_textEditor = vscode.window.activeTextEditor;

        if (w_textEditor &amp;&amp; p_textDocumentChange.document.uri.fsPath === w_textEditor.document.uri.fsPath) {
            for (const p_selection of w_textEditor.selections) {
                // TRY TO DETECT IF LANGUAGE RESET NEEDED!
                if (p_selection.active.line &lt; w_textEditor.document.lineCount) {
                    let w_line = w_textEditor.document.lineAt(p_selection.active.line).text;
                    if (w_line.trim().startsWith('@') || w_line.includes('language') || w_line.includes('wrap') || w_line.includes('killcolor') || w_line.includes('nocolor-node')) {
                        w_needsRefresh = true;
                        break;
                    }
                }
            }
        }
        if (w_hasOtherDetachedTab) {
            this.refreshDocumentsPane();
        }
        if (w_needsRefresh) {
            this.debouncedRefreshBodyStates(1);
            this.refreshCommanderDetachedLanguage();
        }

    }
}

</t>
<t tx="felix.20220930215020.1">/**
 * * Capture instance for further calls on find panel webview
 * @param p_panel The panel (usually that got the latest onDidReceiveMessage)
 */
public setFindPanel(p_panel: vscode.WebviewView): void {
    if (p_panel.viewType === Constants.FIND_EXPLORER_ID) {
        // Explorer find panel
        this._lastFindView = this._findPanelWebviewExplorerView;
        this._findPanelWebviewExplorerView = p_panel;
        this._context.subscriptions.push(
            p_panel.onDidChangeVisibility(() =&gt;
                this._onFindViewVisibilityChanged(true)
            ));
    } else {
        // Leo Pane find panel
        this._findPanelWebviewView = p_panel;
        this._lastFindView = this._findPanelWebviewView;
        this._context.subscriptions.push(
            p_panel.onDidChangeVisibility(() =&gt;
                this._onFindViewVisibilityChanged(false)
            ));
    }
    this.setGotoContent();
    this.checkForceFindFocus(true);
}

</t>
<t tx="felix.20220930215434.1">/**
 * * Places selection on the required node with a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_frame Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_frame: LeoFrame): void {
    if (this._leoDocumentsRevealTimer) {
        clearTimeout(this._leoDocumentsRevealTimer);
    }
    this._leoDocumentsRevealTimer = setTimeout(() =&gt; {
        if (!this._leoDocuments.visible &amp;&amp; !this._leoDocumentsExplorer.visible) {
            return;
        }
        let w_trigger = false;
        let w_docView: undefined | vscode.TreeView&lt;LeoFrame&gt;;
        if (this._leoDocuments.visible &amp;&amp; this._lastLeoDocuments === this._leoDocuments) {
            w_docView = this._leoDocuments;
        } else if (this._leoDocumentsExplorer === this._lastLeoDocuments) {
            w_docView = this._leoDocumentsExplorer;
        }
        if (!w_docView) {
            return;
        }
        if (w_docView.selection.length &amp;&amp; w_docView.selection[0] === p_frame) {
            // console.log('already selected!');
        } else {
            w_trigger = true;
        }
        if (w_trigger &amp;&amp; !this._documentPaneReveal) {
            this._documentPaneReveal = w_docView.reveal(p_frame, { select: true, focus: false })
                .then(
                    (p_result) =&gt; {
                        // Shown document node
                        this._documentPaneReveal = undefined;
                    },
                    (p_reason) =&gt; {
                        this._documentPaneReveal = undefined;
                        console.log('shown doc error on reveal: ', p_reason);
                    }
                );
        }
    }, 0);
}

</t>
<t tx="felix.20220930215533.1"></t>
<t tx="felix.20220930215540.1">/**
 * * highlights the current undo state without disturbing focus
 * @param p_undoNode Node instance in the Leo History view to be the 'selected' one.
 */
private _setUndoSelection(p_undoNode: LeoUndoNode): void {
    if (this._lastLeoUndos &amp;&amp; this._lastLeoUndos.visible &amp;&amp; !this._undoPaneReveal) {
        this._undoPaneReveal = this._lastLeoUndos.reveal(p_undoNode, { select: true, focus: false }).then(
            () =&gt; {
                this._undoPaneReveal = undefined;
            },
            (p_error) =&gt; {
                this._undoPaneReveal = undefined;
                console.log('setUndoSelection could not reveal');
            }
        );
    }
}

</t>
<t tx="felix.20220930215747.1">/**
 * * Reverts to a particular undo bead state
 */
public revertToUndo(p_undo: LeoUndoNode): Promise&lt;any&gt; {

    if (p_undo.contextValue !== Constants.CONTEXT_FLAGS.UNDO_BEAD) {
        return Promise.resolve();
    }
    let action = "redo"; // Constants.LEOBRIDGE.REDO;
    let repeat = p_undo.beadIndex;
    if (p_undo.beadIndex &lt;= 0) {
        action = "undo"; // Constants.LEOBRIDGE.UNDO;
        repeat = (-p_undo.beadIndex) + 1;
    }
    const c = g.app.windowList[this.frameIndex].c;
    const u = c.undoer;
    for (let x = 0; x &lt; repeat; x++) {
        if (action === "redo") {
            if (u.canRedo()) {
                u.redo();
            }
        } else if (action === "undo") {
            if (u.canUndo()) {
                u.undo();
            }
        }
    }
    this.setupRefresh(
        Focus.Outline,
        {
            tree: true,
            body: true,
            documents: true,
            states: true,
            buttons: true,
        }
    );
    return Promise.resolve(this.launchRefresh());
}

</t>
<t tx="felix.20220930222931.1">/**
 * Check if search input should be forced-focused again
 */
public checkForceFindFocus(p_fromInit: boolean): void {
    if (this._findNeedsFocus) {
        let message = 'selectFind';
        if (this._findNeedsFocus === 2) {
            message = 'selectNav';
        }
        this._findNeedsFocus = 0; // Set false before timeout.
        setTimeout(() =&gt; {
            let w_panel: vscode.WebviewView | undefined;
            if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
                w_panel = this._findPanelWebviewView;
            } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
                w_panel = this._findPanelWebviewExplorerView;
            }
            if (w_panel) {
                this._findNeedsFocus = 0; // Set false ALSO AFTER !
                void w_panel.webview.postMessage({ type: message });
            }
        }, 60);
    }
}

</t>
<t tx="felix.20221001002338.1">/**
 * * Public method exposed as 'refreshButtonsPane' setter/getter to refresh the buttons pane
 * Buttons Panel May be refreshed by other services (states service, ...)
 */
private _refreshButtonsPane(): void {
    this._leoButtonsProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20221002011903.1">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns A promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Thenable&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leojs first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            void vscode.window.showInformationMessage(`leojs upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}

</t>
<t tx="felix.20221002124249.1">/**
 * * Opens quickPick minibuffer pallette to choose from all commands in this file's commander
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
private async _showMinibufferHistory(p_choices: vscode.QuickPickItem[]): Promise&lt;unknown&gt; {

    // Wait for _isBusyTriggerSave resolve because the full body save may change available commands
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    if (!c.commandHistory.length) {
        return;
    }
    // Build from list of strings (labels).
    let w_commandList: vscode.QuickPickItem[] = [];
    for (const w_command of c.commandHistory) {
        let w_found = false;
        for (const w_pick of p_choices) {
            if (w_pick.label === w_command) {
                w_commandList.push(w_pick);
                w_found = true;
                break;
            }
        }
        if (!w_found) {
            w_commandList.push({
                label: w_command,
                description: Constants.USER_MESSAGES.MINIBUFFER_BAD_COMMAND,
                detail: `No command function for ${w_command}`
            });
        }
    }
    if (!w_commandList.length) {
        return;
    }
    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
        matchOnDetail: true,
    };
    const w_picked = await vscode.window.showQuickPick(w_commandList, w_options);
    return this._doMinibufferCommand(w_picked);
}

</t>
<t tx="felix.20221002124535.1">/**
 * * Perform chosen minibuffer command
 */
private _doMinibufferCommand(p_picked?: vscode.QuickPickItem): Promise&lt;unknown&gt; {
    if (p_picked &amp;&amp; p_picked.label) {
        // Setup refresh
        this.setupRefresh(Focus.NoChange,
            {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true
            }
        );

        this._addToMinibufferHistory(p_picked);
        const c = g.app.windowList[this.frameIndex].c;

        let w_command = p_picked.label; // May be overriden with async commands

        // * LEOJS : OVERRIDE with custom async commands where applicable
        if (Constants.MINIBUFFER_OVERRIDDEN_NAMES[p_picked.label]) {
            w_command = Constants.MINIBUFFER_OVERRIDDEN_NAMES[p_picked.label];
        }

        const w_commandResult = c.executeMinibufferCommand(w_command);

        if (w_commandResult &amp;&amp; w_commandResult.then) {
            // IS A PROMISE so tack-on the launchRefresh to its '.then' chain. 
            void (w_commandResult as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
                void this.launchRefresh();
            });
        } else {
            void this.launchRefresh();
        }
        // In both cases, return the result, or if a promise: the promise itself, not the result.
        return Promise.resolve(w_commandResult);

    } else {
        // Canceled
        return Promise.resolve(undefined);
    }
}

</t>
<t tx="felix.20221004234249.1">/**
 * Used mostly for leojsOutline ViewsWelcome content
 */
private _leojsStartupDone: boolean = false;
get leojsStartupDone(): boolean {
    return this._leojsStartupDone;
}
set leojsStartupDone(p_value: boolean) {
    this._leojsStartupDone = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_STARTUP_DONE, p_value);
}

</t>
<t tx="felix.20221005002719.1">function setStartupDoneContext(p_value: boolean): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, Constants.CONTEXT_FLAGS.LEO_STARTUP_DONE, p_value);
}

</t>
<t tx="felix.20221009011653.1">export interface CommandOptions {
    node?: Position, // facultative, precise node onto which the command is run (also see p_keepSelection)
    refreshType: ReqRefresh, // Object containing flags for sections needing to refresh after command ran
    finalFocus: Focus, // final focus placement
    keepSelection?: boolean, // flag to bring back selection on the original node
    isNavigation?: boolean // Navigation commands force-show the body and outline
}

</t>
<t tx="felix.20221009233703.1">/**
 * List of command names for both categories of possible offsets when keeping selection.
 */
public static OLD_POS_OFFSETS = {
    DELETE: ["cut-node", "delete-node"],
    ADD: ["clone-node", "async-paste-node", "async-paste-retaining-clones"]
};

</t>
<t tx="felix.20221026222034.1">public set_focus(commander: Commands, widget: any): void {
    this.focusWidget = widget;
    const w_widgetName = this.widget_name(widget);
    // * LeoJS custom finalFocus replacement.
    if (widget &amp;&amp; this.finalFocus === Focus.NoChange) {
        // * Check which panel to focus
        let w_target = Focus.NoChange;
        if (w_widgetName === 'body') {
            w_target = Focus.Body;
        } else if (w_widgetName === 'tree') {
            w_target = Focus.Outline;
        }
        this.setupRefresh(w_target);
    } else {
        // pass
    }
}

</t>
<t tx="felix.20221026222040.1">public get_focus(c?: Commands): StringTextWrapper {
    return this.focusWidget!;
}

</t>
<t tx="felix.20221027153815.1">public widget_name(w: any): string {
    let name: string;
    if (!w) {
        name = '&lt;no widget&gt;';
    } else if (w['getName']) {
        name = w.getName();
    } else if (w['objectName']) {
        name = w.objectName();
    } else if (w['_name']) {
        name = w._name;
    } else if (w['name']) {
        name = w.name;
    } else {
        name = w.toString();
    }
    return name;
}

</t>
<t tx="felix.20221027155442.1">export const enum LeoGotoNavKey {
    prev = 0,
    next,
    first,
    last
}

</t>
<t tx="felix.20221027155905.1">/**
 * * Goto the next, previous, first or last nav entry via arrow keys in
 */
public navigateNavEntry(p_nav: LeoGotoNavKey): void {
    void this.leoGotoProvider.navigateNavEntry(p_nav);
}

</t>
<t tx="felix.20221027230322.1">/**
 * * Build all possible strings for undo icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the undo tree view
 */
export function buildUndoIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_UNDO_ACTIVE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_UNDO_ACTIVE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_UNDO),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_UNDO)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_REDO_ACTIVE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_REDO_ACTIVE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_REDO),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_REDO)
        }
    ];
}

</t>
<t tx="felix.20221101220727.1">/**
 * Set filename as description
 */
public refreshDesc(): void {
    let titleDesc = "";

    if (this.leoStates.fileOpenedReady) {

        const s = this.leoStates.leoOpenedFileName;
        const w_filename = s ? utils.getFileFromPath(s) : Constants.UNTITLED_FILE_NAME;
        let w_path = "";
        const n = s ? s.lastIndexOf(w_filename) : -1;
        if (n &gt;= 0 &amp;&amp; n + w_filename.length &gt;= s.length) {
            w_path = s.substring(0, n);
        }
        titleDesc = w_filename + (w_path ? " in " + w_path : '');

        // const c = g.app.windowList[this.frameIndex].c;
        // titleDesc = c.frame.title;

        if (this._leoTreeView) {
            this._leoTreeView.description = titleDesc;
        }
        if (this._leoTreeExView) {
            this._leoTreeExView.description = titleDesc;
        }
    }
    if (this._leoTreeView.description === titleDesc) {
        return;
    }
    if (this._leoTreeView) {
        this._leoTreeView.description = titleDesc;
    }
    if (this._leoTreeExView) {
        this._leoTreeExView.description = titleDesc;
    }

}

</t>
<t tx="felix.20221106230554.1">/**
 * Handle a successful find match.
 */
public show_find_success(c: Commands, in_headline: boolean, insert: number, p: Position): void {
    // TODO : see focus_to_body !
    // TODO : USE ONLY 'WRAPPER' OR 'WIDGET' like in show_find_success!
    if (in_headline) {
        // edit_widget(p)
        // c.frame.edit_widget(p);
        // console.log('try to set');
        try {
            g.app.gui.set_focus(c, c.frame.tree.edit_widget(p));
        }
        catch (e) {
            console.log('oops!', e);

        }
        // g.app.gui.set_focus(c, { _name: 'tree' });
    } else {
        try {
            g.app.gui.set_focus(c, c.frame.body.widget);
        }
        catch (e) {
            console.log('oops!', e);
        }
    }

    // edit_widget
    // ? needed ?

    // trace = False and not g.unitTesting
    // if in_headline:
    //     if trace:
    //         g.trace('HEADLINE', p.h)
    //     c.frame.tree.widget.select_leo_node(p)
    //     self.focus_to_head(c, p)  # Does not return.
    // else:
    //     w = c.frame.body.widget
    //     row, col = g.convertPythonIndexToRowCol(p.b, insert)
    //     if trace:
    //         g.trace('BODY ROW', row, p.h)
    //     w.cursor_line = row
    //     self.focus_to_body(c)  # Does not return.
}

</t>
<t tx="felix.20221108222157.1">{
  "command": "leojs.hoistNode",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-hoist)"
},
{
  "command": "leojs.hoistSelection",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanHoist",
  "icon": "$(leojs-hoist)"
},
{
  "command": "leojs.hoistSelectionFromOutline",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanHoist",
  "icon": "$(leojs-hoist)"
},
{
  "command": "leojs.deHoist",
  "category": "Leojs",
  "title": "De-Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanDehoist",
  "icon": "$(leojs-dehoist)"
},
{
  "command": "leojs.deHoistFromOutline",
  "category": "Leojs",
  "title": "De-Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanDehoist &amp;&amp; !leojsTopHoistChapter",
  "icon": "$(leojs-dehoist)"
},
{
  "command": "leojs.chapterNext",
  "category": "Leojs",
  "title": "Chapter Next",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-chapter-next)"
},
{
  "command": "leojs.chapterBack",
  "category": "Leojs",
  "title": "Chapter Back",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-chapter-back)"
},
{
  "command": "leojs.chapterMain",
  "category": "Leojs",
  "title": "Chapter Main",
  "enablement": "leojsTreeOpened &amp;&amp; leojsTopHoistChapter",
  "icon": "$(leojs-chapter-main)"
},
{
  "command": "leojs.chapterSelect",
  "category": "Leojs",
  "title": "Chapter Select",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-chapter-select)"
},
</t>
<t tx="felix.20221112230919.1">"editor/title": [
  {
    "command": "leojs.prev",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.next",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leojs.executeScript",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leojs.extract",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leojs.extractNames",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.importAnyFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.chapterSelect",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@7"
  },
  {
    "command": "leojs.writeDirtyAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leojs.refreshFromDiskSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leojs.showSettingsPage",
    "when": "resourceScheme == leojs",
    "group": "1_leojs@1"
  },
  {
    "command": "leojs.showLogPane",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs@2"
  },
  {
    "command": "leojs.newLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs1@1"
  },
  {
    "command": "leojs.openLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs1@2"
  },
  {
    "command": "leojs.saveLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs1@3"
  },
  {
    "command": "leojs.saveAsLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs1@4"
  },
  {
    "command": "leojs.sortChildrenSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@1"
  },
  {
    "command": "leojs.sortSiblingsSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@2"
  },
  {
    "command": "leojs.promoteSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@3"
  },
  {
    "command": "leojs.demoteSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@4"
  },
  {
    "command": "leojs.cloneNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@1"
  },
  {
    "command": "leojs.cutNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@2"
  },
  {
    "command": "leojs.copyNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@3"
  },
  {
    "command": "leojs.pasteNodeAtSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@4"
  },
  {
    "command": "leojs.pasteNodeAsCloneAtSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@5"
  },
  {
    "command": "leojs.readFileIntoNode",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@2"
  },
  {
    "command": "leojs.writeFileFromNode",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@3"
  },
  {
    "command": "leojs.writeAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@4"
  },
  {
    "command": "leojs.writeDirtyAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@5"
  },
  {
    "command": "leojs.cloneFindAll",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@1"
  },
  {
    "command": "leojs.cloneFindAllFlattened",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@2"
  },
  {
    "command": "leojs.cloneFindMarked",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@3"
  },
  {
    "command": "leojs.cloneFindFlattenedMarked",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@4"
  },
  {
    "command": "leojs.cloneFindParents",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@5"
  },
  {
    "command": "leojs.cloneFindTag",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@6"
  }
],
</t>
<t tx="felix.20221113002623.1">public showSettings(): void {
    void this.leoSettingsWebview.openWebview();
}

</t>
<t tx="felix.20221113165005.1">"editor/context": [
  {
    "command": "leojs.findDef",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.extract",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.extractNames",
    "when": "editorHasSelection &amp;&amp; !editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20221113221607.1">/**
 * * Public method exposed as 'refreshGotoPane' setter/getter to refresh the Goto pane
 * Goto Panel May be refreshed by other services (states service, ...)
 */
private _refreshGotoPane(): void {
    this.leoGotoProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20221113232048.1">{
  "command": "leojs.startSearch",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Start Search"
},
{
  "command": "leojs.searchBackward",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Search Backward"
},
{
  "command": "leojs.reSearch",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Regexp Search"
},
{
  "command": "leojs.reSearchBackward",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Regexp Search Backward"
},
{
  "command": "leojs.wordSearch",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Word Search"
},
{
  "command": "leojs.wordSearchBackward",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Word Search Backward"
},
{
  "command": "leojs.findAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find All"
},
{
  "command": "leojs.findNext",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Next"
},
{
  "command": "leojs.findNextFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Next",
  "icon": "$(leojs-find-next)"
},
{
  "command": "leojs.findPrevious",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Previous"
},
{
  "command": "leojs.findPreviousFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Previous",
  "icon": "$(leojs-find-previous)"
},
{
  "command": "leojs.findDef",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find def, class or var assignment"
},
{
  "command": "leojs.replace",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace"
},
{
  "command": "leojs.replaceFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace"
},
{
  "command": "leojs.replaceThenFind",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace Then Find"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace Then Find"
},
{
  "command": "leojs.replaceAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace All"
},
{
  "command": "leojs.gotoGlobalLine",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Global Line"
},
{
  "command": "leojs.setFindEverywhereOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Everywhere",
  "title": "Set Find Everywhere Option"
},
{
  "command": "leojs.setFindNodeOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in Node",
  "title": "Set Find in Node Only Option"
},
{
  "command": "leojs.setFindFileOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in External Files",
  "title": "Set Find in External Files Only Option"
},
{
  "command": "leojs.setFindSuboutlineOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in SubOutline",
  "title": "Set Find in SubOutline Only Option"
},
{
  "command": "leojs.toggleFindIgnoreCaseOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Ignore Case",
  "title": "Toggle Find Ignore Case Option"
},
{
  "command": "leojs.toggleFindMarkChangesOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Mark Changes",
  "title": "Toggle Find Mark Changes Option"
},
{
  "command": "leojs.toggleFindMarkFindsOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Mark Finds",
  "title": "Toggle Find Mark Finds Option"
},
{
  "command": "leojs.toggleFindRegexpOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find RegExp",
  "title": "Toggle Find RegExp Option"
},
{
  "command": "leojs.toggleFindWordOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Whole Word",
  "title": "Toggle Find Whole Word Option"
},
{
  "command": "leojs.toggleFindSearchBodyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Search Body",
  "title": "Toggle Find Search Body Option"
},
{
  "command": "leojs.toggleFindSearchHeadlineOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Search Headline",
  "title": "Toggle Find Search Headline Option"
},
{
  "command": "leojs.cloneFindAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cfa",
  "title": "Clone Find All"
},
{
  "command": "leojs.cloneFindAllFlattened",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cff",
  "title": "Clone Find All Flattened"
},
{
  "command": "leojs.cloneFindMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cfam",
  "title": "cfam - Clone Find All Marked Nodes"
},
{
  "command": "leojs.cloneFindFlattenedMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cffm",
  "title": "cffm - Clone Find Flattened Marked"
},
{
  "command": "leojs.cloneFindParents",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCloned",
  "title": "Clone Find Parents"
},
{
  "command": "leojs.cloneFindTag",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cft",
  "title": "Clone Find Tag"
},
</t>
<t tx="felix.20221113232103.1">{
  "command": "leojs.findQuick",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus on Nav tab"
},
{
  "command": "leojs.goAnywhere",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Go Anywhere"
},
{
  "command": "leojs.gotoNavPrev",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Previous Goto Result"
},
{
  "command": "leojs.gotoNavNext",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Next Goto Result"
},
{
  "command": "leojs.gotoNavFirst",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select First Goto Result"
},
{
  "command": "leojs.gotoNavLast",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Last Goto Result"
},
{
  "command": "leojs.findQuickSelected",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Nav search with current selection",
  "icon": "$(leojs-find-quick-selected)"
},
{
  "command": "leojs.findQuickTimeline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List nodes in reverse gnx order",
  "icon": "$(leojs-find-quick-timeline)"
},
{
  "command": "leojs.findQuickChanged",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List all changed/dirty nodes",
  "icon": "$(leojs-find-quick-changed)"
},
{
  "command": "leojs.history",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List visited nodes from history",
  "icon": "$(leojs-find-quick-history)"
},
{
  "command": "leojs.markedList",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List all marked nodes",
  "icon": "$(leojs-find-quick-marked)"
}
</t>
<t tx="felix.20221113232519.1">{
  "command": "leojs.tagChildren",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "title": "Tag Children"
},
{
  "command": "leojs.tagNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Tag Node"
},
{
  "command": "leojs.removeTag",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Tag"
},
{
  "command": "leojs.removeTags",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove All Tags"
},
</t>
<t tx="felix.20221114213948.1">{
  "command": "leojs.importAnyFile",
  "title": "Import File",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "icon": "$(leojs-import)"
},
{
  "command": "leojs.readFileIntoNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Read File Into Node..."
},
{
  "command": "leojs.exportHeadlines",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Export Outline..."
},
{
  "command": "leojs.flattenOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Flatten Selected Outline..."
},
{
  "command": "leojs.outlineToCweb",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Outline to CWEB..."
},
{
  "command": "leojs.outlineToNoweb",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Outline to Noweb..."
},
{
  "command": "leojs.removeSentinels",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Sentinels..."
},
{
  "command": "leojs.weave",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Weave..."
},
{
  "command": "leojs.writeFileFromNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write File From Node..."
},
</t>
<t tx="felix.20221114220040.1">[CMD.IMPORT_ANY_FILE, () =&gt; p_leoUI.command(LEOCMD.IMPORT_ANY_FILE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.READ_FILE_INTO_NODE, () =&gt; p_leoUI.command(LEOCMD.READ_FILE_INTO_NODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.EXPORT_HEADLINES, () =&gt; p_leoUI.command(LEOCMD.EXPORT_HEADLINES, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.FLATTEN_OUTLINE, () =&gt; p_leoUI.command(LEOCMD.FLATTEN_OUTLINE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.OUTLINE_TO_CWEB, () =&gt; p_leoUI.command(LEOCMD.OUTLINE_TO_CWEB, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.OUTLINE_TO_NOWEB, () =&gt; p_leoUI.command(LEOCMD.OUTLINE_TO_NOWEB, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.REMOVE_SENTINELS, () =&gt; p_leoUI.command(LEOCMD.REMOVE_SENTINELS, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.WEAVE, () =&gt; p_leoUI.command(LEOCMD.WEAVE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.WRITE_FILE_FROM_NODE, () =&gt; p_leoUI.command(LEOCMD.WRITE_FILE_FROM_NODE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

</t>
<t tx="felix.20221115214948.1">{
  "command": "leojs.goAnywhere",
  "key": "ctrl+p",
  "mac": "cmd+p",
  "when": "config.leojs.goAnywhereShortcut &amp;&amp; leojsEditHeadline || config.leojs.goAnywhereShortcut &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/ || config.leojs.goAnywhereShortcut &amp;&amp; leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.findQuickSelected",
  "key": "ctrl+shift+f",
  "mac": "cmd+shift+f",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.findNextFromOutline",
  "key": "f3",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.findNext",
  "key": "f3",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.findPreviousFromOutline",
  "key": "f2",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.findPrevious",
  "key": "f2",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replace",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replaceFromOutline",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.replaceThenFind",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.gotoGlobalLine",
  "key": "alt+g",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindFileOnlyOption",
  "key": "ctrl+alt+l",
  "mac": "cmd+alt+l",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20221115220743.1">{
  "command": "leojs.findNextFromOutline",
  "when": "false"
},
{
  "command": "leojs.findPreviousFromOutline",
  "when": "false"
},
{
  "command": "leojs.replaceFromOutline",
  "when": "false"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20221115230034.1">/**
 * * VSCode Wrapper for showInputBox, or, for showQuickPick if tabList is given.
 */
public get1Arg(
    options?: vscode.InputBoxOptions | vscode.QuickPickOptions,
    token?: vscode.CancellationToken,
    tabList?: string[]
): Thenable&lt;string | undefined&gt; {
    if (tabList) {
        const itemList: vscode.QuickPickItem[] = tabList.map(
            (entry) =&gt; { return { label: entry }; }
        );
        return vscode.window.showQuickPick(itemList, options).then(
            (p_picked) =&gt; {
                if (p_picked &amp;&amp; p_picked.label) {
                    return p_picked.label;
                }
                return undefined;
            }
        );
    } else {
        return vscode.window.showInputBox(options, token);
    }
}

</t>
<t tx="felix.20221119204248.1"></t>
<t tx="felix.20221130233817.1">/**
 * * Adds entries in _openedBodiesGnx and _openedBodiesInfo if needed
 * * and sets the modified time of an opened body.
 */
private _setOpenedBodyTime(p_gnx: string): void {
    const w_now = new Date().getTime();
    let w_created = w_now;
    if (this._openedBodiesInfo[p_gnx]) {
        w_created = this._openedBodiesInfo[p_gnx].ctime; // Already created?
    }
    this._openedBodiesInfo[p_gnx] = {
        ctime: w_created,
        mtime: w_now // new 'modified' time.
    };
}

</t>
<t tx="felix.20221206201231.1">/**
 * Mimic vscode's CTRL+P to find any position by it's headline
 */
public async goAnywhere(): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    const q_allPositions = new Promise&lt;{ label: string; description?: string; position?: Position; }[]&gt;((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            const allPositions: { label: string; description?: string; position?: Position; }[] = [];
            // Options for date to look like : Saturday, September 17, 2016
            const w_dateOptions: Intl.DateTimeFormatOptions = { weekday: "long", year: 'numeric', month: "long", day: 'numeric' };
            const c = g.app.windowList[this.frameIndex].c;

            // 'true' parameter because each position is kept individually for the time the QuickPick control is opened
            for (const p_position of c.all_unique_positions(true)) {

                let w_description = p_position.gnx; // Defaults as gnx.
                const w_gnxParts = w_description.split('.');
                const dateString = w_gnxParts[1] ? w_gnxParts[1] : "";

                if (dateString &amp;&amp; w_gnxParts.length === 3 &amp;&amp; dateString.length === 14 &amp;&amp; /^\d+$/.test(dateString)) {
                    // legit 3 part numeric gnx, so build a string date
                    const w_year = +dateString.substring(0, 4); // unary + operator to convert the strings to numbers.
                    const w_month = +dateString.substring(4, 6);
                    const w_day = +dateString.substring(6, 8);
                    const w_date = new Date(w_year, w_month - 1, w_day);
                    w_description = `by ${w_gnxParts[0]} on ${w_date.toLocaleDateString("en-US", w_dateOptions)}`;
                }
                allPositions.push({
                    label: p_position.h,
                    position: p_position,
                    description: w_description
                });
            }
            resolve(allPositions);
        }, 0);
    });

    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.SEARCH_POSITION_BY_HEADLINE
    };

    const p_picked = await vscode.window.showQuickPick(q_allPositions, w_options);
    const c = g.app.windowList[this.frameIndex].c;

    if (p_picked &amp;&amp; p_picked.label &amp;&amp; p_picked.position) {
        if (c.positionExists(p_picked.position)) {
            c.selectPosition(p_picked.position);  // set this node as selection
        }
        this.setupRefresh(
            Focus.Body, // Finish in body pane given explicitly because last focus was in input box.
            {
                tree: true,
                body: true,
                // documents: false,
                // buttons: false,
                states: true,
            }
        );
        void this.launchRefresh();
    }

    return Promise.resolve(undefined); // Canceled

}

</t>
<t tx="felix.20221207231723.1">{
  "command": "workbench.files.action.collapseExplorerFolders",
  "key": "alt+-",
  "when": "config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == untitled || config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == file || config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; explorerViewletFocus"
},
{
  "command": "workbench.view.extension.leojsView",
  "key": "ctrl+shift+l",
  "when": "config.leojs.activityViewShortcut &amp;&amp; !editorHasSelection &amp;&amp; !inSearchEditor &amp;&amp; focusedView != workbench.view.search"
}
</t>
<t tx="felix.20221213210705.1">{
  "command": "leojs.revertToUndo",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsUndoNode/",
  "group": "leojsUndosContext1@1"
}
</t>
<t tx="felix.20221214003903.1">/**
 * * Looks for given position's coloring language, taking account of '@killcolor', etc.
 */
private _getBodyLanguage(p: Position): string {
    const c = p.v.context;
    let w_language = "plain";
    const w_wrap = !!g.scanAllAtWrapDirectives(c, p);
    if (g.useSyntaxColoring(p)) {

        // DEPRECATED leojs old colorizer language detection--------
        // const aList = g.get_directives_dict_list(p);
        // const d = g.scanAtCommentAndAtLanguageDirectives(aList);
        // w_language =
        //     (d &amp;&amp; d['language'])
        //     || g.getLanguageFromAncestorAtFileNode(p)
        //     || c.config.getLanguage('target-language')
        //     || 'plain';
        // ---------------------------------------------------------

        // * as per original Leo's leoColorizer.py
        w_language = g.getLanguageFromAncestorAtFileNode(p) || c.config.getLanguage('target-language');
        w_language = w_language.toLowerCase();
    }
    // Replace language string if in 'exceptions' array
    w_language = Constants.LEO_LANGUAGE_PREFIX +
        (Constants.LANGUAGE_CODES[w_language] || w_language) +
        (w_wrap ? Constants.LEO_WRAP_SUFFIX : "");
    return w_language;
}

</t>
<t tx="felix.20221222003636.1">/**
 * * Clears the nav search results of the goto pane
 */
public navTextClear(): void {

    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;

    scon.clear();

    this.leoGotoProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20221227223718.1">private _get_focus(): string {
    const c = g.app.windowList[this.frameIndex].c;
    const w = g.app.gui.get_focus(c);
    const focus = g.app.gui.widget_name(w);
    return focus;
}

</t>
<t tx="felix.20230109233134.1">/**
 * Put focus in body widget.
 */
public focus_to_body(c: Commands, p: Position): void {
    // TODO : see show_find_success !
    // TODO : USE ONLY 'WRAPPER' OR 'WIDGET' like in show_find_success!
    this.set_focus(c, c.frame.body.wrapper);
}
</t>
<t tx="felix.20230109233154.1">/**
 * Put focus in tree widget.
 */
public focus_to_head(c: Commands, p: Position): void {
    this.set_focus(c, c.frame.tree.treeWidget);
}
</t>
<t tx="felix.20230112203533.1">/**
 * Utility to convert a string index into a line, col dict
 */
private _row_col_pv_dict(i: number, s: string): { line: number, col: number, index: number } {
    if (!i) {
        i = 0; // prevent none type
    }
    // BUG: this uses current selection wrapper only, use
    // g.convertPythonIndexToRowCol instead !
    let line: number;
    let col: number;
    [line, col] = g.convertPythonIndexToRowCol(s, i);
    return { "line": line, "col": col, "index": i };
};

</t>
<t tx="felix.20230112220003.1">/**
 * Converts from wrapper text index to line /col
 */
private _row_col_wrapper_dict(i: number, wrapper: StringTextWrapper): { "line": number, "col": number, "index": number } {
    if (!i) {
        i = 0; // prevent none type
    }
    let line, col;
    [line, col] = wrapper.toPythonIndexRowCol(i);
    return { "line": line, "col": col, "index": i };
}

</t>
<t tx="felix.20230121211548.1">/**
 * Interactive Search to implement search-backward, re-search, word-search. etc.
 */
public async interactiveSearch(p_backward: boolean, p_regex: boolean, p_word: boolean): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);

    if (p_regex &amp;&amp; p_word) {
        console.error('interactiveSearch called with both "WORD" and "REGEX"');
        return;
    }

    let w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_TITLE;
    let w_searchPrompt = Constants.USER_MESSAGES.INT_SEARCH_PROMPT;
    let w_searchPlaceholder = Constants.USER_MESSAGES.SEARCH_PLACEHOLDER;

    const c = g.app.windowList[this.frameIndex].c;
    const fc = c.findCommands;
    const ftm = fc.ftm;

    if (p_backward) {
        w_searchTitle += Constants.USER_MESSAGES.INT_SEARCH_BACKWARD;
        // Set flag for show_find_options.
        fc.reverse = true;
        // Set flag for do_find_next().
        fc.request_reverse = true;
    }
    if (p_regex) {
        w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_REGEXP + w_searchTitle;
        // Set flag for show_find_options.
        fc.pattern_match = true;
        // Set flag for do_find_next().
        fc.request_pattern_match = true;
    }
    if (p_word) {
        w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_WORD + w_searchTitle;
        // Set flag for show_find_options.
        fc.whole_word = true;
        // Set flag for do_find_next().
        fc.request_whole_word = true;
    }

    fc.show_find_options(); // ! PRINT THEM BUT DONT CHANGE IN FTM/FIND PANEL

    const disposables: vscode.Disposable[] = [];

    // Get value from find panel input
    const w_startValue = this._lastSettingsUsed!.findText === Constants.USER_MESSAGES.FIND_PATTERN_HERE ? '' : this._lastSettingsUsed!.findText;

    try {
        return await new Promise&lt;unknown&gt;((resolve, reject) =&gt; {
            const input = vscode.window.createInputBox();
            input.title = w_searchTitle;
            input.value = w_startValue;
            input.prompt = w_searchPrompt;
            input.placeholder = w_searchPlaceholder;

            this._interactiveSearchOptions = {
                search: "",
                replace: "",
                word: p_word,
                regex: p_regex,
                backward: p_backward
            };

            disposables.push(
                input.onDidAccept(() =&gt; {
                    // utils.setContext(Constants.CONTEXT_FLAGS.INTERACTIVE_SEARCH, false);
                    if (!input.value) {
                        input.hide();
                        return resolve(true); // Cancelled with escape or empty string.
                    }
                    const value = input.value; // maybe this was replace.
                    this._interactiveSearchOptions.search = value;

                    const find_pattern = this._interactiveSearchOptions.search;
                    const change_pattern = this._interactiveSearchOptions.replace;

                    ftm.set_find_text(find_pattern);
                    fc.update_find_list(find_pattern);

                    this.loadSearchSettings(); // * Set vscode's find panel from the Leo find settings
                    fc.init_vim_search(find_pattern);
                    fc.init_in_headline();  // Required.
                    const settings = fc.ftm.get_settings();

                    let p, pos, newpos;
                    [p, pos, newpos] = fc.do_find_next(settings);
                    let w, focus;
                    let found;
                    w = this.get_focus(c); // get focus again after the operation
                    focus = this.widget_name(w);
                    found = p &amp;&amp; p.__bool__();

                    this.findFocusTree = false; // Reset flag for headline range

                    if (!found || !focus) {
                        void vscode.window.showInformationMessage('Not found');
                        return resolve(true);
                    } else {
                        let w_finalFocus = Focus.Body;
                        const w_focus = focus.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_finalFocus = Focus.Outline;
                            this.showOutlineIfClosed = true;
                            // * SETUP HEADLINE RANGE
                            this.findFocusTree = true;
                            this.findHeadlineRange = [w.sel[0], w.sel[1]];
                            this.findHeadlinePosition = c.p;
                        } else {
                            this.showBodyIfClosed = true;
                        }
                        const w_scroll = (found &amp;&amp; w_finalFocus === Focus.Body) || undefined;

                        this.setupRefresh(
                            w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
                            {
                                tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
                                body: true,
                                scroll: w_scroll,
                                // documents: false,
                                // buttons: false,
                                states: true,
                            },
                            this.findFocusTree
                        );
                        void this.launchRefresh();
                        return resolve(true);
                    }

                }),
                input.onDidHide(() =&gt; {
                    // utils.setContext(Constants.CONTEXT_FLAGS.INTERACTIVE_SEARCH, false);
                    return resolve(true);
                })
            );
            if (this._interactiveSearchInputBox) {
                this._interactiveSearchInputBox.dispose(); // just in case.
            }
            this._interactiveSearchInputBox = input;
            this._interactiveSearchInputBox.show();
        });
    } finally {
        disposables.forEach(d =&gt; d.dispose());
        this._interactiveSearchInputBox?.hide();
    }

}

</t>
<t tx="felix.20230121212426.1">[CMD.PREV_NODE, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PREV_NODE_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.NEXT_NODE, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.NEXT_NODE_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
</t>
<t tx="felix.20230121212438.1">[CMD.FIND_QUICK, () =&gt; p_leoUI.findQuick()],
[CMD.FIND_QUICK_SELECTED, () =&gt; p_leoUI.findQuickSelected()],
[CMD.FIND_QUICK_TIMELINE, () =&gt; p_leoUI.findQuickTimeline()],
[CMD.FIND_QUICK_CHANGED, () =&gt; p_leoUI.findQuickChanged()],
[CMD.FIND_QUICK_HISTORY, () =&gt; p_leoUI.findQuickHistory()],
[CMD.FIND_QUICK_MARKED, () =&gt; p_leoUI.findQuickMarked()],
[CMD.FIND_QUICK_GO_ANYWHERE, () =&gt; p_leoUI.goAnywhere()],

[CMD.GOTO_NAV_PREV, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.prev)],
[CMD.GOTO_NAV_NEXT, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.next)],
[CMD.GOTO_NAV_FIRST, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.first)],
[CMD.GOTO_NAV_LAST, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.last)],

[CMD.GOTO_NAV_ENTRY, (p_node: LeoGotoNode) =&gt; p_leoUI.gotoNavEntry(p_node)],

[CMD.START_SEARCH, () =&gt; p_leoUI.command(LEOCMD.START_SEARCH, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.SEARCH_BACKWARD, () =&gt; p_leoUI.command(LEOCMD.SEARCH_BACKWARD, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.RE_SEARCH, () =&gt; p_leoUI.command(LEOCMD.RE_SEARCH, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.RE_SEARCH_BACKWARD, () =&gt; p_leoUI.command(LEOCMD.RE_SEARCH_BACKWARD, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.WORD_SEARCH, () =&gt; p_leoUI.command(LEOCMD.WORD_SEARCH, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.WORD_SEARCH_BACKWARD, () =&gt; p_leoUI.command(LEOCMD.WORD_SEARCH_BACKWARD, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

[CMD.FIND_ALL, () =&gt; p_leoUI.command(LEOCMD.FIND_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.REPLACE_ALL, () =&gt; p_leoUI.command(LEOCMD.REPLACE_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.FIND_NEXT, () =&gt; p_leoUI.find(false, false)],
[CMD.FIND_NEXT_FO, () =&gt; p_leoUI.find(true, false)],
[CMD.FIND_PREVIOUS, () =&gt; p_leoUI.find(false, true)],
[CMD.FIND_PREVIOUS_FO, () =&gt; p_leoUI.find(true, true)],

[CMD.FIND_DEF, () =&gt; p_leoUI.command(LEOCMD.FIND_DEF, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.REPLACE, () =&gt; p_leoUI.replace(false, false)],
[CMD.REPLACE_FO, () =&gt; p_leoUI.replace(true, false)],
[CMD.REPLACE_THEN_FIND, () =&gt; p_leoUI.replace(false, true)],
[CMD.REPLACE_THEN_FIND_FO, () =&gt; p_leoUI.replace(true, true)],

[CMD.GOTO_GLOBAL_LINE, () =&gt; p_leoUI.command(LEOCMD.GOTO_GLOBAL_LINE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

[CMD.TAG_CHILDREN, (p_node?: Position) =&gt; p_leoUI.command(LEOCMD.TAG_CHILDREN, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.NoChange, keepSelection: true })],
[CMD.TAG_NODE, (p_node?: Position) =&gt; p_leoUI.command(LEOCMD.TAG_NODE, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.NoChange, keepSelection: true })],
[CMD.REMOVE_TAG, (p_node?: Position) =&gt; p_leoUI.command(LEOCMD.REMOVE_TAG, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.NoChange, keepSelection: true })],
[CMD.REMOVE_TAGS, (p_node?: Position) =&gt; p_leoUI.command(LEOCMD.REMOVE_ALL_TAGS, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.NoChange, keepSelection: true })],

</t>
<t tx="felix.20230222212520.1">/**
 * Add to the minibuffer history (without duplicating entries)
 */
private _addToMinibufferHistory(p_command: vscode.QuickPickItem): void {
    const c = g.app.windowList[this.frameIndex].c;
    const w_found = c.commandHistory.indexOf(p_command.label);
    // If found, will be removed (and placed on top)
    if (w_found &gt;= 0) {
        c.commandHistory.splice(w_found, 1);
    }
    // Add to top of minibuffer history
    c.commandHistory.unshift(p_command.label);
}

</t>
<t tx="felix.20230305205014.1">{
  "command": "leojs.tagNode",
  "when": "viewItem =~ /leojsNode/",
  "group": "leojsNodeContext2@2"
},
{
  "command": "leojs.removeTag",
  "when": "viewItem =~ /leojsNodeTags/",
  "group": "leojsNodeContext2@3"
},
{
  "command": "leojs.removeTags",
  "when": "viewItem =~ /leojsNodeTags/",
  "group": "leojsNodeContext2@4"
},
</t>
<t tx="felix.20230315215040.1">export function getNonce(): string {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i &lt; 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

</t>
<t tx="felix.20230330224010.1">@language md
@tabwidth -4
# Sponsors and Backers 🏅

[Support Me via GitHub Sponsors](https://github.com/sponsors/boltex)

## Many thanks to these awesome sponsors and backers

&lt;table&gt;
    &lt;tr&gt;
        &lt;td align="center"&gt;
            &lt;a href="https://github.com/edreamleo"&gt;
                &lt;img src="https://avatars.githubusercontent.com/u/592928?v=4"
                     alt="Edward K. Ream"
                     width="48"
                     height="48"
                &gt;
            &lt;/a&gt;
            &lt;br&gt;
            Edward K. Ream
        &lt;/td&gt;
        &lt;td align="center"&gt;
            &lt;a href="https://github.com/tbpassin"&gt;
                &lt;img src="https://avatars.githubusercontent.com/u/36974235?v=4"
                     alt="Thomas Passin"
                     width="48"
                     height="48"
                &gt;
            &lt;/a&gt;
            &lt;br&gt;
            Thomas Passin
        &lt;/td&gt;
        &lt;td align="center"&gt;
            &lt;a href="https://github.com/kghenderson"&gt;
                &lt;img src="https://avatars.githubusercontent.com/u/3522168?v=4"
                     alt="Kevin Henderson"
                     width="48"
                     height="48"
                &gt;
            &lt;/a&gt;
            &lt;br&gt;
            Kevin Henderson
        &lt;/td&gt;
        &lt;td align="center"&gt;
                &lt;img src="data:image/svg+xml;charset=utf8,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E"
                     alt="Jon Nicoll"
                     width="48"
                     height="48"
                &gt;
            &lt;br&gt;
            Jon Nicoll
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</t>
<t tx="felix.20230403223923.1">/**
 * Currently selected can de-hoist state
 */
private _leoTopHoistChapter: boolean = false;
get leoTopHoistChapter(): boolean {
    return this._leoTopHoistChapter;
}
set leoTopHoistChapter(p_value: boolean) {
    this._leoTopHoistChapter = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_TOP_HOIST_CHAPTER, p_value);
}

</t>
<t tx="felix.20230416212643.1">/**
 * Milliseconds converted into seconds, limiting to two decimals. 
 */
export function getDurationSeconds(p_start: [number, number], p_end?: [number, number]): number {
    return parseFloat((getDurationMs(p_start, p_end) / 1000).toFixed(2));
}
</t>
<t tx="felix.20230505220205.1">// Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

// These plugins now contain the importer code for all kinds of @auto nodes.
// Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language typescript
</t>
<t tx="felix.20230715185802.1"></t>
<t tx="felix.20230715185809.1"></t>
<t tx="felix.20230820145332.1">/**
 * * Cycle opened documents
 */
public async tabCycle(): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    let w_chosenIndex;
    const w_files = g.app.windowList;

    if (w_files &amp;&amp; w_files.length &amp;&amp; w_files.length &gt; 1) {
        if (this.frameIndex === w_files.length - 1) {
            w_chosenIndex = 0;
        } else {
            w_chosenIndex = this.frameIndex + 1;
        }
    } else {
        // "Only one, or no opened documents"
        return undefined;
    }

    this.finalFocus = Focus.Outline;
    return this.selectOpenedLeoDocument(w_chosenIndex);
}

</t>
<t tx="felix.20230905212324.1">public static MINIBUFFER_QUICK_PICK: vscode.QuickPickItem = {
    label: Constants.USER_MESSAGES.MINIBUFFER_HISTORY_LABEL,
    description: Constants.USER_MESSAGES.MINIBUFFER_HISTORY_DESC,
    iconPath: new vscode.ThemeIcon("history")
};
</t>
<t tx="felix.20230914004301.1">// Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

// These plugins contain the write code for all kinds of special @auto nodes.
// Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language typescript
</t>
<t tx="felix.20231029213146.1">/**
 * Show a headline input box that resolves to undefined only with escape.
 * Other Leo commands interrupt by accepting the value entered so far.
 */
private _showHeadlineInputBox(p_options: vscode.InputBoxOptions): Promise&lt;string | undefined&gt; {

    const hib = vscode.window.createInputBox();
    this._hibLastValue = undefined; // Prepare for 'cancel' as default.
    const q_headlineInputBox = new Promise&lt;string | undefined&gt;((p_resolve, p_reject) =&gt; {

        hib.ignoreFocusOut = !!p_options.ignoreFocusOut;
        hib.value = p_options.value!;
        hib.valueSelection = p_options.valueSelection;
        hib.prompt = p_options.prompt;
        this._hibDisposables.push(hib.onDidAccept(() =&gt; {
            if (this._hib) {
                this._hib.enabled = false;
                this._hibLastValue = this._hib.value;
                this._hib.hide();
            }
        }, this));
        if (this._hibResolve) {
            console.error('IN _showHeadlineInputBox AND THE _hibResolve PROMISE ALREADY EXISTS!');
        }
        this._hibResolve = p_resolve;
        // onDidHide handles CANCEL AND ACCEPT AND INTERCEPT !
        this._hibDisposables.push(hib.onDidHide(() =&gt; {
            let changed = false;
            const c = g.app.windowList[this.frameIndex].c;
            if (this._hib) {
                changed = this._hib.value !== p_options.value;
                if (g.doHook("headkey1", { c: c, p: c.p, changed: changed })) {
                    // The hook claims to have handled the event, so 'cancel'.
                    this._hibLastValue = undefined;
                } else {
                    // ok
                    this._hibLastValue = this._hib.value; // * FORCE VALUE EVEN WHEN CANCELLING LIKE IN ORIGINAL LEO !
                }
            }
            this.leoStates.leoEditHeadline = false;
            if (this._hibResolve) {
                // RESOLVE whatever value was set otherwise undefined will mean 'canceled'.
                this._hibResolve(this._hibLastValue);
                g.doHook("headkey2", { c: c, p: c.p, changed: changed });
                // Dispose of everything disposable with the edit headline process.
                for (const disp of this._hibDisposables) {
                    disp.dispose();
                }
                // Empty related global variables.
                this._hibDisposables = [];
                this._hibResolve = undefined;
                this._hib = undefined;
            } else {
                console.log('ERROR ON onDidHide NO _hibResolve !');
            }
        }, this));
        this._hibDisposables.push(hib);
        // setup finished, set command context and show it! 
        this._hib = hib;
        this.leoStates.leoEditHeadline = true;
        this._hib.show();
    });
    return q_headlineInputBox;
}

</t>
<t tx="felix.20231030200350.1">private _leoEditHeadline: boolean = false;
get leoEditHeadline(): boolean {
    return this._leoEditHeadline;
}
set leoEditHeadline(p_value: boolean) {
    this._leoEditHeadline = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_EDIT_HEADLINE, p_value);
}

</t>
<t tx="felix.20231120232158.1">public destroySelf(): void {
    // pass // Nothing more needs to be done once all windows have been destroyed.
}

</t>
<t tx="felix.20231127195758.1">public setConfirmBeforeClose(p_state: boolean): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("window")
        .update("confirmBeforeClose", p_state ? "always" : this._confirmOffValue, true);
}

</t>
<t tx="felix.20231127210614.1">public checkConfirmBeforeClose(): void {
    let hasDirty = false;
    for (const frame of g.app.windowList) {
        if (frame.c.changed) {
            hasDirty = true;
        }
    }
    void this.config.setConfirmBeforeClose(hasDirty);
}

</t>
<t tx="felix.20231216165857.1">## 0.2.0 

- First alpha release

</t>
<t tx="felix.20231216165946.1">## 0.2.1

- Fixed importer and @auto related bugs.

</t>
<t tx="felix.20231216170008.1">## 0.2.2

- Fixed more importer and @auto related bugs.
- Added 'Recent Files' icons and buttons.

</t>
<t tx="felix.20231216170011.1">## 0.2.3

- Reset Confirm-Before-Close setting upon starting up.
- Fixed section-reference read-write operation.
- Fixed output messages strings.
- Closing the last Leo document before closing vscode will remove it from the session.
- Fixed labeling of body pane tab.

</t>
<t tx="felix.20231216170017.1">## 0.2.4

- Fixed 'ConfirmBeforeClose' for mobile to prevent closing on keyboard commands.
- Fixed goto-next-clone and goto-next-marked refresh cycles.

</t>
<t tx="felix.20231216233654.1">## 0.2.7

- Fixed tooltips of the 'nav' input box in the find panel.
- Fixed 'Language coloring not supported yet for this language' message.
- Fixed 'object member adressing' d.get() bugs.
- Fixed 'ini' and 'java' importers.

</t>
<t tx="felix.20231219233411.1"></t>
<t tx="felix.20231219233427.1">// @ts-check

// This script will be run within the webview itself
// It cannot access the main VS Code APIs directly.
// Send message to LeoJS with vscode.postMessage({ keyNameEx1: someValue, ... });
// Receive messages from LeoJS with window.addEventListener('message', event =&gt; { ... });
(function () {
    // @ts-expect-error
    const vscode = acquireVsCodeApi();

    let timer; // for debouncing sending the settings from this webview to LeoJS
    let dirty = false; // all but nav input
    let navTextDirty = false;

    let activeTab = 'tab2'; // Initial active tab
    let firstFindTabElId = 'findText';
    let lastFindTabElId = 'searchBody';
    let firstNavTabElId = 'searchOptions';
    let lastNavTabElId = 'navText';
    let lastGotoContent = [];
    let lastSelectedGotoItem;

    /**
     * * Flag for freezing the nav 'search as you type' headlines (concept from original nav plugin)
     * - Resets when switching to tag, or when clearing the input field.
     * - Sets when pressing Enter with non-empty input field &amp;&amp; not tag mode.
     */
    let frozen = false;
    let w_freezeElement = document.getElementById("freeze");
    if (w_freezeElement) {
        w_freezeElement.style.display = 'none';
    }
    let navSearchTimer; // for debouncing the search-headline while typing if unfrozen

    // * LeoSearchSettings Type
    let searchSettings = {
        // Nav settings
        navText: '',
        showParents: true,
        isTag: false,
        searchOptions: 0,
        // Find/replace
        findText: '',
        replaceText: '',
        wholeWord: false,
        ignoreCase: true,
        regExp: false,
        markFinds: false,
        markChanges: false,
        searchHeadline: true,
        searchBody: true,
        searchScope: 0, // 0 is entire outline (1: sub-outline, 2: node only)
    };

    // * Search related controls (No nav inputs)
    let findReplaceInputIds = ['findText', 'replaceText'];
    let checkboxIds = [
        'wholeWord',
        'ignoreCase',
        'regExp',
        'markFinds',
        'markChanges',
        'searchHeadline',
        'searchBody',
    ];
    let radioIds = ['entireOutline', 'subOutlineOnly', 'nodeOnly', 'fileOnly'];

    function resetTagNav() {
        navSearchTimer = setTimeout(() =&gt; {
            if (navTextDirty) {
                navTextDirty = false;
                if (navSearchTimer) {
                    clearTimeout(navSearchTimer);
                }
                sendSearchConfig();
            }
            vscode.postMessage({ type: 'leoNavTextChange' });
        }, 250); // quarter second
    }

    function navTextChange() {
        // cancel timer, reset 'debounced' timer after checks, if still needed
        if (navSearchTimer) {
            clearTimeout(navSearchTimer);
        }

        // * Needed Checks
        if (searchSettings.navText.length === 0) {
            setFrozen(false);
            // if tagging but empty: SEND SEARCH LIST-ALL-TAGS COMMAND
            if (searchSettings.isTag) {
                resetTagNav();
            }

        }
        if (searchSettings.navText === "m" &amp;&amp; !searchSettings.isTag) {
            // ! Easter Egg: calls 'marked-list', which list all marked nodes !
            navSearchTimer = setTimeout(() =&gt; {
                if (navTextDirty) {
                    navTextDirty = false;
                    if (navSearchTimer) {
                        clearTimeout(navSearchTimer);
                    }
                    sendSearchConfig();
                }
                vscode.postMessage({ type: 'leoNavMarkedList' });

            }, 40); // Shorter delay for this command
            return false;
        }

        // User changed text in nav text input
        if (frozen || searchSettings.navText.length &lt; 3) {
            return; // dont even continue if not long enough or already frozen
        }

        // DEBOUNCE .25 to .5 seconds with navSearchTimer
        navSearchTimer = setTimeout(() =&gt; {
            if (navTextDirty) {
                navTextDirty = false;
                if (navSearchTimer) {
                    clearTimeout(navSearchTimer);
                }
                sendSearchConfig();
            }
            vscode.postMessage({ type: 'leoNavTextChange' });
        }, 400); // almost half second

    }

    const gotoPaneContainer = document.getElementById('gotopane');

    // TODO CHECK IF NEEDED ?
    // document.body.addEventListener('mousedown', () =&gt; {
    //     if (!gotoPaneContainer) {
    //         return;
    //     }
    //     // remove selected class
    //     if (lastSelectedGotoItem) {
    //         lastSelectedGotoItem.classList.remove('selected');
    //         lastSelectedGotoItem = undefined;
    //     }
    // });

    function clickedGotoItem(event) {
        if (!gotoPaneContainer) {
            return;
        }
        // remove selected class first
        if (lastSelectedGotoItem) {
            lastSelectedGotoItem.classList.remove('selected');
        }
        event.target.classList.add('selected');
        lastSelectedGotoItem = event.target;
        event.stopPropagation();
        // CALL GOTO COMMAND!
        vscode.postMessage({ type: 'gotoCommand', value: event.target.dataset.order });
    }

    function fillGotoPane(p_gotoContent) {
        lastGotoContent = p_gotoContent;
        if (!gotoPaneContainer) {
            return;
        }
        let i = 0;
        if (lastSelectedGotoItem) {
            lastSelectedGotoItem.classList.remove('selected');
            lastSelectedGotoItem = undefined;
        }
        while (gotoPaneContainer &amp;&amp; gotoPaneContainer.firstChild) {
            gotoPaneContainer.removeChild(gotoPaneContainer.firstChild);
        }
        let hasParent = false;
        for (const gotoItem of p_gotoContent) {
            const smallerDiv = document.createElement('div');
            smallerDiv.dataset.order = i.toString();
            smallerDiv.className = 'goto-item ' + gotoItem.entryType;
            smallerDiv.textContent = gotoItem.label;
            // smallerDiv.title = gotoItem.tooltip; // TOOLTIPS CANNOT BE STYLED!
            smallerDiv.setAttribute('tabindex', '0');
            if (gotoItem.entryType === 'parent') {
                hasParent = true;
            }
            smallerDiv.addEventListener('mousedown', clickedGotoItem);
            gotoPaneContainer.appendChild(smallerDiv);
            i = i + 1;
        }
        gotoPaneContainer.classList.remove('show-parents');
        if (hasParent) {
            gotoPaneContainer.classList.add('show-parents');
        }
    }

    function setSearchSetting(p_id) {
        if (checkboxIds.includes(p_id)) {
            toggleCheckbox(p_id);
        } else if (radioIds.includes(p_id)) {
            setRadio(p_id);
        }
    }

    function setFrozen(p_focus) {
        frozen = p_focus;
        w_freezeElement = document.getElementById("freeze");
        if (w_freezeElement) {
            if (frozen) {
                w_freezeElement.style.display = '';
            } else {
                w_freezeElement.style.display = 'none';
            }
        }
    }

    function setSettings(p_settings) {
        // Nav controls
        // @ts-expect-error
        document.getElementById("navText").value = p_settings["navText"];
        searchSettings["navText"] = p_settings["navText"];

        // showParents
        // @ts-expect-error
        document.getElementById("showParents").checked = p_settings["showParents"];
        searchSettings["showParents"] = p_settings["showParents"];

        // isTag
        // @ts-expect-error
        document.getElementById("isTag").checked = p_settings["isTag"];
        searchSettings["isTag"] = p_settings["isTag"];
        handleIsTagSwitch(false);

        // searchOptions
        // @ts-expect-error
        document.getElementById("searchOptions").value = p_settings["searchOptions"];
        searchSettings["searchOptions"] = p_settings["searchOptions"];

        // When opening a Leo document, set default values of fields
        findReplaceInputIds.forEach((p_inputId) =&gt; {
            // @ts-expect-error
            document.getElementById(p_inputId).value = p_settings[p_inputId];
            searchSettings[p_inputId] = p_settings[p_inputId];
        });
        checkboxIds.forEach((p_inputId) =&gt; {
            // @ts-expect-error
            document.getElementById(p_inputId).checked = p_settings[p_inputId];
            searchSettings[p_inputId] = p_settings[p_inputId];
        });
        // @ts-expect-error
        document.getElementById(radioIds[p_settings['searchScope']]).checked = true;
        searchSettings.searchScope = p_settings['searchScope'];
    }

    function sendSearchConfig() {
        dirty = false; // clear dirty flag
        vscode.postMessage({ type: 'searchConfig', value: searchSettings });
    }

    function processChange() {
        clearTimeout(timer);
        dirty = true;
        timer = setTimeout(() =&gt; {
            sendSearchConfig();
        }, 300);
    }

    function toggleCheckbox(p_inputId) {
        let w_checkbox = document.getElementById(p_inputId);
        let w_setTo = true;
        // @ts-expect-error
        if (w_checkbox.checked) {
            w_setTo = false;
        }
        // @ts-expect-error
        w_checkbox.checked = w_setTo;
        searchSettings[p_inputId] = w_setTo;
        if (timer) {
            clearTimeout(timer);
        }
        sendSearchConfig();
    }

    function setRadio(p_inputId) {
        // @ts-expect-error
        document.getElementById(p_inputId).checked = true;
        searchSettings['searchScope'] = parseInt(
            // @ts-expect-error
            document.querySelector('input[name="searchScope"]:checked').value
        );
        if (timer) {
            clearTimeout(timer);
        }
        sendSearchConfig();
    }

    function checkKeyDown(p_event) {
        if (!p_event) {
            p_event = window.event;
        }
        const keyCode = p_event.code || p_event.key;

        // Detect CTRL+F
        if (p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 70) {
            p_event.preventDefault();
            p_event.stopPropagation();
            // focusOnField('findText');
            activateTab('tab2');

            return;
        }
        // Detect CTRL+SHIFT+F
        if (p_event.ctrlKey &amp;&amp; p_event.shiftKey &amp;&amp; p_event.keyCode === 70) {
            p_event.preventDefault();
            p_event.stopPropagation();
            // focusOnField('navText');
            activateTab('tab3');

            return;
        }

        // ? NEEDED ?
        /*
        // Detect F2
        if (!p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 113) {
            p_event.preventDefault();
            p_event.stopPropagation();
            vscode.postMessage({ type: 'leoFindPrevious' });
            return;
        }
        // Detect F3
        if (!p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 114) {
            p_event.preventDefault();
            p_event.stopPropagation();
            vscode.postMessage({ type: 'leoFindNext' });
            return;
        }
        // Detect Ctrl + =
        if (p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 187) {
            p_event.preventDefault();
            p_event.stopPropagation();
            vscode.postMessage({ type: 'replace' });
            return;
        }
        // Detect Ctrl + -
        if (p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 189) {
            p_event.preventDefault();
            p_event.stopPropagation();
            vscode.postMessage({ type: 'replaceThenFind' });
            return;
        }
        */

        const actEl = document.activeElement;
        if (keyCode === 'Tab') {
            let lastEl;
            let firstEl;
            let selectedNavEl;
            if (activeTab === 'tab2') {
                // find panel
                lastEl = document.getElementById(lastFindTabElId);
                firstEl = document.getElementById(firstFindTabElId);
            } else if (activeTab === 'tab3' &amp;&amp; !lastGotoContent.length) {
                // nav panel regular
                lastEl = document.getElementById(lastNavTabElId);
                firstEl = document.getElementById(firstNavTabElId);
            } else if (activeTab === 'tab3' &amp;&amp; lastGotoContent.length &amp;&amp; gotoPaneContainer) {
                // nav panel WITH nav results.
                lastEl = document.getElementById(lastNavTabElId);
                firstEl = document.getElementById(firstNavTabElId);
                selectedNavEl = gotoPaneContainer?.children[0]; // default

                if (lastSelectedGotoItem) {
                    selectedNavEl = lastSelectedGotoItem;
                }

                if (actEl?.classList.contains('goto-item')) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    if (p_event.shiftKey) {
                        lastEl = document.getElementById(lastNavTabElId);
                        if (lastEl) {
                            lastEl.focus();
                        }
                    } else {
                        if (firstEl) {
                            firstEl.focus();
                        }
                    }
                    return;
                }

            }

            if (p_event.shiftKey) {
                if (selectedNavEl &amp;&amp; actEl === firstEl) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    if (lastSelectedGotoItem) {
                        lastSelectedGotoItem.classList.remove('selected');
                    }
                    selectedNavEl.focus();
                    selectedNavEl.classList.add('selected');
                    lastSelectedGotoItem = selectedNavEl;
                    return;
                }
                // shift + tab so if first got last
                if (lastEl &amp;&amp; actEl === firstEl) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    lastEl.focus();
                    return;
                }
            } else {
                if (selectedNavEl &amp;&amp; actEl === lastEl) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    if (lastSelectedGotoItem) {
                        lastSelectedGotoItem.classList.remove('selected');
                    }
                    selectedNavEl.focus();
                    selectedNavEl.classList.add('selected');
                    lastSelectedGotoItem = selectedNavEl;
                    return;
                }
                // tab, so if last goto first
                if (firstEl &amp;&amp; actEl === lastEl) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    firstEl.focus();
                    return;
                }
            }
        }

        if (activeTab === 'tab3' &amp;&amp; lastGotoContent.length &amp;&amp; actEl &amp;&amp; gotoPaneContainer &amp;&amp; (actEl === gotoPaneContainer || gotoPaneContainer.contains(actEl))) {
            navKeyHandler(p_event);
        }

    }

    function navKeyHandler(p_event) {
        // Handles up/down home/end pgUp/pgDown
        // for GOTO PANE navigation under the nav input
        // if(gotoPaneContainer){
        //     gotoPaneContainer
        // }
        if (!p_event) {
            p_event = window.event;
        }
        const keyCode = p_event.code || p_event.key;

        let code = -1;
        switch (keyCode) {
            case 'ArrowUp':
                code = 0;
                break;
            case 'ArrowDown':
                code = 1;
                break;
            case 'PageUp':
                code = 2;
                break;
            case 'PageDown':
                code = 3;
                break;
            case 'Home':
                code = 2;
                break;
            case 'End':
                code = 3;
                break;
            case 'Enter':
                const actEl = document.activeElement;
                if (actEl &amp;&amp; actEl.classList.contains('goto-item')) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    if (!gotoPaneContainer) {
                        return;
                    }
                    // remove selected class first
                    if (lastSelectedGotoItem) {
                        lastSelectedGotoItem.classList.remove('selected');
                    }
                    actEl.classList.add('selected');
                    lastSelectedGotoItem = actEl;
                    // CALL GOTO COMMAND!
                    // @ts-expect-error
                    vscode.postMessage({ type: 'gotoCommand', value: actEl.dataset.order });
                    return;
                }
                break;

            default:
                break;
        }
        if (code &gt;= 0) {
            p_event.preventDefault();
            p_event.stopPropagation();
            p_event.stopImmediatePropagation();
            vscode.postMessage({ type: 'navigateNavEntry', value: code });
        }
    }

    function throttle(func, limit) {
        let inThrottle;
        let lastFunc;
        let lastRan;
        return function () {
            const context = this;
            const args = arguments;
            if (!inThrottle) {
                func.apply(context, args);
                lastRan = Date.now();
                inThrottle = true;
                setTimeout(() =&gt; {
                    inThrottle = false;
                    if (lastFunc) {
                        lastFunc.apply(context, args);
                        lastRan = Date.now();
                        lastFunc = null;
                    }
                }, limit);
            } else {
                lastFunc = func;
            }
        }
    }

    // TODO : USE THIS EXAMPLE INSTEAD OF CALLING LEOJS TO SWITCH RIGHT AWAY ! ! 
    // Example usage
    const throttledFunction = throttle(function () {
        console.log('Function called!');
    }, 1000); // The function will be called at most once every 1000ms (1 second)


    function focusOnField(p_id) {
        const inputField = document.querySelector('#' + p_id);
        if (inputField) {
            // @ts-expect-error
            inputField.select();
            // TODO : TEST IF NEEDED TO PREVENT FLICKER ON FIRST TRY?
            setTimeout(() =&gt; {
                // @ts-expect-error
                inputField.select();
            }, 0);
        }
    }

    function getSettings() {
        // clear dirty, clear timer,
        if (dirty) {
            dirty = false;
            clearTimeout(timer);
            sendSearchConfig(); // just trigger send settings
        }
    }

    function handleIsTagSwitch(p_wasSet) {
        let w_input = document.getElementById('navText');
        let w_showParent = document.getElementById('showParents');
        let w_navSelect = document.getElementById('searchOptions');
        if (searchSettings.isTag) {

            if (w_input) {
                // @ts-expect-error
                w_input.placeholder = "&lt;tag pattern here&gt;";
                w_input.title = "Enter a tag name to list tagged nodes in the Goto pane\nClear this field to list all tags used in this file";
            }

            // @ts-expect-error
            w_showParent.disabled = true;
            // @ts-expect-error
            w_navSelect.disabled = true;
            if (p_wasSet) {
                // if nav text is empty: show all tags
                setTimeout(() =&gt; {
                    clearTimeout(timer);
                    sendSearchConfig();
                    navTextChange();
                }, 100);
            }
        } else {
            if (w_input) {
                // @ts-expect-error
                w_input.placeholder = "&lt;nav pattern here&gt;";
                w_input.title = "Typing searches headlines interactively\nEnter freezes input and searches body text";
            }
            // @ts-expect-error
            w_showParent.disabled = false;
            // @ts-expect-error
            w_navSelect.disabled = false;
        }

    }

    // * Nav text input detection
    const w_navTextEl = document.getElementById('navText');
    function navEnter() {
        if (searchSettings.navText.length === 0 &amp;&amp; searchSettings.isTag) {
            setFrozen(false);
            resetTagNav();
        } else {
            if (searchSettings.navText.length &gt;= 3 || searchSettings.isTag) {
                setFrozen(true);
                if (navTextDirty) {
                    navTextDirty = false;
                    if (timer) {
                        clearTimeout(timer);
                    }
                    if (navSearchTimer) {
                        clearTimeout(navSearchTimer);
                    }
                    sendSearchConfig();
                }
                vscode.postMessage({ type: 'leoNavEnter' });
            }
            if (searchSettings.navText.length === 0) {
                vscode.postMessage({ type: 'leoNavClear' });
            }
        }
    }

    if (w_navTextEl) {
        w_navTextEl.onkeypress = function (p_event) {
            if (!p_event) {
                // @ts-expect-error
                p_event = window.event;
            }
            const keyCode = p_event.code || p_event.key;
            if (keyCode === 'Enter') {
                navEnter();
                return false;
            }
        };

        w_navTextEl.addEventListener('input', function (p_event) {
            // @ts-expect-error
            searchSettings.navText = this.value;
            navTextDirty = true;
            navTextChange(); // DEBOUNCE THIS! Don't process change too fast!
        });
    }

    const w_showParentsEl = document.getElementById('showParents');
    if (w_showParentsEl) {
        w_showParentsEl.addEventListener('change', function (p_event) {
            // @ts-expect-error
            searchSettings.showParents = this.checked;
            processChange();
        });
    }

    const w_isTagEl = document.getElementById('isTag');
    if (w_isTagEl) {
        w_isTagEl.addEventListener('change', function (p_event) {
            // @ts-expect-error
            let w_checked = this.checked;
            let w_wasSet = false;
            if (searchSettings.isTag !== w_checked) {
                setFrozen(false); // Switched tagging so reset freeze
                if (w_checked) {
                    w_wasSet = true;
                }
            }
            searchSettings.isTag = w_checked;
            // Set placeholder text
            processChange();
            handleIsTagSwitch(w_wasSet);
        });
    }

    // * Find &amp; Replace controls change detection
    const w_searchOptionsEl = document.getElementById('searchOptions');
    if (w_searchOptionsEl) {
        w_searchOptionsEl.addEventListener('change', function (p_event) {
            // @ts-expect-error
            searchSettings.searchOptions = Number(this.value);
            processChange();
        });

    }

    findReplaceInputIds.forEach((p_inputId) =&gt; {
        const w_inputEl = document.getElementById(p_inputId);
        if (w_inputEl) {

            w_inputEl.onkeypress = function (p_event) {
                if (!p_event) {
                    // @ts-expect-error
                    p_event = window.event;
                }
                const keyCode = p_event.code || p_event.key;
                if (keyCode === 'Enter') {
                    if (timer) {
                        clearTimeout(timer);
                        sendSearchConfig();
                    }
                    vscode.postMessage({ type: 'leoFindNext' });
                    return false;
                }
            };
            w_inputEl.addEventListener('input', function (p_event) {
                // @ts-expect-error
                searchSettings[p_inputId] = this.value;
                processChange();
            });
        }
    });

    checkboxIds.forEach((p_inputId) =&gt; {
        const w_inputEl = document.getElementById(p_inputId);
        if (w_inputEl) {

            w_inputEl.addEventListener('change', function (p_event) {
                // @ts-expect-error
                searchSettings[p_inputId] = this.checked;
                processChange();
            });
        }
    });

    radioIds.forEach((p_inputId) =&gt; {
        const w_inputEl = document.getElementById(p_inputId);
        if (w_inputEl) {

            w_inputEl.addEventListener('change', function (p_event) {
                searchSettings['searchScope'] = parseInt(
                    // @ts-expect-error
                    document.querySelector('input[name="searchScope"]:checked').value
                );
                processChange();
            });
        }
    });

    document.onkeydown = checkKeyDown;

    const tabs = document.querySelectorAll('.tab-item');
    const contents = document.querySelectorAll('.tab-content');

    function showTab(newTab) {
        // Remove active class from all tabs and contents
        tabs.forEach(t =&gt; t.classList.remove('active'));
        contents.forEach(c =&gt; c.classList.remove('active'));

        // Add active class to the new tab and content
        // @ts-expect-error
        document.querySelector(`[data-tab="${newTab}"]`).classList.add('active');
        // @ts-expect-error
        document.getElementById(newTab).classList.add('active');

        // Update the active tab state
        activeTab = newTab;
    }

    function activateTab(newTab, replace) {
        showTab(newTab);
        setTimeout(() =&gt; {
            if (activeTab === 'tab2') {
                if (replace) {
                    focusOnField('replaceText');
                } else {
                    focusOnField('findText');
                }
            } else if (activeTab === 'tab3') {
                focusOnField('navText');
            }
        }, 0);
    };

    function revealNavEntry(p_index, p_preserveFocus) {
        if (!p_preserveFocus) {
            showTab('tab3');
        }
        if (lastSelectedGotoItem) {
            lastSelectedGotoItem.classList.remove('selected');
            lastSelectedGotoItem = undefined;
        }
        setTimeout(() =&gt; {
            if (!gotoPaneContainer) {
                return;
            }
            const children = gotoPaneContainer.children;
            if (children &amp;&amp; children.length &amp;&amp; children.length &gt; p_index) {
                lastSelectedGotoItem = gotoPaneContainer.children[p_index];
                lastSelectedGotoItem.classList.add('selected');
                // Will have effect only if visible
                lastSelectedGotoItem.scrollIntoView({ behavior: "instant", block: "nearest" });
                // @ts-expect-error
                if (lastSelectedGotoItem &amp;&amp; lastSelectedGotoItem.focus &amp;&amp; !p_preserveFocus) {
                    // @ts-expect-error
                    lastSelectedGotoItem.focus();
                }
            }
        }, 0);
    }

    tabs.forEach(tab =&gt; {
        tab.addEventListener('mousedown', (event) =&gt; {
            // @ts-expect-error
            const newTab = tab.dataset.tab;
            if (newTab !== activeTab) {
                activateTab(newTab);
                event.preventDefault();
                event.stopPropagation();
            }
        });
    });

    document.addEventListener('focusin', (event) =&gt; {
        vscode.postMessage({ type: 'gotFocus' });
    });

    document.addEventListener('focusout', (event) =&gt; {
        vscode.postMessage({ type: 'lostFocus' });
    });

    const body = document.body;
    const topShadow = document.getElementById("top-shadow");
    let scrolled = false;
    body.addEventListener('scroll', function (event) {
        if (!topShadow) {
            return;
        }
        if (body.scrollTop) {
            if (!scrolled) {
                topShadow.classList.add('scrolled');
                scrolled = true;
            }
        } else {
            if (scrolled) {
                topShadow.classList.remove('scrolled');
                scrolled = false;
            }
        }
    });

    // Handle messages sent from the extension to the webview
    window.addEventListener('message', (event) =&gt; {
        const message = event.data; // The json data that the extension sent
        switch (message.type) {
            // * Nav Tab Controls
            // Focus and select all text in 'nav' field
            case 'selectNav': {
                // focusOnField('navText');
                activateTab('tab3');

                if (message.text) {
                    // @ts-expect-error
                    document.getElementById("navText").value = message.text;
                    searchSettings["navText"] = message.text;
                    if (timer) {
                        clearTimeout(timer);
                    }
                    sendSearchConfig();
                    if (message.forceEnter) {
                        navEnter();
                    }
                }
                break;
            }
            case 'showGoto': {
                showTab('tab3');
                break;
            }
            case 'revealNavEntry': {
                revealNavEntry(message.value, message.preserveFocus);
                break;
            }
            // * Find Tab Controls
            // Focus and select all text in 'find' field
            case 'selectFind': {
                //focusOnField('findText');
                activateTab('tab2');
                break;
            }
            // Focus and select all text in 'replace' field
            case 'selectReplace': {
                //focusOnField('replaceText');
                activateTab('tab2', true);
                break;
            }
            case 'getSettings': {
                getSettings();
                break;
            }
            case 'setSettings': {
                setSettings(message.value);
                break;
            }
            case 'setSearchSetting': {
                setSearchSetting(message.id);
                break;
            }
            case 'refreshGoto': {
                fillGotoPane(message.gotoContent);
                break;
            }
        }
    });

    vscode.postMessage({ type: 'refreshSearchConfig' });
})();
</t>
<t tx="felix.20231219233431.1">html {
    box-sizing: border-box;
    font-size: 13px;
    overflow: hidden;
    --input-padding-vertical: 6px;
    --input-padding-horizontal: 4px;
    --input-margin-vertical: 4px;
    --input-margin-horizontal: 0;
    height: 100%;
}

@supports selector(::-webkit-scrollbar) {
    html {
        scrollbar-color: unset;
    }
}

*,
*:before,
*:after {
    box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
    margin: 0;
    padding: 0;
    font-weight: normal;
}

img {
    max-width: 100%;
    height: auto;
}

html:focus:after {
    content: '';
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    outline: 1px solid;
    outline-width: 1px;
    outline-style: solid;
    outline-offset: -1px;
    outline-color: var(--vscode-focusBorder);
    pointer-events: none;
}

body {
    height: 100%;
    /* margin-left: 20px; */
    background-color: transparent;
    /* padding: 0 var(--container-padding); */
    /* scrollbar-gutter: stable; */
    overflow: hidden;
    /* padding-right: 4px; */
    color: var(--vscode-foreground);
    font-size: var(--vscode-font-size);
    font-weight: var(--vscode-font-weight);
    font-family: var(--vscode-font-family);
}

/* body:hover {
    overflow-y: auto;
} */

.row .col:nth-child(2) {
    padding-right: 4px;
}

ol,
ul {
    padding-left: var(--container-padding);
}

/* body &gt; *,
form &gt; * {
    margin-block-start: var(--input-margin-vertical);
    margin-block-end: var(--input-margin-vertical);
} */

*:focus {
    outline-color: var(--vscode-focusBorder);
}

a {
    color: var(--vscode-textLink-foreground);
}

a:hover,
a:active {
    color: var(--vscode-textLink-activeForeground);
}

code {
    font-size: var(--vscode-editor-font-size);
    font-family: var(--vscode-editor-font-family);
}

button {
    border: none;
    padding: var(--input-padding-vertical) var(--input-padding-horizontal);
    width: 100%;
    text-align: center;
    outline: 1px solid transparent;
    outline-offset: 2px !important;
    color: var(--vscode-button-foreground);
    background: var(--vscode-button-background);
}

button:hover {
    cursor: pointer;
    background: var(--vscode-button-hoverBackground);
}

button:focus {
    outline-color: var(--vscode-focusBorder);
}

button.secondary {
    color: var(--vscode-button-secondaryForeground);
    background: var(--vscode-button-secondaryBackground);
}

button.secondary:hover {
    background: var(--vscode-button-secondaryHoverBackground);
}

select {
    background: var(--vscode-dropdown-background);
    color: var(--vscode-input-foreground);
    border-color: var(--vscode-dropdown-border);
    cursor: pointer;
    /* width: 50px; */
    /* left: 15%; */
    position: relative;
    border-radius: 2px;
}

select:focus {
    outline-color: var(--vscode-input-border);
}

select:disabled {
    opacity: 0.5;
    cursor: default;
}

select option {
    background-color: var(--vscode-dropdown-listBackground);
}

select option:focus {
    background-color: var(--vscode-input-background);
    outline-color: var(--vscode-input-border);
}

input:not([type='radio']):not([type='checkbox']),
textarea {
    display: block;
    margin-right: 20px;
    width: 100%;
    border: none;
    font-family: var(--vscode-font-family);
    padding: var(--input-padding-vertical) var(--input-padding-horizontal);
    padding: 3px var(--input-padding-horizontal);
    border-radius: 2px;
    color: var(--vscode-input-foreground);
    outline-color: var(--vscode-input-border);
    background-color: var(--vscode-input-background);
}

input[type='text'] {
    height: 24px;
}

input[type='checkbox'],
input[type='radio'] {
    cursor: pointer;
}

input[type='checkbox'] {
    vertical-align: text-top;
}

.label-nav {
    vertical-align: baseline;
    line-height: 19px;
}

input[type='checkbox']:focus + label {
    border: 1px solid var(--vscode-button-background);
}

input[type='radio']:focus + label {
    border: 1px solid var(--vscode-button-background);
}

input:disabled {
    opacity: 0.5;
    cursor: default;
}

input::placeholder,
textarea::placeholder {
    color: var(--vscode-input-placeholderForeground);
}

u {
    color: var(--vscode-editor-foreground);
    text-decoration-color: var(--vscode-foreground);
    text-underline-offset: 0.04em;
}

body &gt; div &gt; div &gt; label:focus,
body &gt; div &gt; div &gt; label:active {
    outline-color: none !important;
    border: none !important;
}

#freeze {
    cursor: default;
    position: absolute;
    right: 0.3em;
    line-height: 1em;
    top: 1.555em;
    font-size: 1.8em;
    color: #5c87ff80;
    padding: 0;
    margin: 0;
}

.comment {
    display: none;
}

div.row {
    overflow-x: hidden;
    white-space: nowrap;
}

div.col-full {
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
    width: 100%;
    margin-top: 6px;
    margin-bottom: 3px;
}

div.col {
    vertical-align: top;
    width: 50%;
    max-width: 9.5em;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
}

div.col-nav {
    width: 50%;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
}

.mt-0 {
    margin-top: 0;
}
.mt-1 {
    margin-top: 1px;
}
.mt-2 {
    margin-top: 2px;
}
.mt-3 {
    margin-top: 3px;
}
.mt-4 {
    margin-top: 4px;
}
.mt-5 {
    margin-top: 5px;
}
.mt-6 {
    margin-top: 6px;
}
.mt-7 {
    margin-top: 7px;
}
.mt-8 {
    margin-top: 8px;
}

.mb-0 {
    margin-bottom: 0;
}
.mb-1 {
    margin-bottom: 1px;
}
.mb-2 {
    margin-bottom: 2px;
}
.mb-3 {
    margin-bottom: 3px;
}
.mb-4 {
    margin-bottom: 4px;
}
.mb-5 {
    margin-bottom: 5px;
}
.mb-6 {
    margin-bottom: 6px;
}
.mb-7 {
    margin-bottom: 7px;
}
.mb-8 {
    margin-bottom: 8px;
}

.input-holder {
    padding: 0;
    margin-left: 6px;
    margin-right: 6px;
}

#searchOptions {
    height: 24px;
}

.align-right {
    text-align: right;
}

.float-left {
    float: left;
}

.float-right {
    float: right;
}

.no-overflow {
    text-overflow: unset !important;
}

.label-fix {
    vertical-align: top;
    line-height: 19px;
}

.tab-container {
    position: relative;
    width: 100%;
    display: flex;
    flex-direction: column;
    height: 100%;
}

.tab-list {
    position: relative;
    list-style: none;
    padding: 0;
    padding-top: 4px;
    margin: 0;
    display: flex;
    border-bottom: 1px solid var(--vscode-input-background);
}

.tab-item {
    padding: 3px 14px;
    margin-left: 6px;
    cursor: pointer;
    border-bottom: none;
    color: var(--vscode-disabledForeground);
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.tab-item.active {
    background-color: var(--vscode-input-background);
    color: var(--vscode-foreground);
}

.tab-content {
    flex-grow: 1;
    min-height: 0;
    flex-direction: column;
    position: relative;
    display: none;
    padding: 0;
    margin: 0;
}

.nav-top-section {
    flex-shrink: 0;
}

.tab-content.active {
    display: flex;
}

.bottom-scroll {
    overflow-y: hidden;
    min-height: 0;
    flex-grow: 1;
    padding-bottom: 4px;
}

.bottom-scroll:hover {
    overflow-y: auto;
}

.goto-item {
    width: 100%;
    line-height: 22px;
    overflow: hidden;
    text-overflow: ellipsis;
}

.goto-item.generic {
    padding-left: 20px;
}
.goto-item.parent {
    padding-left: 20px;
}
.goto-item.headline {
    font-weight: bold;
    padding-left: 20px;
}
.goto-item.body {
    padding-left: 30px;
}
.goto-item.tag {
    font-weight: bold;
    padding-left: 20px;
}

.show-parents .goto-item.generic {
    padding-left: 20px;
}
.show-parents .goto-item.parent {
    padding-left: 20px;
}
.show-parents .goto-item.headline {
    font-weight: bold;
    padding-left: 30px;
}
.show-parents .goto-item.body {
    padding-left: 40px;
}
.show-parents .goto-item.tag {
    font-weight: bold;
    padding-left: 30px;
}

.goto-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.goto-item.selected,
.goto-item.selected:hover {
    background-color: var(--vscode-list-inactiveSelectionBackground);
}

.goto-item.selected:focus,
.goto-item.selected:focus:hover {
    background-color: var(--vscode-list-activeSelectionBackground);
    outline: 1px solid
        var(
            --vscode-list-focusAndSelectionOutline,
            var(--vscode-contrastActiveBorder, var(--vscode-list-focusOutline))
        );
    outline-offset: -1px;
}

#top-shadow {
    top: -4px;
    height: 0;
    left: 0;
    position: absolute;
    width: 100%;
}

#top-shadow.scrolled {
    box-shadow: var(--vscode-sideBarStickyScroll-shadow) 0 6px 6px -6px inset;
    height: 3px;
}
</t>
<t tx="felix.20231221231533.1">## 0.2.6

- Fixed keyboard navigation of the outline while being hoisted.

</t>
<t tx="felix.20231224193540.1">public async put_help(c: Commands, s: string, short_title: string): Promise&lt;void&gt; {
    s = g.dedent(s.trimEnd());
    s = this.showdownConverter.makeHtml(s);
    // Get the html file content and replace the three strings :
    // the 'nonce' string, the base url, and 'cspSource', the Content security policy source.
    const fileUri = g.vscode.Uri.joinPath(this._context.extensionUri, 'help-panel', 'index.html');
    const htmlDoc = await g.vscode.workspace.openTextDocument(fileUri);
    const nonce = Array.from({ length: 32 }, () =&gt; Math.random().toString(36).charAt(2)).join('');

    if (short_title.trim()) {
        short_title = `&lt;h1&gt;${short_title}&lt;/h1&gt;\n`;
    }

    if (this._helpPanel) {
        // Already created
        const baseUri = this._helpPanel.webview.asWebviewUri(this._context.extensionUri);
        const html = htmlDoc.getText().replace(
            /#{nonce}/g,
            nonce
        ).replace(
            /#{root}/g,
            `${baseUri}`
        ).replace(
            /#{cspSource}/g,
            `${this._helpPanel.webview.cspSource}`
        ).replace(
            '#{title}',
            short_title
        ).replace(
            '#{body}',
            s
        );
        this._helpPanel.webview.html = html;
        this._helpPanel.reveal(undefined, true);
    } else {
        // First time showing help panel
        this._helpPanel = g.vscode.window.createWebviewPanel(
            'helpPanelWebview',
            'LeoJS Help',
            { viewColumn: vscode.ViewColumn.Beside, preserveFocus: true },
            {
                enableScripts: true,
            }
        );
        this._context.subscriptions.push(this._helpPanel);
        this._helpPanel.onDidDispose(
            () =&gt; {

                this._helpPanel = undefined;
            },
            null,
            this._context.subscriptions
        );
        const baseUri = this._helpPanel.webview.asWebviewUri(this._context.extensionUri);
        const html = htmlDoc.getText().replace(
            /#{nonce}/g,
            nonce
        ).replace(
            /#{root}/g,
            `${baseUri}`
        ).replace(
            /#{cspSource}/g,
            `${this._helpPanel.webview.cspSource}`
        ).replace(
            '#{title}',
            short_title
        ).replace(
            '#{body}',
            s
        );

        this._helpPanel.iconPath = g.vscode.Uri.joinPath(this._context.extensionUri, 'resources', 'leoapp128px.png');
        this._helpPanel.webview.html = html;

    }

    // * Showing with Markdown preview, with the "markdown.showPreviewToSide" command
    // this.helpPanelText = s;

    // // * Close all open help panels 
    // await utils.closeLeoHelpPanels();

    // setTimeout(() =&gt; {
    //     const w_uri = vscode.Uri.parse(Constants.URI_HELP_SCHEME + ":" + Constants.URI_HELP_FILENAME);
    //     this.helpDocumentPaneProvider.update(w_uri);
    //     setTimeout(() =&gt; {
    //         // * Open the virtual document in the preview pane
    //         void vscode.commands.executeCommand('markdown.showPreviewToSide', w_uri);
    //     }, 60);
    // }, 0);

    // * Showing with standard readonly text document provider
    // const doc = await vscode.workspace.openTextDocument(uri); // calls back into the provider
    // await vscode.window.showTextDocument(doc, { preview: false, viewColumn: vscode.ViewColumn.Beside });
}

</t>
<t tx="felix.20231224200501.1">## 0.2.9

- Fixed es_exception and scripting error reporting.
- Added support of the plugin system's 'g.registerHandler' for most of the original Leo event names.
- Fixed line ending of body text when transfered from vscode's text editor to make sure it's lf and not crlf. (Fixed 'Orphan Nodes' when section references are newly created)
- Fixed bug that sometimes asked to 'save' and overwrite/confirm when new node was created with body text containing an ampersand or when using vscode's quick-suggestion autocomplete.

</t>
<t tx="felix.20231224201746.1">import * as vscode from 'vscode';
import { LeoUI } from './leoUI';

export class HelpPanel implements vscode.TextDocumentContentProvider {
@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20231224201802.1">
    // emitter and its event
    onDidChangeEmitter = new vscode.EventEmitter&lt;vscode.Uri&gt;();
    onDidChange = this.onDidChangeEmitter.event;

    constructor(private _ui: LeoUI) { }

    provideTextDocumentContent(p_uri: vscode.Uri): string {
        return this._ui.helpPanelText;
    }

    // Call this method to signal that the content has changed
    public update(uri: vscode.Uri) {
        this.onDidChangeEmitter.fire(uri);
    }

}
</t>
<t tx="felix.20231226205226.1">import * as vscode from 'vscode';
import { Constants } from "./constants";

export class UnlProvider implements vscode.DocumentLinkProvider {

    /*
        * GNX-based UNL Samples
        unl:gnx://leoPy.leo#ekr.20230626064652.1
        unl:gnx://myProject.leo#node12345678.1
        unl:gnx://codeRepo.leo#function.20231231.1
    
        * Headline-based UNL Samples
        unl://C:/leo.repo/leo-editor/leo/doc/LeoDocs.leo#Getting Started--&gt;Introduction
        unl://D:/work/notes.leo#Meeting Notes--&gt;2023--&gt;March--&gt;Project X Discussion
        unl://myDocuments/notes.leo#Ideas--&gt;New Concepts--&gt;brainstorming-session
        unl://relativePath/myFile.leo#Chapter 1--&gt;Section 2--&gt;Paragraph 3
        unl://C:/projects/leoProject.leo#Code Review--&gt;Module 1--&gt;Function XYZ--&gt;Improvements
    
        * Mixed Characters and Edge Cases
        unl://path/to/file.leo#Headline-with-Dashes--&gt;Sub-section--&gt;Item 1
        unl://anotherPath/docs.leo#Special Characters!--&gt;@$%^&amp;*
        unl://leoFile.leo#Testing--&gt;Edge--&gt;Cases--&gt;with--&gt;Multiple Separators

        REFERENCE IN leoGlobals.py
         2. New in Leo 6.7.4: UNLs based on gnx's (global node indices):
        
            Links of the form `unl:gnx:` + `//{outline}#{gnx}` open the given
            outline and select the first outline node with the given gnx. These UNLs
            will work as long as the node exists anywhere in the outline.
        
            For example, the link: `unl:gnx://#ekr.20031218072017.2406` refers to this
            outline's "Code" node. Try it. The link works in this outline.

    */

    // private gnxUnlRegex = /\bunl:gnx:[^\r\n#]*#\S*/g; // This allows spaces and content after the UNL.
    // private headlineUnlRegex = /\bunl:(?!gnx:)[^\r\n#]*#[^\r\n]*\S/g; // This goes on until end of line.

    // *It seems that the double slash is required for valid UNLs (as per this comment in p.get_UNL and related methods in leoNodes.py)

    // All unls must contain a file part: f"//{file-name}#"
    // The file-name may be empty.

    private gnxUnlRegex = /\bunl:gnx:\/\/[^\r\n#]*#\S*/g; // This allows spaces and content after the UNL.
    private headlineUnlRegex = /\bunl:\/\/[^\r\n#]*#[^\r\n]*\S/g; // This goes on until end of line.

    public provideDocumentLinks(document: vscode.TextDocument, token: vscode.CancellationToken): vscode.ProviderResult&lt;vscode.DocumentLink[]&gt; {
        const text = document.getText();
        const links: vscode.DocumentLink[] = [];

        let match;

        // GNX-based UNLs
        while ((match = this.gnxUnlRegex.exec(text)) !== null) {
            const range = new vscode.Range(document.positionAt(match.index), document.positionAt(match.index + match[0].length));
            const args = encodeURIComponent(JSON.stringify({ unl: match[0] }));
            links.push(new vscode.DocumentLink(range, vscode.Uri.parse(`command:${Constants.COMMANDS.HANDLE_UNL}?${args}`)));
        }

        //  Headline - based UNLs
        while ((match = this.headlineUnlRegex.exec(text)) !== null) {
            const range = new vscode.Range(document.positionAt(match.index), document.positionAt(match.index + match[0].length));
            const args = encodeURIComponent(JSON.stringify({ unl: match[0] }));
            links.push(new vscode.DocumentLink(range, vscode.Uri.parse(`command:${Constants.COMMANDS.HANDLE_UNL}?${args}`)));

        }

        return links;
    }
}
</t>
<t tx="felix.20231226210919.1">/**
 * Handles the calls from the DocumentLinkProvider for clicks on UNLs.
 */
public async handleUnl(p_arg: { unl: string }): Promise&lt;void&gt; {
    if (!g.app.windowList.length) {
        // No file opened: exit
        g.es('Handle Unl: No Commanders opened');
        return;
    }
    const c = g.app.windowList[this.frameIndex].c;
    await this.triggerBodySave(true);
    try {

        if (p_arg.unl) {
            this.setupRefresh(
                Focus.Body, // Finish in body pane given explicitly because last focus was in input box.
                {
                    tree: true,
                    body: true,
                    goto: true,
                    states: true,
                    documents: true,
                    buttons: true
                }
            );
            await g.openUrlOnClick(c, p_arg.unl);
            void this.launchRefresh();
            this.loadSearchSettings();

        } else {
            console.log('NO ARGUMENT FOR HANDLE URL! ', p_arg);
        }
    }
    catch (e) {
        console.log('FAILED HANDLE URL! ', p_arg);
    }
}

</t>
<t tx="felix.20231231203518.1">/**
 * Checks if Session per workspace is true, if so returns unl list
 * Undefined otherwise.
 * Note: Can be used to check for Session per workspace flag.
 */
public getWorkspaceSession(): string[] | undefined {
    if (this.config.sessionPerWorkspace) {
        return this._context.workspaceState.get(Constants.LAST_FILES_KEY) || [];
    } else {
        return undefined;
    }
}

</t>
<t tx="felix.20231231203533.1">/**
 * Sets session unl list for this workspace
 */
public setWorkspaceSession(unls: string[]): Thenable&lt;void&gt; {
    return this._context.workspaceState.update(Constants.LAST_FILES_KEY, unls);
}

</t>
<t tx="felix.20240101211218.1">## 0.2.8

- Translated most of helpCommands.py to typescript, enabling 'help' commands.
- Added UNL support for both output pane, body panes and all other editor windows.
- Fixed 'goto-script' for @button items context menu to also work on child of @buttons (plural) nodes in myLeoSettings.leo.
- Fixed @auto markdown .md importer and writer to now preserve full integrity in read-write round-trip cycle.
- Added support of undo/redo actions for UA related commands (Clear UAs and Set UA).
- Fixed 'show clone ancestors' and 'show clone parents' commands.
- The session (last opened files to reopen at startup) is saved per workspace by default. An options setting can be changed to use the original Leo global session.
- LeoJS now stays on the currently selected node when refreshing an external file. (if it is a descendent of the external file node itself)
- Added 'gnx-kind' setting support for generating uuid or ksuid strings instead of regular GNX strings.

</t>
<t tx="felix.20240107181054.1"># 0.2.10

- Fixed 'Orphan Nodes' when section references were newly created.
- Removed futile write to recent files just after opening last session.
- Allow sessions to be empty in sessions manager's save_snapshot method. (as opposed to the original Leo, which will exit the program when closing the last tab)
- Made the default of using JSON for clipbard be a default in leojsSettings.leojs setting "json-outline-clipboard" instead of being hard-coded.
- Many small fixes and code cleanup.

</t>
<t tx="felix.20240113195919.1"># 0.2.11

- Added typescript support for running scripts and using @command or @button nodes.
- Changed button pane interaction so that 'play' icons must be clicked. (instead of clicking anywhere on the entry)
- Leo panel now shows a 'Opening...' message when opening a Leo file if no file were already opened.
- Fixed extraneous delay when opening the 'goAnywhere' palette with CTRL+P when focus is on a LeoJS panel.
- Added support for the 'wrap' state of the body pane. (Along with @wrap and @nowrap directives)

</t>
<t tx="felix.20240121003227.1">public checkBodyWrap(p_forced?: boolean): void {
    let w_missing = false;

    let w_languageSettings: Record&lt;string, string&gt; | undefined;
    let w_totalConfigName = "";

    for (const w_lang of Constants.LANGUAGES) {
        let langWrap = '[' + Constants.LEO_LANGUAGE_PREFIX + w_lang + Constants.LEO_WRAP_SUFFIX + ']';
        w_totalConfigName += langWrap;
    }

    w_languageSettings = vscode.workspace.getConfiguration(w_totalConfigName, null);

    if (!w_languageSettings || !w_languageSettings['editor.wordWrap'] || w_languageSettings['editor.wordWrap'] !== 'on') {
        w_missing = true;
    }

    if (w_missing &amp;&amp; p_forced) {
        void this.setBodyWrap();
        // ! NOT warning the user for this forced setting at startup because its internal to LeoJS only !
    } else if (w_missing &amp;&amp; !p_forced) {
        void vscode.window.showWarningMessage(
            Constants.USER_MESSAGES.BODY_WRAP_RECOMMEND,
            Constants.USER_MESSAGES.FIX_IT
        ).then(p_chosenButton =&gt; {
            if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                void vscode.commands.executeCommand(Constants.COMMANDS.SET_BODY_WRAP_SETTINGS);
                void vscode.window.showInformationMessage(Constants.USER_MESSAGES.BODY_WRAP_SET);
            }
        });
    }
}

</t>
<t tx="felix.20240121004132.1">/**
 * Supported Languages
 */
public static LANGUAGES = [
    "plain",
    "julia",
    "batch",
    "shell",
    "python",
    "javascript",
    "typescript",
    "c",
    "cpp",
    "css",
    "fortran",
    "fortran90",
    "html",
    "java",
    "json",
    "markdown",
    "php",
    "restructuredtext",
    "rust",
    "xml",
];

</t>
<t tx="felix.20240121143955.1">/**
 * * Sets all 'bodywrap' vscode settings
 */
public setBodyWrap(): Thenable&lt;void&gt; {
    let w_totalConfigName = "";
    for (const w_lang of Constants.LANGUAGES) {
        let langWrap = '[' + Constants.LEO_LANGUAGE_PREFIX + w_lang + Constants.LEO_WRAP_SUFFIX + ']';
        w_totalConfigName += langWrap;
    }
    return vscode.workspace.getConfiguration().update(w_totalConfigName, { 'editor.wordWrap': 'on' }, vscode.ConfigurationTarget.Global);
}

</t>
<t tx="felix.20240122215450.1"># 0.2.12

- Help commands were changed from markdown preview panes to html webviews.
- (Breaking Change) Made vscode accessible via g.vscode instead of g.app.vscode.
- Made more external libraries accessible via the global 'g' object:
    - SQL
    - pako
    - showdown
    - JSZip
- Made more OS path related constants available in the global 'g' object:
    - extensionContext
    - extensionUri
    - workspaceUri
- Added 'show-recent-files' command.
- Fixed Find-Panel's behavior and styling.
- Fixed 'open-aside' command.
- Added hover menu to the UNL status bar item to choose from any UNL formats to be copied to the clipboard.
- Removed 'font-size &amp; zoom' related config settings following VSCode's new ZOOM settings API.
- Added support for XML language colorization.
- Implemented Leo's new UNL relative path support.
- Fixed settings being saved properly in db for newly created files from a 'save-as' command.
- Changed .leojs file format to have no state bits in file anymore, and instead save them in db.
- Fixed at-buttons panel to refresh properly after a 'revert-to-saved' command.
- Fixed startup process to block all commands if no LeoID is found, except for the 'Set Leo ID' command.
- Fixed 'Goto' panel's navigation's stability issues after switching panels.

</t>
<t tx="felix.20240209012442.1">/**
 * * Closes all visible text editors that have Leo filesystem scheme (that are not dirty)
 */
export async function closeLeoTextEditors(): Promise&lt;unknown&gt; {
    const w_foundTabs: vscode.Tab[] = [];

    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {

            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                ((p_tab.input as vscode.TabInputText).uri.scheme).startsWith(Constants.URI_LEOJS_SCHEME) &amp;&amp;
                !p_tab.isDirty
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        for (const p_tab of w_foundTabs) {
            if (p_tab.input) {
                await vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                await vscode.workspace.applyEdit(w_edit);
            }
        }
    } else {
        q_closedTabs = Promise.resolve(true);
    }

    return q_closedTabs;
}

</t>
<t tx="felix.20240209012451.1">export async function closeLeoHelpPanels(): Promise&lt;unknown&gt; {

    // * Close all open help panels 
    const w_foundTabs: vscode.Tab[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (
                p_tab.label.endsWith(Constants.URI_HELP_FILENAME)
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        for (const p_tab of w_foundTabs) {
            if (p_tab.label === Constants.URI_HELP_FILENAME &amp;&amp; p_tab.input) {
                // Not a preview
                await vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                await vscode.workspace.applyEdit(w_edit);
            }
        }
    } else {
        q_closedTabs = Promise.resolve(true);
    }
    return q_closedTabs;

}
</t>
<t tx="felix.20240213205001.1">/**
 * Status bar item click handler
 */
public statusBar(): Thenable&lt;string | undefined&gt; {
    return this.unlToClipboard();
}

</t>
<t tx="felix.20240221212119.1">/**
 * Remove body wrap setting from older LeoJS versions
 * that suported less languages
 */
public removeOldBodyWrap(): void {
    // Last version did not have XML
    let w_totalOldVersionConfigName = "";

    // Looping from the first element up to the second-to-last element
    for (let i = 0; i &lt; Constants.LANGUAGES.length - 1; i++) {
        const w_lang = Constants.LANGUAGES[i];
        const langWrap = '[' + Constants.LEO_LANGUAGE_PREFIX + w_lang + Constants.LEO_WRAP_SUFFIX + ']';
        w_totalOldVersionConfigName += langWrap;
    }

    if (vscode.workspace.getConfiguration().has(w_totalOldVersionConfigName)) {
        void vscode.workspace.getConfiguration().update(w_totalOldVersionConfigName, undefined, vscode.ConfigurationTarget.Global);
    }

}

</t>
<t tx="felix.20240222220320.1">/**
 * Sets up the tooltip with a given headline string title
 * for displaying 'click to copy to clipboard' tooltip
 */
public setTooltip(p_headline: string, p_debounceDelay?: number): void {
    if (this._tooltip === p_headline) {
        return; // cancel
    }
    this._tooltip = this._buildToolTip(p_headline);
    this._updateLeoObjectIndicatorDebounced(p_debounceDelay || 0);
}

</t>
<t tx="felix.20240222233600.1">/**
 * Put UNL of current node on the clipboard. 
 * @para optional unlType to specify type.
 */
public unlToClipboard(unlType?: UnlType): Thenable&lt;string&gt; {
    let unl = "";
    const c = g.app.windowList[this.frameIndex].c;
    const p = c.p;
    if (!p.v) {
        return Promise.resolve('');
    }
    if (unlType) {
        switch (unlType) {
            case 'shortGnx':
                unl = p.get_short_gnx_UNL();
                break;
            case 'fullGnx':
                unl = p.get_full_gnx_UNL();
                break;
            case 'shortLegacy':
                unl = p.get_short_legacy_UNL();
                break;
            case 'fullLegacy':
                unl = p.get_full_legacy_UNL();
                break;
        }
    } else {
        unl = c.frame.computeStatusUnl(p);
    }
    return this.replaceClipboardWith(unl);
}

</t>
<t tx="felix.20240222233803.1">export type UnlType = 'shortGnx' | 'fullGnx' | 'shortLegacy' | 'fullLegacy';

</t>
<t tx="felix.20240223001320.1">/**
 * builds tooltip from headline
 */
private _buildToolTip(p_headline: string = ""): string {

    // markdown supports links that execute commands: 
    // [Run it](command:myCommandId)

    let w_tooltip = g.dedent(`\
    #### **UNL for** _${p_headline}_

    #### [Click to copy UNL to clipboard](command:${Constants.COMMANDS.STATUS_BAR})

    ---

    _Or choose a specific UNL type:_

    **[short gnx](command:${Constants.COMMANDS.SHORT_GNX_UNL_TO_CLIPBOARD})** —
    **[full gnx](command:${Constants.COMMANDS.FULL_GNX_UNL_TO_CLIPBOARD})**

    **[short legacy](command:${Constants.COMMANDS.SHORT_LEGACY_UNL_TO_CLIPBOARD})** —
    **[full legacy](command:${Constants.COMMANDS.FULL_LEGACY_UNL_TO_CLIPBOARD})**

    `);

    return w_tooltip;

}

</t>
<t tx="felix.20240224165738.1"></t>
<t tx="felix.20240224165747.1">// @ts-check

// This script will be run within the webview itself
// It cannot access the main VS Code APIs directly.
// Send message to LeoJS with vscode.postMessage({ keyNameEx1: someValue, ... });
// Receive messages from LeoJS with window.addEventListener('message', event =&gt; { ... });
(function () {
    // @ts-expect-error
    const vscode = acquireVsCodeApi();

    // console.log('Help Panel Started!');
})();
</t>
<t tx="felix.20240224165750.1">@language css
html {
  box-sizing: border-box;
  font-size: 13px;
  --input-padding-vertical: 6px;
  --input-padding-horizontal: 4px;
  --input-margin-vertical: 4px;
  --input-margin-horizontal: 0;
  height: 100%;
}

*:focus {
  outline-color: var(--vscode-focusBorder);
}

a {
  color: var(--vscode-textLink-foreground);
}

a:hover,
a:active {
  color: var(--vscode-textLink-activeForeground);
}

code {
  font-size: var(--vscode-editor-font-size);
  font-family: var(--vscode-editor-font-family);
  display: inline-block;
}

button {
  border: 1px solid var(--vscode-button-border,transparent);
  padding: var(--input-padding-vertical) var(--input-padding-horizontal);
  border-radius: 2px;
  width: 100%;
  max-width: 300px;
  text-align: center;
  outline: 1px solid transparent;
  outline-offset: 2px !important;
  color: var(--vscode-button-foreground);
  background: var(--vscode-button-background);
}

button:hover {
  cursor: pointer;
  background: var(--vscode-button-hoverBackground);
}

button:focus {
  outline-color: var(--vscode-focusBorder);
}

button.secondary {
  color: var(--vscode-button-secondaryForeground);
  background: var(--vscode-button-secondaryBackground);
}

button.secondary:hover {
  background: var(--vscode-button-secondaryHoverBackground);
}

label {
  display: inline-block;
  margin-bottom: 0.2em;
}

select {
  background: var(--vscode-dropdown-background);
  color: var(--vscode-input-foreground);
  border-color: var(--vscode-dropdown-border);
  cursor: pointer;
  position: relative;
  border-radius: 2px;
  padding: 3px var(--input-padding-horizontal);
  color: var(--vscode-input-foreground);
}

select:focus {
  outline-color: var(--vscode-input-border);
}

select:disabled {
  opacity: 0.5;
  cursor: default;
}

select option {
  background-color: var(--vscode-dropdown-listBackground);
  padding: 3px var(--input-padding-horizontal);
}

select option:focus {
  background-color: var(--vscode-input-background);
  outline-color: var(--vscode-input-border);
}

input:not([type="radio"]):not([type="checkbox"]),
textarea {
  margin-right: 20px;
  border: none;
  font-family: var(--vscode-font-family);
  padding: 3px var(--input-padding-horizontal);
  border-radius: 2px;
  color: var(--vscode-input-foreground);
  outline-color: var(--vscode-input-border);
  background-color: var(--vscode-input-background);
}

textarea {
  width: 100%;
  display: block;
}

input[type="checkbox"],
input[type="radio"] {
  cursor: pointer;
}

input:disabled {
  opacity: 0.5;
  cursor: default;
}

input::placeholder,
textarea::placeholder {
  color: var(--vscode-input-placeholderForeground);
}

u {
  color: var(--vscode-editor-foreground);
  text-decoration-color: var(--vscode-foreground);
  text-underline-offset: 0.04em;
}

.row {
  margin-bottom: 0.5em;
}

.muted {
  opacity: 0.6;
}

.big {
  font-size: 20px;
}</t>
<t tx="felix.20240224200656.1">&lt;!DOCTYPE html&gt;
&lt;html lang="en" tabindex="-1"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;meta http-equiv="Content-Security-Policy"
    content="default-src 'none'; style-src #{cspSource}; img-src #{cspSource} https:; script-src 'nonce-#{nonce}';" /&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
&lt;link href="#{root}/help-panel/style.css" rel="stylesheet" /&gt;
&lt;title&gt;LeoJS Help&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
#{title}
#{body}
&lt;!-- end of body --&gt;
&lt;script nonce="#{nonce}" src="#{root}/help-panel/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</t>
<t tx="felix.20240303150445.1">/**
 * 'LeoID is unset' state for an empty/unset LeoID state preventing startup
 */
private _leoIdUnset: boolean = false;
get leoIdUnset(): boolean {
    return this._leoIdUnset;
}
set leoIdUnset(p_value: boolean) {
    this._leoIdUnset = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_ID_UNSET, p_value);
}

</t>
<t tx="felix.20240401145215.1">/**
 * * Opens a detached body aside, and set focus in a body pane locked to its commander/gnx. 
 * - Does not select the node in the outline.
 * - If already opened aside in the same targeted column, just reveal.
 * @param p is the position node to be opened aside
 */
public async openAside(p?: Position): Promise&lt;unknown&gt; {
    // Those 'body panes' opened aside, (other than the main body pane), 
    // stay opened until the node's gnx becomes invalid/deleted, or it's commander is closed.
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;
    if (!p) {
        p = c.p;
    }

    const detachedGnx = `${c.id}/${p.gnx}`;
    const detachedUri = utils.strToLeoDetachedUri(detachedGnx);

    // * Step 1 : Open the document
    if (!this._leoDetachedFileSystem.watchedBodiesGnx.includes(detachedGnx)) {
        this._leoDetachedFileSystem.setNewBodyUriTime(detachedUri, p.v);
    }
    this.bodyDetachedTextDocument = await vscode.workspace.openTextDocument(detachedUri);
    let w_bodySel: BodySelectionInfo | undefined;
    const w_language = this._getBodyLanguage(p);
    const insert = p.v.insertSpot;
    const start = p.v.selectionStart;
    const end = p.v.selectionStart + p.v.selectionLength;
    const scroll = p.v.scrollBarSpot;

    w_bodySel = {
        "gnx": p.v.gnx,
        "scroll": scroll,
        "insert": this._row_col_pv_dict(insert, p.v.b),
        "start": this._row_col_pv_dict(start, p.v.b),
        "end": this._row_col_pv_dict(end, p.v.b)
    };
    if (w_language !== this.bodyDetachedTextDocument.languageId) {
        void this._setBodyLanguage(this.bodyDetachedTextDocument, w_language);
    }

    const w_showOptions: vscode.TextDocumentShowOptions =
    {
        viewColumn: vscode.ViewColumn.Beside,
        preserveFocus: this.config.treeKeepFocusWhenAside,
        preview: false,
    };
    // * Actually Show the body pane document in a text editor
    const q_showTextDocument = vscode.window.showTextDocument(
        this.bodyDetachedTextDocument,
        w_showOptions
    ).then(
        (p_textEditor: vscode.TextEditor) =&gt; {

            // * Set text selection range
            const w_bodyTextEditor = p_textEditor;
            if (!w_bodySel) {
                console.log("no selection in returned package from get_body_states");
            }

            const w_leoBodySel: BodySelectionInfo = w_bodySel!;

            // Cursor position and selection range
            const w_activeRow: number = w_leoBodySel.insert.line;
            const w_activeCol: number = w_leoBodySel.insert.col;
            let w_anchorLine: number = w_leoBodySel.start.line;
            let w_anchorCharacter: number = w_leoBodySel.start.col;

            if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                // Active insertion same as start selection, so use the other ones
                w_anchorLine = w_leoBodySel.end.line;
                w_anchorCharacter = w_leoBodySel.end.col;
            }

            const w_selection = new vscode.Selection(
                w_anchorLine,
                w_anchorCharacter,
                w_activeRow,
                w_activeCol
            );

            let w_scrollRange: vscode.Range | undefined;

            // Build scroll position from selection range.
            w_scrollRange = new vscode.Range(
                w_activeRow,
                w_activeCol,
                w_activeRow,
                w_activeCol
            );

            if (w_bodyTextEditor) {

                w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                if (!w_scrollRange) {
                    w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                }

                w_bodyTextEditor.revealRange(w_scrollRange, vscode.TextEditorRevealType.InCenterIfOutsideViewport);

            } else {
                console.log("no selection in returned package from showTextDocument");
            }

        }
    );

    return q_showTextDocument;
}

</t>
<t tx="felix.20240401213604.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import * as path from 'path';
import { BodyTimeInfo } from "./types";
import { LeoUI } from "./leoUI";
import * as g from './core/leoGlobals';
import { Commands } from "./core/leoCommands";
import { VNode } from "./core/leoNodes";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20240401213604.10">public readDirectory(p_uri: vscode.Uri): [string, vscode.FileType][] {
    const w_commanders: Set&lt;string&gt; = new Set();
    const w_detached: Set&lt;string&gt; = new Set();
    if (this._leoUi.leoStates.fileOpenedReady) {

        for (const p_tabGroup of vscode.window.tabGroups.all) {
            for (const p_tab of p_tabGroup.tabs) {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME
                ) {
                    // Found detached. 
                    const [unused, id, gnx] = (p_tab.input as vscode.TabInputText).uri.path.split("/");
                    w_commanders.add(id);
                    w_detached.add((p_tab.input as vscode.TabInputText).uri.path);
                }
            }
        }
    }

    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'

        const w_directory: [string, vscode.FileType][] = [];

        for (const w_commander of [...w_commanders]) {
            w_directory.push([w_commander, vscode.FileType.Directory]);
        }
        return w_directory;

    } else if (
        p_uri.path.split('/').length
    ) {

        const w_directory: [string, vscode.FileType][] = [];
        for (const w_file of [...w_detached]) {
            if (w_file.split('/')[1] === p_uri.path.split('/')[1]) {
                w_directory.push([w_file.split('/')[2], vscode.FileType.File]);
            }
        }
        return w_directory;

    } else {
        throw vscode.FileSystemError.FileNotFound(p_uri);
    }
}

</t>
<t tx="felix.20240401213604.11">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('DETACHED Called createDirectory with ', p_uri.path); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20240401213604.12">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    if (this.preventSaveToLeo) {
        this.preventSaveToLeo = false;
    } else {
        void this._leoUi.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    }
    const w_gnx = utils.leoUriToStr(p_uri);

    if (!this._openedBodiesInfo[w_gnx]) {
        console.error("LeoJS: Tried to save DETACHED but not in _openedBodiesGnx. gnx :", w_gnx);
    }
    this._setOpenedBodyTime(w_gnx);
    this._openedBodiesInfo[w_gnx].lastBodyLength = p_content.byteLength;
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20240401213604.13">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('DETACHED Called rename on ', p_oldUri.path, p_newUri.path); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20240401213604.14">public delete(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesInfo[w_gnx]) {
        delete this._openedBodiesInfo[w_gnx];
        delete this.openedBodiesVNodes[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20240401213604.15">public copy(p_uri: vscode.Uri): void {
    console.warn('DETACHED Called copy on ', p_uri.path); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20240401213604.16">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20240401213604.2">/**
 * * Body panes implementation as a file system using "leojs" as a scheme identifier
 */
export class LeoBodyDetachedProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read

    // * List of currently VISIBLE opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    public watchedBodiesGnx: string[] = [];

    // * List of gnx open in tab(s) (from tryApplyNodeToBody / switchBody and fs.delete)
    public openedBodiesVNodes: { [key: string]: VNode } = {};
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being watched by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoUi: LeoUI) { }

    @others
}
</t>
<t tx="felix.20240401213604.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setNewBodyUriTime(p_uri: vscode.Uri, v: VNode): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._setOpenedBodyTime(w_gnx);
    this.openedBodiesVNodes[w_gnx] = v;
}

</t>
<t tx="felix.20240401213604.4">/**
 * * Adds entries in _openedBodiesGnx and _openedBodiesInfo if needed
 * * and sets the modified time of an opened body.
 */
private _setOpenedBodyTime(p_gnx: string): void {
    const w_now = new Date().getTime();
    let w_created = w_now;
    if (this._openedBodiesInfo[p_gnx]) {
        w_created = this._openedBodiesInfo[p_gnx].ctime; // Already created?
    }

    this._openedBodiesInfo[p_gnx] = {
        ctime: w_created,
        mtime: w_now // new 'modified' time.
    };
}

</t>
<t tx="felix.20240401213604.5">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {

    this._setOpenedBodyTime(p_gnx);

    if (!this.watchedBodiesGnx.includes(p_gnx)) {
        // * Should only be called if vscode.window.tabGroups contained an opened detached body.
        console.log('called fireRefreshFile on an unwatched DETACHED !', p_gnx);
        return; // Document is not being watched (closed tab or non-visible non-dirty tab)
    }

    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoDetachedUri(p_gnx)
    }]);
}

</t>
<t tx="felix.20240401213604.7">public watch(p_resource: vscode.Uri, p_options: { readonly recursive: boolean; readonly excludes: readonly string[] }): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this.watchedBodiesGnx.includes(w_gnx)) {
        this.watchedBodiesGnx.push(w_gnx); // add gnx
    }
    // else already in list
    return new vscode.Disposable(() =&gt; {
        const w_position = this.watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this.watchedBodiesGnx.splice(w_position, 1);
            this.cleanupDetachedBodies(); // IF NOT EVEN AN EXISTING TAB (not just hidden)
        }
    });
}

</t>
<t tx="felix.20240401213604.8">public stat(p_uri: vscode.Uri): vscode.FileStat {
    if (this._leoUi.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        const w_commanders: Set&lt;string&gt; = new Set();
        const w_detached: Set&lt;string&gt; = new Set(); // same whole gnx string as with setNewBodyUriTime

        for (const p_tabGroup of vscode.window.tabGroups.all) {
            for (const p_tab of p_tabGroup.tabs) {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME
                ) {
                    // Found detached. 
                    const [unused, id, gnx] = (p_tab.input as vscode.TabInputText).uri.path.split("/");
                    w_commanders.add(id);
                    w_detached.add(utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri));
                }
            }
        }

        // w_commanders and w_detached are filled up!
        if (p_uri.fsPath.length === 1) {
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
        }

        const [unused, id, gnx] = p_uri.path.split("/");

        if (id &amp;&amp; !gnx) {
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
            // SPECIAL CASE -----------------------------------------------
        } else if (w_gnx === this._lastGnx &amp;&amp; this._openedBodiesInfo[this._lastGnx]) {
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._openedBodiesInfo[this._lastGnx].lastBodyLength!
            };
            // ------------------------------------------------------------
        } else if (this._openedBodiesInfo[w_gnx]) {
            let c: Commands;
            let w_v: VNode | undefined;
            const id = p_uri.path.split("/")[1];
            for (const w_frame of g.app.windowList) {
                if (w_frame.c.id.toString() === id) {
                    c = w_frame.c;
                    w_v = c.fileCommands.gnxDict[p_uri.path.split("/")[2]];
                    break;
                }
            }
            if (w_v) {
                return {
                    type: vscode.FileType.File,
                    ctime: this._openedBodiesInfo[w_gnx].ctime,
                    mtime: this._openedBodiesInfo[w_gnx].mtime,
                    size: Buffer.byteLength(w_v.b, 'utf8') // w_v.b.length
                };
            } else {
                console.warn('DETACHED BODY stat: not found!');
            }
        } else {
            //  should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
            // console.error('DETACHED asked for STAT about file NOT IN _openedBodiesGnx ');
        }
    }
    // throw vscode.FileSystemError.FileNotFound();
    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
    return { type: vscode.FileType.File, ctime: 0, mtime: 0, size: 0 };
}

</t>
<t tx="felix.20240401213604.9">public readFile(p_uri: vscode.Uri): Uint8Array {
    if (this._leoUi.leoStates.fileOpenedReady) {

        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            // * should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
            // if (!this._openedBodiesInfo[w_gnx]) {
            //     console.warn('DETACHED readFile: ERROR File not in _openedBodiesGnx! gnx: ', w_gnx);
            // }
            let c: Commands;
            let w_v: VNode | undefined;

            const id = p_uri.path.split("/")[1];
            for (const w_frame of g.app.windowList) {
                if (w_frame.c.id.toString() === id) {
                    c = w_frame.c;
                    w_v = c.fileCommands.gnxDict[p_uri.path.split("/")[2]];
                    break;
                }
            }

            if (w_v) {
                this._lastGnx = w_gnx;
                this._lastBodyData = w_v.b;
                const w_buffer: Uint8Array = Buffer.from(this._lastBodyData);
                this._openedBodiesInfo[this._lastGnx].lastBodyLength = w_buffer.byteLength;
                return w_buffer;
            } else {
                this._leoUi.fullRefresh();
                if (this._lastGnx === w_gnx) {
                    // was last gnx of closed file about to be switched to new document selected
                    return Buffer.from(this._lastBodyData);
                }
                // * should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
                // console.error("DETACHED ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                return Buffer.from("");
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20240401213850.1">/**
* Builds a 'Leo Detached Scheme' vscode.Uri from a gnx 
* @param p_str leo node gnx strings are used to build Uri
* @returns A vscode 'Uri' object
*/
export function strToLeoDetachedUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_DETACHED_HEADER + p_str);
}

</t>
<t tx="felix.20240403174622.1">/**
 * React to the closing of 'tabs' via
 * events from vscode.window.tabGroups
 */
public _onTabGroupsChanged(p_event: vscode.TabGroupChangeEvent): void {
    this.checkClosedTabs(); // debounced
}

</t>
<t tx="felix.20240403174627.1">/**
 * React to the closing of 'tabgroups' via
 * events from vscode.window.tabGroups
 */
public _onTabsChanged(p_event: vscode.TabChangeEvent): void {
    this.checkClosedTabs(); // debounced
}

</t>
<t tx="felix.20240405235538.1">private _refreshDetachedBodies() {
    //  Refresh detached bodies as needed IF SAME COMMANDER, AND CLOSE : 
    if (!g.app.windowList.length) {
        this._refreshType.excludeDetached = false;
        return;
    }

    const w_commands = g.app.windowList.map(p_frame =&gt; p_frame.c);
    const c = g.app.windowList[this.frameIndex].c;
    const cId = g.app.windowList[this.frameIndex].c.id.toString();
    const w_unfoundTabs: Set&lt;vscode.Tab&gt; = new Set(); // To be closed
    const w_unfoundUri: Set&lt;vscode.Uri&gt; = new Set(); // To be removed from recently opened
    let w_hasDetached = false;

    for (const p_tabGroup of vscode.window.tabGroups.all) {
        for (const p_tab of p_tabGroup.tabs) {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME
            ) {
                const w_uri = (p_tab.input as vscode.TabInputText).uri;
                const [unused, id, gnx] = w_uri.path.split("/");
                if (id === cId) {
                    w_hasDetached = true;
                }

                // Refresh detached bodies if same commander  // ! ALSO FIRE REFRESH !
                if (!this._refreshType.excludeDetached &amp;&amp; this._refreshType.body &amp;&amp; id === cId) {
                    // console.log('fire refresh DETACHED in _refreshDetachedBodies');
                    this._leoDetachedFileSystem.fireRefreshFile(`${id}/${gnx}`);
                }

                // if refresh tree is true, validate that opened detached of same commander still valid and close as needed.
                if (this._refreshType.tree &amp;&amp; id === cId &amp;&amp; !this._refreshType.documents) {
                    let found = false;
                    for (const v of c.all_unique_nodes()) {
                        if (v.gnx === gnx) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        // close !
                        w_unfoundTabs.add(p_tab);
                        w_unfoundUri.add(w_uri);
                    }
                } else if (this._refreshType.documents) {
                    let found = false;
                    for (const w_c of w_commands) {
                        for (const v of w_c.all_unique_nodes()) {
                            if (v.gnx === gnx) {
                                found = true;
                                break;
                            }
                        }
                        if (found) {
                            break;
                        }
                    }
                    if (!found) {
                        // close !
                        w_unfoundTabs.add(p_tab);
                        w_unfoundUri.add(w_uri);
                    }

                }

            }

        }
    }
    if (w_hasDetached &amp;&amp; this._refreshType.tree) {
        this.refreshCommanderDetachedLanguage(); // May have moved outside of language specific outline
    }
    if (w_unfoundTabs.size) {
        void vscode.window.tabGroups.close([...w_unfoundTabs], true);
        for (const w_uri of w_unfoundUri) {
            void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_uri);
        }
    }
    this._refreshType.excludeDetached = false;

}

</t>
<t tx="felix.20240409221347.1">"icons": {
  "leojs-arrow-down": {
    "description": "Arrow Down",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f101"
    }
  },
  "leojs-arrow-left": {
    "description": "Arrow Left",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f102"
    }
  },
  "leojs-arrow-right": {
    "description": "Arrow Right",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f103"
    }
  },
  "leojs-arrow-small-down": {
    "description": "Small Arrow Down",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f104"
    }
  },
  "leojs-arrow-small-left": {
    "description": "Small Arrow Left",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f105"
    }
  },
  "leojs-arrow-small-right": {
    "description": "Small Arrow Right",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f106"
    }
  },
  "leojs-arrow-small-up": {
    "description": "Small Arrow Up",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f107"
    }
  },
  "leojs-arrow-up": {
    "description": "Arrow Up",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f108"
    }
  },
  "leojs-chapter-back": {
    "description": "Chapter Back",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f109"
    }
  },
  "leojs-chapter-main": {
    "description": "Chapter Main",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10a"
    }
  },
  "leojs-chapter-next": {
    "description": "Chapter Next",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10b"
    }
  },
  "leojs-chapter-select": {
    "description": "Chapter Select",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10c"
    }
  },
  "leojs-clear-files": {
    "description": "Clear Files",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10d"
    }
  },
  "leojs-clipboard": {
    "description": "Clipboard",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10e"
    }
  },
  "leojs-close": {
    "description": "Close",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10f"
    }
  },
  "leojs-close-server": {
    "description": "Close Server",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f110"
    }
  },
  "leojs-collapse": {
    "description": "Collapse",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f111"
    }
  },
  "leojs-connect": {
    "description": "Connect",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f112"
    }
  },
  "leojs-cut": {
    "description": "Cut",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f113"
    }
  },
  "leojs-dehoist": {
    "description": "Dehoist",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f114"
    }
  },
  "leojs-delete": {
    "description": "Delete",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f115"
    }
  },
  "leojs-demote": {
    "description": "Demote",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f116"
    }
  },
  "leojs-edit": {
    "description": "Edit",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f117"
    }
  },
  "leojs-extract": {
    "description": "Extract",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f118"
    }
  },
  "leojs-extract-name": {
    "description": "Extract Name",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f119"
    }
  },
  "leojs-find-next": {
    "description": "Find Next",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11a"
    }
  },
  "leojs-find-previous": {
    "description": "Find Previous",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11b"
    }
  },
  "leojs-find-quick": {
    "description": "Find Quick",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11c"
    }
  },
  "leojs-find-quick-changed": {
    "description": "Find Quick Changed",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11d"
    }
  },
  "leojs-find-quick-history": {
    "description": "Find Quick History",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11e"
    }
  },
  "leojs-find-quick-marked": {
    "description": "Find Quick Marked",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11f"
    }
  },
  "leojs-find-quick-selected": {
    "description": "Find Quick Selected",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f120"
    }
  },
  "leojs-find-quick-timeline": {
    "description": "Find Quick Timeline",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f121"
    }
  },
  "leojs-folder": {
    "description": "Folder",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f122"
    }
  },
  "leojs-gear": {
    "description": "Gear",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f123"
    }
  },
  "leojs-hoist": {
    "description": "Hoist",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f124"
    }
  },
  "leojs-icon-leo-fill": {
    "description": "Leo icon filled",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f125"
    }
  },
  "leojs-icon-leo-outline": {
    "description": "Leo icon outlined",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f126"
    }
  },
  "leojs-import": {
    "description": "Import",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f127"
    }
  },
  "leojs-insert": {
    "description": "Insert",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f128"
    }
  },
  "leojs-insert-child": {
    "description": "Insert Child",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f129"
    }
  },
  "leojs-link": {
    "description": "Link",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12a"
    }
  },
  "leojs-mark": {
    "description": "Mark",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12b"
    }
  },
  "leojs-new-file": {
    "description": "New File",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12c"
    }
  },
  "leojs-next": {
    "description": "Next",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12d"
    }
  },
  "leojs-node": {
    "description": "Node",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12e"
    }
  },
  "leojs-open-recent": {
    "description": "Open Recent",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12f"
    }
  },
  "leojs-parent": {
    "description": "Parent",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f130"
    }
  },
  "leojs-paste": {
    "description": "Paste",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f131"
    }
  },
  "leojs-paste-clone": {
    "description": "Paste Clone",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f132"
    }
  },
  "leojs-plus": {
    "description": "Plus",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f133"
    }
  },
  "leojs-plus-small": {
    "description": "Small Plus",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f134"
    }
  },
  "leojs-prev": {
    "description": "Prev",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f135"
    }
  },
  "leojs-promote": {
    "description": "Promote",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f136"
    }
  },
  "leojs-redo": {
    "description": "Redo",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f137"
    }
  },
  "leojs-refresh": {
    "description": "Refresh",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f138"
    }
  },
  "leojs-save": {
    "description": "Save",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f139"
    }
  },
  "leojs-save-as": {
    "description": "Save As",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13a"
    }
  },
  "leojs-save-as-leojs": {
    "description": "Save As .leojs",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13b"
    }
  },
  "leojs-show-log": {
    "description": "Show Log",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13c"
    }
  },
  "leojs-sort-children": {
    "description": "Sort Children",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13d"
    }
  },
  "leojs-sort-siblings": {
    "description": "Sort Siblings",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13e"
    }
  },
  "leojs-start-server": {
    "description": "Start Server",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13f"
    }
  },
  "leojs-switch": {
    "description": "Switch",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f140"
    }
  },
  "leojs-tag": {
    "description": "Tag",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f141"
    }
  },
  "leojs-undo": {
    "description": "Undo",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f142"
    }
  },
  "leojs-unmark": {
    "description": "Unmark",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f143"
    }
  },
  "leojs-write-at-file-nodes": {
    "description": "Write at-file Nodes",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f144"
    }
  },
  "leojs-write-dirty-at-file-nodes": {
    "description": "Write Dirty at-file Nodes",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f145"
    }
  }
},
</t>
<t tx="felix.20240421172320.1">/**
 * Remove entries of openedBodies if not in any tabGroups
 * * This matches _hideBodiesUnknownToFileSys from leoUI !
 */
public cleanupDetachedBodies(): void {
    const w_openedBodiesKeys = Object.keys(this._openedBodiesInfo);
    if (!w_openedBodiesKeys.length) {
        return; // Return if not even one to remove.
    }

    const w_foundTabsGnx: string[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME
            ) {
                w_foundTabsGnx.push(utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri));
            }
        });
    });

    for (const openBody of w_openedBodiesKeys) {
        if (!w_foundTabsGnx.includes(openBody)) {
            // Not an opened tab! remove it!
            delete this._openedBodiesInfo[openBody];
            delete this.openedBodiesVNodes[openBody];
        }
    }
}

</t>
<t tx="felix.20240421175315.1">private _checkClosedTabs(): void {
    // check if selected body still has opened textEditors
    let bodyCount = 0;
    for (const p_tabGroup of vscode.window.tabGroups.all) {
        for (const p_tab of p_tabGroup.tabs) {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                ((p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME)
            ) {
                // a normal body (non detached found)
                bodyCount++;
                break;
            }
        }
        if (bodyCount) {
            break;
        }

    }
    if (!bodyCount) {
        // Make sure no more saving over possible detached with same gnx
        this._bodyLastChangedDocument = undefined;
        this._bodyLastChangedDocumentSaved = false;
    }
    this._leoFileSystem.cleanupBodies();
    this._leoDetachedFileSystem.cleanupDetachedBodies();
}

</t>
<t tx="felix.20240421175450.1">public cleanupBodies(): void {
    const w_foundGnx: string[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME
            ) {
                w_foundGnx.push(utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri));
            }
        });
    });
    if (!w_foundGnx.length) {
        return;
    }
    for (const openBody of Object.keys(this._openedBodiesInfo)) {
        if (!w_foundGnx.includes(openBody)) {
            // Not an opened tab! remove it!

            delete this._openedBodiesInfo[openBody];
        }
    }
}

</t>
<t tx="felix.20240422231239.1">/**
 * Debounced refresh language for all detached bodies of active commander
 */
private _refreshCommanderDetachedLanguage(): void {

    const c = g.app.windowList[this.frameIndex].c;
    const c_id = c.id.toString();
    const w_documents: vscode.TextDocument[] = [];
    const w_uris: string[] = [];

    for (const p_tabGroup of vscode.window.tabGroups.all) {
        for (const p_tab of p_tabGroup.tabs) {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                ((p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_DETACHED_SCHEME)
            ) {
                const [unused, id, gnx] = (p_tab.input as vscode.TabInputText).uri.path.split("/");
                if (id === c_id) {
                    // From same commander
                    if (!w_uris.includes((p_tab.input as vscode.TabInputText).uri.toString())) {
                        w_uris.push((p_tab.input as vscode.TabInputText).uri.toString());
                    }

                }
            }
        }
    }

    for (const w_doc of vscode.workspace.textDocuments) {
        if (!w_doc.isClosed &amp;&amp; w_uris.includes(w_doc.uri.toString())) {
            w_documents.push(w_doc);
        }
    }

    for (const w_doc of w_documents) {
        const w_foundVnode = this._leoDetachedFileSystem.openedBodiesVNodes[utils.leoUriToStr(w_doc.uri)];
        if (w_foundVnode) {
            const gnx = w_foundVnode.gnx;

            for (const p of w_foundVnode.context.all_unique_positions()) {
                if (p.v.gnx === gnx) {
                    let w_language = this._getBodyLanguage(p); // !! 
                    // Set document language only if different
                    if (w_language !== w_doc.languageId) {
                        void this._setBodyLanguage(w_doc, w_language);
                    }
                    break;
                }
            }

        } else {
            console.log('DETACHED VNODE not found when resetting language');
        }
    }

}

</t>
<t tx="felix.20240428224613.1"># 0.2.14

- Fixed import file error when using the 'import any' or other importers.
- Improved 'detached' body panes behavior.
- Fixed the colorization of descendants for nodes with multiple 'language' directives.
- Added context menu to document pane nodes, offering the 'revert' command.
- Fixed the 'refresh-from-disk' command availability.
- Improved some keyboard shortcuts and the related README documentation section.
- Fixed 'reload-setting' command so that it calls the 'reloadSettings' method of subCommanders.
- Implemented the 'write-zip-archive' command.
- Implemented the new find-def command behavior, along with the 'prefer-nav-pane' config setting support.
- Implemented 'execute-general-script' and 'execute-external-file' commands.
- Added language coloring and syntax support for julia, batch and shell languages.
- Implemented most 'edit commands'. (Accessible as 'commands' in the minibuffer or in scripts, etc.)
- Implemented the 'toggle-unl-view' command (Switches the status bar UNL type)

</t>
<t tx="felix.20240518222453.1">/**
 * Close all tabs that are not part of their filesystems
 * * This matches cleanupDetachedBodies from leoBodyDetached !
 */
private _hideBodiesUnknownToFileSys(p_editors: readonly vscode.TextEditor[]): void {
    p_editors.forEach((p_editor) =&gt; {
        if (p_editor) {
            switch (p_editor.document.uri.scheme) {
                case Constants.URI_LEOJS_SCHEME:
                    if (this.bodyUri.fsPath !== p_editor.document.uri.fsPath) {
                        void this._hideDeleteBody(p_editor);
                    }
                    this._checkPreviewMode(p_editor);
                    break;

                case Constants.URI_LEOJS_DETACHED_SCHEME:
                    const w_gnx = utils.leoUriToStr(p_editor.document.uri);
                    //if (!this._leoDetachedFileSystem.watchedBodiesGnx.includes(w_gnx)) {
                    if (!this._leoDetachedFileSystem.openedBodiesVNodes[w_gnx]) {
                        // unknown to the detached filesystem
                        void this._hideDeleteBody(p_editor);
                    }
                    break;

                default:
                    break;
            }

        }

    });
}

</t>
<t tx="felix.20240529234358.1">public showNavResults(): Thenable&lt;unknown&gt; {
    this.leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane({ preserveFocus: true }); // show but dont change focus
}

</t>
<t tx="felix.20240610234327.1">"file/newFile": [
  {
    "command": "leojs.newLeoFile",
    "group": "file"
  }
]
</t>
<t tx="felix.20240617225911.1">public runOpenFilesDialog(
    c: Commands | undefined,
    title: string,
    filetypes: [string, string][],
    defaultExtension: string,
    startpath?: string
): Thenable&lt;string[]&gt; {
    // convert to { [name: string]: string[] } typing
    const types: { [name: string]: string[] } = utils.convertLeoFiletypes(filetypes);
    return vscode.window.showOpenDialog(
        {
            title: title,
            canSelectMany: true,
            filters: types
        }
    ).then((p_uris) =&gt; {
        const names: string[] = [];
        if (p_uris &amp;&amp; p_uris.length) {
            p_uris.forEach(w_uri =&gt; {
                names.push(w_uri.fsPath);
            });
        }
        return names.map((p_name) =&gt; {
            let fileName = g.os_path_fix_drive(p_name);
            fileName = g.os_path_normslashes(fileName);
            return fileName;
        });
    });
}

</t>
<t tx="felix.20240622195331.1"># 0.2.15

- Renamed 'save-file-as-zipped' to 'save-file-as-db'.
- Simplified the find panel's input field placeholder.
- Fixed find panel scrollbars as per VSCode issue #213045.
- Deprecated the 'Goto Panel' by adding tabs to the find panel to separate 'find' and 'nav/tag' search inputs.
- Fixed Ctrl+Shift+F to be quick-find with selected text instead of just focusing on the nav text input.
- Reworked the icons for the 'quick find' commands (dirty-nodes, marked-nodes, reverse-gnx-order, visited-nodes-history and quick-find with selected text) to be graphical symbols instead of latin letters.

</t>
<t tx="felix.20240629151624.1">/**
 * Send the new content of the goto pane to the findPanel.
 */
public setGotoContent(): void {
    const content = this.leoGotoProvider.nodeList.map(
        (gotoNode) =&gt; {
            return {
                "tooltip": gotoNode.tooltip,
                "key": gotoNode.key,
                "entryType": gotoNode.entryType,
                "description": gotoNode.description,
                "label": gotoNode.leoPaneLabel
            };
        }
    );
    if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
        void this._findPanelWebviewExplorerView!.webview.postMessage({ type: 'refreshGoto', gotoContent: content });
    }
    if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
        void this._findPanelWebviewView!.webview.postMessage({ type: 'refreshGoto', gotoContent: content });
    }
}

</t>
<t tx="felix.20240630150534.1">/**
 * Reveals and selects the specific nav entry in the results of the nav pane.
 */
public revealGotoNavEntry(p_index: number, p_preserveFocus?: boolean): void {
    if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
        void this._findPanelWebviewExplorerView!.webview.postMessage({ type: 'revealNavEntry', value: p_index, preserveFocus: p_preserveFocus });
    } else if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
        void this._findPanelWebviewView!.webview.postMessage({ type: 'revealNavEntry', value: p_index, preserveFocus: p_preserveFocus });
    }
}

</t>
<t tx="felix.20240708214046.1">/**
 * Reveal that queues a follow up to prevent revealing before the last one finished.
 */
public safeReveal(tree: vscode.TreeView&lt;Position&gt;, element: Position, options?: {
    select?: boolean;
    focus?: boolean;
    expand?: boolean | number;
}): Thenable&lt;void&gt; {
    if (!this._pendingReveal) {
        // No reveal is currently pending, start the reveal
        this._pendingReveal = this._performReveal(tree, element, options);
        return this._pendingReveal;
    } else {
        // A reveal is already pending, store the parameters for the next reveal
        this._nextRevealParams = { tree, element, options };
        return this._pendingReveal;
    }
}

</t>
<t tx="felix.20240708225108.1">private _performReveal(tree: vscode.TreeView&lt;Position&gt;, element: Position, options?: {
    select?: boolean;
    focus?: boolean;
    expand?: boolean | number;
}): Thenable&lt;void&gt; {
    return tree.reveal(element, options).then(
        () =&gt; this._handleRevealCompletion(),
        (error) =&gt; this._handleRevealCompletion(error)
    );
}

</t>
<t tx="felix.20240708225127.1">private _handleRevealCompletion(error?: any): Thenable&lt;void&gt; | void {
    if (this._nextRevealParams) {
        // If there are queued reveal parameters, start the next reveal
        const { tree, element, options } = this._nextRevealParams;
        this._nextRevealParams = undefined;
        this._pendingReveal = this._performReveal(tree, element, options);
        return this._pendingReveal;
    } else {
        // No more reveals are queued, clear the pending reveal
        this._pendingReveal = undefined;
        if (error) {
            // Propagate the error if there was one
            throw error;
        }
    }
}

</t>
<t tx="fil.20231216220210.1">## 0.2.5

- Fixed regex patterns in 'get_patterns' to support web browser's more unstable support.

</t>
<t tx="fil.20240709150317.1">&lt;!DOCTYPE html&gt;
&lt;html lang="en" tabindex="-1"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; style-src #{webview.cspSource}; script-src 'nonce-#{nonce}';"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;link href="#{style}" rel="stylesheet"&gt;
    &lt;title&gt;Leo Find Panel&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class="tab-container"&gt;
        &lt;ul class="tab-list"&gt;
            &lt;!-- &lt;li class="tab-item active" data-tab="tab1"&gt;Log&lt;/li&gt; --&gt;
            &lt;li class="tab-item active" data-tab="tab2"&gt;Find&lt;/li&gt;
            &lt;li class="tab-item" data-tab="tab3"&gt;Nav&lt;/li&gt;
        &lt;/ul&gt;
        &lt;!-- &lt;div class="tab-content active" id="tab1"&gt;
            &lt;div class="log-pane" contenteditable="true"&gt;

            &lt;/div&gt;
        &lt;/div&gt; --&gt;
        &lt;div class="tab-content active" id="tab2"&gt;
            &lt;div class="input-holder mt-6 mb-6"&gt;
                &lt;input title="Enter or F3 to find and goto the next match&amp;#013;F2 for the previous match" type="text"
                    id="findText" name="findText" placeholder="&lt;find pattern here&gt;"&gt;
            &lt;/div&gt;
            &lt;div class="input-holder mb-6"&gt;
                &lt;input title="Replace (Ctrl+=)&amp;#013;Replace &amp;amp; Find Next (Ctrl+-)" type="text" id="replaceText"
                    name="replaceText" placeholder="&lt;replace pattern here&gt;"&gt;
            &lt;/div&gt;
            &lt;div class="row input-holder bottom-scroll"&gt;
                &lt;div class="col"&gt;
                    &lt;input type="checkbox" id="wholeWord" name="wholeWord"&gt;
                    &lt;label title="Match Whole Word (Ctrl+Alt+W)" class="label-fix" for="wholeWord"&gt;Whole
                        &lt;u&gt;w&lt;/u&gt;ord&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="ignoreCase" name="ignoreCase"&gt;
                    &lt;label title="Matches Ignore Case (Ctrl+Alt+I)" class="label-fix" for="ignoreCase"&gt;&lt;u&gt;I&lt;/u&gt;gnore
                        case&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="regExp" name="regExp"&gt;
                    &lt;label title="Use Regular Expression (Ctrl+Alt+X)" class="label-fix"
                        for="regExp"&gt;Rege&lt;u&gt;x&lt;/u&gt;p&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markFinds" name="markFinds"&gt;
                    &lt;label title="Mark Found nodes (Ctrl+Alt+F)" class="label-fix" for="markFinds"&gt;Mark
                        &lt;u&gt;f&lt;/u&gt;inds&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markChanges" name="markChanges"&gt;
                    &lt;label title="Mark Changed nodes (Ctrl+Alt+C)" class="label-fix" for="markChanges"&gt;Mark
                        &lt;u&gt;c&lt;/u&gt;hanges&lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="col"&gt;
                    &lt;!-- RADIOS --&gt;
                    &lt;input type="radio" id="entireOutline" name="searchScope" value="0"&gt;
                    &lt;label title="Search in Whole Outline (Ctrl+Alt+E)" class="label-fix"
                        for="entireOutline"&gt;&lt;u&gt;E&lt;/u&gt;ntire
                        outline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="subOutlineOnly" name="searchScope" value="1"&gt;
                    &lt;label title="Limit to Selected Outline (Ctrl+Alt+S)" class="label-fix"
                        for="subOutlineOnly"&gt;&lt;u&gt;S&lt;/u&gt;uboutline Only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="nodeOnly" name="searchScope" value="2"&gt;
                    &lt;label title="Limit to Selected Node (Ctrl+Alt+N)" class="label-fix" for="nodeOnly"&gt;&lt;u&gt;N&lt;/u&gt;ode
                        only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="fileOnly" name="searchScope" value="3"&gt;
                    &lt;label title="Limit to External Files (Ctrl+Alt+L)" class="label-fix" for="fileOnly"&gt;Fi&lt;u&gt;l&lt;/u&gt;e
                        only&lt;/label&gt;&lt;br&gt;
                    &lt;!-- CHECKBOXES --&gt;
                    &lt;input type="checkbox" id="searchHeadline" name="searchHeadline"&gt;
                    &lt;label title="Search in Headlines (Ctrl+Alt+H)" class="label-fix" for="searchHeadline"&gt;Search
                        &lt;u&gt;h&lt;/u&gt;eadline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="searchBody" name="searchBody"&gt;
                    &lt;label title="Search in Body Text (Ctrl+Alt+B)" class="label-fix" for="searchBody"&gt;Search
                        &lt;u&gt;b&lt;/u&gt;ody&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="tab-content" id="tab3"&gt;
            &lt;div class="row mb-0 nav-top-section"&gt;
                &lt;div class="col-full input-holder"&gt;
                    &lt;select class="no-overflow" name="searchOptions" id="searchOptions"
                        title="Confine search to:&amp;#013; - All: regular search for all nodes&amp;#013; - Subtree: current node and it's children&amp;#013; - File: only search under a node with an @&lt;file&gt; directive&amp;#013; - Chapter: only search under a node with an @chapter directer&amp;#013; - Node: only search currently selected node"&gt;
                        &lt;option value="0"&gt;All&lt;/option&gt;
                        &lt;option value="1"&gt;Subtree&lt;/option&gt;
                        &lt;option value="2"&gt;File&lt;/option&gt;
                        &lt;option value="3"&gt;Chapter&lt;/option&gt;
                        &lt;option value="4"&gt;Node&lt;/option&gt;
                    &lt;/select&gt;

                    &lt;input type="checkbox" id="isTag" name="isTag"&gt;
                    &lt;label class="label-nav" id="label-isTag" for="isTag"
                        title="Search Tag attributes, set algebra is supported:&amp;#013;&amp;amp; both the given tags&amp;#013;&amp;vert; either of the given tags (or both)&amp;#013;&amp;#45; the first tag, but not the second tag&amp;#013;&amp;#94; either of the given tags (but *not* both)"&gt;Tag&lt;/label&gt;

                    &lt;input type="checkbox" id="showParents" name="showParents"&gt;
                    &lt;label class="label-nav" id="label-show-parents" for="showParents"
                        title="List parents of nodes in text searches"&gt;Show parents&lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="input-holder mb-6"&gt;
                    &lt;input
                        title="Typing searches headlines interactively&amp;#013;Enter freezes input and searches body text"
                        type="text" id="navText" name="navText" placeholder="&lt;nav pattern here&gt;"&gt;
                    &lt;div id="freeze" title="Clear field to unfreeze"&gt;&amp;#x2744;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row bottom-scroll" id="gotopane"&gt;
                &lt;!-- this is the goto pane --&gt;
            &lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id="top-shadow"&gt;&lt;/div&gt;
    &lt;script nonce="#{nonce}" src="#{scriptUri}"&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</t>
<t tx="foo.20240309205342.1"># 0.2.13

- Added new videos to the readme: "Intro to Leo" and "LeoJS Features Demo".
- Fixed icons disabled appearance by changing the graphic format from SVG to a weoff2 font.
- Fixed undo/redo status flags
- Changed behavior of the 'Open Aside' command: it now  opens 'detached' body panes, which allows text editing for a fixed gnx.
- Added common library objects to the scripting global scope:
    - os
    - path
    - Buffer
    - crypto
    - process
    - child_process
- Added 'vscode' API to the scripting global scope. (while  keeping the g.vscode reference for compatibility with old scripts)
- Made more external libraries accessible to scripts via the global 'g' object:
    - dayjs
    - md5
    
</t>
</tnodes>
</leo_file>
