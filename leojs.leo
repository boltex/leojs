<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="felix.20201208214250.2"><vh>Documentation</vh>
<v t="felix.20201208214319.1"><vh>@clean README.md</vh></v>
<v t="felix.20201208214506.1"><vh>@clean CHANGELOG.md</vh></v>
<v t="felix.20201208224703.1"><vh>@clean CONTRIBUTING.md</vh></v>
<v t="felix.20230330224010.1"><vh>@clean BACKERS.md</vh></v>
</v>
<v t="ekr.20201209145358.1"><vh>VSCode extension</vh>
<v t="felix.20211007213344.1"><vh>@clean src/config.ts</vh>
<v t="felix.20211007213344.2"><vh>class Config</vh>
<v t="felix.20211007213344.3"><vh>getConfig</vh></v>
<v t="felix.20211007213344.4"><vh>getFontConfig</vh></v>
<v t="felix.20211007213344.5"><vh>setLeojsSettings</vh></v>
<v t="felix.20211007213344.6"><vh>setFontConfig</vh></v>
<v t="felix.20211007213344.7"><vh>setEnablePreview</vh></v>
<v t="felix.20211007213344.8"><vh>clearCloseEmptyGroups</vh></v>
<v t="felix.20211007213344.10"><vh>checkEnablePreview</vh></v>
<v t="felix.20211007213344.11"><vh>checkCloseEmptyGroups</vh></v>
<v t="felix.20231127195758.1"><vh>setConfirmBeforeClose</vh></v>
<v t="felix.20211007213344.13"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20201214151326.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20201214151326.2"><vh>class Constants</vh>
<v t="felix.20201214151326.3"><vh>general constants</vh></v>
<v t="felix.20201214151326.4"><vh>workbench interface panels</vh></v>
<v t="felix.20201214151326.5"><vh>user messages</vh></v>
<v t="felix.20211008004139.1"><vh>find panel ids</vh></v>
<v t="felix.20201214151326.6"><vh>at-buttons strings</vh></v>
<v t="felix.20211007214102.1"><vh>configuration keys</vh></v>
<v t="felix.20211007214110.1"><vh>config defaults</vh></v>
<v t="felix.20230905212324.1"><vh>history quickItem</vh></v>
<v t="felix.20201214151326.7"><vh>ask/save buttons</vh></v>
<v t="felix.20201214151326.8"><vh>context flags</vh></v>
<v t="felix.20201214151326.9"><vh>vscode commands</vh></v>
<v t="felix.20220923003944.1"><vh>body language code strings</vh></v>
<v t="felix.20201214151326.10"><vh>commands strings</vh></v>
<v t="felix.20201214151326.11"><vh>leo commands</vh></v>
<v t="felix.20221009233703.1"><vh>keep-selection old position offsets</vh></v>
<v t="felix.20220103222715.1"><vh>minibuffer overridden names</vh></v>
</v>
</v>
<v t="felix.20201208214322.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20201214150149.1"><vh>activate</vh></v>
<v t="felix.20221005002719.1"><vh>setStartupDoneContext</vh></v>
<v t="felix.20220523151725.1"><vh>setScheme</vh></v>
<v t="felix.20220523140004.1"><vh>runLeo</vh></v>
<v t="felix.20201208215619.1"><vh>deactivate</vh></v>
<v t="felix.20221002011858.1"><vh>closeLeoTextEditors</vh></v>
<v t="felix.20221002011903.1"><vh>showWelcomeIfNewer</vh></v>
</v>
<v t="felix.20211010192923.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20211010192923.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20211010192923.3"><vh>setNewBodyUriTime</vh></v>
<v t="felix.20221130233817.1"><vh>_setOpenedBodyTime</vh></v>
<v t="felix.20211010192923.4"><vh>fireRefreshFile</vh></v>
<v t="felix.20211010192923.5"><vh>refreshPossibleGnxList</vh></v>
<v t="felix.20211010192923.6"><vh>watch</vh></v>
<v t="felix.20211010192923.7"><vh>stat</vh></v>
<v t="felix.20211010192923.8"><vh>readFile</vh></v>
<v t="felix.20211010192923.9"><vh>readDirectory</vh></v>
<v t="felix.20211010192923.10"><vh>createDirectory</vh></v>
<v t="felix.20211010192923.11"><vh>writeFile</vh></v>
<v t="felix.20211010192923.12"><vh>rename</vh></v>
<v t="felix.20211010192923.13"><vh>delete</vh></v>
<v t="felix.20211010192923.14"><vh>copy</vh></v>
<v t="felix.20211010192923.15"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20201208223553.1"><vh>@clean src/leoOutline.ts</vh>
<v t="felix.20201209011931.1"><vh>class LeoOutlineProvider</vh>
<v t="felix.20201209011931.2"><vh>constructor</vh></v>
<v t="felix.20201209011931.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20211003223641.1"><vh>buildId</vh></v>
<v t="felix.20211003233639.1"><vh>incTreeId</vh></v>
<v t="felix.20201209011931.4"><vh>getTreeItem</vh></v>
<v t="felix.20201209011931.5"><vh>getChildren</vh></v>
<v t="felix.20201209011931.6"><vh>getParent</vh></v>
<v t="felix.20220519232002.1"><vh>resolveTreeItem</vh></v>
</v>
<v t="felix.20211201001847.1"><vh>class LeoNode</vh></v>
</v>
<v t="felix.20201214194144.1"><vh>@clean src/leoUI.ts</vh>
<v t="felix.20201214195752.1"><vh>class LeoUI</vh>
<v t="felix.20201214194144.2"><vh>Constructor</vh></v>
<v t="felix.20220201235548.1"><vh>Finish Startup</vh></v>
<v t="felix.20220417215549.1"><vh>makeAllBindings</vh></v>
<v t="felix.20221113002623.1"><vh>showSettings</vh></v>
<v t="felix.20220920001018.1"><vh>Log Pane</vh>
<v t="felix.20220920001018.2"><vh>addLogPaneEntry</vh></v>
<v t="felix.20220920001018.3"><vh>showLogPane</vh></v>
<v t="felix.20220920001202.1"><vh>hideLogPane</vh></v>
</v>
<v t="felix.20201214194144.3"><vh>Document States</vh>
<v t="felix.20201214202058.1"><vh>_triggerGetStates</vh></v>
<v t="felix.20201227230901.1"><vh>_setupNoOpenedLeoDocument</vh></v>
<v t="felix.20201227230912.1"><vh>_setupOpenedLeoDocument</vh></v>
</v>
<v t="felix.20201214194144.5"><vh>UI Change Events</vh>
<v t="felix.20200719025231.24"><vh>_onChangeConfiguration</vh></v>
<v t="felix.20220930212953.1"><vh>_onDidOpenTextDocument</vh></v>
<v t="felix.20201214202625.1"><vh>_onChangeCollapsedState</vh></v>
<v t="felix.20201214202627.1"><vh>_onTreeViewVisibilityChanged</vh></v>
<v t="felix.20201214202631.1"><vh>_onDocTreeViewVisibilityChanged</vh></v>
<v t="felix.20201214202634.1"><vh>_onButtonsTreeViewVisibilityChanged</vh></v>
<v t="felix.20220930214434.1"><vh>_onGotoTreeViewVisibilityChanged</vh></v>
<v t="felix.20211122230343.1"><vh>_onUndosTreeViewVisibilityChanged</vh></v>
<v t="felix.20220930214530.1"><vh>_onFindViewVisibilityChanged</vh></v>
<v t="felix.20220930214929.1"><vh>_onActiveEditorChanged</vh></v>
<v t="felix.20220930214943.1"><vh>_changedTextEditorViewColumn</vh></v>
<v t="felix.20220930214948.1"><vh>_changedVisibleTextEditors</vh></v>
<v t="felix.20220930214953.1"><vh>_changedWindowState</vh></v>
<v t="felix.20220930214959.1"><vh>_onChangeEditorSelection</vh></v>
<v t="felix.20220930215005.1"><vh>_onChangeEditorScroll</vh></v>
<v t="felix.20220930215012.1"><vh>_onDocumentChanged</vh></v>
<v t="felix.20220930215020.1"><vh>setFindPanel</vh></v>
<v t="felix.20221101220727.1"><vh>refreshDesc</vh></v>
<v t="felix.20231127210614.1"><vh>checkConfirmBeforeClose</vh></v>
</v>
<v t="felix.20211204144931.1"><vh>Body Editing</vh>
<v t="felix.20211204144931.2"><vh>triggerBodySave</vh></v>
<v t="felix.20211204144931.3"><vh>_bodySaveSelection</vh></v>
<v t="felix.20211204144931.4"><vh>_bodySaveDocument</vh></v>
<v t="felix.20211204144931.5"><vh>_bodySaveDeactivate</vh></v>
</v>
<v t="felix.20201214194144.4"><vh>Refresh UI</vh>
<v t="felix.20220725004247.1"><vh>_setTreeViewTitle</vh></v>
<v t="felix.20201214202118.1"><vh>showOutline</vh></v>
<v t="felix.20211007232334.1"><vh>configTreeRefresh</vh></v>
<v t="felix.20201227155008.1"><vh>_setupRefresh</vh></v>
<v t="felix.20201227014627.1"><vh>_launchRefresh</vh></v>
<v t="felix.20220923001725.1"><vh>fullRefresh</vh></v>
<v t="felix.20220923001235.1"><vh>isTsStillValid</vh></v>
<v t="felix.20201222013904.1"><vh>_refreshOutline</vh></v>
<v t="felix.20220922235942.1"><vh>_revealNode</vh></v>
<v t="felix.20201229025520.1"><vh>gotSelectedNode</vh></v>
<v t="felix.20201214202123.1"><vh>_refreshDocumentsPane</vh></v>
<v t="felix.20221001002338.1"><vh>_refreshButtonsPane</vh></v>
<v t="felix.20221113221607.1"><vh>_refreshGotoPane</vh></v>
<v t="felix.20211124223735.1"><vh>_refreshUndoPane</vh></v>
</v>
<v t="felix.20220922000450.1"><vh>Body Pane Management</vh>
<v t="felix.20220922000450.2"><vh>_tryApplyNodeToBody</vh></v>
<v t="felix.20220922000450.3"><vh>_switchBody</vh></v>
<v t="felix.20220922000450.4"><vh>_locateOpenedBody</vh></v>
<v t="felix.20220922000450.5"><vh>_isBodyVisible</vh></v>
<v t="felix.20220922000450.6"><vh>_isBodyPreview</vh></v>
<v t="felix.20220922000450.7"><vh>isOutlineVisible</vh></v>
<v t="felix.20220922000450.8"><vh>_hideDeleteBody</vh></v>
<v t="felix.20220922000450.9"><vh>_checkPreviewMode</vh></v>
<v t="felix.20220922000450.10"><vh>closeBody</vh></v>
<v t="felix.20220922000450.11"><vh>cleanupBody</vh></v>
<v t="felix.20220922000450.12"><vh>showBody</vh></v>
<v t="felix.20230112203533.1"><vh>_row_col_pv_dict</vh></v>
<v t="felix.20230112220003.1"><vh>_row_col_wrapper_dict</vh></v>
<v t="felix.20221214003903.1"><vh>_getBodyLanguage</vh></v>
<v t="felix.20220922000450.13"><vh>_setBodyLanguage</vh></v>
<v t="felix.20220922000450.14"><vh>refreshBodyStates</vh></v>
<v t="felix.20220922000450.15"><vh>debouncedRefreshBodyStates</vh></v>
</v>
<v t="felix.20201214194144.6"><vh>Commands</vh>
<v t="felix.20201214202749.1"><vh>selectTreeNode</vh></v>
<v t="felix.20201214202755.1"><vh>command</vh></v>
<v t="felix.20201214202757.1"><vh>minibuffer</vh></v>
<v t="felix.20221002124249.1"><vh>_showMinibufferHistory</vh></v>
<v t="felix.20221002124535.1"><vh>_doMinibufferCommand</vh></v>
<v t="felix.20230222212520.1"><vh>_addToMinibufferHistory</vh></v>
<v t="felix.20231029213146.1"><vh>_showHeadlineInputBox</vh></v>
<v t="felix.20201214202759.1"><vh>editHeadline</vh></v>
<v t="felix.20201214202800.1"><vh>insertNode</vh></v>
<v t="felix.20211204181418.1"><vh>_insertAndSetHeadline</vh></v>
</v>
<v t="felix.20211024012536.1"><vh>Clipboard</vh>
<v t="felix.20211212205241.1"><vh>replaceClipboardWith</vh></v>
<v t="felix.20220103203600.1"><vh>asyncGetTextFromClipboard</vh></v>
<v t="felix.20211024012523.1"><vh>getTextFromClipboard</vh></v>
</v>
<v t="felix.20220505215916.1"><vh>Nav</vh>
<v t="felix.20221206201231.1"><vh>goAnywhere</vh></v>
<v t="felix.20220505215916.2"><vh>findQuick</vh></v>
<v t="felix.20220505215916.3"><vh>findQuickSelected</vh></v>
<v t="felix.20220505215916.4"><vh>findQuickTimeline</vh></v>
<v t="felix.20220505215916.5"><vh>findQuickChanged</vh></v>
<v t="felix.20220505215916.6"><vh>findQuickHistory</vh></v>
<v t="felix.20220505215916.7"><vh>findQuick_marked</vh></v>
<v t="felix.20220505215916.8"><vh>showGotoPane</vh></v>
<v t="felix.20220505215916.9"><vh>gotoNavEntry</vh></v>
<v t="felix.20221027155905.1"><vh>navigateNavEntry</vh></v>
</v>
<v t="felix.20220505215924.1"><vh>Search</vh>
<v t="felix.20221227223718.1"><vh>_get_focus</vh></v>
<v t="felix.20220505215924.2"><vh>navEnter</vh></v>
<v t="felix.20220505215924.3"><vh>navTextChange</vh></v>
<v t="felix.20221222003636.1"><vh>navTextClear</vh></v>
<v t="felix.20220505215924.4"><vh>startSearch</vh></v>
<v t="felix.20220930222931.1"><vh>checkForceFindFocus</vh></v>
<v t="felix.20220505215924.6"><vh>_inputFindPattern</vh></v>
<v t="felix.20220505215924.7"><vh>find</vh></v>
<v t="felix.20220505215924.8"><vh>findSymbol</vh></v>
<v t="felix.20220505215924.9"><vh>replace &amp; replaceThenFind</vh></v>
<v t="felix.20230121211548.1"><vh>interactiveSearch</vh></v>
<v t="felix.20220505215924.12"><vh>setSearchOption</vh></v>
<v t="felix.20220505215924.13"><vh>loadSearchSettings</vh></v>
<v t="felix.20220505215924.14"><vh>saveSearchSettings</vh></v>
</v>
<v t="felix.20201214194144.8"><vh>Leo Documents</vh>
<v t="felix.20220930215434.1"><vh>setDocumentSelection</vh></v>
<v t="felix.20230820145332.1"><vh>tabCycle</vh></v>
<v t="felix.20220517002104.1"><vh>newLeoFile</vh></v>
<v t="felix.20201214211830.1"><vh>closeLeoFile</vh></v>
<v t="felix.20201214211832.1"><vh>openLeoFile</vh></v>
<v t="felix.20201214211834.1"><vh>showRecentLeoFiles</vh></v>
<v t="felix.20201214211835.1"><vh>saveAsLeoFile</vh></v>
<v t="felix.20211012233514.1"><vh>saveAsLeoJsFile</vh></v>
<v t="felix.20201214211836.1"><vh>saveLeoFile</vh></v>
<v t="felix.20201214211837.1"><vh>switchLeoFile</vh></v>
<v t="felix.20201214211839.1"><vh>selectOpenedLeoDocument</vh></v>
</v>
<v t="felix.20201214194144.7"><vh>At Buttons</vh>
<v t="felix.20201214211742.1"><vh>clickAtButton</vh></v>
<v t="felix.20220517212706.1"><vh>_handleRClicks</vh></v>
<v t="felix.20220517212718.1"><vh>gotoScript</vh></v>
<v t="felix.20201214211744.1"><vh>removeAtButton</vh></v>
</v>
<v t="felix.20220930215533.1"><vh>Undos</vh>
<v t="felix.20220930215747.1"><vh>revertToUndo</vh></v>
<v t="felix.20220930215540.1"><vh>_setUndoSelection</vh></v>
</v>
<v t="felix.20211030165058.1"><vh>GUI Wrappers &amp; Helpers</vh>
<v t="felix.20220201230041.1"><vh>showLeoIDMessage</vh></v>
<v t="felix.20221106230554.1"><vh>show_find_success</vh></v>
<v t="felix.20220201225503.1"><vh>LeoGui.ensure_commander_visible</vh></v>
<v t="felix.20220201194319.1"><vh>setLeoIDCommand</vh></v>
<v t="felix.20220131235418.1"><vh>getIdFromSetting</vh></v>
<v t="felix.20220131234257.1"><vh>setIdSetting</vh></v>
<v t="felix.20221027153815.1"><vh>widget_name</vh></v>
<v t="felix.20221026222034.1"><vh>set_focus</vh></v>
<v t="felix.20221026222040.1"><vh>get_focus</vh></v>
<v t="felix.20230109233134.1"><vh>focus_to_body</vh></v>
<v t="felix.20230109233154.1"><vh>focus_to_head</vh></v>
<v t="felix.20221115230034.1"><vh>get1Arg</vh></v>
<v t="felix.20220613164517.1"><vh>runAboutLeoDialog</vh></v>
<v t="felix.20220108211750.1"><vh>runAskOkDialog</vh></v>
<v t="felix.20220109220155.1"><vh>runAskYesNoDialog</vh></v>
<v t="felix.20220516005841.1"><vh>runAskYesNoCancelDialog</vh></v>
<v t="felix.20220107223824.1"><vh>runOpenFileDialog</vh></v>
<v t="felix.20220108211806.1"><vh>runSaveFileDialog</vh></v>
<v t="felix.20231120232158.1"><vh>destroySelf</vh></v>
</v>
</v>
</v>
<v t="felix.20201214151419.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20201214151419.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20201214151419.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20201214151419.4"><vh>getTreeItem</vh></v>
<v t="felix.20201214151419.5"><vh>getChildren</vh></v>
<v t="felix.20201214151419.6"><vh>getParent</vh></v>
</v>
<v t="felix.20201214151425.2"><vh>class LeoButtonNode</vh>
<v t="felix.20201214151425.3"><vh>iconPath</vh></v>
<v t="felix.20201214151425.4"><vh>id</vh></v>
<v t="felix.20201214151425.5"><vh>tooltip</vh></v>
<v t="felix.20201214151425.6"><vh>description</vh></v>
</v>
</v>
<v t="felix.20201214151429.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20201214151429.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20201214151429.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20201214151429.4"><vh>getTreeItem</vh></v>
<v t="felix.20201214151429.5"><vh>getChildren</vh></v>
<v t="felix.20201214151429.6"><vh>getParent</vh></v>
</v>
<v t="felix.20201214151434.2"><vh>class LeoDocumentNode</vh></v>
</v>
<v t="felix.20220505221929.1"><vh>@clean src/leoGoto.ts</vh>
<v t="felix.20220505222045.1"><vh>class LeoGotoProvider</vh></v>
<v t="felix.20220505222101.1"><vh>class LeoGotoNode</vh></v>
</v>
<v t="felix.20211122205011.1"><vh>@clean src/leoUndos.ts</vh>
<v t="felix.20211122205031.1"><vh>class LeoUndosProvider</vh>
<v t="felix.20211122213012.1"><vh>refreshTreeRoot</vh></v>
<v t="felix.20211122213023.1"><vh>getTreeItem</vh></v>
<v t="felix.20211122214230.1"><vh>getChildren</vh></v>
<v t="felix.20211122213037.1"><vh>getParent</vh></v>
<v t="felix.20220520011951.1"><vh>resolveTreeItem</vh></v>
</v>
<v t="felix.20211122212823.1"><vh>class LeoUndoNode</vh></v>
</v>
<v t="felix.20201214151447.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20201214151447.2"><vh>class LeoStates</vh>
<v t="felix.20201214151447.3"><vh>General State Flags</vh>
<v t="felix.20221004234249.1"><vh>leojsStartupDone &amp; helper</vh></v>
<v t="felix.20201214233119.1"><vh>leoReady &amp; helper</vh></v>
<v t="felix.20201214151447.4"><vh>fileOpenedReady &amp; helper</vh></v>
<v t="felix.20201214151447.5"><vh>leoOpenedFileName</vh></v>
<v t="felix.20201214151447.6"><vh>leoChanged &amp; helper</vh></v>
<v t="felix.20201214151447.7"><vh>leoCanUndo &amp; helper</vh></v>
<v t="felix.20201214151447.8"><vh>leoCanRedo &amp; helper</vh></v>
<v t="felix.20220508201944.1"><vh>leoCanGoBack &amp; helper</vh></v>
<v t="felix.20220508201944.2"><vh>leoCanGoNext &amp; helper</vh></v>
<v t="felix.20201214151447.9"><vh>leoCanDemote &amp; helper</vh></v>
<v t="felix.20201214151447.10"><vh>leoCanPromote &amp; helper</vh></v>
<v t="felix.20201214151447.11"><vh>leoCanDehoist &amp; helper</vh></v>
<v t="felix.20230403223923.1"><vh>leoTopHoistChapter &amp; helper</vh></v>
<v t="felix.20231030200350.1"><vh>leoEditHeadline &amp; helper</vh></v>
</v>
<v t="felix.20201214151447.12"><vh>Selected Node Flags</vh>
<v t="felix.20201214151447.13"><vh>leoMarked</vh></v>
<v t="felix.20201214151447.14"><vh>leoCloned</vh></v>
<v t="felix.20201214151447.15"><vh>leoDirty</vh></v>
<v t="felix.20201214151447.16"><vh>leoEmpty</vh></v>
<v t="felix.20201214151447.17"><vh>leoChild</vh></v>
<v t="felix.20201214151447.18"><vh>leoAtFile</vh></v>
<v t="felix.20201214151447.19"><vh>leoRoot</vh></v>
</v>
<v t="felix.20201214151447.20"><vh>constructor</vh></v>
<v t="felix.20201214151447.21"><vh>selectedNodeFlags</vh></v>
<v t="felix.20201214151447.22"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20201214151451.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20201214151451.2"><vh>class LeoStatusBar</vh>
<v t="felix.20201214151451.3"><vh>show</vh></v>
<v t="felix.20201214151451.4"><vh>hide</vh></v>
<v t="felix.20201214151451.5"><vh>setString</vh></v>
<v t="felix.20201214151451.6"><vh>update</vh></v>
<v t="felix.20201214151451.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20201214151451.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20201214154816.1"><vh>@clean src/types.ts</vh>
<v t="felix.20211007213900.1"><vh>ConfigMembers</vh></v>
<v t="felix.20211007213909.1"><vh>ConfigSetting</vh></v>
<v t="felix.20211007213915.1"><vh>FontSettings</vh></v>
<v t="felix.20220922215553.1"><vh>Focus</vh></v>
<v t="felix.20201214154816.3"><vh>RevealType</vh></v>
<v t="felix.20201214154816.4"><vh>ReqRefresh</vh></v>
<v t="felix.20221009011653.1"><vh>CommandOptions</vh></v>
<v t="felix.20211010221959.1"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201214154816.7"><vh>LeoPackageStates</vh></v>
<v t="felix.20201214154816.8"><vh>LeoDocument</vh></v>
<v t="felix.20201214154816.9"><vh>LeoButton</vh></v>
<v t="felix.20220505220527.1"><vh>TGotoTypes</vh></v>
<v t="felix.20220505220532.1"><vh>LeoGoto</vh></v>
<v t="felix.20221027155442.1"><vh>LeoGotoNavKey</vh></v>
<v t="felix.20220505220537.1"><vh>LeoSearchScope</vh></v>
<v t="felix.20220505220544.1"><vh>LeoSearchSettings</vh></v>
<v t="felix.20220505220550.1"><vh>LeoGuiFindTabManagerSettings</vh></v>
<v t="felix.20201214154816.10"><vh>Icon</vh></v>
<v t="felix.20220505220619.1"><vh>BodyTimeInfo</vh></v>
<v t="felix.20220505220626.1"><vh>BodyPosition</vh></v>
<v t="felix.20220505220630.1"><vh>BodySelectionInfo</vh></v>
<v t="felix.20201214154816.11"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20201214154816.12"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20201214154816.13"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20201214154816.14"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20201214154816.15"><vh>AskMessageItem</vh></v>
<v t="felix.20201214154816.16"><vh>ChooseDocumentItem</vh></v>
<v t="felix.20220505220706.1"><vh>ChooseRClickItem</vh></v>
<v t="felix.20201214154816.17"><vh>MinibufferCommand</vh></v>
</v>
<v t="felix.20210110210346.1"><vh>@clean src/declarations.d.ts</vh></v>
<v t="felix.20201208224407.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20220929001102.1"><vh>performanceNow</vh></v>
<v t="felix.20220505225030.1"><vh>uniqueId</vh></v>
<v t="felix.20220505225023.1"><vh>getUniqueId</vh></v>
<v t="felix.20230315215040.1"><vh>getOnce</vh></v>
<v t="felix.20201208224407.2"><vh>padNumber2</vh></v>
<v t="felix.20201208224407.4"><vh>addFileToGlobal</vh></v>
<v t="felix.20201208224407.5"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20201208224407.6"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20201208224407.7"><vh>buildDocumentIconPaths</vh></v>
<v t="felix.20221027230322.1"><vh>buildUndoIconPaths</vh></v>
<v t="felix.20201208224407.8"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20220505225236.1"><vh>buildGotoIconPaths</vh></v>
<v t="felix.20220109180351.1"><vh>convertLeoFiletypes</vh></v>
<v t="felix.20201208224407.10"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20230416212643.1"><vh>getDurationSeconds</vh></v>
<v t="felix.20201208224407.11"><vh>getFileFromPath</vh></v>
<v t="felix.20220417151556.1"><vh>getIdFromDialog</vh></v>
<v t="felix.20220201195806.1"><vh>isAlphaNumeric</vh></v>
<v t="felix.20201208224407.12"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20211007214455.1"><vh>isHexColor</vh></v>
<v t="felix.20201208224407.14"><vh>strToLeoUri</vh></v>
<v t="felix.20201208224407.15"><vh>leoUriToStr</vh></v>
<v t="felix.20201208224407.16"><vh>setContext</vh></v>
</v>
<v t="felix.20220417155704.1"><vh>@clean src/commandBindings.ts</vh>
<v t="felix.20220417155732.1"><vh>makeAllBindings</vh>
<v t="felix.20201214150149.2"><vh>&lt;&lt; Define entries for all commands &gt;&gt;</vh>
<v t="felix.20201214150149.15"><vh>Show UI panes</vh></v>
<v t="felix.20201214150149.3"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20201214150149.4"><vh>Leo File Documents</vh></v>
<v t="felix.20221114220040.1"><vh>Import Export Files</vh></v>
<v t="felix.20201214150149.5"><vh>Headline Editing</vh></v>
<v t="felix.20201214150149.6"><vh>Node Editing</vh></v>
<v t="felix.20201214150149.7"><vh>Tree View Interaction</vh></v>
<v t="felix.20201214150149.8"><vh>Goto Nodes</vh></v>
<v t="felix.20201214150149.9"><vh>Hoisting</vh></v>
<v t="felix.20201214150149.10"><vh>Outline Editing</vh></v>
<v t="felix.20201214150149.11"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214150149.12"><vh>Body Editing</vh></v>
<v t="felix.20201214150149.13"><vh>Move Nodes</vh></v>
<v t="felix.20201214150149.14"><vh>Undo</vh></v>
<v t="felix.20201214150149.16"><vh>Marked Nodes Commands</vh></v>
<v t="felix.20230121212426.1"><vh>History Commands</vh></v>
<v t="felix.20230121212438.1"><vh>Search and Tag Commands</vh></v>
<v t="felix.20201214150149.17"><vh>Clone Find Commands</vh></v>
<v t="felix.20220917013425.1"><vh>Config Set Recommended</vh></v>
</v>
</v>
</v>
<v t="felix.20201214205159.1"><vh>@clean package.json</vh>
<v t="felix.20201214205159.2"><vh>&lt;&lt; contributes &gt;&gt;</vh>
<v t="felix.20211006225245.1"><vh>configuration</vh></v>
<v t="felix.20201214205159.3"><vh>viewsContainers</vh></v>
<v t="felix.20201214205159.4"><vh>views</vh></v>
<v t="felix.20220918234128.1"><vh>languages</vh></v>
<v t="felix.20220918234147.1"><vh>grammars</vh></v>
<v t="felix.20220918234152.1"><vh>snippets</vh></v>
<v t="felix.20201214205159.5"><vh>viewsWelcome</vh></v>
<v t="felix.20201214205159.6"><vh>commands</vh>
<v t="felix.20201214205159.9"><vh>Show UI Panes</vh></v>
<v t="felix.20201214205159.8"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20201214205159.10"><vh>Leo File Documents</vh></v>
<v t="felix.20221114213948.1"><vh>Import Export Files</vh></v>
<v t="felix.20201214205159.11"><vh>Tree View</vh></v>
<v t="felix.20201214205159.12"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.13"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.14"><vh>Node Editing</vh></v>
<v t="felix.20201214205159.15"><vh>Body Editing</vh></v>
<v t="felix.20201214205159.16"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.17"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.18"><vh>Goto Nodes</vh></v>
<v t="felix.20221108222157.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20201214205159.20"><vh>Undo/Redo</vh></v>
<v t="felix.20221113232048.1"><vh>Search</vh></v>
<v t="felix.20221113232519.1"><vh>Tags</vh></v>
<v t="felix.20221113232103.1"><vh>Nav</vh></v>
</v>
<v t="felix.20201214205159.23"><vh>menus</vh>
<v t="felix.20201214205159.24"><vh>commandPalette</vh>
<v t="felix.20201214205159.42"><vh>Scripting &amp; @Buttons</vh></v>
<v t="felix.20201214205159.44"><vh>Leo File Documents</vh></v>
<v t="felix.20201214205159.45"><vh>Tree View</vh></v>
<v t="felix.20201214205159.46"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.47"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.48"><vh>Node Editing</vh></v>
<v t="felix.20201214205159.49"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.50"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.51"><vh>Goto Nodes</vh></v>
<v t="felix.20201214205159.52"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20221115220743.1"><vh>Search</vh></v>
<v t="felix.20201214205159.53"><vh>Undo/Redo</vh></v>
</v>
<v t="felix.20201214205159.54"><vh>explorer/context</vh></v>
<v t="felix.20221112230919.1"><vh>editor/title</vh></v>
<v t="felix.20221113165005.1"><vh>editor/context</vh></v>
<v t="felix.20201214205159.55"><vh>view/title</vh></v>
<v t="felix.20201214205159.56"><vh>view/item/context</vh>
<v t="felix.20220517202245.1"><vh>leo documents commands</vh></v>
<v t="felix.20201214205159.57"><vh>Headline Editing Hover Icon</vh></v>
<v t="felix.20201214205159.58"><vh>Insert Node Hover Icon</vh></v>
<v t="felix.20201214205159.60"><vh>Outline Editing Hover Icon</vh></v>
<v t="felix.20201214205159.61"><vh>Mark/Unmark Hover Icon</vh></v>
<v t="felix.20201214205159.62"><vh>Tree View Interaction Context Menu</vh></v>
<v t="felix.20201214205159.63"><vh>Hoisting Context Menu</vh></v>
<v t="felix.20201214205159.64"><vh>Leo File Documents Context Menu</vh></v>
<v t="felix.20201214205159.65"><vh>Mark/Unmark Context Menu</vh></v>
<v t="felix.20230305205014.1"><vh>Tagging Context Menu</vh></v>
<v t="felix.20201214205159.66"><vh>Outline Editing Context Menu</vh></v>
<v t="felix.20220517203332.1"><vh>at buttons</vh></v>
<v t="felix.20221213210705.1"><vh>undos</vh></v>
</v>
</v>
<v t="felix.20201214205159.67"><vh>keybindings</vh>
<v t="felix.20201214205159.68"><vh>Scripting &amp; @Buttons</vh></v>
<v t="felix.20201214205159.69"><vh>Show UI Panes</vh></v>
<v t="felix.20201214205159.70"><vh>Leo File Documents</vh></v>
<v t="felix.20201214205159.71"><vh>Tree View Interaction</vh></v>
<v t="felix.20201214205159.72"><vh>Headline Editing</vh></v>
<v t="felix.20201214205159.73"><vh>Mark/Unmark</vh></v>
<v t="felix.20201214205159.74"><vh>Body Editing</vh></v>
<v t="felix.20201214205159.75"><vh>Move Nodes</vh></v>
<v t="felix.20201214205159.76"><vh>Outline Editing</vh></v>
<v t="felix.20201214205159.77"><vh>Node Editing</vh></v>
<v t="felix.20211117232843.1"><vh>Undo/Redo</vh></v>
<v t="felix.20221115214948.1"><vh>Search</vh></v>
<v t="felix.20201214205159.78"><vh>Goto Nodes</vh></v>
<v t="felix.20221207231723.1"><vh>VSCode Commands</vh></v>
</v>
<v t="felix.20211119001637.1"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="felix.20201214205159.79"><vh>&lt;&lt; scripts &gt;&gt;</vh></v>
<v t="felix.20201214205159.80"><vh>&lt;&lt; devDependencies &gt;&gt;</vh></v>
<v t="felix.20201214205159.81"><vh>&lt;&lt; dependencies &gt;&gt;</vh></v>
</v>
</v>
<v t="felix.20210102000055.1"><vh>Leo</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="felix.20210102000100.1"><vh>Core classes</vh>
<v t="felix.20211018202009.1"><vh>@file src/core/decorators.ts</vh></v>
<v t="felix.20230509194418.1"><vh>@file src/core/idle_time.ts</vh></v>
<v t="felix.20210102012334.1"><vh>@file src/core/leoApp.ts</vh></v>
<v t="felix.20211211234842.1"><vh>@file src/core/leoAtFile.ts</vh></v>
<v t="felix.20230802145823.1"><vh>@file src/core/leoCache.ts</vh></v>
<v t="felix.20220429005433.1"><vh>@file src/core/leoChapters.ts</vh></v>
<v t="felix.20210110222544.1"><vh>@file src/core/leoCommands.ts</vh></v>
<v t="felix.20230430023337.1"><vh>@file src/core/leoCompare.ts</vh></v>
<v t="felix.20211031230132.1"><vh>@file src/core/leoConfig.ts</vh></v>
<v t="felix.20211212162008.1"><vh>@file src/core/leoExternalFiles.ts</vh></v>
<v t="felix.20210220181245.1"><vh>@file src/core/leoFileCommands.ts</vh></v>
<v t="felix.20210102012410.1"><vh>@file src/core/leoGlobals.ts</vh></v>
<v t="felix.20211021231651.1"><vh>@file src/core/leoHistory.ts</vh></v>
<v t="felix.20220105221256.1"><vh>@file src/core/leoImport.ts</vh></v>
<v t="felix.20210102012632.1"><vh>@file src/core/leoNodes.ts</vh></v>
<v t="felix.20230420210348.1"><vh>@file src/core/leoPersistence.ts</vh></v>
<v t="felix.20230427003032.1"><vh>@file src/core/leoRst.ts</vh></v>
<v t="felix.20231003002131.1"><vh>@file src/core/leoSessions.ts</vh></v>
<v t="felix.20211212162359.1"><vh>@file src/core/leoShadow.ts</vh></v>
<v t="felix.20211026230613.1"><vh>@file src/core/leoUndo.ts</vh></v>
<v t="felix.20230924174338.1"><vh>@file src/core/mod_scripting.ts</vh></v>
<v t="felix.20221019001448.1"><vh>@file src/core/nodeTags.ts</vh></v>
<v t="felix.20221105221426.1"><vh>@file src/core/quicksearch.ts</vh></v>
</v>
<v t="felix.20211002194716.1"><vh>Command classes</vh>
<v t="felix.20221220233857.1"><vh>@file src/commands/baseCommands.ts</vh></v>
<v t="felix.20220414231314.1"><vh>@file src/commands/commanderEditCommands.ts</vh></v>
<v t="felix.20211017230407.1"><vh>@file src/commands/commanderFileCommands.ts</vh></v>
<v t="felix.20220612234816.1"><vh>@file src/commands/commanderHelpCommands.ts</vh></v>
<v t="felix.20211002221425.1"><vh>@file src/commands/commanderOutlineCommands.ts</vh></v>
<v t="felix.20220503003653.1"><vh>@file src/commands/editCommands.ts</vh></v>
<v t="felix.20211212162627.1"><vh>@file src/commands/editFileCommands.ts</vh></v>
<v t="felix.20220503003725.1"><vh>@file src/commands/gotoCommands.ts</vh></v>
</v>
<v t="felix.20221119204248.1"><vh>Gui base classes</vh>
<v t="felix.20221109235435.1"><vh>@file src/core/findTabManager.ts</vh></v>
<v t="felix.20211212000140.1"><vh>@file src/core/leoFind.ts</vh></v>
<v t="felix.20220512205042.1"><vh>@file src/core/leoFrame.ts</vh></v>
<v t="felix.20221119204422.1"><vh>@file src/core/leoGui.ts</vh></v>
</v>
<v t="felix.20230505220205.1"><vh>Importer plugins</vh>
<v t="felix.20230522010520.1"><vh>@file src/importers/base_importer.ts</vh></v>
<v t="felix.20230911193725.1"><vh>@file src/importers/c.ts</vh></v>
<v t="felix.20230912201234.1"><vh>@file src/importers/coffeescript.ts</vh></v>
<v t="felix.20230912201323.1"><vh>@file src/importers/csharp.ts</vh></v>
<v t="felix.20230912201336.1"><vh>@file src/importers/cython.ts</vh></v>
<v t="felix.20230912221938.1"><vh>@file src/importers/dart.ts</vh></v>
<v t="felix.20230912223458.1"><vh>@file src/importers/elisp.ts</vh></v>
<v t="felix.20230912223504.1"><vh>@file src/importers/html.ts</vh></v>
<v t="felix.20230912223510.1"><vh>@file src/importers/ini.ts</vh></v>
<v t="felix.20230913212159.1"><vh>@file src/importers/java.ts</vh></v>
<v t="felix.20230911233839.1"><vh>@file src/importers/javascript.ts</vh></v>
<v t="felix.20230913212609.1"><vh>@file src/importers/leo_rst.ts</vh></v>
<v t="felix.20230913224120.1"><vh>@file src/importers/lua.ts</vh></v>
<v t="felix.20230913225656.1"><vh>@file src/importers/markdown.ts</vh></v>
<v t="felix.20230913231752.1"><vh>@file src/importers/org.ts</vh></v>
<v t="felix.20230913231807.1"><vh>@file src/importers/otl.ts</vh></v>
<v t="felix.20230913235814.1"><vh>@file src/importers/pascal.ts</vh></v>
<v t="felix.20230913235829.1"><vh>@file src/importers/perl.ts</vh></v>
<v t="felix.20230913235836.1"><vh>@file src/importers/php.ts</vh></v>
<v t="felix.20230911210454.1"><vh>@file src/importers/python.ts</vh></v>
<v t="felix.20230914002433.1"><vh>@file src/importers/rust.ts</vh></v>
<v t="felix.20230914002711.1"><vh>@file src/importers/tcl.ts</vh></v>
<v t="felix.20230914002938.1"><vh>@file src/importers/treepad.ts</vh></v>
<v t="felix.20230911234728.1"><vh>@file src/importers/typescript.ts</vh></v>
<v t="felix.20230912233339.1"><vh>@file src/importers/xml.ts</vh></v>
</v>
<v t="felix.20230914004301.1"><vh>Writer plugins</vh>
<v t="felix.20230914004349.1"><vh>@file src/writers/basewriter.ts</vh></v>
<v t="felix.20230914011239.1"><vh>@file src/writers/dart.ts</vh></v>
<v t="felix.20230914214929.1"><vh>@file src/writers/leo_rst.ts</vh></v>
<v t="felix.20230914214935.1"><vh>@file src/writers/markdown.ts</vh></v>
<v t="felix.20230914214940.1"><vh>@file src/writers/org.ts</vh></v>
<v t="felix.20230914214945.1"><vh>@file src/writers/otl.ts</vh></v>
<v t="felix.20230914214949.1"><vh>@file src/writers/treepad.ts</vh></v>
</v>
<v t="felix.20220128232146.1"><vh>unittests</vh>
<v t="felix.20220130224933.1"><vh>@file src/test/leoTest2.ts</vh></v>
<v t="felix.20220129002501.1"><vh>@file src/test/extension.test.ts</vh></v>
<v t="felix.20230529171913.1"><vh>@file src/test/test_importers.test.ts</vh></v>
<v t="felix.20230923150253.1"><vh>@file src/test/test_writers.test.ts</vh></v>
<v t="felix.20230715185802.1"><vh>unittest commands</vh>
<v t="felix.20230715191150.1"><vh>@file src/test/leoCommanderFileCommands.test.ts</vh></v>
<v t="felix.20230805122326.1"><vh>@file src/test/leoGotoCommands.test.ts</vh></v>
<v t="felix.20230715191134.1"><vh>@file src/test/leoEditCommands.test.ts</vh></v>
<v t="felix.20230715191137.1"><vh>@file src/test/leoEditFileCommands.test.ts</vh></v>
<v t="felix.20230531185455.1"><vh>@file src/test/leoOutlineCommands.test.ts</vh></v>
</v>
<v t="felix.20230715185809.1"><vh>unittest core</vh>
<v t="felix.20220129200448.1"><vh>@file src/test/leoApp.test.ts</vh></v>
<v t="felix.20220129003133.1"><vh>@file src/test/leoAtFile.test.ts</vh></v>
<v t="felix.20220129002752.1"><vh>@file src/test/leoCommands.test.ts</vh></v>
<v t="felix.20230723005339.1"><vh>@file src/test/leoCompare.test.ts</vh></v>
<v t="felix.20220129003431.1"><vh>@file src/test/leoConfig.test.ts</vh></v>
<v t="felix.20220129003154.1"><vh>@file src/test/leoExternalFiles.test.ts</vh></v>
<v t="felix.20220129003044.1"><vh>@file src/test/leoFileCommands.test.ts</vh></v>
<v t="felix.20220129003458.1"><vh>@file src/test/leoFind.test.ts</vh></v>
<v t="felix.20230528193401.1"><vh>@file src/test/leoFrame.test.ts</vh></v>
<v t="felix.20220129002458.1"><vh>@file src/test/leoGlobals.test.ts</vh></v>
<v t="felix.20220129003526.1"><vh>@file src/test/leoImport.test.ts</vh></v>
<v t="felix.20220129002948.1"><vh>@file src/test/leoNodes.test.ts</vh></v>
<v t="felix.20230528205401.1"><vh>@file src/test/leoPersistence.test.ts</vh></v>
<v t="felix.20230528205401.2"><vh>@file src/test/leoRst.test.ts</vh></v>
<v t="felix.20220129003553.1"><vh>@file src/test/leoShadow.test.ts</vh></v>
<v t="felix.20220129003013.1"><vh>@file src/test/leoUndo.test.ts</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.

</t>
<t tx="ekr.20201209145358.1"></t>
<t tx="felix.20200719025231.24">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {

    if (
        p_event.affectsConfiguration(Constants.CONFIG_NAME) ||
        p_event.affectsConfiguration('editor.fontSize') ||
        p_event.affectsConfiguration('window.zoomLevel')
    ) {
        void this.config.setLeoJsSettingsPromise.then(
            () =&gt; {
                this.config.buildFromSavedSettings();
                void this.leoSettingsWebview.changedConfiguration();
                if (
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.INVERT_NODES) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_EDIT) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_ADD) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_MARK) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_CLONE) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_COPY)
                ) {
                    this.configTreeRefresh();
                }
            }
        );

    }

    // also check if workbench.editor.enablePreview
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // Check For specific vscode settings needed for leojs
    // Leave small delay for multiple possible forced changes at startup
    setTimeout(() =&gt; {
        this.config.checkEnablePreview();
        this.config.checkCloseEmptyGroups();
    }, 150);
}

</t>
<t tx="felix.20201208214250.2"></t>
<t tx="felix.20201208214319.1"># ![LeoEditor](https://raw.githubusercontent.com/boltex/leojs/master/resources/leoapp.png) Literate Editor with Outline

LeoJS is a javascript implementation of the Leo Editor.

_If you find LeoJS useful, please consider [**sponsoring**](https://boltex.github.io/) it. Also please [write a review](https://marketplace.visualstudio.com/items?itemName=boltex.leojs#review-details 'Write a review') or [star it on GitHub](https://github.com/boltex/leojs 'Star it on GitHub')_

## Literate Programming with _Directed Acyclic Graphs_ ([dag](https://en.wikipedia.org/wiki/Directed_acyclic_graph))

### Break down your code into a structured outline that generates or parses back your source files

&gt; Leo is a fundamentally different way of using and organizing data, programs and scripts. [📺 Introduction Video](https://www.youtube.com/watch?v=SYwlfdEukD4)

See Leo, the Literate Editor with Outline, at [leo-editor.github.io/leo-editor](https://leo-editor.github.io/leo-editor/)
or on [github](https://github.com/leo-editor/leo-editor).

![Screenshot](https://raw.githubusercontent.com/boltex/leojs/master/resources/animated-screenshot.gif)

# Web-Based Development

LeoJS can be run as a web extension on [VSCode for the web](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project). It can edit Leo documents directly inside online repositories such as on GitHub and Azure Repos.

_You can open a GitHub repository in VS Code for the Web directly from a URL, following the schema:_ `https://vscode.dev/github/&lt;organization&gt;/&lt;repo&gt;`

Or, simply visit your desired GitHub repository, Press the period '.' key on your keyboard to switch to web edition of VSCode. Make sure the LeoJS extension is installed and you're good to go!

&gt; The web extension version of LeoJS cannot open local files: Use the regular desktop LeoJS version to edit local Leo documents and projects.

# Features

-   UI controls such as a **Leo Outline** in the explorer view, and as a standalone sidebar, **body pane**, **opened documents selector** along with a **Log Window** [output channel](https://code.visualstudio.com/api/extension-capabilities/common-capabilities#output-channel).
-   Keybindings that match those of the Leo editor, including arrow keys behavior for outline keyboard navigation. (Can be turned off with the **'Leo Tree Browsing'** option setting)
-   **Derived files change detection**. See [External Files](#derive-external-files-) below for more details
-   **'@button' panel** for [creating your own commands with @buttons](https://leo-editor.github.io/leo-editor/tutorial-tips.html#use-button-nodes)
-   **Find panel** that reacts to Leo's typical keybindings, Ctrl+F, F2, F3... when focus is in the outline or body pane
-   **Nav and Tag panel** controls are integrated in the Find panel
-   **Goto Anywhere panel** to navigate directly from list of nodes, such as the results of Nav or Tag searches
-   **Undo History panel**, showing all actions and allowing going back, or forward, to any undo states.

## Leo Commands

![Menus](https://raw.githubusercontent.com/boltex/leojs/master/resources/context-hover-menus.png)

LeoJS offers an extensive set of integrated commands, accessible through a variety of interfaces — toolbar buttons, dedicated menus, and intuitive keybindings. Those commands are also discoverable via the Visual Studio Code Command Palette. (accessible through F1 or Ctrl+Shift+P)

### Context-Aware Keybindings

The keybinding architecture is designed to be context-aware. When your focus is within the LeoJS Body or Outline pane, LeoJS-specific keybindings take precedence. Shift your focus outside these panes, and Visual Studio Code's native keybindings resume control.

### The Minibuffer

For those familiar with Leo, the 'minibuffer' serves as the nerve center for command execution. Access it through Alt+X and use the complete set of Leo's commands!

## Keybindings

Listed here are the most useful commands and their keyboard shortcuts.

| Outline Commands |                                                                  |
| :--------------- | :--------------------------------------------------------------- |
| Undo / Redo      | `Ctrl + Z` &amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp; `Ctrl + Shift + Z`          |
| Insert Node      | `Ctrl + I` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift + Insert`         |
| Insert Child     | `Ctrl + Insert`                                                  |
| Edit Headline    | `Ctrl + H`                                                       |
| Mark / Unmark    | `Ctrl + M`                                                       |
| Copy Node        | `Ctrl + Shift + C`                                               |
| Cut Node         | `Ctrl + Shift + X`                                               |
| Paste Node       | `Ctrl + Shift + V`                                               |
| Delete Node      | `Ctrl + Shift + Backspace` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Delete` |
| Clone Node       | `Ctrl + Backquote`                                               |
| Promote / Demote | `Ctrl + {` &amp;nbsp;&amp;nbsp;_and_&amp;nbsp;&amp;nbsp; `Ctrl + }`              |

| Moving Nodes       |                                                                 |
| :----------------- | :-------------------------------------------------------------- |
| Move Outline Up    | `Ctrl + U` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Up`    |
| Move Outline Down  | `Ctrl + D` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Down`  |
| Move Outline Left  | `Ctrl + L` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Left`  |
| Move Outline Right | `Ctrl + R` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Right` |

_Move-Outline commands need the 'Alt' key modifier only when focus is on body pane._

| Common Operations   |                                                                                                                           |
| :------------------ | :------------------------------------------------------------------------------------------------------------------------ |
| Toggle Outline/Body | `Ctrl + T`                                                                                                                |
| Focus on Body       | `Tab` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Enter` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + D` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Ctrl + G` |
| Focus on Outline    | `Alt + T`                                                                                                                 |
| Contract All        | `Alt + -`                                                                                                                 |
| Sort Siblings       | `Alt + A`                                                                                                                 |
| Start Search        | `Ctrl + F`                                                                                                                |
| Find Next           | `F3`                                                                                                                      |
| Find Previous       | `F2`                                                                                                                      |
| Replace             | `Ctrl + =`                                                                                                                |
| Replace then Find   | `Ctrl + -`                                                                                                                |
| Extract             | `Ctrl + Shift + D`                                                                                                        |
| Extract Names       | `Ctrl + Shift + N`                                                                                                        |
| Execute Script      | `Ctrl + B`                                                                                                                |
| Minibuffer Palette  | `Alt + X`                                                                                                                 |

| Tree Navigation          |                                                              |
| :----------------------- | :----------------------------------------------------------- |
| Show the LeoJS View      | `Ctrl+Shift+L`                                               |
| Go Anywhere              | `Ctrl+P`                                                     |
| Go To First Visible Node | `Home` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + Home`             |
| Go To Last Visible Node  | `End` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + End`               |
| Tree page up/down        | `PgUp / pgDn`                                                |
| Go To Next Clone         | `Alt + N`                                                    |
| Browse Tree              | `Arrow Keys` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + Arrow Keys` |
| Go To Global Line        | `Alt + G`                                                    |

_With the **'Leo Tree Browsing'** setting enabled by default, the arrows, home, end, pageUp/Down keys will change the outline's selection directly._

| File Commands       |                    |
| :------------------ | :----------------- |
| Save Leo Document   | `Ctrl + S`         |
| New Leo Document    | `Ctrl + N`         |
| Open Leo Document   | `Ctrl + O`         |
| Cycle Next Document | `Ctrl + Tab`       |
| Write File Nodes    | `Ctrl + Shift + W` |
| Write Dirty Files   | `Ctrl + Shift + Q` |

---

## External Files

Use either of the **Save Leo Document**, **Write File Nodes** or **Write Dirty Files** commands to derive external files for any type of **@file** nodes.

| @\&lt;file\&gt; Kind | Sentinels | @others | .leo Data | Write Only |
| :------------- | :-------: | :-----: | :-------: | :--------: |
| @asis          |    ❌     |   ❌    |    ✔️     |     ✔️     |
| @auto          |    ❌     |   ✔️    |    ❌     |     ❌     |
| @clean         |    ❌     |   ✔️    |    ✔️     |     ❌     |
| @edit          |    ❌     |   ❌    |    ❌     |     ❌     |
| @file          |    ✔️     |   ✔️    |    ❌     |     ❌     |
| @nosent        |    ❌     |   ✔️    |    ✔️     |     ✔️     |

Leo will detect external file changes, and will ask to either **refresh from disk** or **ignore the changes**.

![Derive files](https://raw.githubusercontent.com/boltex/leojs/master/resources/derived-file.gif)

## Extension Settings

### Open the command palette `Ctrl+Shift+P` and start typing `LeoJS settings` to access LeoJS's welcome/settings screen

&gt; _(Changes are auto-saved to the user's profile after 0.5 seconds)_

-   Control the visibility of the outline pane in the explorer view.
-   Decide how and when to refresh and synchronize content when derived (external) file are modified.
-   Show additional icons on outline nodes (Move, delete, mark, copy, paste...)
-   Choose to either focus on the body pane, or keep focus in the outline when a node is selected.
-   Hide or show the "Open on the side" command in the context menu to open a node beside the active editor

![Settings](https://raw.githubusercontent.com/boltex/leojs/master/resources/welcome-settings.png)

## Navigating a Leo Document

Arrow keys, home/end, page up/down are used for basic navigation. But in order to **find and goto specific nodes directly**, use the methods described below.

### Goto Anywhere Command

Normally in vscode, the the **`Ctrl+P`** shortcut allows you to switch to any project file, but when the focus is in one of Leo's panels, the **`Ctrl+P`** keybinding allows you to switch to a node directly by typing (part of) it's headline.

![Goto Anywhere](https://raw.githubusercontent.com/boltex/leojs/master/resources/goto-anywhere.gif)

### Find Commands

With focus in Leo's outline or body pane, Hit **`Ctrl+F`** to open the _find panel_.

Enter your search pattern directly in the **\&lt;find pattern here\&gt;** field. Press **`Enter`** to find the first match starting from your current position.

Hitting **`F3`** repeatedly will find the subsequent matches. (**`F2`** for previous matches)

![Find results](https://raw.githubusercontent.com/boltex/leojs/master/resources/find-in-headlines.gif)

### Nav and the Goto Panel

Type your search pattern in the **Nav** field instead to see all results show up below in leo's **Goto Pane**. This will show the headlines as you type.

Press **`Enter`** to freeze the results and show results also found in **body text of any node**. This will add a snowflake icon ❄️ to the **Nav** field.

From the **Goto Pane**, you can use the arrow keys, home/end, page up/down to cycle directly to any of those matches.

![Goto pane](https://raw.githubusercontent.com/boltex/leojs/master/resources/nav-goto-pane.gif)

### Using Tags

If you check the **Tag** option, the **Nav** field and **Goto Pane** are then used to find nodes by their tag 🏷 _ua_ (user attribute).

![Node tags](https://raw.githubusercontent.com/boltex/leojs/master/resources/nav-tags.gif)

## Undo Panel

&gt; In LeoJS, the undo functionality is a multi-tiered system that segregates structural outline changes from text changes within the body pane. The Undo Panel captures outline alterations as individual 'Undo Beads', independent from VS Code's native text undo states. When focus resides in the body pane, the Undo keybinding triggers VS Code's text-specific undo action. However, once the focus shifts or a new node is selected, all concurrent text changes coalesce into a single 'Undo Bead' within the Undo Panel. These 'Undo Beads' can then be manipulated either through the Undo Panel or by keybindings, provided the focus is explicitly set on the outline pane. This dual-layer undo architecture enables precise control over both code and structural modifications.

Use the undo / redo icons above the outline or above the undo pane itself. You can also right-click on an undo step to directly switch to that specific state!

![Undo pane](https://raw.githubusercontent.com/boltex/leojs/master/resources/undo-pane.gif)

# Issues

Common issues are listed below. See the repository's [Issues Page](https://github.com/boltex/leojs/issues) to submit issues.

### Linux Keybindings

If you're experiencing trouble with the keyboard shortcuts for
the 'Clone Node' or the 'Promote' and 'Demote' commands,
set **"keyboard.dispatch": "keyCode"** in your vscode settings and restart vscode.
See [Troubleshoot Linux Keybindings](https://github.com/microsoft/vscode/wiki/Keybinding-Issues#troubleshoot-linux-keybindings)
for more information.

### Keybindings Conflicts Resolution

If you have a keybinding conflict for a command that you would like **not** to be resolved by Leo when the focus is on the body pane,
add **`&amp;&amp; resourceScheme != 'leojs'`** to the keybinding's "_when_" condition. (Use **`Ctrl+K Ctrl+S`** in vscode to open the Keyboards Shortcuts panel)

### Move Outline Keyboard Commands

For some users, the **`Alt+[Arrow Keys]`**, **`Ctrl+D`** and **`Ctrl+T`** keybinding are already assigned.

To help with this conflict, tree-browsing, outline-move keyboard commands, and switch focus command will only trigger
with the additional condition of having no text selection in the editor.

So select at least one character to use the previously assigned original keyboard commands, while focus is in the body pane.

&gt; Refer to the [issue tracker](https://github.com/boltex/leojs/issues) page to learn more about the known issues, or to contribute with additional information if you encounter some yourself.

If you would like to modify and build this project yourself, see [CONTRIBUTING.md](./CONTRIBUTING.md) for how to get started.

# Acknowledgments

### _Thanks to_

-   [Edward K. Ream](https://github.com/edreamleo) creator of the [Leo Editor](https://leo-editor.github.io/leo-editor/)
-   [Eric Amodio](https://github.com/eamodio) for the [welcome screen templates](https://github.com/eamodio/vscode-gitlens/tree/master/src/webviews)
-   [Vitalije Milošević](https://github.com/vitalije) for his contributions and support
-   [Arjan Mossel](https://github.com/ar-jan) for his suggestions and ideas
-   [Thomas Passin](https://github.com/tbpassin) for his contributions and support
-   [Viktor](https://github.com/ranvik14) for his contributions and support
-   [Gaurami](https://github.com/ATikhonov2) for his suggestions, bug reports and support
-   [Kevin Henderson](https://github.com/kghenderson) for his suggestions and support
-   [Ville M. Vainio](https://github.com/vivainio) for his Nav tab original concept
-   [Jacob M. Peck](https://github.com/gatesphere) for his Tags tab original concept
-   [Matt Wilkie](https://github.com/maphew) for his contributions and support

## 🤍 To sponsor, donate or contribute see my [user page 🦁](https://boltex.github.io/)
</t>
<t tx="felix.20201208214322.1">import * as vscode from 'vscode';
import initSqlJs from '../sqlite/sql-wasm-debug';
import * as JSZip from 'jszip';
import * as pako from 'pako';

import * as GitAPI from './git';
import * as GitBaseAPI from './git-base';

import { Constants } from './constants';
import * as path from 'path';
import * as utils from "./utils";
import * as g from './core/leoGlobals';
import { LeoApp } from './core/leoApp';
import { LoadManager } from "./core/leoApp";
import { RemoteHubApi } from './remote-hub';
import { Database, SqlJsStatic } from 'sql.js';
process.hrtime = require('browser-process-hrtime'); // Overwrite 'hrtime' of process

const activateDebug = false;


@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208214506.1"># Change Log

## 0.1.0 Dec 9, 2020

- Initial state

## 0.1.1 Dec 31, 2021

- Outline, undos and commands

## 0.1.2 Jan 01 2022

- Support web extension compilation for vscode.dev

## 0.1.3 Mar 11 2023

- Implemented Find and Goto panels and commands

## 0.1.4 Apr 04 2023

- Implemented extract &amp; extract-names commands
- Fixed clipboard handling of JSON clipbard content
- Added new headline numbering commands
- Fixed undo behavior and added multiple-headline-change helpers
- Fixed @chapter/hoisting related issues
- implemented c.registerCommand (instead of c.k.registerCommand)
- Fixed reading/writing JSON leojs file format
- Removed status bar indicator (until vscode API can provide focus status)

# 0.1.5 June 24 2023

- Implemented Leo's atFile, atShadow and external files features
- Implemented javascript scripting, along with c, g and p references.

# 0.1.6 December 5 2023

- Added new option setting "showBranchInOutlineTitle" to show the branch with the filename in the outline's title bar
- Implemented importers
- Instead of Leo's original SaveAsLeojs command, (accessible via alt+x) Using SaveAsLeojs from vscode's menu interaction resolves to 'Save as .leojs' instead of 'Save To .leojs'
- Editing a headline, when inserting or renaming a node, can now be interrupted by most other keyboard shortcuts and commands
- Implemented Global Settings, Sessions and recent files. (saved to db and other files in the .leo folder.)
- Fixed log pane

# 0.1.7

- First feature complete version
- Fixed external file generation bugs
- Fixed conflict with leointeg when both expansions showed the same gnx body
- Fixed creation of local .leo folder when running as web extension
- Fixed md5 checksum and external file change detection bugs
- Various small bug fixes and corrections

# 0.2.0 

- First alpha release

# 0.2.1

- Changes</t>
<t tx="felix.20201208215619.1">// this method is called when your extension is deactivated
export async function deactivate(): Promise&lt;unknown&gt; {
    if (g.app) {

        // ! NOT SAVED ON EXIT !
        // // Save session data.
        // console.log('------------------------start saveSession');

        // await g.app.saveSession();
        // // Similar to qt_gui.close_event.
        // console.log('------------------------end saveSession');

        for (const c of g.app.commanders()) {
            if (c.exists) {
                await g.app.closeLeoWindow(c.frame, undefined, true);
            }
            // allow = c.exists &amp;&amp; g.app.closeLeoWindow(c.frame)
            // if (!allow)
            //     return
        }
        // sys.exit(0)
        console.log('leojs extension has been deactivated.');
        return undefined;
    } else {
        console.log('no g.app');
    }
}

</t>
<t tx="felix.20201208223553.1">import * as vscode from 'vscode';
import { Constants } from "./constants";
import { Icon } from './types';
import { LeoUI } from './leoUI';
import * as g from './core/leoGlobals';
import { Position } from './core/leoNodes';

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20201208224407.1">import * as vscode from "vscode";
import { Utils as uriUtils } from "vscode-uri";
import { Constants } from "./constants";
import { Icon } from "./types";
import { LeoOutlineNode } from "./leoOutline";
import { Position } from "./core/leoNodes";

// String and other types/structures helper functions, along with common vscode API calls

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208224407.10">/**
 * * Returns milliseconds between the p_start process.hrtime tuple and p_end (or current call to process.hrtime)
 * @param p_start starting process.hrtime to subtract from p_end or current immediate time
 * @param p_end optional end process.hrtime (or immediate time)
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number], p_end?: [number, number]): number {
    if (!p_end) {
        p_end = process.hrtime();
    }
    const w_secs = p_end[0] - p_start[0];
    const w_nanosecs = p_end[1] - p_start[1];

    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201208224407.11">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20201208224407.12">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: Position, p_newHasBody: boolean): boolean {
    // hasBody can be undefined so force boolean.
    if (!p_node.isDirty() || (!!p_node.bodyString().length === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20201208224407.14">/**
* Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
* @param p_str leo node gnx strings are used to build Uri
* @returns A vscode 'Uri' object
*/
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20201208224407.15">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substring(1);
}

</t>
<t tx="felix.20201208224407.16">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'leoReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20201208224407.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20201208224407.4">/**
 * * Performs the actual addition into globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
 */
export function addFileToGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.globalState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.globalState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.globalState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.globalState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201208224407.5">/**
 * * Removes file entry from globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
  */
export function removeFileFromGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.globalState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.globalState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.globalState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201208224407.6">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {

            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
        };
    });
}

</t>
<t tx="felix.20201208224407.7">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20201208224407.8">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON_RCLICK),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON_RCLICK)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="felix.20201208224703.1">@language rest
@wrap
# How to install and run the development version

Thanks for trying out the development version of Leojs! :sunglasses: Contributions and pull requests are more than welcome!

## Introduction

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

## Development Version Installation

Make sure you have Node.js and Git installed, then clone the sources and run `npm install` in a terminal to install the remaining development dependencies.

![run extension](https://raw.githubusercontent.com/boltex/leojs/master/resources/run-extension.png)

You can then run the **Run Extension** target, as shown above, in the **Debug View**.

## Web extension version

See [VSCode for the web](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for usage example

## Running Development version as a web extension

&gt; For exact information on this procedure, see [Test your web extension](https://code.visualstudio.com/api/extension-guides/web-extensions#test-your-web-extension-in-vscode.dev).

To try out running as a web extension on vscode.dev, use the following commands:

First, you'll need to [install mkcert](https://github.com/FiloSottile/mkcert#installation).

Then, generate the localhost.pem and localhost-key.pem files into a location you won't lose them (for example $HOME/certs):

```
$ mkdir -p $HOME/certs
$ cd $HOME/certs
$ mkcert -install
$ mkcert localhost
```

Then, from your extension's path, start an HTTP server by running

```
$ npx serve --cors -l 5000 --ssl-cert $HOME/certs/localhost.pem --ssl-key $HOME/certs/localhost-key.pem
```

Finally, open vscode.dev pointing to a github repo, similar to: `https://vscode.dev/github/boltex/practice-leo-phys` and run **Developer: Install Web Extension...** from the Command Palette and paste `https://localhost:5000`

# Converting from Python to Typescript

## Useful tricks and common pitfalls

### Raw String

Raw String (prefixed with an 'r') do not exist in js. Except for regex defined with slashes.

Those regex defined with slashes are equivalent to raw strings being compiled into a regex in python.

If raw strings are needed for strings OTHER THAN regex, then the have to be escaped. (\\r, \\n, etc.)

This applies for regular strings and multiline strings.

### Multiline string

Multiline strings can be made with back-ticks "`" .

### Regex 'match' methods

The regexp 'match' method exists in python, but it only matches at the start of the string.

This implies that when the 'match' method is used in js, a caret "^" has to be prefixed onto the regex to match at the start of the string.

### Regex 'end-of-line' and 'm' switch

If a regex uses the '\$' character to match an end-of-line, it needs the 'm' switch if the tested string has '\n' at the end. (is considered multiline)

No need for 'm' switch for a '\$' match if the tested string has no newlines at all.

### For 'in/of' loops

A "for in" loop in python loops over the values which is equivalent to a "for of" loop in js.

Although legal in js, it is NOT equivalent: A "for in" loop in js loops over the keys, not the values.
</t>
<t tx="felix.20201209011931.1">export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;Position&gt; {
    private _onDidChangeTreeData: vscode.EventEmitter&lt;Position | undefined&gt; = new vscode.EventEmitter&lt;Position | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;Position | undefined&gt; = this._onDidChangeTreeData.event;

    public treeId: number = 0; // Starting salt for generated tree node Ids

    @others
}

</t>
<t tx="felix.20201209011931.2">constructor(
    private _icons: Icon[],
    private _leoUI: LeoUI
) {
}

</t>
<t tx="felix.20201209011931.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201209011931.4">public getTreeItem(element: Position): Thenable&lt;LeoOutlineNode&gt; | LeoOutlineNode {

    const w_ui = this._leoUI;

    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (element.hasChildren()) {
        w_collapse = element.isExpanded() ? vscode.TreeItemCollapsibleState.Expanded : vscode.TreeItemCollapsibleState.Collapsed;
    }
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (element.isMarked()) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (element.isAnyAtFileNode()) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (element.isCloned()) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (element._isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    const w_icon: number =
        (+(w_ui.config.invertNodeContrast !== !!element.isDirty()) &lt;&lt; 3) |
        (+element.isCloned() &lt;&lt; 2) |
        (+element.isMarked() &lt;&lt; 1) |
        +element.v.hasBody();

    const w_u = (element.v.u &amp;&amp; Object.keys(element.v.u).length) ? element.v.u : false;
    let desc: string = "";
    // * some smaller grayed-out text accompanying the main label
    if (w_u) {
        const w_uLength = Object.keys(w_u).length;
        if (w_uLength) {
            desc = "\u{1F4CE} (" + w_uLength + ")";
            if (w_u.__node_tags) {
                w_contextValue += Constants.CONTEXT_FLAGS.NODE_TAGS;
                if (w_uLength === 1) {
                    // was only tag, so reset it
                    desc = "";
                } else {
                    desc = desc + " "; // add space
                }
                desc = desc + "\u{1F3F7} (" + Object.keys(w_u.__node_tags).length + ")";
            }
        }
    } else {
        // desc = "id:" + this.id; // ! debug test
        // desc = "gnx:" + this.gnx; // ! debug test
    }

    let w_isSelected = false;
    if (element.__eq__(g.app.windowList[w_ui.frameIndex].c.p)) {
        w_isSelected = true;
    }

    let w_hl: [number, number] = [0, 0];
    if (w_isSelected &amp;&amp; w_ui.findFocusTree) {
        if (w_ui.findHeadlinePosition?.__eq__(element)) {
            w_hl = w_ui.findHeadlineRange;
        }
    }

    const w_leoNode = new LeoOutlineNode(
        { label: element.h, highlights: [w_hl] },
        w_collapse,
        element, // Position
        desc,
        this._icons[w_icon],
        this._buildId(element, w_collapse),
        w_contextValue
    );
    // Check if its the selected node and call signal it to the UI
    if (w_isSelected) {
        w_ui.gotSelectedNode(element);
    }
    // Build a LeoNode (a vscode tree node) from the Position
    return w_leoNode;
}

</t>
<t tx="felix.20201209011931.5">public getChildren(element?: Position): Position[] {
    if (!this._leoUI.leoStates.fileOpenedReady) {
        return [];
    }
    if (element) {
        return [...element.children()];
    } else {
        if (g.app.windowList[this._leoUI.frameIndex]) {
            // Currently Selected Document's Commander
            const w_c = g.app.windowList[this._leoUI.frameIndex].c;
            if (w_c.hoistStack.length) {
                // HOISTED: Topmost hoisted node starts the outline as single root 'child'
                const w_rootPosition = w_c.hoistStack[w_c.hoistStack.length - 1].p;
                w_rootPosition._isRoot = true;
                return [w_rootPosition];
            } else {
                // NOT HOISTED: Normal list of root nodes
                const w_rootNodes = [...w_c.all_Root_Children()];
                if (w_rootNodes.length === 1) {
                    // Exactly one: prevent hoisting on SINGLE top node
                    w_rootNodes[0]._isRoot = true;
                }
                return w_rootNodes;
            }
        } else {
            return []; // Attempted to access un-existent frame
        }
    }
}

</t>
<t tx="felix.20201209011931.6">public getParent(element: Position): vscode.ProviderResult&lt;Position&gt; {
    if (element) {
        const p_parent = element.parent();
        if (p_parent.v) {
            return p_parent;
        } else {
            return undefined;
        }
    }
    return undefined;
}

</t>
<t tx="felix.20201214150149.1">/**
 * Entry point for Leo in Javascript. 
 * @returns Leo’s leo.core.leoGlobals containing many useful functions, including g.es.
 */
export async function activate(p_context: vscode.ExtensionContext): Promise&lt;typeof g&gt; {

    /*
        * Original Leo startup *

        g.app = leoApp.LeoApp()
        g.app.loadManager = leoApp.LoadManager()
        g.app.loadManager.load(fileName, pymacs)
    */

    (g.extensionContext as vscode.ExtensionContext) = p_context; // Useful for accessing workspace storage or other utilities.
    (g.extensionUri as vscode.Uri) = p_context.extensionUri; // Useful for accessing files in extension package itself.

    if (p_context.extensionUri &amp;&amp; activateDebug) {
        console.log('STARTUP: context.extensionUri.fsPath: ', p_context.extensionUri.fsPath);
        console.log('STARTUP: context.extensionUri.scheme: ', p_context.extensionUri.scheme,);
    }

    if (activateDebug) {
        console.log('STARTUP:                 g.osBrowser: ', g.isBrowser);
        console.log('STARTUP:                    path.sep: ', path.sep);
        console.log('STARTUP:                  env scheme: ', vscode.env.uriScheme);
        console.log('STARTUP:                 env appHost: ', vscode.env.appHost);
        console.log('STARTUP:               process.cwd(): ', process.cwd());
    }

    const w_leojsExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leojsVersion = w_leojsExtension.packageJSON.version;

    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);
    let SQL: SqlJsStatic;

    // * Close remaining Leo Bodies restored by vscode from last session.
    await closeLeoTextEditors();

    // * Show a welcome screen on version updates, then start the actual extension.
    void showWelcomeIfNewer(w_leojsVersion, w_previousVersion)
        .then(() =&gt; {
            void p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leojsVersion);
        });

    if (!g.app) {
        (g.app as LeoApp) = new LeoApp();
        (g.app as LeoApp).vscodeExtensionDir = g.os_path_normslashes(g.os_path_fix_drive(p_context.extensionUri.fsPath));

        const gitExtension = vscode.extensions.getExtension&lt;GitAPI.GitExtension&gt;('vscode.git');
        if (gitExtension) {
            await gitExtension.activate();
            try {
                (g.gitAPI as GitAPI.API) = gitExtension.exports.getAPI(1);
                if (activateDebug) {
                    console.log("STARTUP:          GIT extension installed as g.gitAPI");
                }
            } catch (e) {
                console.log("LEOJS ERROR : GIT EXTENSION NOT INSTALLED !");
            }
        } else {
            // console.log("LEOJS ERROR : GIT EXTENSION NOT AVAILABLE !");
        }

        const gitBaseExtension = vscode.extensions.getExtension&lt;GitBaseAPI.GitBaseExtension&gt;('vscode.git-base');
        if (gitBaseExtension) {
            await gitBaseExtension.activate();
            try {
                (g.gitBaseAPI as GitBaseAPI.API) = gitBaseExtension.exports.getAPI(1);

                if (activateDebug) {
                    console.log("STARTUP:          GIT_BASE extension installed as g.gitBaseAPI");
                }

            } catch (e) {
                console.log("LEOJS ERROR : GIT_BASE EXTENSION NOT INSTALLED !");
            }
        } else {
            // console.log("LEOJS ERROR : GIT_BASE EXTENSION NOT AVAILABLE !");
        }

        const extension = vscode.extensions.getExtension&lt;RemoteHubApi&gt;('ms-vscode.remote-repositories')
            ?? vscode.extensions.getExtension&lt;RemoteHubApi&gt;('GitHub.remoteHub')
            ?? vscode.extensions.getExtension&lt;RemoteHubApi&gt;('GitHub.remoteHub-insiders');

        if (extension == null) {
            // console.log("LEOJS ERROR : GIT_REMOTE EXTENSION NOT AVAILABLE !");
        }
        if (extension) {
            const api = extension.isActive ? extension.exports : await extension.activate();
            (g.remoteHubAPI as RemoteHubApi) = api;

            if (activateDebug) {
                console.log("STARTUP:          GIT_REMOTE_HUB extension installed as g.remoteHubAPI");
            }
        }

        // Test paco
        // console.log('paco start test:  ');
        // const test = { my: 'super', puper: [456, 567], awesome: 'pako' };
        // const compressed = pako.deflate(JSON.stringify(test));
        // const restored = JSON.parse(pako.inflate(compressed, { to: 'string' }));
        // console.log('paco restored test:  ', restored);


        // console.log('SQL start');
        const sqliteBits = await vscode.workspace.fs.readFile(
            vscode.Uri.joinPath(p_context.extensionUri, 'sqlite', 'sql-wasm-debug.wasm')
        );
        // console.log('got sql-wasm-debug.wasm', sqliteBits.length);

        SQL = await initSqlJs(undefined, sqliteBits);

        if (activateDebug) {
            console.log("STARTUP:          SQLITE has started");
        }

        (g.SQL as SqlJsStatic) = SQL;


    } else {
        void vscode.window.showWarningMessage("g.app leojs application instance already exists!");
    }

    p_context.subscriptions.push(
        vscode.workspace.onDidChangeWorkspaceFolders((p_event =&gt; setScheme(p_event, p_context)))
    );

    async function dbTests() {

        // Start SQLITE engine
        // const filebuffer = await vscode.workspace.fs.readFile(
        //     vscode.Uri.joinPath(p_context.extensionUri, 'test1.db')
        // );

        const filebuffer = await vscode.workspace.fs.readFile(
            g.makeVscodeUri(path.join(vscode.workspace.workspaceFolders![0].uri.fsPath, "test2.db"))
            // vscode.Uri.joinPath(p_context.extensionUri, 'test1.db')
        );
        console.log('got db file!!  Length in bytes: ', filebuffer.length);

        // Load the db.
        const db: Database = new SQL.Database(filebuffer);
        console.log('db', db);

        // Test executing query on db.
        const q_result1 = db.exec("SELECT `name`, `sql`  FROM `sqlite_master`  WHERE type='table';");
        // exec returns an  QueryExecResult {
        //					columns: string[];
        //					values: SqlValue[][];
        // 				}
        console.log('result', q_result1);

        const w_date = new Date();
        const w_dateStringKey = "d_" + w_date.getTime().toString();
        const w_dateStringVal = w_date.toLocaleDateString() + " " + w_date.toLocaleTimeString();

        const w_insertQuery = `INSERT OR IGNORE INTO extra_infos (name, value) VALUES ('${w_dateStringKey}', '${w_dateStringVal}');`;
        console.log("w_insertQuery", w_insertQuery);

        const q_result2 = db.exec(w_insertQuery);
        console.log('result2', q_result2);

        const db_data = db.export();
        const db_buffer = Buffer.from(db_data);

        const db_fileName = path.join(vscode.workspace.workspaceFolders![0].uri.fsPath, "my_db_save.db");
        const db_uri = g.makeVscodeUri(db_fileName);
        await vscode.workspace.fs.writeFile(db_uri, db_buffer);

        console.log("buffer db to be written byte length :", db_buffer.length);
        const w_stats = await vscode.workspace.fs.stat(db_uri);
        console.log('DB written file size check : ', w_stats.size);
        console.log('Done with DB tests');

    }

    async function readZipTest() {
        console.log('Starting readZipTest');

        let fileName;

        fileName = path.join(vscode.workspace.workspaceFolders![0].uri.fsPath, "myziptest.zip");
        const w_uri = g.makeVscodeUri(fileName);
        let w_stats: vscode.FileStat;
        // const zip = new JSZip();
        try {
            w_stats = await vscode.workspace.fs.stat(w_uri);
        } catch {
            return false;
        }
        console.log('w_stats.size', w_stats.size);

        await vscode.workspace.fs.readFile(w_uri)
            .then(JSZip.loadAsync)                            // 3) chain with the zip promise
            .then(function (zip) {
                return zip.file("hello.txt")?.async("string"); // 4) chain with the text content promise
            })
            .then((read_str) =&gt; {
                console.log('read from zip hello.txt: ', read_str);
            });
        console.log('Done with readZipTest');

    }

    async function makeZipTest() {
        console.log('Starting makeZipTest');

        // Test JSZip
        const zip = new JSZip();

        // create a file
        zip.file("hello.txt", "Hello new world");

        // create a file and a folder
        zip.file("nested/hello.txt", "Hello World\ninside on other line!\n");
        // // same as
        // zip.folder("nested")!.file("hello.txt", "Hello World\n");

        let fileName;
        // if (g.isBrowser) {
        //     fileName = "/myziptest.zip";
        // } else {
        // }
        fileName = path.join(vscode.workspace.workspaceFolders![0].uri.fsPath, "myziptest2.zip");
        const w_ZIP_uri = g.makeVscodeUri(fileName);


        const zip_data = await zip.generateAsync({ type: "uint8array" });
        console.log('zip_data byte length: ', zip_data.byteLength);

        const zip_buffer = Buffer.from(zip_data);
        console.log('zip_buffer length: ', zip_buffer.length);

        await vscode.workspace.fs.writeFile(w_ZIP_uri, zip_buffer);
        // console.log('done with zip file test!');
        console.log("zip buffer length", zip_buffer.length);
        const w_stats = await vscode.workspace.fs.stat(w_ZIP_uri);
        console.log('ZIP w_stats.size', w_stats.size);
        console.log('Done with makeZipTest');

    }

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders.length) {
        g.app.vscodeWorkspaceUri = vscode.workspace.workspaceFolders[0].uri;
        g.app.vscodeUriScheme = vscode.workspace.workspaceFolders[0].uri.scheme;
        g.app.vscodeUriAuthority = vscode.workspace.workspaceFolders[0].uri.authority;
        g.app.vscodeUriPath = vscode.workspace.workspaceFolders[0].uri.path;

        // console.log('GOT WORKSPACE: starting file-system ZIP &amp; DB tests');
        if (0) {
            await dbTests();
        }
        if (0) {
            await readZipTest();
        } else if (0) {
            await makeZipTest();
        }

    }

    if (!g.isBrowser) {
        // Regular NodeJs Extension: Dont wait for workspace being opened
        if (!g.app.vscodeUriScheme) {
            // Only setting if undefined, because regular vscode can still work on remote github virtual filesystem
            g.app.vscodeUriScheme = 'file';
        }
        await runLeo(p_context);
    } else {
        // Web Browser Extension: Check for type of workspace opened first
        if (g.app.vscodeUriScheme) {

            if (!vscode.workspace.fs.isWritableFileSystem(g.app.vscodeUriScheme)) {

                // NOTE : ! THIS RETURNS FALSE POSITIVES ! 
                console.log('NOT WRITABLE WORKSPACE: FALSE POSITIVE?');

                // void vscode.window.showInformationMessage("Non-writable filesystem scheme: " + g.app.vscodeUriScheme, "More Info")
                //     .then(selection =&gt; {
                //         if (selection === "More Info") {
                //             vscode.env.openExternal(
                //                 vscode.Uri.parse('https://code.visualstudio.com/docs/editor/vscode-web#_current-limitations')
                //             ).then(() =&gt; { }, (e) =&gt; {
                //                 console.error('LEOJS: Could not open external vscode help URL in browser.', e);
                //             });
                //         }
                //     });
                // console.log('NOT started because not writable workspace');
                // void setStartupDoneContext(true);
                // return;
            }

            // Check if not file scheme : only virtual workspaces are suported if g.isBrowser is true.
            if (g.app.vscodeUriScheme !== 'file') {
                if (activateDebug) {
                    console.log('STARTUP:           g.app.vscodeWorkspaceUri: ', g.app.vscodeWorkspaceUri);
                }

                await runLeo(p_context);
            } else {
                // Is local filesystem
                void vscode.window.showInformationMessage("LeoJS in browser supports remote virtual filesystems: Local Filesystem requires desktop VSCode application: ", "More Info").then(selection =&gt; {
                    if (selection === "More Info") {
                        vscode.env.openExternal(
                            vscode.Uri.parse('https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project')
                        ).then(() =&gt; { }, (e) =&gt; {
                            console.error('LEOJS: Could not open external vscode help URL in browser.', e);
                        });
                    }
                });
                console.log('NOT started because no remote workspace yet');
                void setStartupDoneContext(true);
                return g;
            }
        } else {
            console.log('NOT started because no remote workspace yet');
            void setStartupDoneContext(true);
        }

    }
    return g;
}

</t>
<t tx="felix.20201214150149.10">[CMD.INSERT, (p_node: Position) =&gt; p_leoUI.insertNode(p_node, true, false)],
[CMD.INSERT_SELECTION, () =&gt; p_leoUI.insertNode(U, false, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; p_leoUI.insertNode(U, true, false)],
// Special command for when inserting rapidly more than one node without
// even specifying a headline label, e.g. spamming CTRL+I rapidly.
// [CMD.INSERT_SELECTION_INTERRUPT, () =&gt; p_leoUI.insertNode(U, false, true, false)],

[CMD.INSERT_CHILD, (p_node: Position) =&gt; p_leoUI.insertNode(p_node, true, true)],
[CMD.INSERT_CHILD_SELECTION, () =&gt; p_leoUI.insertNode(U, false, true)],
[CMD.INSERT_CHILD_SELECTION_FO, () =&gt; p_leoUI.insertNode(U, true, true)],
// Special command for when inserting rapidly more than one node without
// even specifying a headline label, e.g. spamming CTRL+I rapidly.
// [CMD.INSERT_CHILD_SELECTION_INTERRUPT, () =&gt; p_leoUI.insertNode(U, false, true, true)],

[CMD.CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.CLONE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.PROMOTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PROMOTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.PROMOTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PROMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.DEMOTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.DEMOTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.DEMOTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.DEMOTE_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.SORT_CHILDREN, () =&gt; p_leoUI.command(LEOCMD.SORT_CHILDREN, { refreshType: REFRESH_TREE, finalFocus: Focus.Body, keepSelection: true })],
[CMD.SORT_SIBLING, () =&gt; p_leoUI.command(LEOCMD.SORT_SIBLINGS, { refreshType: REFRESH_TREE, finalFocus: Focus.Body, keepSelection: true })],
[CMD.SORT_SIBLING_FO, () =&gt; p_leoUI.command(LEOCMD.SORT_SIBLINGS, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],

</t>
<t tx="felix.20201214150149.11">[CMD.MARK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MARK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MARK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.UNMARK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.UNMARK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.UNMARK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_MARK, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.UNMARK_ALL, () =&gt; p_leoUI.command(LEOCMD.UNMARK_ALL, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.12">[CMD.EXTRACT, () =&gt; p_leoUI.command(LEOCMD.EXTRACT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.EXTRACT_NAMES, () =&gt; p_leoUI.command(LEOCMD.EXTRACT_NAMES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

</t>
<t tx="felix.20201214150149.13">[CMD.MOVE_DOWN, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_DOWN_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_DOWN, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_LEFT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_LEFT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_LEFT, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_RIGHT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_RIGHT, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.MOVE_UP, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.MOVE_UP_SELECTION, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.MOVE_PNODE_UP, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.14">[CMD.REDO, () =&gt; p_leoUI.command(LEOCMD.REDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.REDO_FO, () =&gt; p_leoUI.command(LEOCMD.REDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.UNDO, () =&gt; p_leoUI.command(LEOCMD.UNDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.UNDO_FO, () =&gt; p_leoUI.command(LEOCMD.UNDO, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.REVERT_TO_UNDO, (p_undo: LeoUndoNode) =&gt; p_leoUI.revertToUndo(p_undo)],

</t>
<t tx="felix.20201214150149.15">[CMD.SHOW_WELCOME, () =&gt; p_leoUI.showSettings()],
[CMD.SHOW_SETTINGS, () =&gt; p_leoUI.showSettings()],
[CMD.SHOW_OUTLINE, () =&gt; p_leoUI.showOutline(true)], // Also focuses on outline
[CMD.SHOW_LOG, () =&gt; p_leoUI.showLogPane()],
[CMD.SHOW_BODY, () =&gt; p_leoUI.showBody(false, undefined)], // Also focuses on body
</t>
<t tx="felix.20201214150149.16">[CMD.COPY_MARKED, () =&gt; p_leoUI.command(LEOCMD.COPY_MARKED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DIFF_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.DIFF_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MARK_CHANGED_ITEMS, () =&gt; p_leoUI.command(LEOCMD.MARK_CHANGED_ITEMS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MARK_SUBHEADS, () =&gt; p_leoUI.command(LEOCMD.MARK_SUBHEADS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.CLONE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.CLONE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DELETE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.DELETE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.MOVE_MARKED_NODES, () =&gt; p_leoUI.command(LEOCMD.MOVE_MARKED_NODES, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

</t>
<t tx="felix.20201214150149.17">[CMD.CLONE_FIND_TAG, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_TAG, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.CLONE_FIND_PARENTS, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_PARENTS, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.CLONE_FIND_ALL, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_ALL_FLATTENED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CLONE_FIND_MARKED, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_MARKED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; p_leoUI.command(LEOCMD.CLONE_FIND_FLATTENED_MARKED, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.SET_FIND_EVERYWHERE_OPTION, () =&gt; p_leoUI.command(LEOCMD.SET_FIND_EVERYWHERE_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.SET_FIND_NODE_ONLY_OPTION, () =&gt; p_leoUI.command(LEOCMD.SET_FIND_NODE_ONLY_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.SET_FIND_FILE_ONLY_OPTION, () =&gt; p_leoUI.command(LEOCMD.SET_FIND_FILE_ONLY_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, () =&gt; p_leoUI.command(LEOCMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

[CMD.TOGGLE_FIND_IGNORE_CASE_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_IGNORE_CASE_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_MARK_CHANGES_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_MARK_CHANGES_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_MARK_FINDS_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_MARK_FINDS_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_REGEXP_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_REGEXP_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_WORD_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_WORD_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_SEARCH_BODY_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_SEARCH_BODY_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, () =&gt; p_leoUI.command(LEOCMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

</t>
<t tx="felix.20201214150149.2">@others
</t>
<t tx="felix.20201214150149.3">[CMD.EXECUTE, () =&gt; p_leoUI.command(LEOCMD.EXECUTE_SCRIPT, { refreshType: REFRESH_ALL, finalFocus: Focus.NoChange })],

[CMD.MINIBUFFER, () =&gt; p_leoUI.minibuffer()], // Is referenced in package.json
[CMD.SET_LEO_ID, () =&gt; p_leoUI.setLeoIDCommand()],

[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; p_leoUI.clickAtButton(p_node)], // Not referenced in package.json
[CMD.GOTO_SCRIPT, (p_node: LeoButtonNode) =&gt; p_leoUI.gotoScript(p_node)],
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; p_leoUI.removeAtButton(p_node)],

</t>
<t tx="felix.20201214150149.4">[CMD.CLOSE_FILE, () =&gt; p_leoUI.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; p_leoUI.newLeoFile()],
[CMD.OPEN_FILE, (p_uri?: vscode.Uri) =&gt; p_leoUI.openLeoFile(p_uri)],
[CMD.REVERT, () =&gt; p_leoUI.command(LEOCMD.REVERT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

[CMD.SAVE_AS_FILE, () =&gt; p_leoUI.saveAsLeoFile()],
[CMD.SAVE_AS_LEOJS, () =&gt; p_leoUI.saveAsLeoJsFile()],
[CMD.SAVE_FILE, () =&gt; p_leoUI.saveLeoFile()],
[CMD.SAVE_FILE_FO, () =&gt; p_leoUI.saveLeoFile(true)],

[CMD.SWITCH_FILE, () =&gt; p_leoUI.switchLeoFile()],
[CMD.RECENT_FILES, () =&gt; p_leoUI.showRecentLeoFiles()],

[CMD.WRITE_AT_FILE_NODES, () =&gt; p_leoUI.command(LEOCMD.WRITE_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.WRITE_AT_FILE_NODES_FO, () =&gt; p_leoUI.command(LEOCMD.WRITE_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],
[CMD.WRITE_DIRTY_AT_FILE_NODES, () =&gt; p_leoUI.command(LEOCMD.WRITE_DIRTY_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.WRITE_DIRTY_AT_FILE_NODES_FO, () =&gt; p_leoUI.command(LEOCMD.WRITE_DIRTY_AT_FILE_NODES, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.SET_OPENED_FILE, (p_index: number) =&gt; p_leoUI.selectOpenedLeoDocument(p_index, true)],

[CMD.REFRESH_FROM_DISK, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],

[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.REFRESH_FROM_DISK, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.GIT_DIFF, () =&gt; p_leoUI.command(LEOCMD.GIT_DIFF, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

[CMD.TAB_CYCLE_NEXT, () =&gt; p_leoUI.tabCycle()],

</t>
<t tx="felix.20201214150149.5">[CMD.HEADLINE, (p_node: Position) =&gt; p_leoUI.editHeadline(p_node, true)],
[CMD.HEADLINE_SELECTION, () =&gt; p_leoUI.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; p_leoUI.editHeadline(U, true)],

</t>
<t tx="felix.20201214150149.6">// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.COPY_PNODE, { node: p_node, refreshType: NO_REFRESH, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.CUT, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.DELETE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PASTE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],
[CMD.PASTE_CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, keepSelection: true })],

// cut/copy/paste/delete current selection (self.commander.p)
[CMD.COPY_SELECTION, () =&gt; p_leoUI.command(LEOCMD.COPY_PNODE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.CUT_SELECTION, () =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.CUT_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.CUT_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.DELETE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.DELETE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.DELETE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.PASTE_CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PASTE_CLONE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.PASTE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PASTE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.PASTE_PNODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.SET_UA, () =&gt; p_leoUI.command(LEOCMD.SET_UA, { refreshType: REFRESH_TREE, finalFocus: Focus.NoChange })],

</t>
<t tx="felix.20201214150149.7">// Called by nodes in the tree when selected either by mouse, or with enter
[CMD.SELECT_NODE, (p_outlineNode: LeoOutlineNode) =&gt; p_leoUI.selectTreeNode(p_outlineNode.position, false)], // Select is NOT a Position!
[CMD.OPEN_ASIDE, (p_position: Position) =&gt; p_leoUI.selectTreeNode(p_position, true)],

[CMD.CONTRACT_ALL, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.CONTRACT_ALL_FO, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.CONTRACT_OR_GO_LEFT, () =&gt; p_leoUI.command(LEOCMD.CONTRACT_OR_GO_LEFT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.EXPAND_AND_GO_RIGHT, () =&gt; p_leoUI.command(LEOCMD.EXPAND_AND_GO_RIGHT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

</t>
<t tx="felix.20201214150149.8">[CMD.GOTO_NEXT_CLONE, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { node: p_node, refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Body, isNavigation: true })],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_CLONE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

[CMD.GOTO_NEXT_MARKED, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_MARKED, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_FIRST_SIBLING, () =&gt; p_leoUI.command(LEOCMD.GOTO_FIRST_SIBLING, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_LAST_SIBLING, () =&gt; p_leoUI.command(LEOCMD.GOTO_LAST_SIBLING, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_FIRST_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_FIRST_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_LAST_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_LAST_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.GOTO_PREV_VISIBLE, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_VISIBLE, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

[CMD.PAGE_UP, () =&gt; p_leoUI.command(LEOCMD.PAGE_UP, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],
[CMD.PAGE_DOWN, () =&gt; p_leoUI.command(LEOCMD.PAGE_DOWN, { refreshType: REFRESH_NODE_BODY, finalFocus: Focus.Outline, isNavigation: true })],

</t>
<t tx="felix.20201214150149.9">[CMD.DEHOIST, () =&gt; p_leoUI.command(LEOCMD.DEHOIST, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.DEHOIST_FO, () =&gt; p_leoUI.command(LEOCMD.DEHOIST, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.HOIST, (p_node: Position) =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { node: p_node, refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.HOIST_SELECTION, () =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Body })],
[CMD.HOIST_SELECTION_FO, () =&gt; p_leoUI.command(LEOCMD.HOIST_PNODE, { refreshType: REFRESH_TREE, finalFocus: Focus.Outline })],

[CMD.CHAPTER_NEXT, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_NEXT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.CHAPTER_BACK, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_BACK, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
[CMD.CHAPTER_MAIN, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_MAIN, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.CHAPTER_SELECT, () =&gt; p_leoUI.command(LEOCMD.CHAPTER_SELECT, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

</t>
<t tx="felix.20201214151326.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151326.10">/**
 * All commands this expansion exposes to the user via GUI/keybindings in package.json
 */
public static COMMANDS = {
    // Access to the Settings/Welcome Webview
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    // STATUS_BAR: Constants.NAME + ".statusBar", // Status Bar Click Command
    // Leo Documents
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    REVERT: Constants.NAME + ".revert",
    CLEAR_RECENT_FILES: Constants.NAME + ".clearRecentFiles",
    // Import Export Commands
    IMPORT_ANY_FILE: Constants.NAME + ".importAnyFile",
    READ_FILE_INTO_NODE: Constants.NAME + ".readFileIntoNode",
    EXPORT_HEADLINES: Constants.NAME + ".exportHeadlines",
    FLATTEN_OUTLINE: Constants.NAME + ".flattenOutline",
    OUTLINE_TO_CWEB: Constants.NAME + ".outlineToCweb",
    OUTLINE_TO_NOWEB: Constants.NAME + ".outlineToNoweb",
    REMOVE_SENTINELS: Constants.NAME + ".removeSentinels",
    WEAVE: Constants.NAME + ".weave",
    WRITE_FILE_FROM_NODE: Constants.NAME + ".writeFileFromNode",
    // Leo Document Files
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile",
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline",
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    SAVE_AS_LEOJS: Constants.NAME + ".saveAsLeoJsFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    SET_LEO_ID: Constants.NAME + ".setLeoID",
    GIT_DIFF: Constants.NAME + ".gitDiff",
    TAB_CYCLE_NEXT: Constants.NAME + ".tabCycleNext",
    WRITE_AT_FILE_NODES: Constants.NAME + ".writeAtFileNodes",
    WRITE_AT_FILE_NODES_FO: Constants.NAME + ".writeAtFileNodesFromOutline",
    WRITE_DIRTY_AT_FILE_NODES: Constants.NAME + ".writeDirtyAtFileNodes",
    WRITE_DIRTY_AT_FILE_NODES_FO: Constants.NAME + ".writeDirtyAtFileNodesFromOutline",
    // At-buttons
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    GOTO_SCRIPT: Constants.NAME + ".gotoScript",
    // Outline Node User Interaction
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside", // selects and opens body splitting the workspace
    // Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_FIRST_SIBLING: Constants.NAME + ".gotoFirstSibling",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    REVERT_TO_UNDO: Constants.NAME + ".revertToUndo",
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection",
    SORT_CHILDREN_FO: Constants.NAME + ".sortChildrenSelectionFromOutline",
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    PREV_NODE: Constants.NAME + ".prev",
    PREV_NODE_FO: Constants.NAME + ".prevFromOutline",
    NEXT_NODE: Constants.NAME + ".next",
    NEXT_NODE_FO: Constants.NAME + ".nextFromOutline",
    // Commands from tree panel buttons or context: focus on OUTLINE
    SET_UA: Constants.NAME + ".setUa",
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    INSERT_CHILD: Constants.NAME + ".insertChildNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version
    INSERT_CHILD_SELECTION: Constants.NAME + ".insertChildNodeSelection", // Can be interrupted
    INSERT_CHILD_SELECTION_INTERRUPT: Constants.NAME + ".insertChildNodeSelectionInterrupt", // Can be interrupted
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // Commands from keyboard, while focus on OUTLINE (no need for COPY_SELECTION)
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    INSERT_CHILD_SELECTION_FO: Constants.NAME + ".insertChildNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    CHAPTER_NEXT: Constants.NAME + ".chapterNext",
    CHAPTER_BACK: Constants.NAME + ".chapterBack",
    CHAPTER_MAIN: Constants.NAME + ".chapterMain",
    CHAPTER_SELECT: Constants.NAME + ".chapterSelect",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",

    FIND_QUICK: Constants.NAME + ".findQuick",
    FIND_QUICK_SELECTED: Constants.NAME + ".findQuickSelected",
    FIND_QUICK_TIMELINE: Constants.NAME + ".findQuickTimeline",
    FIND_QUICK_CHANGED: Constants.NAME + ".findQuickChanged",
    FIND_QUICK_HISTORY: Constants.NAME + ".history",
    FIND_QUICK_MARKED: Constants.NAME + ".markedList",
    FIND_QUICK_GO_ANYWHERE: Constants.NAME + ".goAnywhere",
    GOTO_NAV_ENTRY: Constants.NAME + ".gotoNav",

    GOTO_NAV_PREV: Constants.NAME + ".gotoNavPrev",
    GOTO_NAV_NEXT: Constants.NAME + ".gotoNavNext",
    GOTO_NAV_FIRST: Constants.NAME + ".gotoNavFirst",
    GOTO_NAV_LAST: Constants.NAME + ".gotoNavLast",

    START_SEARCH: Constants.NAME + ".startSearch",
    SEARCH_BACKWARD: Constants.NAME + ".searchBackward",
    RE_SEARCH: Constants.NAME + ".reSearch",
    RE_SEARCH_BACKWARD: Constants.NAME + ".reSearchBackward",
    WORD_SEARCH: Constants.NAME + ".wordSearch",
    WORD_SEARCH_BACKWARD: Constants.NAME + ".wordSearchBackward",
    FIND_ALL: Constants.NAME + ".findAll",
    FIND_NEXT: Constants.NAME + ".findNext",
    FIND_NEXT_FO: Constants.NAME + ".findNextFromOutline",
    FIND_PREVIOUS: Constants.NAME + ".findPrevious",
    FIND_PREVIOUS_FO: Constants.NAME + ".findPreviousFromOutline",
    FIND_VAR: Constants.NAME + ".findVar",
    FIND_DEF: Constants.NAME + ".findDef",
    REPLACE: Constants.NAME + ".replace",
    REPLACE_FO: Constants.NAME + ".replaceFromOutline",
    REPLACE_THEN_FIND: Constants.NAME + ".replaceThenFind",
    REPLACE_THEN_FIND_FO: Constants.NAME + ".replaceThenFindFromOutline",
    REPLACE_ALL: Constants.NAME + ".replaceAll",

    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_TAG: Constants.NAME + ".cloneFindTag",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",

    CLONE_FIND_PARENTS: Constants.NAME + ".cloneFindParents",
    GOTO_GLOBAL_LINE: Constants.NAME + ".gotoGlobalLine",
    TAG_CHILDREN: Constants.NAME + ".tagChildren",
    TAG_NODE: Constants.NAME + ".tagNode",
    REMOVE_TAG: Constants.NAME + ".removeTag",
    REMOVE_TAGS: Constants.NAME + ".removeTags",
    SET_FIND_EVERYWHERE_OPTION: Constants.NAME + ".setFindEverywhereOption",
    SET_FIND_NODE_ONLY_OPTION: Constants.NAME + ".setFindNodeOnlyOption",
    SET_FIND_FILE_ONLY_OPTION: Constants.NAME + ".setFindFileOnlyOption",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: Constants.NAME + ".setFindSuboutlineOnlyOption",
    TOGGLE_FIND_IGNORE_CASE_OPTION: Constants.NAME + ".toggleFindIgnoreCaseOption",
    TOGGLE_FIND_MARK_CHANGES_OPTION: Constants.NAME + ".toggleFindMarkChangesOption",
    TOGGLE_FIND_MARK_FINDS_OPTION: Constants.NAME + ".toggleFindMarkFindsOption",
    TOGGLE_FIND_REGEXP_OPTION: Constants.NAME + ".toggleFindRegexpOption",
    TOGGLE_FIND_WORD_OPTION: Constants.NAME + ".toggleFindWordOption",
    TOGGLE_FIND_SEARCH_BODY_OPTION: Constants.NAME + ".toggleFindSearchBodyOption",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: Constants.NAME + ".toggleFindSearchHeadlineOption",
    SET_ENABLE_PREVIEW: Constants.NAME + ".setEnablePreview",
    CLEAR_CLOSE_EMPTY_GROUPS: Constants.NAME + ".clearCloseEmptyGroups",
};

</t>
<t tx="felix.20201214151326.11">/**
 * Leo command names that are called from vscode's gui/menu/buttons/keybindings triggers
 */
public static LEO_COMMANDS = {

    // * File Commands
    // NEW: 'new', // newLeoFile used instead
    // OPEN_OUTLINE: 'open_outline', // openLeoFile used instead
    WRITE_AT_FILE_NODES: 'write-at-file-nodes',
    WRITE_DIRTY_AT_FILE_NODES: 'write-dirty-at-file-nodes',
    REVERT: 'revert',
    // * More Commands
    GOTO_GLOBAL_LINE: "!goto_global_line", // USE LEOJS INSTEAD OF UI
    SET_UA: 'set-ua',

    // * Import Export
    IMPORT_ANY_FILE: "import-file",
    READ_FILE_INTO_NODE: "read-file-into-node",

    EXPORT_HEADLINES: "export-headlines",
    FLATTEN_OUTLINE: "flatten-outline",
    OUTLINE_TO_CWEB: "outline-to-cweb",
    OUTLINE_TO_NOWEB: "outline-to-noweb",
    REMOVE_SENTINELS: "remove-sentinels",
    WEAVE: "weave",
    WRITE_FILE_FROM_NODE: "write-file-from-node",

    // * Search operations
    START_SEARCH: "start-search",
    FIND_ALL: "find-all",
    // FIND_NEXT: "!find_next",
    // FIND_PREVIOUS: "!find_previous",
    FIND_VAR: "find-var",
    FIND_DEF: "find-def",
    // REPLACE: "!replace",
    // REPLACE_THEN_FIND: "!replace_then_find",
    REPLACE_ALL: "change-all",

    SET_FIND_EVERYWHERE_OPTION: "set-find-everywhere",
    SET_FIND_NODE_ONLY_OPTION: "set-find-node-only",
    SET_FIND_FILE_ONLY_OPTION: "set-find-file-only",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: "set-find-suboutline-only",
    TOGGLE_FIND_IGNORE_CASE_OPTION: "toggle-find-ignore-case-option",
    TOGGLE_FIND_MARK_CHANGES_OPTION: "toggle-find-mark-changes-option",
    TOGGLE_FIND_MARK_FINDS_OPTION: "toggle-find-mark-finds-option",
    TOGGLE_FIND_REGEXP_OPTION: "toggle-find-regex-option",
    TOGGLE_FIND_WORD_OPTION: "toggle-find-word-option",
    TOGGLE_FIND_SEARCH_BODY_OPTION: "toggle-find-in-body-option",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: "toggle-find-in-headline-option",

    SEARCH_BACKWARD: "search-backward",
    RE_SEARCH: "re-search",
    RE_SEARCH_BACKWARD: "re-search-backward",
    WORD_SEARCH: "word-search",
    WORD_SEARCH_BACKWARD: "word-search-backward",

    TAG_NODE: "tag-node",
    TAG_CHILDREN: "tag-children",
    REMOVE_TAG: "remove-tag",
    REMOVE_ALL_TAGS: "remove-all-tags",

    // * Undo Operations
    UNDO: "undo",
    REDO: "redo",
    // * Tree Building
    EXECUTE_SCRIPT: "execute-script",
    REFRESH_FROM_DISK: "refresh-from-disk",
    GIT_DIFF: "git-diff",
    // * Outline from body text
    EXTRACT: "extract",
    EXTRACT_NAMES: "extract-names",
    // * Hoist Operations
    HOIST_PNODE: "hoist",
    DEHOIST: "de-hoist",
    CHAPTER_NEXT: "chapter-next",
    CHAPTER_BACK: "chapter-back",
    CHAPTER_SELECT: "chapter-select",
    CHAPTER_MAIN: "chapter-select-main",
    // * History Navigation
    GOTO_PREV_HISTORY: "goto-prev-history-node",
    GOTO_NEXT_HISTORY: "goto-next-history-node",
    // * Goto &amp; Folding
    PAGE_UP: "tree-page-up",
    PAGE_DOWN: "tree-page-down",
    GOTO_FIRST_VISIBLE: "goto-first-visible-node",
    GOTO_LAST_VISIBLE: "goto-last-visible-node",
    GOTO_FIRST_SIBLING: "goto-first-sibling",
    GOTO_LAST_SIBLING: "goto-last-sibling",
    GOTO_NEXT_VISIBLE: "goto-next-visible",
    GOTO_PREV_VISIBLE: "goto-prev-visible",
    GOTO_NEXT_MARKED: "goto-next-marked",
    // GOTO_PREV_MARKED: "goto-prev-marked", // ! Not in Leo's menu nor LeoJS package.json.
    GOTO_NEXT_CLONE: "goto-next-clone",
    CONTRACT_OR_GO_LEFT: "contract-or-go-left",
    EXPAND_AND_GO_RIGHT: "expand-and-go-right",
    CONTRACT_ALL: "contract-all",
    // * Mark Operations
    TOGGLE_MARK: "toggle-mark",
    COPY_MARKED: "copy-marked-nodes",
    DIFF_MARKED_NODES: "diff-marked-nodes",
    MARK_CHANGED_ITEMS: "mark-changed-items",
    MARK_SUBHEADS: "mark-subheads",
    UNMARK_ALL: "unmark-all",
    CLONE_MARKED_NODES: "clone-marked-nodes",
    DELETE_MARKED_NODES: "delete-marked-nodes",
    MOVE_MARKED_NODES: "move-marked-nodes",
    // * Clipboard Operations
    COPY_PNODE: "copy-node",
    CUT_PNODE: "cut-node",
    PASTE_PNODE: "async-paste-node",
    PASTE_CLONE_PNODE: "async-paste-retaining-clones",
    // * Outline Editing
    DELETE_PNODE: "delete-node",
    MOVE_PNODE_DOWN: "move-outline-down",
    MOVE_PNODE_LEFT: "move-outline-left",
    MOVE_PNODE_RIGHT: "move-outline-right",
    MOVE_PNODE_UP: "move-outline-up",
    INSERT_PNODE: "insert-node",
    INSERT_CHILD_PNODE: "insert-child",
    CLONE_PNODE: "clone-node",
    // * Marshalling Operations
    PROMOTE_PNODE: "promote",
    DEMOTE_PNODE: "demote",
    SORT_CHILDREN: "sort-children",
    SORT_SIBLINGS: "sort-siblings",
    // * Clone-find functionality

    CLONE_FIND_ALL_FLATTENED: "cff",

    CLONE_FIND_FLATTENED_MARKED: "cffm",
    CLONE_FIND_TAG: "cft",
    CLONE_FIND_ALL: "cfa",
    CLONE_FIND_MARKED: "cfam",
    CLONE_FIND_PARENTS: "clone-find-parents",
};

</t>
<t tx="felix.20201214151326.2">/**
 * Text and numeric constants used throughout leojs
 */
export class Constants {

    /**
     * Identity of account that can publish extensions to the Visual Studio Code Marketplace. 
     */
    public static PUBLISHER: string = "boltex";

    /**
     * The name of the extension - should be all lowercase with no spaces.
     */
    @others
}
</t>
<t tx="felix.20201214151326.3">public static NAME: string = "leojs";

public static TREEVIEW_ID: string = "leojsOutline";
public static TREEVIEW_EXPLORER_ID: string = "leojsOutlineExplorer";

public static DOCUMENTS_ID: string = "leojsDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leojsDocumentsExplorer";

public static BUTTONS_ID: string = "leojsButtons";
public static BUTTONS_EXPLORER_ID: string = "leojsButtonsExplorer";

public static FIND_ID: string = "leojsFindPanel";
public static FIND_EXPLORER_ID: string = "leojsFindPanelExplorer";

public static GOTO_ID: string = "leojsGotoPanel";
public static GOTO_EXPLORER_ID: string = "leojsGotoPanelExplorer";

public static UNDOS_ID: string = "leojsUndos";
public static UNDOS_EXPLORER_ID: string = "leojsUndosExplorer";

public static VERSION_STATE_KEY: string = "leojsVersion";

public static FILE_EXTENSION: string = "leo";
public static DB_FILE_EXTENSION: string = "db";
public static JS_FILE_EXTENSION: string = "leojs";

public static LEO_LANGUAGE_PREFIX: string = "leojsbody."; // all lowercase.

public static URI_LEOJS_SCHEME: string = "leojs";
public static URI_FILE_SCHEME: string = "file";
public static URI_SCHEME_HEADER: string = "leojs:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files"; // Meant for all 3 leo, db and leojs.
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leojsRecentFiles";
public static LAST_FILES_KEY: string = "leojsLastFiles";

public static REFRESH_DEBOUNCE_DELAY: number = 50;
public static STATES_DEBOUNCE_DELAY: number = 60;
public static TITLE_DEBOUNCE_DELAY: number = 20;
public static BUTTONS_DEBOUNCE_DELAY: number = 160;
public static DOCUMENTS_DEBOUNCE_DELAY: number = 80;
public static UNDOS_DEBOUNCE_DELAY: number = 140;
public static UNDOS_REVEAL_DEBOUNCE_DELAY: number = 50;
public static GOTO_DEBOUNCE_DELAY: number = 50;
public static BODY_STATES_DEBOUNCE_DELAY: number = 120;

public static CONFIG_NAME: string = "leojs";
public static CONFIG_WORKBENCH_ENABLED_PREVIEW: string = "workbench.editor.enablePreview";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

</t>
<t tx="felix.20201214151326.4">/**
 * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_PARENT: "resources/light/parent.svg",
    ICON_DARK_PARENT: "resources/dark/parent.svg",
    ICON_LIGHT_NODE: "resources/light/node.svg",
    ICON_DARK_NODE: "resources/dark/node.svg",
    ICON_LIGHT_BODY: "resources/light/body.svg",
    ICON_DARK_BODY: "resources/dark/body.svg",
    ICON_LIGHT_TAG: "resources/light/tag.svg",
    ICON_DARK_TAG: "resources/dark/tag.svg",

    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",

    ICON_LIGHT_UNDO_ACTIVE: "resources/light/undo.svg",
    ICON_DARK_UNDO_ACTIVE: "resources/dark/undo.svg",
    ICON_LIGHT_UNDO: "resources/dark/undo.svg",
    ICON_DARK_UNDO: "resources/light/undo.svg",
    ICON_LIGHT_REDO_ACTIVE: "resources/light/redo.svg",
    ICON_DARK_REDO_ACTIVE: "resources/dark/redo.svg",
    ICON_LIGHT_REDO: "resources/dark/redo.svg",
    ICON_DARK_REDO: "resources/light/redo.svg",

    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_RCLICK: "resources/light/button-rclick.svg",
    ICON_DARK_BUTTON_RCLICK: "resources/dark/button-rclick.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",

    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    SVG_SHEME: "data",
    SVG_OPEN: 'image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none"&gt;',
    SVG_CLOSE: "&lt;/svg&gt;",
    STATUSBAR_INDICATOR: "$(keyboard) ",
    STATUSBAR_COLOR: "fb7c47",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leojs: ",
    EXPLORER_TREEVIEW_PREFIX: "LEOJS ",
    TREEVIEW_TITLE: "OUTLINE",
    BODY_TITLE: "LEOJS BODY",
    LOG_PANE_TITLE: "LeoJS Log Window",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20201214151326.5">/**
 * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "from selected node",
    SCRIPT_BUTTON_TOOLTIP:
        "Creates a new button with the presently selected node.\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing a script. e.g. \"g.es(p.h)\"\n" +
        "2.  Press 'Script Button' to create a new button.\n" +
        "3.  Select another node on which to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    SAVE_DIALOG_LABEL: "Save Leo File",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOJS: "Open this Leojs file?",
    OPEN_RECENT_FILE: "Open Recent Leojs File",
    RIGHT_CLICK_TO_OPEN: "Right-click to open with leojs",
    FILE_ALREADY_OPENED: "Leojs file already opened",

    CLEARED_RECENT: "Cleared recent files list",
    CHOOSE_OPENED_FILE: "Select an opened Leojs File",
    FILE_NOT_OPENED: "No files opened.",

    // STATUS BAR UNUSED FOR NOW IN LEOJS // 
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked

    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    PROMPT_INSERT_CHILD: "Insert Child",
    DEFAULT_HEADLINE: "New Headline",

    TITLE_GOTO_GLOBAL_LINE: "Goto global line", // TODO : REMOVE IF NOT USED
    PLACEHOLDER_GOTO_GLOBAL_LINE: "#", // TODO : REMOVE IF NOT USED
    PROMPT_GOTO_GLOBAL_LINE: "Line number", // TODO : REMOVE IF NOT USED

    REPLACE_TITLE: "Replace with",
    REPLACE_PROMPT: "Type text to replace with and press enter.",
    REPLACE_PLACEHOLDER: "Replace pattern here",

    SEARCH_TITLE: "Search for",
    SEARCH_PROMPT: "Type text to search for and press enter.",
    SEARCH_PLACEHOLDER: "Find pattern here",

    INT_SEARCH_TITLE: "Search",
    INT_SEARCH_PROMPT: "'Enter' to search",
    INT_SEARCH_BACKWARD: " Backward", // Leading space intended
    INT_SEARCH_REGEXP: "Regexp ", // Trailing space intended
    INT_SEARCH_WORD: "Word ", // Trailing space intended

    SEARCH_NOT_FOUND: "Not found",
    FIND_PATTERN_HERE: "&lt;find pattern here&gt;",

    TAGS_CHARACTERS_ERROR: "Cannot add tags containing any of these characters: &amp;|^-",
    NO_TAGS_ON_NODE: "No tags on node: ", // Trailing space intended

    TITLE_TAG_CHILDREN: "Tag Children",
    TITLE_REMOVE_TAG: "Remove Tag",
    TITLE_TAG_NODE: "Tag Node",
    PLACEHOLDER_TAG: "&lt;tag&gt;",
    PROMPT_TAG: "Enter a tag name",

    TITLE_FIND_TAG: "Find Tag", // TODO remove if used directly in leoFind.ts
    PLACEHOLDER_CLONE_FIND_TAG: "&lt;tag&gt;", // TODO remove if used directly in leoFind.ts
    PROMPT_CLONE_FIND_TAG: "Enter a tag name",// TODO remove if used directly in leoFind.ts

    CLOSE_ERROR: "Cannot close: No files opened.",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    CHOOSE_BUTTON: "Choose @button or @rclick",
    SEARCH_POSITION_BY_HEADLINE: "Search positions by headline",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    SELECT_CHAPTER_PROMPT: "Select chapter",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "Leo is busy! ", // with voluntary trailing space

    UNKNOWN_LANGUAGE_NOT_SUPPORTED: "Language not yet supported.",
    LANGUAGE_NOT_SUPPORTED: " language not yet supported.", // with leading space
    MINIBUFFER_BUTTON_START: "@button-",
    MINIBUFFER_RCLICK_START: "@rclick-",
    MINIBUFFER_SCRIPT_BUTTON: "script-button",
    MINIBUFFER_DEL_SCRIPT_BUTTON: "delete-script-",
    MINIBUFFER_DEL_BUTTON_START: "delete-@button-",
    MINIBUFFER_COMMAND_START: "@command-",
    MINIBUFFER_USER_DEFINED: "User defined command.",
    MINIBUFFER_BUTTON: "$(run) @button",
    MINIBUFFER_RCLICK: "$(chevron-right) @rclick",
    MINIBUFFER_COMMAND: "$(zap) @command",
    MINIBUFFER_BAD_COMMAND: "$(error) Not Available",
    MINIBUFFER_HISTORY_LABEL: "Minibuffer History",
    MINIBUFFER_HISTORY_DESC: "Choose from last run commands...",

    ZOOM_LEVEL_RANGE_LIMIT: "Value for zoom level should be between -12 and 12",
    FONT_SIZE_RANGE_LIMIT: "Value for font size should be between 6 and 30",
    FIX_IT: "Fix it",
    ENABLE_PREVIEW_SET: "'Enable Preview' setting was set",
    ENABLE_PREVIEW_RECOMMEND: "'Enable Preview' setting is recommended (currently disabled)",
    CLOSE_EMPTY_CLEARED: "'Close Empty Groups' setting was cleared",
    CLOSE_EMPTY_RECOMMEND: "'Close Empty Groups' setting is NOT recommended!",
    CLOSE_ON_DELETE_SET: "'Close on File Delete' setting was set",
    CLOSE_ON_DELETE_RECOMMEND: "'Close on File Delete' setting is recommended (currently disabled)",
    SET_LEO_ID_MESSAGE: "Leo ID not found. Please enter an id that identifies you uniquely.",
    GET_LEO_ID_PROMPT: "Please enter an id that identifies you uniquely.\n(Letters and numbers only, and at least 3 characters in length)",
    ENTER_LEO_ID: "Enter Leo id"
};

</t>
<t tx="felix.20201214151326.6">/**
 * * Strings used in 'at-button' panel display in LeoButtonNode
 */
public static BUTTON_STRINGS = {
    NULL_WIDGET: "nullButtonWidget",
    SCRIPT_BUTTON: "script-button",
    ADD_BUTTON: "leojsButtonAdd",
    NORMAL_BUTTON: "leojsButtonNode"
};

</t>
<t tx="felix.20201214151326.7">/**
 * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20201214151326.8">/**
 * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    LEO_STARTUP_DONE: "leojsStartupDone",
    LEO_READY: "leojsReady", // Extension activated and classes created and ready
    TREE_OPENED: "leojsTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leojsTreeTitled", // Tree is a Leo file and not a new untitled document

    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leojsChanged",
    LEO_CAN_UNDO: "leojsCanUndo",
    LEO_CAN_REDO: "leojsCanRedo",
    LEO_CAN_BACK: "leojsCanGoBack",
    LEO_CAN_NEXT: "leojsCanGoNext",
    LEO_CAN_DEMOTE: "leojsCanDemote",
    LEO_CAN_PROMOTE: "leojsCanPromote",
    LEO_CAN_DEHOIST: "leojsCanDehoist",
    LEO_CAN_HOIST: "leojsCanHoist", // isNotRoot equivalent, Computed by hand
    LEO_TOP_HOIST_CHAPTER: "leojsTopHoistChapter",
    LEO_EDIT_HEADLINE: "leojsEditHeadline",

    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leojsMarked", // no need for unmarked here, use !leojsMarked
    SELECTED_CLONE: "leojsCloned",
    SELECTED_DIRTY: "leojsDirty",
    SELECTED_EMPTY: "leojsEmpty",
    SELECTED_CHILD: "leojsChild", // Has children
    SELECTED_ATFILE: "LeojsAtFile", // Can be refreshed

    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leojsObjectSelected", // keybindings "On": Outline or body has focus

    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leojsNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leojsNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leojsNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leojsNodeCloned",
    NODE_ROOT: "leojsNodeRoot",
    NODE_NOT_ROOT: "leojsNodeNotRoot",
    NODE_TAGS: "leojsNodeTags",

    // Flags for undo nodes 
    UNDO_BEAD: "leojsUndoNode",
    NOT_UNDO_BEAD: "leojsNoUndoNode",

    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leojsDocumentSelectedTitled",
    DOCUMENT_TITLED: "leojsDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leojsDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leojsDocumentUntitled",

    // Flags for focus context
    FOCUS_FIND: "leojsFindFocus",

    // Context flags that are mapped 'directly' onto leojs config settings
    // * PREFIXED WITH 'leojs' *
    LEO_TREE_BROWSE: Constants.NAME + Constants.CONFIG_NAMES.LEO_TREE_BROWSE[0].toUpperCase() + Constants.CONFIG_NAMES.LEO_TREE_BROWSE.slice(1), // Force ar'jan's suggestion of Leo's tree behavior override
    TREE_IN_EXPLORER: Constants.NAME + Constants.CONFIG_NAMES.TREE_IN_EXPLORER[0].toUpperCase() + Constants.CONFIG_NAMES.TREE_IN_EXPLORER.slice(1), // Leo outline also in the explorer view
    SHOW_OPEN_ASIDE: Constants.NAME + Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE.slice(1),   // Show 'open aside' in context menu
    SHOW_EDIT: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EDIT[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EDIT.slice(1),              // Hover Icons on outline nodes
    // SHOW_ARROWS: Constants.NAME + Constants.CONFIG_NAMES.SHOW_ARROWS[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_ARROWS.slice(1),           // Hover Icons on outline nodes
    SHOW_ADD: Constants.NAME + Constants.CONFIG_NAMES.SHOW_ADD[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_ADD.slice(1),                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.NAME + Constants.CONFIG_NAMES.SHOW_MARK[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_MARK.slice(1),               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.NAME + Constants.CONFIG_NAMES.SHOW_CLONE[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_CLONE.slice(1),             // Hover Icons on outline nodes
    SHOW_COPY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_COPY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_COPY.slice(1),               // Hover Icons on outline nodes

    // SHOW_EDITION_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EDITION_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EDITION_BODY.slice(1),
    // SHOW_CLIPBOARD_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY.slice(1),
    // SHOW_PROMOTE_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY.slice(1),
    // SHOW_EXECUTE_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY.slice(1),
    // SHOW_EXTRACT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY.slice(1),
    // SHOW_IMPORT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_IMPORT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_IMPORT_BODY.slice(1),
    // SHOW_REFRESH_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_REFRESH_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_REFRESH_BODY.slice(1),
    // SHOW_HOIST_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_HOIST_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_HOIST_BODY.slice(1),
    // SHOW_MARK_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_MARK_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_MARK_BODY.slice(1),
    // SHOW_SORT_BODY: Constants.NAME + Constants.CONFIG_NAMES.SHOW_SORT_BODY[0].toUpperCase() + Constants.CONFIG_NAMES.SHOW_SORT_BODY.slice(1)
};

</t>
<t tx="felix.20201214151326.9">/**
 * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20201214151419.1">import * as vscode from "vscode";
import { Icon, LeoButton } from "./types";
import { Constants } from "./constants";
import { LeoStates } from "./leoStates";
import * as g from './core/leoGlobals';
import { RClick } from "./core/mod_scripting";
import { nullButtonWidget } from "./core/leoFrame";

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20201214151419.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _icons: Icon[],
    ) { }

    @others
}

</t>
<t tx="felix.20201214151419.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201214151419.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20201214151419.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {
    const w_children: LeoButtonNode[] = [];
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element) {

        const c = g.app.windowList[g.app.gui.frameIndex].c;

        let d: nullButtonWidget[];
        if (c &amp;&amp; c.theScriptingController) {
            d = c.theScriptingController.buttonsArray || [];
        } else {
            d = [];
        }

        const buttons = [];

        let i_but = 0;
        for (const but of d) {
            let rclickList: RClick[] = [];

            if (but.rclicks) {
                rclickList = but.rclicks;
            }

            const entry: LeoButton = {
                name: but.text,
                index: i_but,
                rclicks: rclickList,
            };

            buttons.push(entry);
            i_but += 1;
        }


        buttons.forEach(p_button =&gt; {
            w_children.push(new LeoButtonNode(p_button, this._icons));
        });


    }
    return Promise.resolve(w_children); // Defaults to an empty list of children
}

</t>
<t tx="felix.20201214151419.6">public getParent(element: LeoButtonNode): vscode.ProviderResult&lt;LeoButtonNode&gt; | null {
    // Buttons are just a list, as such, entries are always child of root so return null
    return null;
}

</t>
<t tx="felix.20201214151425.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;
    public rclicks: RClick[];

    // is the special 'add' button used to create button from a given node's script
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _buttonIcons: Icon[], // pointer to global array of node icons
    ) {
        super(button.name);

        // Setup this instance (just differentiate 'script-button' for now)
        this.command = {
            command: Constants.COMMANDS.CLICK_BUTTON,
            title: '',
            arguments: [this]
        };

        this._isAdd = this.button.name === Constants.BUTTON_STRINGS.SCRIPT_BUTTON;

        this.rclicks = button.rclicks ? button.rclicks : [];
        this.contextValue = this._isAdd ? Constants.BUTTON_STRINGS.ADD_BUTTON : Constants.BUTTON_STRINGS.NORMAL_BUTTON;

    }

    @others
}

</t>
<t tx="felix.20201214151425.3">// @ts-ignore
public get iconPath(): Icon {
    return this._buttonIcons[this._isAdd ? 2 : this.rclicks.length ? 1 : 0];

}

</t>
<t tx="felix.20201214151425.4">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to index to prevent accidental duplicates
    return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20201214151425.5">// @ts-ignore
public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20201214151425.6">// @ts-ignore
public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20201214151429.1">import * as vscode from "vscode";
import { LeoUI } from './leoUI';
import { LeoStates } from "./leoStates";
import { Constants } from "./constants";
import * as utils from "./utils";
import * as g from './core/leoGlobals';
import { Commands } from "./core/leoCommands";
import { LeoFrame } from "./core/leoFrame";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151429.2">/**
 * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoFrame&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoFrame | undefined&gt; = new vscode.EventEmitter&lt;LeoFrame | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoFrame | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _leoUI: LeoUI,
    ) { }

    @others
}

</t>
<t tx="felix.20201214151429.3">/**
 * Refresh the whole Leo Document panel
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20201214151429.4">public getTreeItem(element: LeoFrame): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return new LeoDocumentNode(element, this._leoUI,);
}

</t>
<t tx="felix.20201214151429.5">public getChildren(element?: LeoFrame): LeoFrame[] {
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element) {
        return g.app.windowList;
    } else {
        return []; // Should not happen!
    }
}

</t>
<t tx="felix.20201214151429.6">public getParent(element: LeoFrame): vscode.ProviderResult&lt;LeoFrame&gt; {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return undefined;
}

</t>
<t tx="felix.20201214151434.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    constructor(
        public frame: LeoFrame,
        private _leoUI: LeoUI,
    ) {
        super(frame.c.fileName() ? utils.getFileFromPath(frame.c.fileName()) : Constants.UNTITLED_FILE_NAME);

        const c: Commands = frame.c;
        const filename = c.fileName();
        const isNamed: boolean = !!filename;
        this.label = isNamed ? utils.getFileFromPath(filename) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = isNamed ? filename : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [g.app.windowList.indexOf(frame)]
        };

        if (frame === g.app.windowList[this._leoUI.frameIndex]) {
            // If this was created as a selected node, make sure it's selected
            this._leoUI.setDocumentSelection(frame);
            this.contextValue = isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }

        this.id = `d${g.app.windowList.indexOf(frame)}f${c.fileName()}c${c.changed.toString()}`;
        this.iconPath = this._leoUI.documentIcons[c.changed ? 1 : 0];
    }

}
</t>
<t tx="felix.20201214151447.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { LeoUI } from "./leoUI";
import { Constants } from "./constants";
import { LeoPackageStates } from "./types";
import { Position } from "./core/leoNodes";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151447.10">/**
 * Current selection allows promote command
 */
private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20201214151447.11">/**
 * Currently selected can de-hoist state
 */
private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20201214151447.12"></t>
<t tx="felix.20201214151447.13">// * 'states' flags about current selection, for visibility and commands availability
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20201214151447.14">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20201214151447.15">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20201214151447.16">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20201214151447.17">private _leoChild: boolean = false;
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20201214151447.18">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20201214151447.19">// * Special is-root 'state' flag about current selection, for visibility and commands availability
private _leoRoot: boolean = false;
get leoRoot(): boolean {
    return this._leoRoot;
}
set leoRoot(p_value: boolean) {
    this._leoRoot = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_HOIST, !p_value);
}

</t>
<t tx="felix.20201214151447.2">/**
 * * Global states service
 * Holds state flags used to restrict command availability and icon visibility
 * Changes UI by changing vscode's context variables
 */
export class LeoStates {

    public qLastContextChange: Thenable&lt;unknown&gt;; // Promise that the last state change is applied

    @others
}
</t>
<t tx="felix.20201214151447.20">constructor(
    private _context: vscode.ExtensionContext,
    private _leoJs: LeoUI
) {
    this.qLastContextChange = Promise.resolve(); // Temporary.
}

</t>
<t tx="felix.20201214151447.21">public setSelectedNodeFlags(p_node: Position): void {
    this.leoMarked = p_node.isMarked();
    this.leoCloned = p_node.isCloned();
    this.leoDirty = p_node.isDirty();
    this.leoEmpty = !p_node.v.hasBody();
    this.leoChild = p_node.hasChildren();
    this.leoAtFile = p_node.isAtFileNode();
    this.leoRoot = p_node._isRoot;
}

</t>
<t tx="felix.20201214151447.22">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoChanged = p_states.changed;
    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;
    this.leoCanGoBack = p_states.canGoBack;
    this.leoCanGoNext = p_states.canGoNext;
    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;
    this.leoCanDehoist = p_states.canDehoist;
    this.leoRoot = !p_states.canHoist;
    this.leoTopHoistChapter = p_states.topIsChapter;
}
</t>
<t tx="felix.20201214151447.3"></t>
<t tx="felix.20201214151447.4">/**
 * A Leo file is opened
 */
private _fileOpenedReady: boolean = false; // Sets context flag along with treeview title
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.5">/**
 * Currently opened Leo file path and name, empty string if new unsaved file.
 */
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {
    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.6">/**
 * Currently opened commander is dirty
 */
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    if (this._leoChanged !== p_value) {
        // Refresh Documents Panel
        // ? Needed?
        this._leoJs.refreshDocumentsPane();
    }
    this._leoChanged = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
    this._leoJs.setTreeViewTitle();
}

</t>
<t tx="felix.20201214151447.7">/**
 * Undo operation available state
 */
private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20201214151447.8">/**
 * Redo operation available state
 */
private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20201214151447.9">/**
 * Current selection allows demote command
 */
private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20201214151451.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoUI } from "./leoUI";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214151451.2">/**
 * * Statusbar indicator controller service
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _statusbarNormalColor = new vscode.ThemeColor(Constants.GUI.THEME_STATUSBAR);  // "statusBar.foreground"
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the default from config

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoJs: LeoUI
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._context.subscriptions.push(this._leoStatusBarItem); // Disposable 

        this._leoStatusBarItem.color = Constants.GUI.STATUSBAR_COLOR;
        // this._leoStatusBarItem.command = Constants.COMMANDS.SWITCH_FILE;
        this._leoStatusBarItem.command = Constants.COMMANDS.SHOW_LOG;
        // this._leoStatusBarItem.command = "leojs.test"; // just call test function for now to help debugging
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;

        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20201214151451.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20201214151451.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20201214151451.5">/**
 * * Sets string to replace default from config &amp; refresh it
 */
public setString(p_string: string): void {
    this._string = p_string;
    this._updateLeoObjectIndicator();
}

</t>
<t tx="felix.20201214151451.6">/**
 * * Updates the status bar visual indicator visual indicator with optional debouncing delay
 * @param p_state True/False flag for On or Off status
 * @param p_debounceDelay Optional, in milliseconds
 */
public update(p_state: boolean, p_debounceDelay?: number, p_forced?: boolean): void {
    if (p_forced || (p_state !== this.statusBarFlag)) {
        this.statusBarFlag = p_state;
        if (p_debounceDelay) {
            this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
        } else {
            this._updateLeoObjectIndicator();
        }
    }
}

</t>
<t tx="felix.20201214151451.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20201214151451.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }

    void utils.setContext(Constants.CONTEXT_FLAGS.LEO_SELECTED, !!this.statusBarFlag);

    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR +
        (this._string ? this._string : '') + " " +
        (this._leoJs.leoStates.leoOpenedFileName ? utils.getFileFromPath(this._leoJs.leoStates.leoOpenedFileName) : Constants.UNTITLED_FILE_NAME);

    // Also check in constructor for statusBar properties (the createStatusBarItem call itself)
    if (this.statusBarFlag &amp;&amp; this._leoJs.leoStates.fileOpenedReady) {
        this._leoStatusBarItem.color = "#" + Constants.GUI.STATUSBAR_COLOR;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
    } else {
        this._leoStatusBarItem.color = this._statusbarNormalColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_OFF;
    }
}

</t>
<t tx="felix.20201214154816.1">import * as vscode from "vscode";
import { Position } from "./core/leoNodes";
import { LeoOutlineNode } from "./leoOutline";
import { RClick } from "./core/mod_scripting";
import { nullButtonWidget } from "./core/leoFrame";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214154816.10">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string | vscode.Uri;
    dark: string | vscode.Uri;
}

</t>
<t tx="felix.20201214154816.11">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    "initialFile": string;
    "title": string;
    "message": string;
    "filetypes": string[];
    "defaultExtension": string;
}

</t>
<t tx="felix.20201214154816.12">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    "ask": string;
    "message": string;
    "yes_all": boolean;
    "no_all": boolean;
}

</t>
<t tx="felix.20201214154816.13">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    "warn": string;
    "message": string;
}

</t>
<t tx="felix.20201214154816.14">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    "message": string;
}

</t>
<t tx="felix.20201214154816.15">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20201214154816.16">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20201214154816.17">/**
 * * Used by the minibuffer command pallette
 */
export interface MinibufferCommand extends vscode.QuickPickItem {
    func: string;
}
</t>
<t tx="felix.20201214154816.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // Re-use the old treeId with "NoReveal" for the selected node.
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20201214154816.4">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    scroll?: boolean; // Body needs to set and reveal text selection

    states?: boolean; // Currently opened tree view states needs refresh:
    // changed, canUndo, canRedo, canGoBack, canGoNext, canDemote, canPromote, 
    // canHoist, canDehoist, inChapter, topHoistChapter

    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
    goto?: boolean; // Goto pane needs refresh
}

</t>
<t tx="felix.20201214154816.7">/**
 * * General state flags for UI representation and controls visibility.
 */
export interface LeoPackageStates {
    changed: boolean; // Leo document has changed (is dirty)
    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'
    canGoBack: boolean; // Has history
    canGoNext: boolean; // Has used goBack at least once
    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted
    canDehoist: boolean; // Leo Document is currently hoisted and can be de-hoisted
    canHoist: boolean; // Selected node is not the first top node already root
    topIsChapter: boolean; // Top of the hoisted outline is an @chapter node
}

</t>
<t tx="felix.20201214154816.8">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20201214154816.9">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider
 */
export interface LeoButton {
    name: string;
    index: number;
    rclicks?: RClick[];
}

</t>
<t tx="felix.20201214194144.1">import * as vscode from "vscode";
import { Utils as uriUtils } from "vscode-uri"; // May be useful!
import { DebouncedFunc, debounce } from "lodash";
import * as path from 'path'; // May be useful!

import * as utils from "./utils";
import * as commandBindings from "./commandBindings";
import { Constants } from "./constants";
import {
    RevealType,
    Icon,
    ReqRefresh,
    LeoPackageStates,
    ConfigSetting,
    LeoSearchSettings,
    Focus,
    BodySelectionInfo,
    CommandOptions,
    LeoGotoNavKey,
    LeoGuiFindTabManagerSettings,
    ChooseDocumentItem,
    LeoDocument,
    ChooseRClickItem
} from "./types";

import { Config } from "./config";
import { LeoOutlineProvider } from './leoOutline';
import { LeoButtonNode, LeoButtonsProvider } from "./leoButtons";
import { LeoDocumentsProvider } from "./leoDocuments";
import { LeoStates } from "./leoStates";
import { LeoBodyProvider } from "./leoBody";
import { LeoUndoNode, LeoUndosProvider } from "./leoUndos";

import * as g from './core/leoGlobals';
import { Commands } from "./core/leoCommands";
import { Position } from "./core/leoNodes";
import { LeoGotoNode, LeoGotoProvider } from "./leoGoto";
import { LeoFrame, StringTextWrapper } from "./core/leoFrame";
import { LeoFindPanelProvider } from "./leoFindPanelWebview";
import { LeoSettingsProvider } from "./leoSettingsWebview";
import { ISettings, LeoFind } from "./core/leoFind";
import { NullGui } from "./core/leoGui";
import { StringFindTabManager } from "./core/findTabManager";
import { QuickSearchController } from "./core/quicksearch";
import { IdleTime } from "./core/idle_time";
import { RClick } from "./core/mod_scripting";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201214194144.2">constructor(guiName = 'vscodeGui', private _context: vscode.ExtensionContext) {
    super(guiName);
    this.isNullGui = false;

    this.idleTimeClass = IdleTime;

    // * Log pane instanciation
    this._leoLogPane = vscode.window.createOutputChannel(Constants.GUI.LOG_PANE_TITLE);
    this._context.subscriptions.push(this._leoLogPane);

    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);

    // * Set required vscode configs if needed
    this.config.checkEnablePreview(true);
    this.config.checkCloseEmptyGroups(true);

    // * also check workbench.editor.enablePreview
    this.config.buildFromSavedSettings();
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.undoIcons = utils.buildUndoIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);
    this.gotoIcons = utils.buildGotoIconPaths(_context);

    // * Debounced refresh flags and UI parts, other than the tree and body, when operation(s) are done executing
    this.getStates = debounce(
        this._triggerGetStates,
        Constants.STATES_DEBOUNCE_DELAY
    );
    this.setTreeViewTitle = debounce(
        this._setTreeViewTitle,
        Constants.TITLE_DEBOUNCE_DELAY
    );
    this.refreshDocumentsPane = debounce(
        this._refreshDocumentsPane,
        Constants.DOCUMENTS_DEBOUNCE_DELAY
    );
    this.refreshButtonsPane = debounce(
        this._refreshButtonsPane,
        Constants.BUTTONS_DEBOUNCE_DELAY
    );
    this.refreshGotoPane = debounce(
        this._refreshGotoPane,
        Constants.GOTO_DEBOUNCE_DELAY
    );
    this.refreshUndoPane = debounce(
        this._refreshUndoPane,
        Constants.UNDOS_DEBOUNCE_DELAY
    );
    this.setUndoSelection = debounce(
        this._setUndoSelection,
        Constants.UNDOS_REVEAL_DEBOUNCE_DELAY
    );
    this.launchRefresh = debounce(
        this._launchRefresh,
        Constants.REFRESH_DEBOUNCE_DELAY
    );

    // * Create a single data provider for both outline trees, Leo view and Explorer view
    this._leoTreeProvider = new LeoOutlineProvider(this.nodeIcons, this);

    this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    this._context.subscriptions.push(
        this._leoTreeView,
        this._leoTreeView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeView))),
        this._leoTreeView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeView))),
        this._leoTreeView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, false)))
    );

    this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    this._context.subscriptions.push(
        this._leoTreeExView,
        this._leoTreeExView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeExView))),
        this._leoTreeExView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeExView))),
        this._leoTreeExView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, true)))
    );

    if (this.config.treeInExplorer) {
        this._lastTreeView = this._leoTreeExView;
    } else {
        this._lastTreeView = this._leoTreeView;
    }

    // * Configuration / Welcome webview
    this.leoSettingsWebview = new LeoSettingsProvider(this._context, this);

    void this.showLogPane();
}

</t>
<t tx="felix.20201214194144.3"></t>
<t tx="felix.20201214194144.4"></t>
<t tx="felix.20201214194144.5"></t>
<t tx="felix.20201214194144.6"></t>
<t tx="felix.20201214194144.7"></t>
<t tx="felix.20201214194144.8"></t>
<t tx="felix.20201214195752.1">/**
 * Creates and manages instances of the UI elements along with their events
 */
export class LeoUI extends NullGui {
    // * State flags
    public leoStates: LeoStates;
    public verbose: boolean = true;
    public trace: boolean = false; //true;
    public lastRefreshHadDirty = false; // We start with fresh documents.

    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE; // VScode's outline pane title: Might need to be re-set when switching visibility
    private _hasShownContextOpenMessage: boolean = false;

    // * Timers
    public refreshTimer: [number, number] | undefined; // until the selected node is found - even if already started refresh
    public lastRefreshTimer: [number, number] | undefined; // until the selected node is found - refreshed even if not found
    public commandRefreshTimer: [number, number] | undefined; // until the selected node is found -  keep if starting a new command already pending
    public lastCommandRefreshTimer: [number, number] | undefined; // until the selected node is found - refreshed if starting a new command
    public commandTimer: [number, number] | undefined; // until the command done - keep if starting a new one already pending
    public lastCommandTimer: [number, number] | undefined; // until the command done - refreshed if starting a new one

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, and leoNode for inverted contrast

    // * Icon Paths (Singleton static arrays)
    public nodeIcons: Icon[] = [];
    public undoIcons: Icon[] = [];
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];
    public gotoIcons: Icon[] = [];

    // * Refresh Cycle
    private _refreshType: ReqRefresh = {}; // Flags for commands to require parts of UI to refresh
    private _revealType: RevealType = RevealType.NoReveal; // Type of reveal for the selected node (when refreshing outline)
    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing.
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    public finalFocus: Focus = Focus.NoChange; // Set in _setupRefresh : Last command issued had focus on outline, as opposed to the body
    public showBodyIfClosed: boolean = false;
    public showOutlineIfClosed: boolean = false;
    public refreshPreserveRange = false; // this makes the next refresh cycle preserve the "findFocusTree" flag once.

    private __refreshNode: Position | undefined; // Set in _setupRefresh : Last command issued a specific node to reveal
    private _lastRefreshNodeTS: number = 0;
    get _refreshNode(): Position | undefined {
        return this.__refreshNode;
    }
    set _refreshNode(p_ap: Position | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this.__refreshNode = p_ap;
        this._lastRefreshNodeTS = utils.performanceNow();
    }

    // * Outline Pane
    private _leoTreeProvider!: LeoOutlineProvider; // TreeDataProvider single instance
    private _leoTreeView!: vscode.TreeView&lt;Position&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExView!: vscode.TreeView&lt;Position&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastTreeView!: vscode.TreeView&lt;Position&gt;; // Last visible treeview

    private _revealNodeRetriedRefreshOutline: boolean = false; // USED IN _refreshOutline and _revealNode

    private _lastSelectedNode: Position | undefined;
    private _lastSelectedNodeTS: number = 0;
    get lastSelectedNode(): Position | undefined {
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_ap: Position | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this._lastSelectedNode = p_ap;
        this._lastSelectedNodeTS = utils.performanceNow();
    }

    // * Find panel
    private _leoFindPanelProvider!: vscode.WebviewViewProvider;
    private _findPanelWebviewView: vscode.WebviewView | undefined;
    private _findPanelWebviewExplorerView: vscode.WebviewView | undefined;
    private _lastFindView: vscode.WebviewView | undefined;  // ? Maybe unused ?
    private _findNeedsFocus: boolean = false;
    private _lastSettingsUsed: LeoSearchSettings | undefined; // Last settings loaded / saved for current document
    public findFocusTree = false;
    public findHeadlineRange: [number, number] = [0, 0];
    public findHeadlinePosition: Position | undefined;

    // * Interactive Find Input
    private _interactiveSearchInputBox: vscode.InputBox | undefined;
    private _interactiveSearchOptions: {
        search: string,
        replace: string,
        word: boolean,
        regex: boolean,
        backward: boolean
    } = {
            search: "",
            replace: "",
            word: false,
            regex: false,
            backward: false
        };

    // * Reveal Timers
    private _gotSelectedNodeBodyTimer: undefined | NodeJS.Timeout;
    private _gotSelectedNodeRevealTimer: undefined | NodeJS.Timeout;
    private _showBodySwitchBodyTimer: undefined | NodeJS.Timeout;
    private _leoDocumentsRevealTimer: undefined | NodeJS.Timeout;

    // * Documents Pane
    private _leoDocumentsProvider!: LeoDocumentsProvider;
    private _leoDocuments!: vscode.TreeView&lt;LeoFrame&gt;;
    private _leoDocumentsExplorer!: vscode.TreeView&lt;LeoFrame&gt;;
    private _lastLeoDocuments: vscode.TreeView&lt;LeoFrame&gt; | undefined;

    // * Goto nav panel
    private _leoGotoProvider!: LeoGotoProvider;
    private _leoGoto!: vscode.TreeView&lt;LeoGotoNode&gt;;
    private _leoGotoExplorer!: vscode.TreeView&lt;LeoGotoNode&gt;;

    // * '@button' pane
    private _leoButtonsProvider!: LeoButtonsProvider;
    private _leoButtons!: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer!: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _rclickSelected: number[] = [];
    private _lastLeoButtons: vscode.TreeView&lt;LeoButtonNode&gt; | undefined;

    // * Undos pane
    private _leoUndosProvider!: LeoUndosProvider;
    private _leoUndos!: vscode.TreeView&lt;LeoUndoNode&gt;;
    private _leoUndosShown = false;
    private _leoUndosExplorer!: vscode.TreeView&lt;LeoUndoNode&gt;;
    private _leoUndosExplorerShown = false;
    private _lastLeoUndos: vscode.TreeView&lt;LeoUndoNode&gt; | undefined;

    // * Body pane
    private _bodyFileSystemStarted: boolean = false;
    private _bodyEnablePreview: boolean = true;
    private _leoFileSystem!: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _languageFlagged: string[] = [];

    private _bodyPreviewMode: boolean = true;

    private _editorTouched: boolean = false; // Flag for applying editor changes to body when 'icon' state change and 'undo' back to untouched

    private _bodyStatesTimer: NodeJS.Timeout | undefined;

    private _bodyUri: vscode.Uri = utils.strToLeoUri("");
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setNewBodyUriTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * Selection &amp; scroll
    private _selectionDirty: boolean = false; // Flag set when cursor selection is changed
    private _selectionGnx: string = ''; // Packaged into 'BodySelectionInfo' structures, sent to Leo
    private _selection: vscode.Selection | undefined; // also packaged into 'BodySelectionInfo'
    private _scrollDirty: boolean = false; // Flag set when cursor selection is changed
    private _scrollGnx: string = '';
    private _scroll: vscode.Range | undefined;

    // * Settings / Welcome webview
    public leoSettingsWebview: LeoSettingsProvider;

    // * Log Pane
    private _leoLogPane: vscode.OutputChannel;

    // * Status Bar
    // private _leoStatusBar: LeoStatusBar; // ! NOT USED UNTIL VSCODE API SUPPORTS "CURRENT-FOCUS" LOCATION INFO !

    // * Edit/Insert Headline Input Box System made with 'createInputBox'.
    private _hib: undefined | vscode.InputBox;
    private _hibResolve: undefined | ((value: string | PromiseLike&lt;string | undefined&gt; | undefined) =&gt; void);
    private _onDidHideResolve: undefined | ((value: PromiseLike&lt;void&gt; | undefined) =&gt; void);
    private _hibLastValue: undefined | string;
    private _hibInterrupted = false;
    private _hibDisposables: vscode.Disposable[] = [];

    // * Timing
    private _needLastSelectedRefresh = false; // USED IN showBody
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged
    private _bodyLastChangedDocumentSaved: boolean = true; // don't use 'isDirty' of the document!

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void);

    // * Debounced method used to set the outline tree title
    public setTreeViewTitle: (() =&gt; void);

    // * Debounced method used to get opened Leo Files for the documents pane
    public refreshDocumentsPane: (() =&gt; void);

    // * Debounced method used to get content of the at-buttons pane
    public refreshButtonsPane: (() =&gt; void);

    // * Debounced method used to get content of the goto pane
    public refreshGotoPane: (() =&gt; void);

    // * Debounced method used to get content of the undos pane
    public refreshUndoPane: (() =&gt; void);

    // * Debounced method used to set focused element of the undos pane
    public setUndoSelection: ((p_node: LeoUndoNode) =&gt; void);

    // * Debounced method for refreshing the UI
    public launchRefresh: DebouncedFunc&lt;() =&gt; Promise&lt;unknown&gt;&gt;;

    @others
}

</t>
<t tx="felix.20201214202058.1">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {

    const c = g.app.windowList[this.frameIndex].c;

    if (this._refreshType.states) {
        this._refreshType.states = false;
        const p = c.p;
        let w_canHoist = true;
        let w_topIsChapter = false;
        if (c.hoistStack.length) {
            const w_ph = c.hoistStack[c.hoistStack.length - 1].p;
            w_topIsChapter = w_ph.h.startsWith('@chapter ');
            if (p.__eq__(w_ph)) {
                // p is already the hoisted node
                w_canHoist = false;
            }
        } else {
            // not hoisted, was it the single top child of the real root?
            if (c.rootPosition()!.__eq__(p) &amp;&amp; c.hiddenRootNode.children.length === 1) {
                w_canHoist = false;
            }
        }
        const w_states: LeoPackageStates = {
            changed: c.changed, // Document has changed (is dirty)
            canUndo: c.canUndo(), // Document can undo the last operation done
            canRedo: c.canRedo(), // Document can redo the last operation 'undone'
            canGoBack: c.nodeHistory.beadPointer &gt; 0,
            canGoNext: c.nodeHistory.beadPointer + 1 &lt; c.nodeHistory.beadList.length,
            canDemote: c.canDemote(), // Selected node can have its siblings demoted
            canPromote: c.canPromote(), // Selected node can have its children promoted
            canDehoist: c.canDehoist(), // Document is currently hoisted and can be de-hoisted
            canHoist: w_canHoist,
            topIsChapter: w_topIsChapter
            // 
        };
        this.leoStates.setLeoStateFlags(w_states);
        this.refreshUndoPane();
    }
    // Set leoChanged and leoOpenedFilename
    this.leoStates.leoChanged = c.changed;
    this.leoStates.leoOpenedFileName = c.fileName();

    if (this._refreshType.documents) {
        this._refreshType.documents = false;
        this.refreshDocumentsPane();
    }
    if (this._refreshType.goto) {
        this._refreshType.goto = false;
        this.refreshGotoPane();
    }
    if (this._refreshType.buttons) {
        this._refreshType.buttons = false;
        this.refreshButtonsPane();
    }
}

</t>
<t tx="felix.20201214202118.1">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public showOutline(p_focusOutline?: boolean): void {
    const c = g.app.windowList[this.frameIndex].c;
    this._lastTreeView.reveal(c.p, {
        select: true,
        focus: !!p_focusOutline
    }).then(
        () =&gt; { }, // Ok
        (p_error) =&gt; {
            console.log('showOutline could not reveal');
        }
    );
}

</t>
<t tx="felix.20201214202123.1">/**
 * * Public method exposed as 'refreshDocumentsPane' setter/getter to refresh the documents pane
 * Document Panel May be refreshed by other services (states service, ...)
 */
private _refreshDocumentsPane(): void {
    this._leoDocumentsProvider.refreshTreeRoot();
    this.checkConfirmBeforeClose();
}

</t>
<t tx="felix.20201214202625.1">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private async _onChangeCollapsedState(p_event: vscode.TreeViewExpansionEvent&lt;Position&gt;, p_expand: boolean, p_treeView: vscode.TreeView&lt;Position&gt;): Promise&lt;unknown&gt; {

    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo.
    await this.triggerBodySave(true); // Get any modifications from the editor into the Leo's body model
    if (p_treeView.selection.length &amp;&amp; p_treeView.selection[0] &amp;&amp; p_treeView.selection[0].__eq__(p_event.element)) {
        // * This happens if the tree selection is the same as the expanded/collapsed node: Just have Leo do the same
        // pass
    } else {
        // * This part only happens if the user clicked on the arrow without trying to select the node
        if (this.config.leoTreeBrowse) {
            // * This part only happens if the user clicked on the arrow without trying to select the node
            void this._revealNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
            void this.selectTreeNode(p_event.element, true); // not waiting for a .then(...) so not to add any lag
        }
    }

    // * vscode will update its tree by itself, but we need to change Leo's model of its outline
    if (p_expand) {
        return p_event.element.expand();
    } else {
        return p_event.element.contract();
    }
}

</t>
<t tx="felix.20201214202627.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (!this.leoStates.leoReady || !this.leoStates.leojsStartupDone || !this.leoStates.fileOpenedReady) {
        return;
    }
    if (p_event.visible) {
        this._lastTreeView = p_explorerView ? this._leoTreeExView : this._leoTreeView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        if (this.leoStates.fileOpenedReady) {
            this.loadSearchSettings();
        }
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20201214202631.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._lastLeoDocuments = p_explorerView ? this._leoDocumentsExplorer : this._leoDocuments;
        this.refreshDocumentsPane(); // List may not have changed, but it's selection may have
    }
}

</t>
<t tx="felix.20201214202634.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._lastLeoButtons = p_explorerView ? this._leoButtonsExplorer : this._leoButtons;
    }
}

</t>
<t tx="felix.20201214202749.1">/**
 * * Called by UI when the user selects in the tree (click or 'open aside' through context menu)
 * @param p_node is the position node selected in the tree
 * @param p_reveal
 * @returns thenable for reveal to finish or select position to finish
 */
public async selectTreeNode(
    p_node: Position,
    p_internalCall?: boolean,
    p_aside?: boolean
    // p_reveal?: boolean, p_aside?: boolean
): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true); // Needed for self-selection to avoid 'cant save file is newer...'

    const c = g.app.windowList[this.frameIndex].c;

    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    if (
        p_aside &amp;&amp;
        c.positionExists(p_node) &amp;&amp;
        !p_node.__eq__(this.lastSelectedNode)
    ) {
        void this._revealNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    }

    this.showBodyIfClosed = true;

    this.leoStates.setSelectedNodeFlags(p_node);
    // this._leoStatusBar.update(true); // Just selected a node directly, or via expand/collapse
    const w_showBodyKeepFocus = p_aside
        ? this.config.treeKeepFocusWhenAside
        : this.config.treeKeepFocus;

    // * Check if having already this exact node position selected : Just show the body and exit
    // (other tree nodes with same gnx may have different syntax language coloring because of parents lineage)
    if (p_node.__eq__(this.lastSelectedNode)) {
        this._locateOpenedBody(p_node.gnx); // LOCATE NEW GNX
        return this.showBody(!!p_aside, w_showBodyKeepFocus).catch((p_error) =&gt; {
            return Promise.resolve(); // intercept cancellation as success: next one is going to replace anyways.
        });
        // Voluntary exit
    }

    // * Set selected node in Leo
    c.selectPosition(p_node);

    if (!p_internalCall) {
        if (this.findFocusTree) {
            // had a range but now refresh from other than find/replace
            // So make sure tree is also refreshed.
            this.findFocusTree = false;
            this.setupRefresh(
                Focus.Outline,
                {
                    tree: true,
                    body: true,
                    // documents: false,
                    // buttons: false,
                    // states: false,
                }
            );
            return this._launchRefresh();
        }
        this._refreshType.states = true;
        this.getStates();
    }

    // * Apply the node to the body text without waiting for the selection promise to resolve
    return this._tryApplyNodeToBody(p_node, !!p_aside, w_showBodyKeepFocus);

}

</t>
<t tx="felix.20201214202755.1">/**
 * Leo Command
 * @param p_cmd Command name string
 * @param p_options: CommandOptions for the command
 */
public async command(
    p_cmd: string,
    p_options: CommandOptions
): Promise&lt;unknown&gt; {
    this.lastCommandTimer = process.hrtime();
    if (this.commandTimer === undefined) {
        this.commandTimer = this.lastCommandTimer;
    }
    this.lastCommandRefreshTimer = this.lastCommandTimer;
    if (this.commandRefreshTimer === undefined) {
        this.commandRefreshTimer = this.lastCommandTimer;
    }

    await this.triggerBodySave(true);

    if (p_options.isNavigation) {
        // If any navigation command is used from outline or command palette: show body.
        this.showBodyIfClosed = true;
        // If alt+arrow is used to navigate: SHOW and leave focus on outline.
        this.showOutlineIfClosed = true;
    }

    const c = g.app.windowList[this.frameIndex].c;
    this.setupRefresh(p_options.finalFocus, p_options.refreshType);

    let value: any = undefined;
    const p = p_options.node ? p_options.node : c.p;

    let w_offset = 0;
    if (p_options.keepSelection) {
        if (Constants.OLD_POS_OFFSETS.DELETE.includes(p_cmd)) {
            w_offset = -1;
        } else if (Constants.OLD_POS_OFFSETS.ADD.includes(p_cmd)) {
            w_offset = 1;
        }
    }

    try {
        if (p.__eq__(c.p)) {
            value = c.doCommandByName(p_cmd); // no need for re-selection
        } else {
            const old_p = c.p;
            c.selectPosition(p);
            value = c.doCommandByName(p_cmd);
            if (p_options.keepSelection) {
                if (value &amp;&amp; value.then) {
                    void (value as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
                        if (c.positionExists(old_p)) {
                            c.selectPosition(old_p);
                        } else {
                            old_p._childIndex = old_p._childIndex + w_offset;
                            if (c.positionExists(old_p)) {
                                c.selectPosition(old_p);
                            }
                        }
                    });
                } else {
                    if (c.positionExists(old_p)) {
                        c.selectPosition(old_p);
                    } else {
                        old_p._childIndex = old_p._childIndex + w_offset;
                        if (c.positionExists(old_p)) {
                            c.selectPosition(old_p);
                        }
                    }
                }
            }
        }
    } catch (e) {
        void vscode.window.showErrorMessage("LeoUI Error: " + e);
    }

    if (this.trace) {
        if (this.lastCommandTimer) {
            console.log('lastCommandTimer', utils.getDurationMs(this.lastCommandTimer));
        }
    }

    this.lastCommandTimer = undefined;

    if (value &amp;&amp; value.then) {
        void (value as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
            void this.launchRefresh();
        });
        return value;
    } else {
        void this.launchRefresh();
        return Promise.resolve(value); // value may be a promise but it will resolve all at once.
    }

}

</t>
<t tx="felix.20201214202757.1">/**
 * Opens quickPick minibuffer pallette to choose from all commands in this file's Thenable
 * @returns Promise from the command resolving - or resolve with undefined if cancelled
 */
public async minibuffer(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const c = g.app.windowList[this.frameIndex].c;
    const commands: vscode.QuickPickItem[] = [];
    const cDict = c.commandsDict;
    for (let key in cDict) {
        const command = cDict[key];
        // Going to get replaced. Don't take those that begin with 'async-'
        const w_name = (command as any).__name__ || '';
        if (!w_name.startsWith('async-')) {
            commands.push({
                label: key,
                detail: (command as any).__doc__
            });
        }
    }

    const w_noDetails: vscode.QuickPickItem[] = [];
    const stash_button: string[] = [];
    const stash_rclick: string[] = [];
    const stash_command: string[] = [];

    for (const w_com of commands) {
        if (
            !w_com.detail &amp;&amp; !(
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START) ||
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START) ||
                w_com.label === Constants.USER_MESSAGES.MINIBUFFER_SCRIPT_BUTTON ||
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_DEL_SCRIPT_BUTTON) ||
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_DEL_BUTTON_START) ||
                w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START)
            )
        ) {
            w_noDetails.push(w_com);
        }

        if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START)) {
            stash_button.push(w_com.label);
        }
        if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START)) {
            stash_rclick.push(w_com.label);
        }
        if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START)) {
            stash_command.push(w_com.label);
        }
    }

    for (const p_command of w_noDetails) {
        if (stash_button.includes(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START + p_command.label)) {
            p_command.description = Constants.USER_MESSAGES.MINIBUFFER_BUTTON;
        }
        if (stash_rclick.includes(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START + p_command.label)) {
            p_command.description = Constants.USER_MESSAGES.MINIBUFFER_RCLICK;
        }
        if (stash_command.includes(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START + p_command.label)) {
            p_command.description = Constants.USER_MESSAGES.MINIBUFFER_COMMAND;
        }
        p_command.description = p_command.description ? p_command.description : Constants.USER_MESSAGES.MINIBUFFER_USER_DEFINED;
    }

    const w_withDetails = commands.filter(p_command =&gt; !!p_command.detail);

    // Only sort 'regular' Leo commands, leaving custom commands at the top
    w_withDetails.sort((a, b) =&gt; {
        return a.label &lt; b.label ? -1 : (a.label === b.label ? 0 : 1);
    });

    const w_choices: vscode.QuickPickItem[] = [];

    if (c.commandHistory.length) {
        w_choices.push(Constants.MINIBUFFER_QUICK_PICK);
    }

    // Finish minibuffer list
    if (w_noDetails.length) {
        w_choices.push(...w_noDetails);
    }

    // Separator above real commands, if needed...
    if (w_noDetails.length || c.commandHistory.length) {
        w_choices.push({
            label: "", kind: vscode.QuickPickItemKind.Separator
        });
    }

    w_choices.push(...w_withDetails);

    const w_disposables: vscode.Disposable[] = [];

    const q_minibufferQuickPick: Promise&lt;vscode.QuickPickItem | undefined&gt; = new Promise((resolve, reject) =&gt; {
        const quickPick = vscode.window.createQuickPick();
        quickPick.items = w_choices;
        quickPick.placeholder = Constants.USER_MESSAGES.MINIBUFFER_PROMPT;
        quickPick.matchOnDetail = true;

        w_disposables.push(
            quickPick.onDidChangeSelection(selection =&gt; {
                if (selection[0]) {
                    resolve(selection[0]);
                    quickPick.hide();
                }
            }),
            quickPick.onDidAccept(accepted =&gt; {
                if (/^\d+$/.test(quickPick.value)) {
                    // * Was an integer
                    this.setupRefresh(Focus.Body,
                        {
                            tree: true,
                            body: true,
                            documents: false,
                            buttons: false,
                            states: true
                        }
                    );
                    // not awaited
                    c.editCommands.gotoGlobalLine(Number(quickPick.value)).then(() =&gt; {
                        void this.launchRefresh();
                    }, () =&gt; {
                        // pass
                    });
                    resolve(undefined);
                    quickPick.hide();
                }
            }),
            quickPick.onDidChangeValue(changed =&gt; {
                if (/^\d+$/.test(changed)) {
                    if (quickPick.items.length) {
                        quickPick.items = [];
                    }
                } else if (quickPick.items !== w_choices) {
                    quickPick.items = w_choices;
                }
            }),
            quickPick.onDidHide(() =&gt; {
                resolve(undefined);
            }),
            quickPick
        );
        quickPick.show();

    });

    const w_picked: vscode.QuickPickItem | undefined = await q_minibufferQuickPick;

    w_disposables.forEach(d =&gt; d.dispose());

    // First, check for undo-history list being requested
    if (w_picked &amp;&amp; w_picked.label === Constants.USER_MESSAGES.MINIBUFFER_HISTORY_LABEL) {
        return this._showMinibufferHistory(w_choices);
    }
    if (w_picked) {
        return this._doMinibufferCommand(w_picked);
    }
}

</t>
<t tx="felix.20201214202759.1">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_prompt Optional prompt, to override the default 'edit headline' prompt. (for insert-* commands usage)
 * @returns Thenable that resolves when done
 */
public async editHeadline(p_node?: Position, p_fromOutline?: boolean, p_prompt?: string): Promise&lt;Position&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const u = c.undoer;
    const w_p: Position = p_node || c.p;

    if (this._hib &amp;&amp; this._hib.enabled) {
        return Promise.resolve(w_p); // DO NOT REACT IF ALREADY EDITING A HEADLINE! 
    }

    await this.triggerBodySave(true);

    let w_finalFocus: Focus = p_fromOutline ? Focus.Outline : Focus.Body; // Use w_fromOutline for where we intend to leave focus when done with the insert

    this.setupRefresh(
        w_finalFocus,
        { tree: true, states: true }
    );

    const w_headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: w_p.h,  // preset input pop up
        valueSelection: undefined,
        prompt: p_prompt || Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE,
    };
    let p_newHeadline = await this._showHeadlineInputBox(w_headlineInputOptions);

    if ((p_newHeadline || p_newHeadline === "") &amp;&amp; p_newHeadline !== "\n") {
        let w_truncated = false;
        if (p_newHeadline.indexOf("\n") &gt;= 0) {
            p_newHeadline = p_newHeadline.split("\n")[0];
            w_truncated = true;
        }
        if (p_newHeadline.length &gt; 1000) {
            p_newHeadline = p_newHeadline.substring(0, 1000);
            w_truncated = true;
        }

        if (p_newHeadline &amp;&amp; w_p &amp;&amp; w_p.h !== p_newHeadline) {
            if (w_truncated) {
                void vscode.window.showInformationMessage("Truncating headline");
            }

            const undoData = u.beforeChangeHeadline(w_p);
            c.setHeadString(w_p, p_newHeadline); // Set v.h *after* calling the undoer's before method.
            if (!c.changed) {
                c.setChanged();
            }
            u.afterChangeHeadline(w_p, 'Edit Headline', undoData);
            void this.launchRefresh();
        }

    } else {
        if (p_fromOutline) {
            this.showOutline(true);
        }
    }
    if (this._onDidHideResolve) {
        this._onDidHideResolve(undefined);
        this._onDidHideResolve = undefined;
    }
    return w_p;
}

</t>
<t tx="felix.20201214202800.1">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_interrupt Signifies the insert action is actually interrupting itself (e.g. rapid CTRL+I actions by the user)
 * @returns Thenable that resolves when done
 */
public async insertNode(p_node: Position | undefined, p_fromOutline: boolean, p_asChild: boolean): Promise&lt;unknown&gt; {

    let w_hadHib = false;
    if (this._hib &amp;&amp; this._hib.enabled) {
        w_hadHib = true;
    }

    if (!this.isOutlineVisible()) {
        p_fromOutline = false;
    }

    let w_finalFocus: Focus = p_fromOutline ? Focus.Outline : Focus.Body; // Use w_fromOutline for where we intend to leave focus when done with the insert
    if (w_hadHib) {
        this._focusInterrupt = true; // this will affect next refresh by triggerbodysave, not the refresh of this pass
    }

    await this.triggerBodySave(true);

    // * if node has child and is expanded: turn p_asChild to true!
    const w_headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: Constants.USER_MESSAGES.DEFAULT_HEADLINE,
        valueSelection: undefined,
        prompt: p_asChild ? Constants.USER_MESSAGES.PROMPT_INSERT_CHILD : Constants.USER_MESSAGES.PROMPT_INSERT_NODE
    };

    if (w_hadHib &amp;&amp; !this.isOutlineVisible()) {
        await new Promise((p_resolve, p_reject) =&gt; {
            setTimeout(() =&gt; {
                p_resolve(undefined);
            }, 60);
        });
    }

    const p_newHeadline = await this._showHeadlineInputBox(w_headlineInputOptions);

    if (this._hibInterrupted) {
        w_finalFocus = Focus.NoChange;
        this._hibInterrupted = false;
    }

    this.lastCommandTimer = process.hrtime();
    if (this.commandTimer === undefined) {
        this.commandTimer = this.lastCommandTimer;
    }
    this.lastCommandRefreshTimer = this.lastCommandTimer;
    if (this.commandRefreshTimer === undefined) {
        this.commandRefreshTimer = this.lastCommandTimer;
    }

    const c = g.app.windowList[this.frameIndex].c;

    let value: any = undefined;
    const p = p_node ? p_node : c.p;

    const w_refreshType: ReqRefresh = { documents: true, buttons: true, states: true };
    if (!this.isOutlineVisible()) {

    }
    if (this.isOutlineVisible()) {
        w_refreshType.tree = true;
    } else {
        w_refreshType.body = true;
    }

    if (p.__eq__(c.p)) {
        w_refreshType.body = true;
        this.setupRefresh(w_finalFocus, w_refreshType);
        this._insertAndSetHeadline(p_newHeadline, p_asChild); // no need for re-selection
    } else {
        const old_p = c.p;  // c.p is old already selected
        c.selectPosition(p); // p is now the new one to be operated on
        this._insertAndSetHeadline(p_newHeadline, p_asChild);
        // Only if 'keep' old position was needed (specified with a p_node parameter), and old_p still exists
        if (!!p_node &amp;&amp; c.positionExists(old_p)) {
            // no need to refresh body
            this.setupRefresh(w_finalFocus, w_refreshType);
            c.selectPosition(old_p);
        } else {
            old_p._childIndex = old_p._childIndex + 1;
            if (!!p_node &amp;&amp; c.positionExists(old_p)) {
                // no need to refresh body
                this.setupRefresh(w_finalFocus, w_refreshType);
                c.selectPosition(old_p);
            } else {
                w_refreshType.body = true;
                this.setupRefresh(w_finalFocus, w_refreshType);
            }
        }
    }
    if (this.trace) {
        if (this.lastCommandTimer) {
            console.log('lastCommandTimer', utils.getDurationMs(this.lastCommandTimer));
        }
    }
    this.lastCommandTimer = undefined;

    if (this._onDidHideResolve) {
        this._onDidHideResolve(undefined);
        this._onDidHideResolve = undefined;
    } else {
        // pass
    }
    void this.launchRefresh();

    return value;

}

</t>
<t tx="felix.20201214205159.1">@language json
@tabwidth -2
{
  "name": "leojs",
  "displayName": "Leo Editor for Visual Studio Code",
  "description": "LeoJS — The literate editor with outline javascript implementation",
  "version": "0.2.1",
  "publisher": "boltex",
  "author": {
    "name": "Félix Malboeuf"
  },
  "sponsor": {
    "url": "https://boltex.github.io/"
  },
  "license": "SEE LICENSE IN LICENSE",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leojs"
  },
  "engines": {
    "vscode": "^1.83.0"
  },
  "keywords": [
    "leo",
    "tree",
    "outline",
    "editor",
    "literate"
  ],
  "categories": [
    "Other"
  ],
  "galleryBanner": {
    "color": "#faeadb",
    "theme": "light"
  },
  "preview": true,
  "activationEvents": [
    "onStartupFinished"
  ],
  "qna": false,
  "main": "./dist/extension-node",
  "browser": "./dist/extension-web",
  "icon": "resources/leoapp256px.png",
  "contributes": {
    &lt;&lt; contributes &gt;&gt;
  },
  "scripts": {
    &lt;&lt; scripts &gt;&gt;
  },
  "devDependencies": {
    &lt;&lt; devDependencies &gt;&gt;
  },
  "dependencies": {
    &lt;&lt; dependencies &gt;&gt;
  }
}
</t>
<t tx="felix.20201214205159.10">{
  "command": "leojs.openLeoFile",
  "title": "Open with LeoJS",
  "category": "Leojs",
  "enablement": "leojsReady",
  "icon": {
    "light": "resources/light/folder.svg",
    "dark": "resources/dark/folder.svg"
  }
},
{
  "command": "leojs.revert",
  "category": "Leojs",
  "enablement": "leojsReady &amp;&amp; leojsTreeOpened",
  "shortTitle": "Revert Leo outline to last saved contents",
  "title": "Revert"
},
{
  "command": "leojs.recentLeoFiles",
  "title": "Recent Files",
  "category": "Leojs",
  "enablement": "leojsReady",
  "icon": {
    "light": "resources/light/open-recent.svg",
    "dark": "resources/dark/open-recent.svg"
  }
},
{
  "command": "leojs.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leojs",
  "enablement": "leojsReady &amp;&amp; leojsTreeOpened",
  "icon": {
    "light": "resources/light/switch.svg",
    "dark": "resources/dark/switch.svg"
  }
},
{
  "command": "leojs.newLeoFile",
  "title": "New Leo File",
  "category": "Leojs",
  "enablement": "leojsReady",
  "icon": {
    "light": "resources/light/new-file.svg",
    "dark": "resources/dark/new-file.svg"
  }
},
{
  "command": "leojs.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leojs.saveLeoFile",
  "category": "Leojs",
  "title": "Save Leo File",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leojs.saveLeoFileFromOutline",
  "category": "Leojs",
  "title": "Save Leo File",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leojs.saveAsLeoFile",
  "category": "Leojs",
  "title": "Save Leo File as...",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/save-as.svg",
    "dark": "resources/dark/save-as.svg"
  }
},
{
  "command": "leojs.saveAsLeoJsFile",
  "category": "Leojs",
  "title": "Save a copy as leojs File...",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/save-as-leojs.svg",
    "dark": "resources/dark/save-as-leojs.svg"
  }
},
{
  "command": "leojs.refreshFromDisk",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leojs.refreshFromDiskSelection",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened &amp;&amp; LeojsAtFile",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leojs.refreshFromDiskSelectionFromOutline",
  "category": "Leojs",
  "title": "Refresh from Disk",
  "enablement": "leojsTreeOpened &amp;&amp; LeojsAtFile",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leojs.writeAtFileNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write @&lt;file&gt; Nodes",
  "icon": {
    "light": "resources/light/write-at-file-nodes.svg",
    "dark": "resources/dark/write-at-file-nodes.svg"
  }
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write @&lt;file&gt; Nodes",
  "icon": {
    "light": "resources/light/write-at-file-nodes.svg",
    "dark": "resources/dark/write-at-file-nodes.svg"
  }
},
{
  "command": "leojs.writeDirtyAtFileNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write Dirty @&lt;file&gt; Nodes",
  "icon": {
    "light": "resources/light/write-dirty-at-file-nodes.svg",
    "dark": "resources/dark/write-dirty-at-file-nodes.svg"
  }
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write Dirty @&lt;file&gt; Nodes",
  "icon": {
    "light": "resources/light/write-dirty-at-file-nodes.svg",
    "dark": "resources/dark/write-dirty-at-file-nodes.svg"
  }
},
{
  "command": "leojs.gitDiff",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Git Diff"
},
{
  "command": "leojs.tabCycleNext",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Tab Cycle Next"
},
</t>
<t tx="felix.20201214205159.11">{
  "command": "leojs.openAside",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Open to the Side"
},
{
  "command": "leojs.contractAll",
  "category": "Leojs",
  "title": "Contract All",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leojs.contractAllFromOutline",
  "category": "Leojs",
  "title": "Contract All",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leojs.prev",
  "category": "Leojs",
  "title": "Prev",
  "enablement": "leojsCanGoBack",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leojs.prevFromOutline",
  "category": "Leojs",
  "title": "Prev",
  "enablement": "leojsCanGoBack",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leojs.next",
  "category": "Leojs",
  "title": "Next",
  "enablement": "leojsCanGoNext",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
{
  "command": "leojs.nextFromOutline",
  "category": "Leojs",
  "title": "Next",
  "enablement": "leojsCanGoNext",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
</t>
<t tx="felix.20201214205159.12">{
  "command": "leojs.editHeadline",
  "category": "Leojs",
  "title": "Edit Headline",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/edit.svg",
    "dark": "resources/dark/edit.svg"
  }
},
{
  "command": "leojs.editSelectedHeadline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Edit Headline"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Edit Headline"
},
</t>
<t tx="felix.20201214205159.13">{
  "command": "leojs.mark",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leojs.markSelection",
  "category": "Leojs",
  "title": "Mark",
  "enablement": "leojsTreeOpened &amp;&amp; !leojsMarked",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leojs.markSelectionFromOutline",
  "category": "Leojs",
  "title": "Mark",
  "enablement": "leojsTreeOpened &amp;&amp; !leojsMarked",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leojs.unmark",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leojs.unmarkSelection",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened &amp;&amp; leojsMarked",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "category": "Leojs",
  "title": "Unmark",
  "enablement": "leojsTreeOpened &amp;&amp; leojsMarked",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leojs.unmarkAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Unmark All"
},
{
  "command": "leojs.copyMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Copy Marked"
},
{
  "command": "leojs.diffMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Diff Marked Nodes"
},
{
  "command": "leojs.markChangedItems",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark Changed Items"
},
{
  "command": "leojs.markSubheads",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Mark Subheads"
},
{
  "command": "leojs.cloneMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Clone Marked Nodes"
},
{
  "command": "leojs.deleteMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Delete Marked Nodes"
},
{
  "command": "leojs.moveMarkedNodes",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Marked Nodes"
},
</t>
<t tx="felix.20201214205159.14">{
  "command": "leojs.copyNode",
  "category": "Leojs",
  "title": "Copy Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leojs.copyNodeSelection",
  "category": "Leojs",
  "title": "Copy Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leojs.cutNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Cut Node"
},
{
  "command": "leojs.cutNodeSelection",
  "category": "Leojs",
  "title": "Cut Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/cut.svg",
    "dark": "resources/dark/cut.svg"
  }
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Cut Node"
},
{
  "command": "leojs.pasteNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node"
},
{
  "command": "leojs.pasteNodeAtSelection",
  "category": "Leojs",
  "title": "Paste Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/paste.svg",
    "dark": "resources/dark/paste.svg"
  }
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node"
},
{
  "command": "leojs.pasteNodeAsClone",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node as Clone"
},
{
  "command": "leojs.pasteNodeAsCloneAtSelection",
  "category": "Leojs",
  "title": "Paste Node as Clone",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/paste-clone.svg",
    "dark": "resources/dark/paste-clone.svg"
  }
},
{
  "command": "leojs.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Paste Node as Clone"
},
{
  "command": "leojs.delete",
  "category": "Leojs",
  "title": "Delete",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leojs.deleteSelection",
  "category": "Leojs",
  "title": "Delete Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/delete.svg",
    "dark": "resources/dark/delete.svg"
  }
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Delete Node"
},
{
  "command": "leojs.setUa",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Set uA"
},
</t>
<t tx="felix.20201214205159.15">{
  "command": "leojs.extract",
  "category": "Leojs",
  "title": "Extract",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/extract.svg",
    "dark": "resources/dark/extract.svg"
  }
},
{
  "command": "leojs.extractNames",
  "category": "Leojs",
  "title": "Extract Names",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/extract-name.svg",
    "dark": "resources/dark/extract-name.svg"
  }
},
</t>
<t tx="felix.20201214205159.16">{
  "command": "leojs.moveOutlineDown",
  "category": "Leojs",
  "title": "Move Outline Down",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/arrow-down.svg",
    "dark": "resources/dark/arrow-down.svg"
  }
},
{
  "command": "leojs.moveOutlineDownSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Down"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Down"
},
{
  "command": "leojs.moveOutlineLeft",
  "category": "Leojs",
  "title": "Move Outline Left",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/arrow-left.svg",
    "dark": "resources/dark/arrow-left.svg"
  }
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Left"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Left"
},
{
  "command": "leojs.moveOutlineRight",
  "category": "Leojs",
  "title": "Move Outline Right",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/arrow-right.svg",
    "dark": "resources/dark/arrow-right.svg"
  }
},
{
  "command": "leojs.moveOutlineRightSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Right"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Right"
},
{
  "command": "leojs.moveOutlineUp",
  "category": "Leojs",
  "title": "Move Outline Up",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/arrow-up.svg",
    "dark": "resources/dark/arrow-up.svg"
  }
},
{
  "command": "leojs.moveOutlineUpSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Up"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Move Outline Up"
},
</t>
<t tx="felix.20201214205159.17">{
  "command": "leojs.insertNode",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leojs.insertChildNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leojs.insertNodeSelection",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leojs.insertChildNodeSelection",
  "category": "Leojs",
  "title": "Insert Child",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Insert Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Insert Child",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leojs.cloneNode",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leojs.cloneNodeSelection",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "category": "Leojs",
  "title": "Clone Node",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leojs.promote",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leojs.promoteSelection",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsCanPromote",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "category": "Leojs",
  "title": "Promote Children",
  "enablement": "leojsCanPromote",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leojs.demote",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leojs.demoteSelection",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsCanDemote",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "category": "Leojs",
  "title": "Demote Siblings",
  "enablement": "leojsCanDemote",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leojs.sortChildrenSelection",
  "category": "Leojs",
  "title": "Sort Children",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "icon": {
    "light": "resources/light/sort-children.svg",
    "dark": "resources/dark/sort-children.svg"
  }
},
{
  "command": "leojs.sortChildrenSelectionFromOutline",
  "category": "Leojs",
  "title": "Sort Children",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "icon": {
    "light": "resources/light/sort-children.svg",
    "dark": "resources/dark/sort-children.svg"
  }
},
{
  "command": "leojs.sortSiblingsSelection",
  "category": "Leojs",
  "title": "Sort Siblings",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/sort-siblings.svg",
    "dark": "resources/dark/sort-siblings.svg"
  }
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "category": "Leojs",
  "title": "Sort Siblings",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/sort-siblings.svg",
    "dark": "resources/dark/sort-siblings.svg"
  }
},
</t>
<t tx="felix.20201214205159.18">{
  "command": "leojs.gotoFirstVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto First Visible"
},
{
  "command": "leojs.gotoLastVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Last Visible"
},
{
  "command": "leojs.pageUp",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Page Up"
},
{
  "command": "leojs.pageDown",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Page Down"
},
{
  "command": "leojs.gotoFirstSibling",
  "category": "leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto First Sibling"
},
{
  "command": "leojs.gotoLastSibling",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Last Sibling"
},
{
  "command": "leojs.gotoNextVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Visible"
},
{
  "command": "leojs.gotoPrevVisible",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Prev Visible"
},
{
  "command": "leojs.contractOrGoLeft",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Contract Or Go Left"
},
{
  "command": "leojs.expandAndGoRight",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Expand And Go Right"
},
{
  "command": "leojs.gotoNextMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Marked"
},
{
  "command": "leojs.gotoNextClone",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Next Clone"
},
{
  "command": "leojs.gotoNextCloneSelection",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCloned",
  "title": "Goto Next Clone"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCloned",
  "title": "Goto Next Clone"
},
</t>
<t tx="felix.20201214205159.2">@others
</t>
<t tx="felix.20201214205159.20">{
  "command": "leojs.undo",
  "category": "Leojs",
  "title": "Undo",
  "enablement": "leojsCanUndo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leojs.undoFromOutline",
  "category": "Leojs",
  "title": "Undo",
  "enablement": "leojsCanUndo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leojs.redo",
  "category": "Leojs",
  "title": "Redo",
  "enablement": "leojsCanRedo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leojs.redoFromOutline",
  "category": "Leojs",
  "title": "Redo",
  "enablement": "leojsCanRedo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leojs.revertToUndo",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Revert to Undo State"
},
</t>
<t tx="felix.20201214205159.23">"menus": {
  @others
},
</t>
<t tx="felix.20201214205159.24">"commandPalette": [
  @others
],
</t>
<t tx="felix.20201214205159.3">"viewsContainers": {
  "activitybar": [
    {
      "id": "leojsView",
      "title": "Leojs",
      "icon": "resources/icon.svg"
    }
  ]
},
</t>
<t tx="felix.20201214205159.4">"views": {
  "explorer": [
    {
      "id": "leojsOutlineExplorer",
      "name": "Leojs Outline",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer",
      "visibility": "visible"
    },
    {
      "type": "webview",
      "id": "leojsFindPanelExplorer",
      "contextualTitle": "Leojs",
      "name": "Leojs Find",
      "title": "Leojs Find",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsGotoPanelExplorer",
      "name": "Leojs Goto",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsDocumentsExplorer",
      "name": "Leojs Documents",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsUndosExplorer",
      "name": "Leojs Undo History",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsButtonsExplorer",
      "name": "Leojs Buttons",
      "contextualTitle": "Leojs",
      "when": "config.leojs.treeInExplorer &amp;&amp; leojsTreeOpened",
      "visibility": "collapsed"
    }
  ],
  "leojsView": [
    {
      "id": "leojsOutline",
      "contextualTitle": "Leojs",
      "name": "Outline",
      "visibility": "visible"
    },
    {
      "type": "webview",
      "contextualTitle": "Leojs",
      "id": "leojsFindPanel",
      "name": "Find",
      "title": "Find",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsGotoPanel",
      "contextualTitle": "Leojs",
      "name": "Goto",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsDocuments",
      "contextualTitle": "Leojs",
      "name": "Documents",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsUndos",
      "contextualTitle": "Leojs",
      "name": "Undo History",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leojsButtons",
      "contextualTitle": "Leojs",
      "name": "Buttons",
      "when": "leojsTreeOpened",
      "visibility": "collapsed"
    }
  ]
},
</t>
<t tx="felix.20201214205159.42">{
  "command": "leojs.gotoScript",
  "when": "false"
},
{
  "command": "leojs.removeButton",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.44">{
  "command": "leojs.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leojs.refreshFromDisk",
  "when": "false"
},
{
  "command": "leojs.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "when": "false"
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.45">{
  "command": "leojs.openAside",
  "when": "false"
},
{
  "command": "leojs.contractAllFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.46">{
  "command": "leojs.editHeadline",
  "when": "false"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.47">{
  "command": "leojs.mark",
  "when": "false"
},
{
  "command": "leojs.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.unmark",
  "when": "false"
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.48">{
  "command": "leojs.copyNode",
  "when": "false"
},
{
  "command": "leojs.cutNode",
  "when": "false"
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.pasteNode",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leojs.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.delete",
  "when": "false"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.49">{
  "command": "leojs.moveOutlineDown",
  "when": "false"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineRight",
  "when": "false"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.moveOutlineUp",
  "when": "false"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.5">"viewsWelcome": [
  {
    "view": "leojsOutline",
    "contents": "Starting up leojs...",
    "when": "!leojsReady &amp;&amp; !leojsStartupDone"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "Starting up leojs...",
    "when": "!leojsReady &amp;&amp; !leojsStartupDone"
  },
  {
    "view": "leojsOutline",
    "contents": "Open a remote repository first to enable LeoJS\n[Open Remote Repository](command:remoteHub.openRepository)\nSee [Opening a project](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for more info.",
    "when": "!leojsReady &amp;&amp; leojsStartupDone"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "Open a remote repository first to enable LeoJS\n[Open Remote Repository](command:remoteHub.openRepository)\nSee [Opening a project](https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project) for more info.",
    "when": "!leojsReady &amp;&amp; leojsStartupDone"
  },
  {
    "view": "leojsOutline",
    "contents": "[Open Leo File](command:leojs.openLeoFile)\n[Create Leo File](command:leojs.newLeoFile)\nView LeoJS [configuration settings](command:leojs.showSettingsPage)",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened &amp;&amp; leojsStartupDone"
  },
  {
    "view": "leojsOutlineExplorer",
    "contents": "[Open Leo File](command:leojs.openLeoFile)\n[Create Leo File](command:leojs.newLeoFile)\nView LeoJS [configuration settings](command:leojs.showSettingsPage)",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened &amp;&amp; leojsStartupDone"
  },
  {
    "view": "leojsDocuments",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsDocumentsExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsGotoPanel",
    "contents": "No Results",
    "when": "leojsReady"
  },
  {
    "view": "leojsGotoPanelExplorer",
    "contents": "No Results",
    "when": "leojsReady"
  },
  {
    "view": "leojsButtons",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsButtonsExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsButtons",
    "contents": "There are no @buttons in this outline",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsButtonsExplorer",
    "contents": "There are no @buttons in this outline",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsUndos",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsUndosExplorer",
    "contents": "There are no Leo files currently opened",
    "when": "leojsReady &amp;&amp; !leojsTreeOpened"
  },
  {
    "view": "leojsUndos",
    "contents": "Can't undo",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  },
  {
    "view": "leojsUndosExplorer",
    "contents": "Can't undo",
    "when": "leojsReady &amp;&amp; leojsTreeOpened"
  }
],
</t>
<t tx="felix.20201214205159.50">{
  "command": "leojs.insertNode",
  "when": "false"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.insertChildNode",
  "when": "false"
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.cloneNode",
  "when": "false"
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.promote",
  "when": "false"
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.demote",
  "when": "false"
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.sortChildrenSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.51">{
  "command": "leojs.gotoNextClone",
  "when": "false"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leojs.gotoLastVisible",
  "when": "false"
},
{
  "command": "leojs.gotoFirstSibling",
  "when": "false"
},
{
  "command": "leojs.gotoLastSibling",
  "when": "false"
},
{
  "command": "leojs.gotoNextVisible",
  "when": "false"
},
{
  "command": "leojs.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leojs.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leojs.expandAndGoRight",
  "when": "false"
},
{
  "command": "leojs.pageUp",
  "when": "false"
},
{
  "command": "leojs.pageDown",
  "when": "false"
},
{
  "command": "leojs.gotoNavPrev",
  "when": "false"
},
{
  "command": "leojs.gotoNavNext",
  "when": "false"
},
{
  "command": "leojs.gotoNavFirst",
  "when": "false"
},
{
  "command": "leojs.gotoNavLast",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.52">{
  "command": "leojs.hoistNode",
  "when": "false"
},
{
  "command": "leojs.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leojs.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20201214205159.53">{
  "command": "leojs.undoFromOutline",
  "when": "false"
},
{
  "command": "leojs.redoFromOutline",
  "when": "false"
},
{
  "command": "leojs.revertToUndo",
  "when": "false"
}
</t>
<t tx="felix.20201214205159.54">"explorer/context": [
  {
    "command": "leojs.openLeoFile",
    "when": "resourceExtname == .leo || resourceExtname == .leojs",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20201214205159.55">"view/title": [
  {
    "command": "leojs.showSettingsPage",
    "when": "view =~ /^leojsDocuments|^leojsButtons/ &amp;&amp; leojsReady",
    "group": "navigation@9"
  },
  {
    "command": "leojs.showLogPane",
    "when": "view =~ /^leojsDocuments|^leojsButtons/ &amp;&amp; leojsReady",
    "group": "navigation@9"
  },
  {
    "command": "leojs.recentLeoFiles",
    "when": "view =~ /^leojsDocuments/ &amp;&amp; leojsReady",
    "group": "navigation@8"
  },
  {
    "command": "leojs.findQuickSelected",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findQuickTimeline",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findQuickChanged",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.history",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.markedList",
    "when": "view =~ /^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.openLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsReady",
    "group": "navigation@1"
  },
  {
    "command": "leojs.newLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsReady",
    "group": "navigation@1"
  },
  {
    "command": "leojs.saveLeoFileFromOutline",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.saveAsLeoFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; !leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.saveAsLeoJsFile",
    "when": "view =~ /^leojsOutline|^leojsDocuments/ &amp;&amp; leojsTreeOpened &amp;&amp; !leojsTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leojs.prevFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leojs.nextFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leojs.undoFromOutline",
    "when": "view =~ /^leojsOutline|^leojsUndo/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.redoFromOutline",
    "when": "view =~ /^leojsOutline|^leojsUndo/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.deHoistFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened &amp;&amp; !leojsTopHoistChapter",
    "group": "navigation@7"
  },
  {
    "command": "leojs.chapterMain",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened &amp;&amp; leojsTopHoistChapter",
    "group": "navigation@7"
  },
  {
    "command": "leojs.hoistSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leojs.chapterBack",
    "when": "view =~ /^leojsFindPanel|^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterNext",
    "when": "view =~ /^leojsFindPanel|^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterSelect",
    "when": "view =~ /^leojsFindPanel|^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.chapterMain",
    "when": "view =~ /^leojsFindPanel|^leojsGotoPanel/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.promoteSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leojs.demoteSelectionFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@10"
  },
  {
    "command": "leojs.contractAllFromOutline",
    "when": "view =~ /^leojsOutline/ &amp;&amp; leojsTreeOpened",
    "group": "navigation@11"
  }
],
</t>
<t tx="felix.20201214205159.56">"view/item/context": [
  @others
]
</t>
<t tx="felix.20201214205159.57">{
  "command": "leojs.editHeadline",
  "when": "config.leojs.showEditOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@1"
},
</t>
<t tx="felix.20201214205159.58">{
  "command": "leojs.insertNode",
  "when": "config.leojs.showAddOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@2"
},
</t>
<t tx="felix.20201214205159.6">"commands": [
  @others
],
</t>
<t tx="felix.20201214205159.60">{
  "command": "leojs.copyNode",
  "when": "config.leojs.showCopyOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@4"
},
{
  "command": "leojs.cloneNode",
  "when": "config.leojs.showCloneOnNodes &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "inline@4"
},
</t>
<t tx="felix.20201214205159.61">{
  "command": "leojs.mark",
  "when": "config.leojs.showMarkOnNodes &amp;&amp; viewItem =~ /^leojsNodeUnmarked/",
  "group": "inline@5"
},
{
  "command": "leojs.unmark",
  "when": "config.leojs.showMarkOnNodes &amp;&amp; viewItem =~ /^leojsNodeMarked/",
  "group": "inline@5"
},
</t>
<t tx="felix.20201214205159.62">{
  "command": "leojs.openAside",
  "when": "config.leojs.showOpenAside &amp;&amp; viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext1@1"
},
</t>
<t tx="felix.20201214205159.63">{
  "command": "leojs.hoistNode",
  "when": "viewItem =~ /leojsNodeNotRoot/",
  "group": "leojsNodeContext1@2"
},
{
  "command": "leojs.deHoist",
  "when": "leojsCanDehoist &amp;&amp; viewItem =~ /leojsNodeRoot/",
  "group": "leojsNodeContext1@2"
},
</t>
<t tx="felix.20201214205159.64">{
  "command": "leojs.refreshFromDisk",
  "when": "viewItem =~ /leojsNodeAtFile/",
  "group": "leojsNodeContext1@3"
},
</t>
<t tx="felix.20201214205159.65">{
  "command": "leojs.mark",
  "when": "viewItem =~ /^leojsNodeUnmarked/",
  "group": "leojsNodeContext2@1"
},
{
  "command": "leojs.unmark",
  "when": "viewItem =~ /^leojsNodeMarked/",
  "group": "leojsNodeContext2@1"
},
</t>
<t tx="felix.20201214205159.66">{
  "command": "leojs.copyNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@5"
},
{
  "command": "leojs.cutNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@6"
},
{
  "command": "leojs.pasteNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@7"
},
{
  "command": "leojs.pasteNodeAsClone",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@8"
},
{
  "command": "leojs.delete",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext2@9"
},
{
  "command": "leojs.insertNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext3@1"
},
{
  "command": "leojs.cloneNode",
  "when": "viewItem =~ /^leojsNode/",
  "group": "leojsNodeContext3@2"
},
{
  "command": "leojs.gotoNextClone",
  "when": "viewItem =~ /leojsNodeCloned/",
  "group": "leojsNodeContext3@3"
},
</t>
<t tx="felix.20201214205159.67">"keybindings": [
  @others
],
</t>
<t tx="felix.20201214205159.68">{
  "command": "leojs.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.minibuffer",
  "key": "alt+x",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20201214205159.69">{
  "command": "leojs.showOutline",
  "key": "alt+t",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs || leojsFindFocus || focusedView =~ /^leojsUndos|^leojsFindPanel|^leojsDocuments|^leojsGoto|^leojsButtons/"
},
{
  "command": "leojs.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.showBody",
  "key": "alt+d",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.showBody",
  "key": "ctrl+g",
  "mac": "cmd+g",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.showBody",
  "key": "tab",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsButtons|^leojsUndos/"
},
{
  "command": "leojs.showBody",
  "key": "enter",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.70">{
  "command": "leojs.tabCycleNext",
  "key": "ctrl+tab",
  "mac": "cmd+tab",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.newLeoFile",
  "key": "ctrl+n",
  "mac": "cmd+n",
  "when": "leojsEditHeadline || editorTextFocus &amp;&amp; resourceScheme == leojs || leojsFindFocus || sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.openLeoFile",
  "key": "ctrl+o",
  "mac": "cmd+o",
  "when": "leojsEditHeadline || editorTextFocus &amp;&amp; resourceScheme == leojs || leojsFindFocus || sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.writeAtFileNodes",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.writeAtFileNodesFromOutline",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.writeDirtyAtFileNodes",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.writeDirtyAtFileNodesFromOutline",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
</t>
<t tx="felix.20201214205159.71">{
  "command": "leojs.contractAll",
  "key": "alt+-",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.contractAllFromOutline",
  "key": "alt+-",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
</t>
<t tx="felix.20201214205159.72">{
  "command": "leojs.editSelectedHeadline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.editSelectedHeadlineFromOutline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments|^leojsButtons|^leojsUndos/"
},
</t>
<t tx="felix.20201214205159.73">{
  "command": "leojs.markSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsTreeOpened &amp;&amp; !leojsMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.markSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; !leojsMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.unmarkSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsTreeOpened &amp;&amp; leojsMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.unmarkSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; leojsMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.74">{
  "command": "leojs.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd+shift+n",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20201214205159.75">{
  "command": "leojs.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "shift+down",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "shift+left",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "shift+right",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "shift+up",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.76">{
  "command": "leojs.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertNodeSelection",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertNodeSelectionFromOutline",
  "key": "insert",
  "mac": "insert",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.insertChildNodeSelection",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.insertChildNodeSelectionFromOutline",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.cloneNodeSelection",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.cloneNodeSelectionFromOutline",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/"
},
</t>
<t tx="felix.20201214205159.77">{
  "command": "leojs.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/"
},
{
  "command": "leojs.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/"
},
{
  "command": "leojs.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.deleteSelectionFromOutline",
  "key": "delete",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
</t>
<t tx="felix.20201214205159.78">{
  "command": "leojs.gotoFirstVisible",
  "key": "alt+home",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoLastVisible",
  "key": "alt+end",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoFirstVisible",
  "key": "home",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNavFirst",
  "key": "home",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsGoto/"
},
{
  "command": "leojs.gotoLastVisible",
  "key": "end",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNavLast",
  "key": "end",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsGoto/"
},
{
  "command": "leojs.pageUp",
  "key": "pageup",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNavFirst",
  "key": "pageup",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsGoto/"
},
{
  "command": "leojs.pageDown",
  "key": "pagedown",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNavLast",
  "key": "pagedown",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsGoto/"
},
{
  "command": "leojs.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoNextVisible",
  "key": "down",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsEditHeadline || config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNavNext",
  "key": "down",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsGoto/"
},
{
  "command": "leojs.gotoNextVisible",
  "key": "alt+down",
  "when": "leojsTreeOpened &amp;&amp; leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.gotoPrevVisible",
  "key": "up",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsEditHeadline || config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.gotoNavPrev",
  "key": "up",
  "when": "leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsGoto/"
},
{
  "command": "leojs.gotoPrevVisible",
  "key": "alt+up",
  "when": "leojsTreeOpened &amp;&amp; leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.contractOrGoLeft",
  "key": "left",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.contractOrGoLeft",
  "key": "alt+left",
  "when": "leojsTreeOpened &amp;&amp; leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.expandAndGoRight",
  "key": "right",
  "when": "config.leojs.leoTreeBrowse &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline/"
},
{
  "command": "leojs.expandAndGoRight",
  "key": "alt+right",
  "when": "leojsTreeOpened &amp;&amp; leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojsOutline|^leojsDocuments/ || leojsTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20201214205159.79">"cleanup": "node ./cleanup.js",
"vscode:prepublish": "npm run package",
"compile": "webpack",
"compile-web": "webpack",
"open-in-browser": "node ./prepare.js &amp;&amp; vscode-test-web --browserType=chromium --extensionDevelopmentPath=. &amp;&amp; node ./cleanup.js",
"watch": "webpack --watch",
"watch-web": "webpack --watch",
"package": "webpack --mode production --devtool hidden-source-map",
"package-web": "webpack --mode production --devtool hidden-source-map",
"compile-tests": "tsc -p . --outDir out",
"watch-tests": "tsc -p . -w --outDir out",
"pretest": "npm run compile-tests &amp;&amp; npm run compile &amp;&amp; npm run lint",
"lint": "eslint src --ext ts",
"test": "node ./out/test/runTest.js",
"test-web": "node ./prepare.js &amp;&amp; vscode-test-web --extensionDevelopmentPath=. --extensionTestsPath=dist/test/suite/index-web.js &amp;&amp; node ./cleanup.js"
</t>
<t tx="felix.20201214205159.8">{
  "command": "leojs.executeScript",
  "category": "Leojs",
  "title": "Execute Script",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/execute.svg",
    "dark": "resources/dark/execute.svg"
  }
},
{
  "command": "leojs.minibuffer",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Minibuffer"
},
{
  "command": "leojs.gotoScript",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Script"
},
{
  "command": "leojs.removeButton",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Button"
},
</t>
<t tx="felix.20201214205159.80">"@types/debounce": "^1.2.0",
"@types/difflib": "^0.2.1",
"@types/elementtree": "^0.1.1",
"@types/glob": "^7.2.0",
"@types/lodash": "^4.14.177",
"@types/md5": "^2.3.1",
"@types/mocha": "^9.1.0",
"@types/node": "16.x",
"@types/pako": "^2.0.0",
"@types/safe-json-stringify": "^1.1.2",
"@types/sql.js": "^1.4.4",
"@types/vscode": "^1.83.0",
"@types/webpack-env": "^1.16.3",
"@typescript-eslint/eslint-plugin": "^5.16.0",
"@typescript-eslint/parser": "^5.16.0",
"@vscode/test-electron": "^2.0.3",
"@vscode/test-web": "^0.0.24",
"assert": "^2.0.0",
"buffer": "^6.0.3",
"eslint": "^8.11.0",
"glob": "^7.2.0",
"mocha": "^9.1.3",
"process": "^0.11.10",
"terser-webpack-plugin": "^5.3.1",
"ts-loader": "^9.2.6",
"typescript": "^4.5.5",
"webpack": "^5.70.0",
"webpack-cli": "^4.9.2",
"webpack-shell-plugin-next": "^2.2.2"
</t>
<t tx="felix.20201214205159.81">"binascii": "^0.0.2",
"bowser": "^2.11.0",
"browser-process-hrtime": "^1.0.0",
"console-browserify": "^1.2.0",
"crypto-browserify": "^3.12.0",
"csvtojson": "^2.0.10",
"date-format-lite": "^17.7.0",
"dayjs": "^1.11.3",
"dayjs-plugin-utc": "^0.1.2",
"difflib": "^0.2.4",
"elementtree": "^0.1.7",
"jszip": "^3.10.1",
"lodash": "^4.17.21",
"md5": "^2.3.0",
"os-browserify": "^0.3.0",
"pako": "^2.1.0",
"path-browserify": "^1.0.1",
"stream": "^0.0.2"
</t>
<t tx="felix.20201214205159.9">{
  "command": "leojs.showSettingsPage",
  "title": "Open Leojs Settings",
  "category": "Leojs",
  "icon": {
    "light": "resources/light/gear.svg",
    "dark": "resources/dark/gear.svg"
  }
},
{
  "command": "leojs.showWelcomePage",
  "title": "Welcome",
  "category": "Leojs"
},
{
  "command": "leojs.setLeoID",
  "category": "Leojs",
  "enablement": "!leojsReady",
  "title": "Set Leo ID"
},
{
  "command": "leojs.showBody",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus to Body"
},
{
  "command": "leojs.showOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus to Tree"
},
{
  "command": "leojs.showLogPane",
  "category": "Leojs",
  "title": "Show Log Pane",
  "enablement": "leojsReady",
  "icon": {
    "light": "resources/light/show-log.svg",
    "dark": "resources/dark/show-log.svg"
  }
},
</t>
<t tx="felix.20201214211742.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was clicked
 * @returns Promises that resolves when done
 */
public async clickAtButton(p_node: LeoButtonNode): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const c = g.app.windowList[g.app.gui.frameIndex].c;
    const d = c.theScriptingController.buttonsArray;
    const button = d[p_node.button.index];
    let result: any;
    if (p_node.rclicks.length) {
        // Has rclicks so show menu to choose
        this._rclickSelected = [];
        let w_rclick: number[] | undefined;
        const p_picked = await this._handleRClicks(p_node.rclicks, p_node.button.name);

        if (
            p_picked
        ) {
            // Check if only one in this._rclickSelected and is zero: normal press
            if (this._rclickSelected.length === 1 &amp;&amp; this._rclickSelected[0] === 0) {
                // Normal 'top' button, not one of it's child rclicks.
            } else {
                // One of its child 'rclick', so decrement first one, and send this._rclickSelected as array of choices
                this._rclickSelected[0] = this._rclickSelected[0] - 1;
                w_rclick = this._rclickSelected;
            }

            try {
                let w_rclickChosen: RClick | undefined;

                if (w_rclick &amp;&amp; button.rclicks) {
                    // Had w_rclick setup so it's a child rclick, not the recular 'top' button.
                    let toChooseFrom: RClick[] = button.rclicks;
                    for (const i_rc of w_rclick) {
                        w_rclickChosen = toChooseFrom[i_rc];
                        toChooseFrom = w_rclickChosen.children;
                    }
                    if (w_rclickChosen) {
                        result = c.theScriptingController.executeScriptFromButton(button, '', w_rclickChosen.position, '');
                    }
                } else {
                    // Normal 'top' button.
                    result = await Promise.resolve(button.command());
                }

            } catch (e: any) {
                void vscode.window.showErrorMessage("LEOJS: LeoUI clickAtButton Error: " + e.toString());
            }

        } else {
            // Escaped so  just return, no 'setupRefresh' nor 'launchRefresh'!
            return Promise.resolve();
        }

    } else {
        // no rclicks nor menus, so just call the button's command.
        result = await Promise.resolve(button.command());
    }

    this.setupRefresh(Focus.NoChange, {
        tree: true,
        body: true,
        documents: true,
        buttons: true,
        states: true
    });

    void this.launchRefresh();
    return result;

}

</t>
<t tx="felix.20201214211744.1">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was chosen to remove
 * @returns Thenable that resolves when done
 */
public async removeAtButton(p_node: LeoButtonNode): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const tag: string = 'remove_button';
    const index = p_node.button.index;
    const c = g.app.windowList[g.app.gui.frameIndex].c;
    const d = c.theScriptingController.buttonsArray;
    const butWidget = d[index];
    if (butWidget) {
        try {
            d.splice(index, 1);
        } catch (e) {
            g.es_exception(e);
        }
    } else {
        console.log(`LEOJS : ERROR ${tag}: button ${String(index)} does not exist`);
    }
    this.setupRefresh(Focus.NoChange, { buttons: true });
    return this.launchRefresh();

}

</t>
<t tx="felix.20201214211830.1">/**
* * Close an opened Leo file
* @returns the promise started after it's done closing the Leo document
*/
public async closeLeoFile(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);

    this.setupRefresh(Focus.Body, {
        tree: true,
        body: true,
        documents: true,
        buttons: true,
        states: true
    });

    const c = g.app.windowList[this.frameIndex].c;
    await c.close();
    void this.launchRefresh(); // start to refresh first
    return this.loadSearchSettings();
}

</t>
<t tx="felix.20201214211832.1">/**
 * * Sets up the call to the 'open-outline' command and its possible file url parameter.
 * @param p_leoFileUri optional uri for specifying a file, if missing, a dialog will open
 * @returns A promise that resolves when done trying to open the file
 */
public async openLeoFile(p_uri?: vscode.Uri): Promise&lt;unknown&gt; {

    if (p_uri) {
        if (!!p_uri.toJSON &amp;&amp; !!p_uri.fsPath &amp;&amp; p_uri.fsPath.trim()) {
            // valid: pass!
        } else {
            p_uri = undefined; // clear uri
        }
    }

    if (!this.leoStates.fileOpenedReady) {
        // override with given argument
        let fileName: string;

        // make sure it's a real uri because vscode may send selected
        // node from other tree that has this command in title

        if (p_uri &amp;&amp; p_uri?.fsPath?.trim() &amp;&amp; g.app.loadManager) {
            fileName = p_uri.fsPath;
        } else {
            fileName = await this.runOpenFileDialog(
                undefined,
                "Open",
                [
                    ["Leo files", "*.leo *.leojs *.db"],
                    ["Python files", "*.py"],
                    ["All files", "*"]
                ],
                g.defaultLeoFileExtension(),
                false
            ) as string;
        }
        if (fileName &amp;&amp; g.app.loadManager) {
            await g.app.loadManager.loadLocalFile(fileName, this);
            this.showBodyIfClosed = true;
            this.showOutlineIfClosed = true;
            this.setupRefresh(this.finalFocus, {
                tree: true,
                body: true,
                goto: true,
                states: true,
                documents: true,
                buttons: true
            });
            void this.launchRefresh();
        } else {
            return Promise.resolve();
        }
    } else {
        await this.triggerBodySave(true);
        const c = g.app.windowList[this.frameIndex].c;
        await c.open_outline(p_uri);
        this.showBodyIfClosed = true;
        this.showOutlineIfClosed = true;
        this.setupRefresh(this.finalFocus, {
            tree: true,
            body: true,
            goto: true,
            states: true,
            documents: true,
            buttons: true
        });
        void this.launchRefresh();
    }
    return this.loadSearchSettings();
}

</t>
<t tx="felix.20201214211834.1">/**
 * * Shows the recent Leo files list, choosing one will open it
 * @returns A promise that resolves when the a file is finally opened, rejected otherwise
 */
public async showRecentLeoFiles(): Promise&lt;unknown&gt; {

    // if shown, chosen and opened
    const w_recentFiles: string[] = g.app.recentFilesManager.recentFiles;

    let q_chooseFile: Thenable&lt;string | undefined&gt;;
    if (w_recentFiles.length) {
        q_chooseFile = vscode.window.showQuickPick(w_recentFiles, {
            placeHolder: Constants.USER_MESSAGES.OPEN_RECENT_FILE,
        });
    } else {
        // No file to list
        return Promise.resolve(undefined);
    }
    const w_result = await q_chooseFile;
    if (w_result) {
        return this.openLeoFile(vscode.Uri.file(w_result));
    } else {
        // Canceled
        return Promise.resolve(undefined);
    }

}

</t>
<t tx="felix.20201214211835.1">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results.
 */
public async saveAsLeoFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        {
            tree: true,
            states: true,
            documents: true
        }
    );

    await c.saveAs();
    void this.launchRefresh();
    return;
}

</t>
<t tx="felix.20201214211836.1">/**
 * * Invokes the commander.save() command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns Promise that resolves when the save command is done
 */
public async saveLeoFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    await c.save();

    // ON THE WEB THE SAVE DOES NOT FINISH BEFORE INTERUPTING OTHER COMMANDS!
    setTimeout(() =&gt; {
        this.setupRefresh(
            p_fromOutline ? Focus.Outline : Focus.Body,
            {
                tree: true,
                states: true,
                documents: true
            }
        );
        void this.launchRefresh();
    });

    return Promise.resolve();
}

</t>
<t tx="felix.20201214211837.1">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly selected document
 */
public async switchLeoFile(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);

    const w_entries: ChooseDocumentItem[] = []; // Entries to offer as choices.
    let w_index: number = 0;
    const w_files: LeoDocument[] = g.app.windowList.map((p_frame) =&gt; {
        const s = p_frame.c.fileName();
        const w_filename = s ? utils.getFileFromPath(s) : Constants.UNTITLED_FILE_NAME;
        return {
            name: w_filename,
            index: w_index++,
            changed: p_frame.c.isChanged(),
            selected: g.app.windowList[this.frameIndex] === p_frame,
        };
    });
    w_index = 0; // reset w_index
    let w_chosenDocument: ChooseDocumentItem | undefined;
    if (w_files &amp;&amp; w_files.length) {
        w_files.forEach(function (p_filePath: LeoDocument) {
            w_entries.push({
                label: w_index.toString(),
                description: p_filePath.name
                    ? p_filePath.name
                    : Constants.UNTITLED_FILE_NAME,
                value: w_index,
                alwaysShow: true,
            });
            w_index++;
        });
        const w_pickOptions: vscode.QuickPickOptions = {
            matchOnDescription: true,
            placeHolder: Constants.USER_MESSAGES.CHOOSE_OPENED_FILE,
        };
        w_chosenDocument = await vscode.window.showQuickPick(w_entries, w_pickOptions);
    } else {
        // "No opened documents"
        return Promise.resolve(undefined);
    }
    if (w_chosenDocument) {
        return Promise.resolve(this.selectOpenedLeoDocument(w_chosenDocument.value));
    } else {
        // Canceled
        return Promise.resolve(undefined);
    }

}

</t>
<t tx="felix.20201214211839.1">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 * @param p_index position of the opened Leo document in the document array
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly opened document
 */
public async selectOpenedLeoDocument(p_index: number, p_fromOutline?: boolean): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    this.frameIndex = p_index;
    // Like we just opened or made a new file
    if (g.app.windowList.length) {
        this.setupRefresh(
            this.finalFocus,
            {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true,
                goto: true

            }
        );
        void this.launchRefresh();
        this.loadSearchSettings();
    } else {
        void this.launchRefresh();
        console.log('Select Opened Leo File Error');
        return Promise.reject('Select Opened Leo File Error');
    }

}

</t>
<t tx="felix.20201214233119.1">/**
 * General 'Leo is ready' state, equivalent to leoBridgeReady in leoInteg
 */
private _leoReady: boolean = false;
get leoReady(): boolean {
    return this._leoReady;
}
set leoReady(p_value: boolean) {
    this._leoReady = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_READY, p_value);
}

</t>
<t tx="felix.20201222013904.1">/**
 * * Refreshes the outline. A reveal type can be passed along to specify the reveal type for the selected node
 * @param p_incrementTreeId Make all node id's be 'new' by incrementing the treeId prefix of the id's.
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_incrementTreeId: boolean, p_revealType?: RevealType): void {
    if (p_incrementTreeId) {
        this._leoTreeProvider.incTreeId();
    }
    if (p_revealType !== undefined &amp;&amp; p_revealType.valueOf() &gt;= this._revealType.valueOf()) { // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    try {
        if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            this.showOutlineIfClosed = false;
            // Force showing last used Leo outline first
            let w_viewName: string;
            if (this._lastTreeView === this._leoTreeExView) {
                w_viewName = Constants.TREEVIEW_EXPLORER_ID;
            } else {
                w_viewName = Constants.TREEVIEW_ID;
            }
            vscode.commands.executeCommand(w_viewName + ".focus").then(
                () =&gt; {
                    this._revealNodeRetriedRefreshOutline = false;
                    this._leoTreeProvider.refreshTreeRoot();
                },
                (p_reason) =&gt; {
                    // Reveal failed: retry once.
                    console.log('_refreshOutline could not reveal. Rejected reason: ', p_reason);
                    this._leoTreeProvider.refreshTreeRoot();
                }
            );

        } else {
            this.showOutlineIfClosed = false;
            // was visible, just refresh
            this._leoTreeProvider.refreshTreeRoot();
        }
    } catch (error) {
        // Also retry once on error
        console.log('_refreshOutline could not reveal. Catch Error: ', error);
        this._leoTreeProvider.refreshTreeRoot();
    }

}

</t>
<t tx="felix.20201227014627.1">/**
 * * Launches refresh for UI components and context states (Debounced)
 */
public async _launchRefresh(): Promise&lt;unknown&gt; {
    if (!this.refreshPreserveRange) {
        if (this.findFocusTree) {
            // had a range but now refresh from other than find/replace
            // So make sure tree is also refreshed.
            this._refreshType.tree = true;
        }
        // Clear no matter what.
        this.findFocusTree = false;
    } else {
        this.refreshPreserveRange = false; // preserved once, now cleared.
    }

    // check states for having at least a document opened
    if (this.leoStates.leoReady &amp;&amp; this.leoStates.fileOpenedReady) {
        // Had some opened
        if (!g.app.windowList.length) {
            return this._setupNoOpenedLeoDocument(); // All closed now!
        }
    }
    if (this.leoStates.leoReady &amp;&amp; !this.leoStates.fileOpenedReady) {
        // Was all closed
        if (g.app.windowList.length) {
            this._setupOpenedLeoDocument();
            // Has a commander opened, but wait for UI!
            await this.leoStates.qLastContextChange;
        }
    }

    // Consider last command finished since the refresh cycle is starting
    if (this.trace) {
        if (this.commandTimer !== undefined) {
            console.log('commandTimer', utils.getDurationMs(this.commandTimer));
        }
    }
    this.commandTimer = undefined;

    // Start reset-timer capture, if has been reset.
    this.lastRefreshTimer = process.hrtime();
    if (this.refreshTimer === undefined) {
        this.refreshTimer = this.lastRefreshTimer;
    }

    let w_revealType: RevealType;
    if (this.finalFocus.valueOf() === Focus.Outline) {
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        w_revealType = RevealType.RevealSelect;
    }

    const c = g.app.windowList[this.frameIndex].c;
    this._refreshNode = c.p;

    if (
        this._refreshNode &amp;&amp;
        this._refreshType.body &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty
    ) {
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        // Do this only if gnx is different from what is coming from Leo in this refresh cycle.
        const w_lastChangedDocGnx = utils.leoUriToStr(this._bodyLastChangedDocument.uri);
        if (
            this._refreshNode.gnx !== w_lastChangedDocGnx &amp;&amp; !this._bodyLastChangedDocumentSaved
        ) {
            void this._bodyLastChangedDocument.save(); // Voluntarily save to 'clean' any pending body (no await)
            this._bodyLastChangedDocumentSaved = true;
        }
        if (this._refreshNode.gnx === w_lastChangedDocGnx) {
            this._leoFileSystem.preventSaveToLeo = true;
            await this._bodyLastChangedDocument.save(); // SAME GNX : so wait for it! (await)
        }
    }

    // * _focusInterrupt insertNode Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }

    const w_showBodyNoFocus: boolean = this.finalFocus.valueOf() !== Focus.Body;

    // console.log('showBodyIfClosed', this.showBodyIfClosed);// 
    // console.log('showOutlineIfClosed', this.showOutlineIfClosed);// 
    // console.log('explorer visible', this._leoTreeExView.visible);// 
    // console.log('visible', this._leoTreeView.visible); // 
    // console.log('this._refreshType.tree', this._refreshType.tree);
    // console.log('this._refreshType.body', this._refreshType.body); //

    // * Force refresh tree when body update required for 'navigation/insert node' commands
    if (

        this.showBodyIfClosed &amp;&amp;
        this.showOutlineIfClosed &amp;&amp;
        !this.isOutlineVisible() &amp;&amp;
        this._refreshType.body

    ) {
        // console.log('HAD TO ADJUST!');
        this._refreshType.tree = true;
    }

    // * Either the whole tree refreshes, or a single tree node is revealed when just navigating
    if (this._refreshType.tree) {
        this._refreshType.tree = false;
        this._refreshType.node = false; // Also clears node
        if (!this.isOutlineVisible() &amp;&amp; !this.showOutlineIfClosed &amp;&amp; this._refreshType.body) {
            // wont get 'gotSelectedNode so show body!
            this._refreshType.body = false;
            void this._tryApplyNodeToBody(this._refreshNode || this.lastSelectedNode!, false, w_showBodyNoFocus);
        } else if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            let w_treeName;
            if (this._lastTreeView === this._leoTreeExView) {
                w_treeName = Constants.TREEVIEW_EXPLORER_ID;
            } else {
                w_treeName = Constants.TREEVIEW_ID;
            }
            // Reveal will trigger a native outline refresh
            this._leoTreeProvider.incTreeId();
            this._revealType = w_revealType;
            void vscode.commands.executeCommand(w_treeName + '.focus');
            // } else if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            //     const c = g.app.windowList[this.frameIndex].c;
            //     this._lastTreeView.reveal(c.p, { select: true });
            // } else {
            //     this._refreshOutline(true, w_revealType);
            // }
        } else {
            this._refreshOutline(true, w_revealType);
        }
    } else if (this._refreshType.node &amp;&amp; this._refreshNode) {
        // * Force single node "refresh" by revealing it, instead of "refreshing" it
        this._refreshType.node = false;
        this.leoStates.setSelectedNodeFlags(this._refreshNode);
        let w_showOutline = this.isOutlineVisible();
        if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            this.showOutlineIfClosed = false;
            w_showOutline = true;
        }
        void this._revealNode(
            this._refreshNode,
            {
                select: true,
                focus: w_showOutline
            }
        );
        if (this._refreshType.body) {
            // * if no outline visible, just update body pane as needed
            if (!this.isOutlineVisible()) {
                this._refreshType.body = false;
                void this._tryApplyNodeToBody(this._refreshNode, false, w_showBodyNoFocus);
            }
        }
    } else if (this._refreshType.body) {
        this._refreshType.body = false;
        void this._tryApplyNodeToBody(this._refreshNode || this.lastSelectedNode!, false, w_showBodyNoFocus);
    }

    // * DEBUG INFO

    // console.log('***********************finished refresh');
    // console.log('**** c.config should be lowercase: ', c.config.new_leo_file_encoding);
    // // @ts-expect-error
    // console.log('**** g.app.config should be uppercase: ', g.app.config.new_leo_file_encoding);
    // console.log('**** c.collapse_on_lt_arrow :', c.collapse_on_lt_arrow);
    // console.log('**** c.collapse_nodes_after_move :', c.collapse_nodes_after_move);
    // console.log('**** c.sparse_move: ', c.sparse_move);

    // getStates will check if documents, buttons and states flags are set and refresh accordingly
    return this.getStates();
}

</t>
<t tx="felix.20201227155008.1">/**
 * * Setup global refresh options
 * @param p_finalFocus Flag for focus to be placed in outline
 * @param p_refreshType Refresh flags for each UI part
*/
public setupRefresh(p_finalFocus: Focus, p_refreshType?: ReqRefresh, p_preserveRange?: boolean): void {
    if (p_preserveRange) {
        this.refreshPreserveRange = true; // Will be cleared after a refresh cycle.
    }
    // Set final "focus-placement" EITHER true or false
    this.finalFocus = p_finalFocus;

    if (p_refreshType) {
        // Set all properties WITHOUT clearing others.
        Object.assign(this._refreshType, p_refreshType);
    }
}

</t>
<t tx="felix.20201227230901.1">/**
 * * Setup UI for having no opened Leo documents
 */
private _setupNoOpenedLeoDocument(): void {
    this.leoStates.fileOpenedReady = false;
    this._bodyTextDocument = undefined;
    this.lastSelectedNode = undefined;
    this._refreshOutline(false, RevealType.NoReveal);
    this.refreshDocumentsPane();
    this.refreshButtonsPane();
    this.refreshUndoPane();
    void this.closeBody();
}

</t>
<t tx="felix.20201227230912.1">/**
 * * A Leo file was opened: setup UI accordingly.
 * @param p_openFileResult Returned info about currently opened and editing document
 */
private _setupOpenedLeoDocument(): void {
    this._needLastSelectedRefresh = true;

    const c = g.app.windowList[this.frameIndex].c;
    this.leoStates.leoOpenedFileName = c.fileName();
    this.leoStates.leoChanged = c.changed;

    // * Startup flag
    this.leoStates.fileOpenedReady = true;

    this._revealType = RevealType.RevealSelect; // For initial outline 'visible' event

    this.showBodyIfClosed = true;
    this.showOutlineIfClosed = true;
    this.setupRefresh(
        Focus.Body, // Original Leo seems to open itself with focus in body.
        {
            tree: true,
            body: true,
            states: true,
            buttons: true,
            documents: true,
            goto: true
        },
    );

    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEOJS_SCHEME,
                this._leoFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._bodyFileSystemStarted = true;
    }

    this.loadSearchSettings();
}

</t>
<t tx="felix.20201229025520.1">/**
 * * Handle selected node being created for the outline
 * @param p_node Position that was just created and detected as selected node
 */
public gotSelectedNode(p_node: Position): void {

    const w_focusTree = (this._revealType.valueOf() &gt;= RevealType.RevealSelectFocus.valueOf());
    const w_last = this.lastSelectedNode;

    if (
        !w_focusTree &amp;&amp;
        this._refreshType.scroll &amp;&amp;
        w_last &amp;&amp;
        w_last.__eq__(p_node) &amp;&amp; // utils.isApEqual(w_last, p_node) &amp;&amp;
        this._lastTreeView &amp;&amp;
        this._lastTreeView.visible

    ) {
        // ! MINIMAL TIMEOUT REQUIRED ! WHY ?? (works so leave)
        if (this._gotSelectedNodeBodyTimer) {
            clearTimeout(this._gotSelectedNodeBodyTimer);
        }
        this._gotSelectedNodeBodyTimer = setTimeout(() =&gt; {
            // SAME with scroll information specified
            void this.showBody(false, this.finalFocus.valueOf() !== Focus.Body);
        }, 25);
    } else {

        if (this._revealType) {
            if (this._gotSelectedNodeRevealTimer) {
                clearTimeout(this._gotSelectedNodeRevealTimer);
            }
            this._gotSelectedNodeRevealTimer = setTimeout(() =&gt; {
                this._lastTreeView.reveal(p_node, {
                    select: true,
                    focus: w_focusTree
                }).then(() =&gt; {
                    // ok
                    if (this.trace) {
                        if (this.refreshTimer) {
                            console.log('refreshTimer', utils.getDurationMs(this.refreshTimer));
                        }
                        if (this.lastRefreshTimer) {
                            console.log('lastRefreshTimer', utils.getDurationMs(this.lastRefreshTimer));
                        }
                        if (this.commandRefreshTimer) {
                            console.log('commandRefreshTimer', utils.getDurationMs(this.commandRefreshTimer));
                        }
                        if (this.lastCommandRefreshTimer) {
                            console.log('lastCommandRefreshTimer', utils.getDurationMs(this.lastCommandRefreshTimer));
                        }
                    }
                    this.refreshTimer = undefined;
                    this.lastRefreshTimer = undefined;
                    this.commandRefreshTimer = undefined;
                    this.lastCommandRefreshTimer = undefined;
                }, (p_reason) =&gt; {
                    // Reveal failed. Retry refreshOutline once
                    this._refreshOutline(true, RevealType.RevealSelect);
                });
                // Done, so reset reveal type 'flag'
                this._revealType = RevealType.NoReveal;
            }, 0);
        }

        // Apply node to body pane
        let w_showBodyNoFocus: boolean = this.finalFocus.valueOf() !== Focus.Body; // Will preserve focus where it is without forcing into the body pane if true
        if (this._focusInterrupt) {
            this._focusInterrupt = false;
            w_showBodyNoFocus = true;
        }
        if (!w_last || this._needLastSelectedRefresh) {
            // lastSelectedNode will be set in _tryApplyNodeToBody !
            this._needLastSelectedRefresh = false;
        }

        if (this._bodyTextDocument &amp;&amp;
            !this._bodyTextDocument.isClosed &amp;&amp; // IS OPENED
            !this._refreshType.body &amp;&amp; // NO NEED TO REFRESH BODY !
            this._locateOpenedBody(p_node.gnx) // DID LOCATE NEW GNX =&gt; ALREADY SHOWN!
        ) {
            // * Just make sure body selection is considered done.
            this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context
            this._preventShowBody = false; // in case it was a config-changed-refresh
        } else {
            // * Actually run the normal 'APPLY NODE TO BODY' to show or switch
            void this._tryApplyNodeToBody(p_node, false, w_showBodyNoFocus);
        }

        // Set context flags
        this.leoStates.setSelectedNodeFlags(p_node);
    }

}

</t>
<t tx="felix.20210102000055.1"></t>
<t tx="felix.20210102000100.1"></t>
<t tx="felix.20210110210346.1">@language typescript
@tabwidth -4

// ambient module declaration for https://www.npmjs.com/package/date-format-lite
declare module "date-format-lite" { }

// date-format-lite augments built-in Date
interface Date {
    format: (format?: string) =&gt; string;
    masks: { default: string };
}

</t>
<t tx="felix.20211002194716.1"></t>
<t tx="felix.20211003223641.1">/**
 * * Builds a unique Id from gnx and stack, plus collapsed state,
 * for vscode to distinguish the collapsed state.
 */
private _buildId(p_position: Position, p_collapsed: number): string {
    // concatenate gnx, stacks gnx's, and collapsible state number.
    // (vscode uses id for collapsible state)
    let w_stringId = this.treeId.toString() +
        p_position.v.gnx + p_position.childIndex().toString() +
        p_position.stack.map(p_stackEntry =&gt; p_stackEntry[0].gnx + p_stackEntry[1].toString()).join("");
    // NOT NEEDED -&gt; p_collapsed.toString(); // Added Uniqueness: VSCode's collapsible state in id
    return w_stringId;
}

</t>
<t tx="felix.20211003233639.1">/**
 * * Force uniqueness of ids generated for nodes in the  next tree refresh
 */
public incTreeId(): void {
    this.treeId++;
}

</t>
<t tx="felix.20211006225245.1">"configuration": {
  "title": "LeoJS Leo Editor",
  "properties": {
    "leojs.checkForChangeExternalFiles": {
      "scope": "application",
      "default": "none",
      "type": "string",
      "description": "Set default for checking changes to external files",
      "enum": [
        "none",
        "force-check",
        "force-ignore"
      ],
      "enumDescriptions": [
        "Default from Leo's config",
        "Check for changes",
        "Ignore all changes"
      ]
    },
    "leojs.defaultReloadIgnore": {
      "scope": "application",
      "default": "none",
      "type": "string",
      "description": "Set default for derived files so that they reload, or ignore, when changes are detected",
      "enum": [
        "none",
        "yes-all",
        "no-all"
      ],
      "enumDescriptions": [
        "Choose each time",
        "Reload All",
        "Ignore All"
      ]
    },
    "leojs.leoTreeBrowse": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
    },
    "leojs.treeKeepFocus": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
    },
    "leojs.treeKeepFocusWhenAside": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
    },
    "leojs.goAnywhereShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables Leo's 'Go Anywhere' to replace 'Go to file' with the Ctrl+P keyboard shortcut when focus in in outline or body"
    },
    "leojs.collapseAllShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables the Alt+'-' keyboard shortcut for collapsing all folders in the Explorer View"
    },
    "leojs.activityViewShortcut": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Enables the Ctrl+Shift+L keyboard shortcut for showing the LeoJS view"
    },
    "leojs.treeInExplorer": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Show the outline tree in the explorer view"
    },
    "leojs.showOpenAside": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Offer 'Open to the Side' in nodes context menu"
    },
    "leojs.showEditOnNodes": {
      "scope": "application",
      "default": true,
      "type": "boolean",
      "description": "Shows 'Edit Headline' button on tree nodes"
    },
    "leojs.showAddOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Insert' button on tree nodes"
    },
    "leojs.showMarkOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Mark/Unmark' buttons on tree nodes"
    },
    "leojs.showCloneOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Clone' button on tree nodes"
    },
    "leojs.showCopyOnNodes": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Shows 'Copy' button on tree nodes"
    },
    "leojs.invertNodeContrast": {
      "scope": "application",
      "default": false,
      "type": "boolean",
      "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
    },
    "leojs.leoID": {
      "scope": "application",
      "default": "",
      "type": "string",
      "description": "Used to uniquely identify nodes - Defaults to the OS/Environment user name",
      "pattern": "(^$|^[a-zA-Z0-9]*$)",
      "patternErrorMessage": "Your id should contain only letters and numbers, and must contain at least 3 characters."
    }
  }
},
</t>
<t tx="felix.20211007213344.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, ConfigSetting, FontSettings } from "./types";
import { Constants } from "./constants";
import { LeoUI } from "./leoUI";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20211007213344.10">/**
 * * Check if the workbench.editor.enablePreview flag is set
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkEnablePreview(p_forced?: boolean): void {
    let w_result: any = true;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("enablePreview")!.globalValue === undefined) {
        w_result = w_setting.inspect("enablePreview")!.defaultValue;
    } else {
        w_result = w_setting.inspect("enablePreview")!.globalValue;
    }
    if (w_result === false) {
        if (p_forced) {
            void this.setEnablePreview();
            void vscode.window.showInformationMessage(Constants.USER_MESSAGES.ENABLE_PREVIEW_SET);
        } else {
            void vscode.window.showWarningMessage(
                Constants.USER_MESSAGES.ENABLE_PREVIEW_RECOMMEND,
                Constants.USER_MESSAGES.FIX_IT
            ).then(p_chosenButton =&gt; {
                if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                    void vscode.commands.executeCommand(Constants.COMMANDS.SET_ENABLE_PREVIEW);
                }
            });
        }
    }
}

</t>
<t tx="felix.20211007213344.11">/**
 * * Check if the 'workbench.editor.closeEmptyGroups' setting is false
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkCloseEmptyGroups(p_forced?: boolean): void {
    let w_result: any = false;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("closeEmptyGroups")!.globalValue === undefined) {
        w_result = w_setting.inspect("closeEmptyGroups")!.defaultValue;
    } else {
        w_result = w_setting.inspect("closeEmptyGroups")!.globalValue;
    }
    if (w_result === true) {
        if (p_forced) {
            void this.clearCloseEmptyGroups();
            void vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_EMPTY_CLEARED);
        } else {
            void vscode.window.showWarningMessage(
                Constants.USER_MESSAGES.CLOSE_EMPTY_RECOMMEND,
                Constants.USER_MESSAGES.FIX_IT
            ).then(p_chosenButton =&gt; {
                if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                    void vscode.commands.executeCommand(Constants.COMMANDS.CLEAR_CLOSE_EMPTY_GROUPS);
                }
            });
        }
    }
}

</t>
<t tx="felix.20211007213344.13">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    // Shorthand pointers for readability
    const GET = vscode.workspace.getConfiguration;
    const NAME = Constants.CONFIG_NAME;
    const NAMES = Constants.CONFIG_NAMES;
    const DEFAULTS = Constants.CONFIG_DEFAULTS;
    const FLAGS = Constants.CONTEXT_FLAGS;

    if (this._isBusySettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        this.checkForChangeExternalFiles = GET(NAME).get(NAMES.CHECK_FOR_CHANGE_EXTERNAL_FILES, DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES);
        this.defaultReloadIgnore = GET(NAME).get(NAMES.DEFAULT_RELOAD_IGNORE, DEFAULTS.DEFAULT_RELOAD_IGNORE);
        this.leoTreeBrowse = GET(NAME).get(NAMES.LEO_TREE_BROWSE, DEFAULTS.LEO_TREE_BROWSE);
        this.treeKeepFocus = GET(NAME).get(NAMES.TREE_KEEP_FOCUS, DEFAULTS.TREE_KEEP_FOCUS);
        this.treeKeepFocusWhenAside = GET(NAME).get(NAMES.TREE_KEEP_FOCUS_WHEN_ASIDE, DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE);

        this.collapseAllShortcut = GET(NAME).get(NAMES.COLLAPSE_ALL_SHORTCUT, DEFAULTS.COLLAPSE_ALL_SHORTCUT);
        this.activityViewShortcut = GET(NAME).get(NAMES.ACTIVITY_VIEW_SHORTCUT, DEFAULTS.ACTIVITY_VIEW_SHORTCUT);
        this.goAnywhereShortcut = GET(NAME).get(NAMES.GO_ANYWHERE_SHORTCUT, DEFAULTS.GO_ANYWHERE_SHORTCUT);

        // this.statusBarString = GET(NAME).get(NAMES.STATUSBAR_STRING, DEFAULTS.STATUSBAR_STRING);
        // if (this.statusBarString.length &gt; 8) {
        //     this.statusBarString = DEFAULTS.STATUSBAR_STRING;
        // }
        // this.statusBarColor = GET(NAME).get(NAMES.STATUSBAR_COLOR, DEFAULTS.STATUSBAR_COLOR);
        // if (!utils.isHexColor(this.statusBarColor)) {
        //     this.statusBarColor = DEFAULTS.STATUSBAR_COLOR;
        // }
        this.treeInExplorer = GET(NAME).get(NAMES.TREE_IN_EXPLORER, DEFAULTS.TREE_IN_EXPLORER);
        this.showOpenAside = GET(NAME).get(NAMES.SHOW_OPEN_ASIDE, DEFAULTS.SHOW_OPEN_ASIDE);
        this.showEditOnNodes = GET(NAME).get(NAMES.SHOW_EDIT, DEFAULTS.SHOW_EDIT);
        this.showAddOnNodes = GET(NAME).get(NAMES.SHOW_ADD, DEFAULTS.SHOW_ADD);
        this.showMarkOnNodes = GET(NAME).get(NAMES.SHOW_MARK, DEFAULTS.SHOW_MARK);
        this.showCloneOnNodes = GET(NAME).get(NAMES.SHOW_CLONE, DEFAULTS.SHOW_CLONE);
        this.showCopyOnNodes = GET(NAME).get(NAMES.SHOW_COPY, DEFAULTS.SHOW_COPY);

        // this.showArrowsOnNodes = GET(NAME).get(NAMES.SHOW_ARROWS, DEFAULTS.SHOW_ARROWS);

        // this.showEditionOnBody = GET(NAME).get(NAMES.SHOW_EDITION_BODY, DEFAULTS.SHOW_EDITION_BODY);
        // this.showClipboardOnBody = GET(NAME).get(NAMES.SHOW_CLIPBOARD_BODY, DEFAULTS.SHOW_CLIPBOARD_BODY);
        // this.showPromoteOnBody = GET(NAME).get(NAMES.SHOW_PROMOTE_BODY, DEFAULTS.SHOW_PROMOTE_BODY);
        // this.showExecuteOnBody = GET(NAME).get(NAMES.SHOW_EXECUTE_BODY, DEFAULTS.SHOW_EXECUTE_BODY);
        // this.showExtractOnBody = GET(NAME).get(NAMES.SHOW_EXTRACT_BODY, DEFAULTS.SHOW_EXTRACT_BODY);
        // this.showImportOnBody = GET(NAME).get(NAMES.SHOW_IMPORT_BODY, DEFAULTS.SHOW_IMPORT_BODY);
        // this.showRefreshOnBody = GET(NAME).get(NAMES.SHOW_REFRESH_BODY, DEFAULTS.SHOW_REFRESH_BODY);
        // this.showHoistOnBody = GET(NAME).get(NAMES.SHOW_HOIST_BODY, DEFAULTS.SHOW_HOIST_BODY);
        // this.showMarkOnBody = GET(NAME).get(NAMES.SHOW_MARK_BODY, DEFAULTS.SHOW_MARK_BODY);
        // this.showSortOnBody = GET(NAME).get(NAMES.SHOW_SORT_BODY, DEFAULTS.SHOW_SORT_BODY);

        this.invertNodeContrast = GET(NAME).get(NAMES.INVERT_NODES, DEFAULTS.INVERT_NODES);
        this.leoID = GET(NAME).get(NAMES.LEO_ID, DEFAULTS.LEO_ID);

    }
}

</t>
<t tx="felix.20211007213344.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {

    // Config settings used on Leo's side
    public checkForChangeExternalFiles: string = Constants.CONFIG_DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES;
    public defaultReloadIgnore: string = Constants.CONFIG_DEFAULTS.DEFAULT_RELOAD_IGNORE;

    // Config settings used on vscode's side
    public leoTreeBrowse: boolean = Constants.CONFIG_DEFAULTS.LEO_TREE_BROWSE; // Used as Context Flag
    public treeKeepFocus: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS;
    public treeKeepFocusWhenAside: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE;

    public collapseAllShortcut: boolean = Constants.CONFIG_DEFAULTS.COLLAPSE_ALL_SHORTCUT;
    public activityViewShortcut: boolean = Constants.CONFIG_DEFAULTS.ACTIVITY_VIEW_SHORTCUT;
    public goAnywhereShortcut: boolean = Constants.CONFIG_DEFAULTS.GO_ANYWHERE_SHORTCUT;

    // public statusBarString: string = Constants.CONFIG_DEFAULTS.STATUSBAR_STRING;
    // public statusBarColor: string = Constants.CONFIG_DEFAULTS.STATUSBAR_COLOR;
    public treeInExplorer: boolean = Constants.CONFIG_DEFAULTS.TREE_IN_EXPLORER; // Used as Context Flag
    public showOpenAside: boolean = Constants.CONFIG_DEFAULTS.SHOW_OPEN_ASIDE; // Used as Context Flag
    public showEditOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDIT; // Used as Context Flag

    // public showArrowsOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ARROWS; // Used as Context Flag
    public showAddOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ADD; // Used as Context Flag
    public showMarkOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK; // Used as Context Flag
    public showCloneOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLONE; // Used as Context Flag
    public showCopyOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_COPY; // Used as Context Flag

    // public showEditionOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDITION_BODY; // Used as Context Flag
    // public showClipboardOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLIPBOARD_BODY; // Used as Context Flag
    // public showPromoteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_PROMOTE_BODY; // Used as Context Flag
    // public showExecuteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXECUTE_BODY; // Used as Context Flag
    // public showExtractOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXTRACT_BODY; // Used as Context Flag
    // public showImportOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_IMPORT_BODY; // Used as Context Flag
    // public showRefreshOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_REFRESH_BODY; // Used as Context Flag
    // public showHoistOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_HOIST_BODY; // Used as Context Flag
    // public showMarkOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK_BODY; // Used as Context Flag
    // public showSortOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_SORT_BODY; // Used as Context Flag

    public invertNodeContrast: boolean = Constants.CONFIG_DEFAULTS.INVERT_NODES;
    public leoID: string = Constants.CONFIG_DEFAULTS.LEO_ID;

    public setLeoJsSettingsPromise: Promise&lt;unknown&gt; = Promise.resolve();

    private _isBusySettingConfig: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoUI: LeoUI
    ) { }

    @others
}
</t>
<t tx="felix.20211007213344.3">/**
 * * Get actual 'live' Leojs configuration
 * @returns An object with config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,
        defaultReloadIgnore: this.defaultReloadIgnore,
        leoTreeBrowse: this.leoTreeBrowse, // Used as Context Flag
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,

        collapseAllShortcut: this.collapseAllShortcut,
        activityViewShortcut: this.activityViewShortcut,
        goAnywhereShortcut: this.goAnywhereShortcut,

        // statusBarString: this.statusBarString,
        // statusBarColor: this.statusBarColor,
        treeInExplorer: this.treeInExplorer, // Used as Context Flag
        showOpenAside: this.showOpenAside,  // Used as Context Flag
        showEditOnNodes: this.showEditOnNodes, // Used as Context Flag
        // showArrowsOnNodes: this.showArrowsOnNodes, // Used as Context Flag
        showAddOnNodes: this.showAddOnNodes, // Used as Context Flag
        showMarkOnNodes: this.showMarkOnNodes, // Used as Context Flag
        showCloneOnNodes: this.showCloneOnNodes, // Used as Context Flag
        showCopyOnNodes: this.showCopyOnNodes, // Used as Context Flag

        // showEditionOnBody: this.showEditionOnBody, // Used as Context Flag
        // showClipboardOnBody: this.showClipboardOnBody, // Used as Context Flag
        // showPromoteOnBody: this.showPromoteOnBody, // Used as Context Flag
        // showExecuteOnBody: this.showExecuteOnBody, // Used as Context Flag
        // showExtractOnBody: this.showExtractOnBody, // Used as Context Flag
        // showImportOnBody: this.showImportOnBody, // Used as Context Flag
        // showRefreshOnBody: this.showRefreshOnBody, // Used as Context Flag
        // showHoistOnBody: this.showHoistOnBody, // Used as Context Flag
        // showMarkOnBody: this.showMarkOnBody, // Used as Context Flag
        // showSortOnBody: this.showSortOnBody, // Used as Context Flag

        invertNodeContrast: this.invertNodeContrast,
        leoID: this.leoID
    };
}

</t>
<t tx="felix.20211007213344.4">/**
 * * Get config from vscode for the UI font sizes
 * @returns the font settings object (zoom level and editor font size)
 */
public getFontConfig(): FontSettings {
    let w_zoomLevel = vscode.workspace.getConfiguration(
        "window"
    ).get("zoomLevel");

    let w_fontSize = vscode.workspace.getConfiguration(
        "editor"
    ).get("fontSize");

    const w_config: FontSettings = {
        zoomLevel: Number(w_zoomLevel),
        fontSize: Number(w_fontSize)
    };

    return w_config;
}

</t>
<t tx="felix.20211007213344.5">/**
 * * Apply changes to the expansion config settings and save them in user settings.
 * @param p_changes is an array of codes and values to be changed
 * @returns a promise that resolves upon completion
 */
public setLeojsSettings(p_changes: ConfigSetting[]): Promise&lt;unknown&gt; {
    this._isBusySettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        // tslint:disable-next-line: strict-comparisons
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // Set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
        } else {
            // Set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
        }
    });

    this.setLeoJsSettingsPromise = Promise.all(w_promises);
    return this.setLeoJsSettingsPromise.then(() =&gt; {
        this._isBusySettingConfig = false;
        this.buildFromSavedSettings();
        return Promise.resolve();
    });

}

</t>
<t tx="felix.20211007213344.6">/**
 * * Apply changes in font size settings and save them in user settings.
 */
public setFontConfig(p_settings: FontSettings): void {
    if (p_settings.zoomLevel || p_settings.zoomLevel === 0) {
        if (!isNaN(p_settings.zoomLevel) &amp;&amp; p_settings.zoomLevel &lt;= 12 &amp;&amp; p_settings.zoomLevel &gt;= -12) {
            void vscode.workspace.getConfiguration("window")
                .update("zoomLevel", p_settings.zoomLevel, true);
        } else {
            void vscode.window.showInformationMessage(
                Constants.USER_MESSAGES.ZOOM_LEVEL_RANGE_LIMIT
            );
        }
    }
    if (p_settings.fontSize) {
        if (!isNaN(p_settings.fontSize) &amp;&amp; p_settings.fontSize &lt;= 30 &amp;&amp; p_settings.fontSize &gt;= 6) {
            void vscode.workspace.getConfiguration("editor")
                .update("fontSize", p_settings.fontSize, true);
        } else {
            void vscode.window.showInformationMessage(
                Constants.USER_MESSAGES.FONT_SIZE_RANGE_LIMIT
            );
        }
    }
}

</t>
<t tx="felix.20211007213344.7">/**
 * * Set the workbench.editor.enablePreview vscode setting
 */
public setEnablePreview(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("enablePreview", true, true);
}

</t>
<t tx="felix.20211007213344.8">/**
 * * Clears the workbench.editor.closeEmptyGroups vscode setting
 */
public clearCloseEmptyGroups(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("closeEmptyGroups", false, true);
}

</t>
<t tx="felix.20211007213900.1">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;

    collapseAllShortcut: boolean;
    activityViewShortcut: boolean;
    goAnywhereShortcut: boolean;

    // statusBarString: string;
    // statusBarColor: string;

    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    // showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;

    // showEditionOnBody: boolean; // clone delete insert(s)
    // showClipboardOnBody: boolean; // cut copy paste(s)
    // showPromoteOnBody: boolean; // promote demote
    // showExecuteOnBody: boolean; // extract(s)
    // showExtractOnBody: boolean;
    // showImportOnBody: boolean;
    // showRefreshOnBody: boolean;
    // showHoistOnBody: boolean;
    // showMarkOnBody: boolean;
    // showSortOnBody: boolean;

    invertNodeContrast: boolean;
    leoID: string;
}

</t>
<t tx="felix.20211007213909.1">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20211007213915.1">/**
 * * Structure for the two vscode font settings
 */
export interface FontSettings {
    zoomLevel: number;
    fontSize: number;
}

</t>
<t tx="felix.20211007214102.1">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG_NAMES = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    // STATUSBAR_STRING: "statusBarString",
    // STATUSBAR_COLOR: "statusBarColor",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_OPEN_ASIDE: "showOpenAside",
    SHOW_EDIT: "showEditOnNodes",
    // SHOW_ARROWS: "showArrowsOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",

    COLLAPSE_ALL_SHORTCUT: "collapseAllShortcut",
    ACTIVITY_VIEW_SHORTCUT: "ActivityViewShortcut",
    GO_ANYWHERE_SHORTCUT: "goAnywhereShortcut",

    // SHOW_EDITION_BODY: "showEditionOnBody",
    // SHOW_CLIPBOARD_BODY: "showClipboardOnBody",
    // SHOW_PROMOTE_BODY: "showPromoteOnBody",
    // SHOW_EXECUTE_BODY: "showExecuteOnBody",
    // SHOW_EXTRACT_BODY: "showExtractOnBody",
    // SHOW_IMPORT_BODY: "showImportOnBody",
    // SHOW_REFRESH_BODY: "showRefreshOnBody",
    // SHOW_HOIST_BODY: "showHoistOnBody",
    // SHOW_MARK_BODY: "showMarkOnBody",
    // SHOW_SORT_BODY: "showSortOnBody",

    INVERT_NODES: "invertNodeContrast",
    LEO_ID: "leoID"
};

</t>
<t tx="felix.20211007214110.1">/**
 * * Configuration Defaults used in config.ts
 * Used when setting itself and getting parameters from vscode
 */
public static CONFIG_DEFAULTS = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "none",  // Used in leoBridge scrip,
    DEFAULT_RELOAD_IGNORE: "none", // Used in leoBridge scrip,
    LEO_TREE_BROWSE: true,
    TREE_KEEP_FOCUS: true,
    TREE_KEEP_FOCUS_WHEN_ASIDE: false,

    COLLAPSE_ALL_SHORTCUT: true,
    ACTIVITY_VIEW_SHORTCUT: true,
    GO_ANYWHERE_SHORTCUT: true,

    // STATUSBAR_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: \u{1F981}
    // STATUSBAR_COLOR: "fb7c47",

    TREE_IN_EXPLORER: true,
    SHOW_OPEN_ASIDE: true,
    SHOW_EDIT: true,
    // SHOW_ARROWS: false,
    SHOW_ADD: false,
    SHOW_MARK: false,
    SHOW_CLONE: false,
    SHOW_COPY: false,

    // SHOW_EDITION_BODY: true,
    // SHOW_CLIPBOARD_BODY: true,
    // SHOW_PROMOTE_BODY: true,
    // SHOW_EXECUTE_BODY: true,
    // SHOW_EXTRACT_BODY: true,
    // SHOW_IMPORT_BODY: true,
    // SHOW_REFRESH_BODY: true,
    // SHOW_HOIST_BODY: true,
    // SHOW_MARK_BODY: true,
    // SHOW_SORT_BODY: true,

    INVERT_NODES: false,
    LEO_ID: ""
};

</t>
<t tx="felix.20211007214455.1">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="felix.20211007232334.1">/**
 * * Refresh tree for 'node hover icons' to show up properly after changing their settings
 */
public configTreeRefresh(): void {
    if (this.leoStates.fileOpenedReady) {
        this._preventShowBody = true;
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20211008004139.1">/**
 * * Find panel controls ids
 */
public static FIND_INPUTS_IDS = {
    FIND_TEXT: "findText",
    REPLACE_TEXT: "replaceText",
    ENTIRE_OUTLINE: "entireOutline",
    FILE_ONLY: "fileOnly",
    NODE_ONLY: "nodeOnly",
    SUBOUTLINE_ONLY: "subOutlineOnly",
    IGNORE_CASE: "ignoreCase",
    MARK_CHANGES: "markChanges",
    MARK_FINDS: "markFinds",
    REG_EXP: "regExp",
    WHOLE_WORD: "wholeWord",
    SEARCH_BODY: "searchBody",
    SEARCH_HEADLINE: "searchHeadline"
};

</t>
<t tx="felix.20211010192923.1">import * as vscode from "vscode";
import { Utils as uriUtils } from "vscode-uri";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { BodyTimeInfo } from "./types";
import { LeoUI } from "./leoUI";
import * as g from './core/leoGlobals';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20211010192923.10">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20211010192923.11">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    if (!this.preventSaveToLeo) {
        void this._leoUi.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    } else {
        this.preventSaveToLeo = false;
    }
    const w_gnx = utils.leoUriToStr(p_uri);
    if (!this._openedBodiesGnx.includes(w_gnx)) {
        console.error("LeoJS: Tried to save body other than selected node's body", w_gnx);
    }
    this._setOpenedBodyTime(w_gnx);
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20211010192923.12">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('Called rename on ', p_oldUri.fsPath, p_newUri.fsPath); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20211010192923.13">public delete(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.splice(this._openedBodiesGnx.indexOf(w_gnx), 1);
        delete this._openedBodiesInfo[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20211010192923.14">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20211010192923.15">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20211010192923.2">/**
 * * Body panes implementation as a file system using "leojs" as a scheme identifier
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;
    private _errorRefreshFlag: boolean = false;

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastBodyLength: number = 0; // length of last file read

    // * List of currently opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    private _watchedBodiesGnx: string[] = [];

    // * List of gnx that should be available (from more.selectNode and fs.delete)
    private _openedBodiesGnx: string[] = [];
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    private _lastBodyTimeGnx: string = "";

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being watched by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoUi: LeoUI) { }

    @others
}
</t>
<t tx="felix.20211010192923.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setNewBodyUriTime(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._lastBodyTimeGnx = w_gnx;
    this._setOpenedBodyTime(w_gnx);
}

</t>
<t tx="felix.20211010192923.4">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {

    if (!this._openedBodiesGnx.includes(p_gnx)) {
        console.error("ASKED TO REFRESH NOT EVEN IN SELECTED BODY: ", p_gnx);
    }

    this._setOpenedBodyTime(p_gnx);

    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    }]);
}

</t>
<t tx="felix.20211010192923.5">/**
 * ? Maybe deprecated 
 * * Refreshes the '_possibleGnxList' list of all unique gnx from Leo
 * @returns a 'fresh' gnx string array
 */
public refreshPossibleGnxList(): string[] {
    // * Get updated list of possible gnx

    // all_gnx = [p.v.gnx for p in c.all_unique_positions(copy=False)]
    const c = g.app.windowList[this._leoUi.frameIndex].c;
    return [...c.all_unique_positions(false)].map(p =&gt; p.v.gnx);
}

</t>
<t tx="felix.20211010192923.6">public watch(p_resource: vscode.Uri, p_options: { readonly recursive: boolean; readonly excludes: readonly string[] }): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this._watchedBodiesGnx.includes(w_gnx)) {
        this._watchedBodiesGnx.push(w_gnx); // add gnx
    }
    // else already in list
    return new vscode.Disposable(() =&gt; {
        const w_position = this._watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this._watchedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20211010192923.7">public stat(p_uri: vscode.Uri): vscode.FileStat {
    if (this._leoUi.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        if (p_uri.fsPath.length === 1) {
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
        } else if (false &amp;&amp; w_gnx === this._lastGnx &amp;&amp; this._openedBodiesGnx.includes(this._lastGnx)) {
            // ! Always return current size: w_v.b.length ! Not this._lastBodyLength !
            console.log('had stats: modified: ', this._openedBodiesInfo[this._lastGnx].mtime);
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._lastBodyLength
            };
        } else if (this._openedBodiesGnx.includes(w_gnx)) {
            const c = g.app.windowList[this._leoUi.frameIndex].c;
            const w_v = c.fileCommands.gnxDict[w_gnx];
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[w_gnx].ctime,
                mtime: this._openedBodiesInfo[w_gnx].mtime,
                size: w_v.b.length
            };
        }
    }
    // throw vscode.FileSystemError.FileNotFound();
    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
    return { type: vscode.FileType.File, ctime: 0, mtime: 0, size: 0 };
}

</t>
<t tx="felix.20211010192923.8">public readFile(p_uri: vscode.Uri): Uint8Array {
    if (this._leoUi.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);

            if (!this._openedBodiesGnx.includes(w_gnx)) {
                console.log(
                    " _openedBodiesGnx length: ", this._openedBodiesGnx.length,
                    '\n *** readFile: ERROR File not in _openedBodiesGnx! readFile missing refreshes? gnx: ', w_gnx
                );
            }

            const c = g.app.windowList[this._leoUi.frameIndex].c;
            const w_v = c.fileCommands.gnxDict[w_gnx];
            if (w_v) {
                this._errorRefreshFlag = false; // got body so reset possible flag!
                this._lastGnx = w_gnx;
                this._lastBodyData = w_v.b;
                const w_buffer: Uint8Array = Buffer.from(this._lastBodyData);
                this._lastBodyLength = w_buffer.byteLength;
                return w_buffer;
            } else {
                if (!this._errorRefreshFlag) {
                    this._leoUi.fullRefresh();
                }
                if (this._lastGnx === w_gnx) {
                    // was last gnx of closed file about to be switched to new document selected
                    console.log('Passed in not found: ' + w_gnx);
                    return Buffer.from(this._lastBodyData);
                }
                console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                return Buffer.from("");
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20211010192923.9">public readDirectory(p_uri: vscode.Uri): [string, vscode.FileType][] {
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._lastBodyTimeGnx, vscode.FileType.File]);
        return w_directory;
    } else {
        throw vscode.FileSystemError.FileNotFound(p_uri);
    }
}

</t>
<t tx="felix.20211010221959.1">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20211012233514.1">/**
 * * Asks for .leojs file name and path, then saves the JSON Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results.
 */
public async saveAsLeoJsFile(p_fromOutline?: boolean): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    this.setupRefresh(
        p_fromOutline ? Focus.Outline : Focus.Body,
        {
            tree: true,
            states: true,
            documents: true
        }
    );

    // ! THIS WOULD DO A 'SAVE TO' INSTEAD OF 'SAVE AS' !
    // await c.save_as_leojs();

    // * DO THIS INSTEAD !
    let fileName = await g.app.gui.runSaveFileDialog(
        c,
        'Save As JSON (.leojs)',
        [['Leo JSON files', '*.leojs']],
        '.leojs'
    );
    if (!fileName) {
        return;
    }
    if (!fileName.endsWith('.leojs')) {
        fileName = `${fileName}.leojs`;
    }
    await c.save(fileName);

    void this.launchRefresh();
    return;
}

</t>
<t tx="felix.20211024012523.1">/**
 * Returns clipboard content
*/
public getTextFromClipboard(): string {
    return this.clipboardContents;
}

</t>
<t tx="felix.20211024012536.1"></t>
<t tx="felix.20211030165058.1"></t>
<t tx="felix.20211117232843.1">{
  "command": "leojs.undoFromOutline",
  "key": "ctrl+z",
  "mac": "cmd+z",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.redoFromOutline",
  "key": "ctrl+shift+z",
  "mac": "cmd+shift+z",
  "when": "leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/"
},
</t>
<t tx="felix.20211119001637.1">"resourceLabelFormatters": [
  {
    "scheme": "leojs",
    "formatting": {
      "label": "LEOJS: BODY",
      "separator": "/",
      "workspaceSuffix": ""
    }
  }
]
</t>
<t tx="felix.20211122205011.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoStates } from "./leoStates";
import * as g from './core/leoGlobals';
import { Icon } from "./types";
import { LeoUI } from "./leoUI";

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20211122205031.1">/**
 * * Undo beads shown as a list with this TreeDataProvider implementation
 */
export class LeoUndosProvider implements vscode.TreeDataProvider&lt;LeoUndoNode&gt; {

    private _beadId = 0;

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoUndoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoUndoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoUndoNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoStates: LeoStates,
        private _leoUI: LeoUI,
        private _icons: Icon[],
    ) { }

    @others
}

</t>
<t tx="felix.20211122212823.1">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoUndoNode extends vscode.TreeItem {

    constructor(
        public label: string,
        public description: string,
        public id: string,
        public contextValue: string,
        public beadIndex: number,
        public iconPath?: Icon
    ) {
        super(label);
    }

    @others
}

</t>
<t tx="felix.20211122213012.1">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20211122213023.1">public getTreeItem(element: LeoUndoNode): Thenable&lt;LeoUndoNode&gt; | LeoUndoNode {
    return element;
}

</t>
<t tx="felix.20211122213037.1">public getParent(element: LeoUndoNode): vscode.ProviderResult&lt;LeoUndoNode&gt; {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return undefined;
}

</t>
<t tx="felix.20211122214230.1">public getChildren(element?: LeoUndoNode): LeoUndoNode[] {
    const w_children: LeoUndoNode[] = [];
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoStates.fileOpenedReady &amp;&amp; !element &amp;&amp; g.app.windowList.length) {
        const c = g.app.windowList[this._leoUI.frameIndex].c;
        const undoer = c.undoer;

        if (undoer.beads.length) {

            let w_foundNode: LeoUndoNode | undefined;
            let i: number = 0;
            let w_defaultIcon = 1;

            undoer.beads.forEach(p_bead =&gt; {
                let w_description: string = "";
                let w_undoFlag: boolean = false;
                let w_icon = w_defaultIcon;
                if (i === undoer.bead) {
                    w_description = "Undo";
                    w_undoFlag = true;
                    w_icon = 0;
                    w_defaultIcon = 2;
                }
                if (i === undoer.bead + 1) {
                    w_description = "Redo";
                    w_icon = 2;
                    w_defaultIcon = 3;
                    if (!w_foundNode) {
                        w_undoFlag = true; // Passed all nodes until 'redo', no undo found.
                    }
                }
                const w_node = new LeoUndoNode(
                    p_bead.undoType || "unknown",
                    w_description,
                    (this._beadId++).toString(),
                    Constants.CONTEXT_FLAGS.UNDO_BEAD,
                    i - undoer.bead,
                    this._icons[w_icon]
                );
                w_children.push(w_node);
                if (w_undoFlag) {
                    w_foundNode = w_node;
                }
                i++;
            });
            if (w_foundNode) {
                this._leoUI.setUndoSelection(w_foundNode);
            }
        } else {
            const w_node = new LeoUndoNode(
                "Unchanged",
                "",
                (this._beadId++).toString(),
                Constants.CONTEXT_FLAGS.NOT_UNDO_BEAD,
                0,
                undefined
            );
            w_children.push(w_node);
        }

    }
    return w_children; // Defaults to an empty list of children
}

</t>
<t tx="felix.20211122230343.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onUndosTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        if (p_explorerView) {
            this._lastLeoUndos = this._leoUndosExplorer;
            if (this._leoUndosExplorerShown) {
                this._leoUndosProvider.refreshTreeRoot(); // Already shown, will redraw but not re-select
            }
            this._leoUndosExplorerShown = true; // either way set it
        } else {
            this._lastLeoUndos = this._leoUndos;
            if (this._leoUndosShown) {
                this._leoUndosProvider.refreshTreeRoot(); // Already shown, will redraw but not re-select
            }
            this._leoUndosShown = true; // either way set it
        }
    }
}

</t>
<t tx="felix.20211124223735.1">/**
 * * Refreshes the undo pane
 */
private _refreshUndoPane(): void {
    this._leoUndosProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20211201001847.1">export class LeoOutlineNode extends vscode.TreeItem {

    constructor(
        public label: vscode.TreeItemLabel, // Node headline
        public collapsibleState: vscode.TreeItemCollapsibleState,
        public position: Position, // Pointer/reference for leo's node position
        public description: string,
        public iconPath: Icon,
        public id: string,
        public contextValue: string // For contextual menu on each node (not the global 'selected node' flag!)
    ) {
        super(label, collapsibleState);
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            // using 'this' as LeoOutlineNode instead of position, to match 'openToTheSide' paramter
            arguments: [this]
        };
    }

}
</t>
<t tx="felix.20211204144931.1"></t>
<t tx="felix.20211204144931.2">/**
 * * Validate headline edit input box if active, or, Save body to the Leo app if its dirty.
 *   That is, only if a change has been made to the body 'document' so far
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean, p_fromFocusChange?: boolean): Thenable&lt;unknown&gt; {

    // * Check if headline edit input box is active. Validate it with current value.
    if (!p_fromFocusChange &amp;&amp; this._hib &amp;&amp; this._hib.enabled) {
        this._hibInterrupted = true;
        this._hib.enabled = false;
        this._hibLastValue = this._hib.value;
        this._hib.hide();
        if (this._onDidHideResolve) {
            console.error('IN triggerBodySave AND _onDidHideResolve PROMISE ALREADY EXISTS!');
        }
        const w_resolveAfterEditHeadline = new Promise&lt;void&gt;((p_resolve, p_reject) =&gt; {
            this._onDidHideResolve = p_resolve;
        });
        return w_resolveAfterEditHeadline;
    }

    // * Save body to Leo if a change has been made to the body 'document' so far
    let q_savePromise: Thenable&lt;boolean&gt;;
    if (
        this._bodyLastChangedDocument &amp;&amp;
        (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
        !this._bodyLastChangedDocumentSaved
    ) {
        // * Is dirty and unsaved, so proper save is in order
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        this._bodyLastChangedDocumentSaved = true;
        this._editorTouched = false;
        q_savePromise = this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else if (
        p_forcedVsCodeSave &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        this._bodyLastChangedDocumentSaved
    ) {
        // * Had 'forcedVsCodeSave' and isDirty only, so just clean up dirty VSCODE document flag.
        this._bodySaveSelection(); // just save selection if it's changed
        q_savePromise = this._bodyLastChangedDocument.save(); // ! USED INTENTIONALLY: This trims trailing spaces
    } else {
        this._bodyLastChangedDocumentSaved = true;
        this._bodySaveSelection();  // just save selection if it's changed
        q_savePromise = Promise.resolve(true);
    }
    return q_savePromise.then((p_result) =&gt; {

        // this.debouncedRefreshBodyStates(); // ! test this !

        return p_result;
    }, (p_reason) =&gt; {
        console.log('BodySave rejected :', p_reason);
        return false;
    });
}

</t>
<t tx="felix.20211204144931.3">/**
 * * Saves the cursor position along with the text selection range and scroll position
 */
private _bodySaveSelection(): void {

    if (!this._selectionDirty || !this._selection) {
        return;
    }
    // Prepare scroll data separately

    let scroll: number;
    if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
        scroll = this._scroll?.start.line || 0;
    } else {
        scroll = 0;
    }
    const gnx = this._selectionGnx;

    const start = {
        line: this._selection.start.line || 0,
        col: this._selection.start.character || 0,
    };
    const end = {
        line: this._selection.end.line || 0,
        col: this._selection.end.character || 0,
    };
    const active = {
        line: this._selection.active.line || 0,
        col: this._selection.active.character || 0,
    };

    const c = g.app.windowList[this.frameIndex].c;
    let p: Position | undefined;
    if (c.p.gnx === gnx) {
        p = c.p;
    } else {
        // find p.
        for (let p_p of c.all_positions()) {
            if (p_p.v.gnx === gnx) {
                p = p_p;
                break;
            }
        }
    }
    if (!p) {
        return;
    }

    // - "ap":     An archived position for position p.
    // - "start":  The start of the selection.
    // - "end":    The end of the selection.
    // - "active": The insert point. Must be either start or end.
    // - "scroll": An optional scroll position.

    const v = p.v;
    const wrapper = c.frame.body.wrapper;
    const insert = g.convertRowColToPythonIndex(v.b, active['line'], active['col']);
    const startSel = g.convertRowColToPythonIndex(v.b, start['line'], start['col']);
    const endSel = g.convertRowColToPythonIndex(v.b, end['line'], end['col']);

    // If it's the currently selected node set the wrapper's states too
    if (p.__eq__(c.p)) {
        wrapper.setSelectionRange(startSel, endSel, insert);
        wrapper.setYScrollPosition(scroll);
    }
    // Always set vnode attrs.
    v.scrollBarSpot = scroll;
    v.insertSpot = insert;
    v.selectionStart = startSel &lt; endSel ? startSel : endSel;
    v.selectionLength = Math.abs(startSel - endSel);

    this._scrollDirty = false;
    this._selectionDirty = false;

}

</t>
<t tx="felix.20211204144931.4">/**
 * * Sets new body text on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDocument(
    p_document: vscode.TextDocument,
    p_forcedVsCodeSave?: boolean
): Thenable&lt;boolean&gt; {
    if (p_document) {

        const c = g.app.windowList[this.frameIndex].c;
        const u = c.undoer;
        const wrapper = c.frame.body.wrapper;
        const w_gnx = utils.leoUriToStr(p_document.uri);
        const body = p_document.getText(); // new body text

        const w_v = c.fileCommands.gnxDict[w_gnx]; // target to change
        if (w_v) {

            if (body !== w_v.b) {
                // if different, replace body and set dirty
                let w_p: Position | undefined;
                if (c.p.gnx === w_v.gnx) {
                    // same gnx so it's the same position for saving the new body pane text.
                    w_p = c.p;
                } else {
                    // find p.
                    for (let p of c.all_positions()) {
                        if (p.v.gnx === w_gnx) {
                            w_p = p;
                            break;
                        }
                    }
                }
                if (w_p) {
                    // ok we got a valid p.
                    const bunch = u.beforeChangeNodeContents(w_p);
                    w_p.v.setBodyString(body);
                    u.afterChangeNodeContents(w_p, "Body Text", bunch);
                    // Set in wrapper too if same gnx
                    if (c.p.__eq__(w_p)) {
                        wrapper.setAllText(body);
                    }
                    if (!c.isChanged()) {
                        c.setChanged();
                    }
                    if (!w_p.v.isDirty()) {
                        w_p.setDirty();
                    }
                    // this.clearHeadlineSelection();
                }

            }

        } else {
            console.error("ERROR SAVING BODY FROM VSCODE TO LEOJS");
            if (p_forcedVsCodeSave) {
                return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
            }
            return Promise.resolve(false); // EARLY EXIT
        }

        // save the cursor selection
        this._bodySaveSelection();

        this._refreshType.states = true;
        this.getStates();
        if (p_forcedVsCodeSave) {
            return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
        }

        return Promise.resolve(p_document.isDirty);
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20211204144931.5">/**
 * * Sets new body text on leo's side before vscode closes itself if body is dirty
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDeactivate(
    p_document: vscode.TextDocument
): Thenable&lt;unknown&gt; {
    const w_gnx = utils.leoUriToStr(p_document.uri);
    const c = g.app.windowList[this.frameIndex].c;
    const w_v = c.fileCommands.gnxDict[w_gnx];
    if (w_v) {
        w_v.b = p_document.getText();
    }

    return Promise.resolve(true);
}

</t>
<t tx="felix.20211204181418.1">/**
 * * Perform insert and rename commands
 */
private _insertAndSetHeadline(p_name?: string, p_asChild?: boolean): any {
    const LEOCMD = Constants.LEO_COMMANDS;
    const w_command = p_asChild ? LEOCMD.INSERT_CHILD_PNODE : LEOCMD.INSERT_PNODE;
    const c = g.app.windowList[this.frameIndex].c;
    const u = c.undoer;
    let value: any = c.doCommandByName(w_command);
    if (!p_name) {
        return value;
    }
    const undoData = u.beforeChangeHeadline(c.p);
    c.setHeadString(c.p, p_name);  // Set v.h *after* calling the undoer's before method.
    if (!c.changed) {
        c.setChanged();
    }
    u.afterChangeHeadline(c.p, 'Edit Headline', undoData);
    return value;
}

</t>
<t tx="felix.20211212205241.1">/**
 * Replaces the system's clipboard with the given string
 * @param p_string actual string content to go onto the clipboard
 * @returns a promise that resolves when the string is put on the clipboard
 */
public replaceClipboardWith(s: string): Thenable&lt;string&gt; {
    this.clipboardContents = s; // also set immediate clipboard string
    return vscode.env.clipboard.writeText(s).then(() =&gt; { return s; });
}

</t>
<t tx="felix.20220103203600.1">/**
 * Asynchronous clipboards getter
 * Get the system's clipboard contents and returns a promise
 * Also puts it in the global clipboardContents variable
 * @returns a promise of the clipboard string content
 */
public asyncGetTextFromClipboard(): Thenable&lt;string&gt; {
    return vscode.env.clipboard.readText().then((s) =&gt; {
        // also set immediate clipboard string for possible future read
        this.clipboardContents = s;
        return this.getTextFromClipboard();
    });
}

</t>
<t tx="felix.20220103222715.1">/**
 * * Overridden 'good' minibuffer command name strings
 */
public static MINIBUFFER_OVERRIDDEN_NAMES: { [key: string]: string } = {
    'paste-node': 'async-paste-node',
    'paste-retaining-clones': 'async-paste-retaining-clones',
    'paste-as-template': 'async-paste-as-template',
    'insert-child': 'async-insert-child',
    'insert-node': 'async-insert-node',
    'insert-as-first-child': 'async-insert-as-first-child',
    'insert-as-last-child': 'async-insert-as-last-child',
    'insert-node-before': 'async-insert-node-before',
};

</t>
<t tx="felix.20220107223824.1">public runOpenFileDialog(
    c: Commands | undefined,
    title: string,
    filetypes: [string, string][],
    defaultExtension: string,
    multiple?: boolean,
    startpath?: string // TODO
): Thenable&lt;string[] | string&gt; {
    // convert to { [name: string]: string[] } typing
    const types: { [name: string]: string[] } = utils.convertLeoFiletypes(filetypes);
    return vscode.window.showOpenDialog(
        {
            title: title,
            canSelectMany: !!multiple,
            filters: types
        }
    ).then((p_uris) =&gt; {
        const names: string[] = [];
        if (p_uris &amp;&amp; p_uris.length) {
            p_uris.forEach(w_uri =&gt; {
                names.push(w_uri.fsPath);
            });
        }
        if (multiple) {

            return names.map((p_name) =&gt; {
                let fileName = g.os_path_fix_drive(p_name);
                fileName = g.os_path_normslashes(fileName);
                return fileName;
            });
        } else {
            // Not multiple: return as string!
            let fileName = g.os_path_fix_drive(names.length ? names[0] : "");
            fileName = g.os_path_normslashes(fileName);
            return fileName;
        }
    });
}

</t>
<t tx="felix.20220108211750.1">public runAskOkDialog(
    c: Commands | undefined,
    title: string,
    message: string,
    text = "Ok"
): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage(
        title,
        {
            modal: true,
            detail: message
        });
}

</t>
<t tx="felix.20220108211806.1">public runSaveFileDialog(
    c: Commands | undefined,
    title: string,
    filetypes: [string, string][],
    defaultExtension: string,
): Thenable&lt;string&gt; {
    // convert to { [name: string]: string[] } typing
    const types: { [name: string]: string[] } = utils.convertLeoFiletypes(filetypes);
    return vscode.window.showSaveDialog(
        {
            title: title,
            filters: types
        }
    ).then((p_uri) =&gt; {
        if (p_uri) {
            let fileName = g.os_path_fix_drive(p_uri.fsPath);
            fileName = g.os_path_normslashes(fileName);
            return fileName;
        } else {
            return "";
        }
    });
}

</t>
<t tx="felix.20220109180351.1">/**
 * Convert Leo's internal filetype descriptions array
 * to vscode's option format for open/save dialogs.
 */
export function convertLeoFiletypes(p_filetypes: [string, string][]): { [name: string]: string[] } {
    /*
        from :
            [
                ["", ""],
                ["Leo files", "*.leo *.db"]
            ],

        to :
        {
            'Images': ['png', 'jpg']
            'TypeScript': ['ts', 'tsx']
        }

    */
    const w_types: { [name: string]: string[] } = {};
    p_filetypes.forEach(type =&gt; {
        w_types[type[0]] = type[1].split(" ").map((p_entry) =&gt; {

            return p_entry.startsWith("*.") ? p_entry.substring(2) : p_entry;
        });
    });
    return w_types;
}
</t>
<t tx="felix.20220109220155.1">public runAskYesNoDialog(
    c: Commands | undefined,
    title: string,
    message: string,
    yes_all = false,
    no_all = false,

): Thenable&lt;string&gt; {
    const w_choices = [
        Constants.USER_MESSAGES.YES,
        Constants.USER_MESSAGES.NO
        // Note: Already shows a 'cancel' !
    ];
    if (yes_all) {
        w_choices.push(Constants.USER_MESSAGES.YES_ALL,);
    }
    if (no_all) {
        w_choices.push(Constants.USER_MESSAGES.NO_ALL,);
    }

    return vscode.window
        .showInformationMessage(
            title,
            {
                modal: true,
                detail: message
            },
            ...w_choices
        )
        .then((answer) =&gt; {
            if (answer === Constants.USER_MESSAGES.YES) {
                return Constants.USER_MESSAGES.YES.toLowerCase();
            } else if (answer === Constants.USER_MESSAGES.NO) {
                return Constants.USER_MESSAGES.NO.toLowerCase();
            } else if (answer === Constants.USER_MESSAGES.YES_ALL) {
                return "yes-all";
            } else { // (answer === Constants.USER_MESSAGES.NO_ALL)
                return "no-all";
            }
        });
}

</t>
<t tx="felix.20220128232146.1"></t>
<t tx="felix.20220131234257.1">/**
 * * Sets the leoID setting for immediate use, and in next activation
 */
public setIdSetting(p_leoID: string): Promise&lt;unknown&gt; {
    const w_changes: ConfigSetting[] = [{
        code: "leoID",
        value: p_leoID
    }];
    g.app.leoID = p_leoID;
    if (g.app.nodeIndices) {
        g.app.nodeIndices.defaultId = p_leoID;
        g.app.nodeIndices.userId = p_leoID;
    }
    return this.config.setLeojsSettings(w_changes);
}

</t>
<t tx="felix.20220131235418.1">/**
 * * Returns the leoID from the leojs settings
 */
public getIdFromSetting(): string {
    return this.config.leoID;
}

</t>
<t tx="felix.20220201194319.1">/**
 * * Command to get the LeoID from dialog, save it to user settings.
 * Start leojs if the ID is valid, and not already started.
 */
public setLeoIDCommand(): Thenable&lt;unknown&gt; {
    return utils.getIdFromDialog().then((p_id) =&gt; {
        p_id = p_id.trim();
        p_id = g.app.cleanLeoID(p_id, '');
        if (p_id &amp;&amp; p_id.length &gt;= 3 &amp;&amp; utils.isAlphaNumeric(p_id)) {
            // valid id: set in config settings
            return this.setIdSetting(p_id);
        } else {
            // Canceled or invalid: (re)warn user.
            this.showLeoIDMessage();
        }
    });
}

</t>
<t tx="felix.20220201195806.1">export function isAlphaNumeric(str: string): boolean {
    let code: number;
    let i: number;
    let len: number;
    for (i = 0, len = str.length; i &lt; len; i++) {
        code = str.charCodeAt(i);
        if (!(code &gt; 47 &amp;&amp; code &lt; 58) &amp;&amp; // numeric (0-9)
            !(code &gt; 64 &amp;&amp; code &lt; 91) &amp;&amp; // upper alpha (A-Z)
            !(code &gt; 96 &amp;&amp; code &lt; 123) // lower alpha (a-z)
        ) {
            return false;
        }
    }
    return true;
};
</t>
<t tx="felix.20220201225503.1">public ensure_commander_visible(c: Commands): void {
    this.showBodyIfClosed = true;
    this.showOutlineIfClosed = true;
}

</t>
<t tx="felix.20220201230041.1">/**
 * Show info window about requiring leoID to start
 * and a button to perform the 'set leoID' command.
 */
public showLeoIDMessage(): void {
    void vscode.window.showInformationMessage(
        Constants.USER_MESSAGES.SET_LEO_ID_MESSAGE,
        Constants.USER_MESSAGES.ENTER_LEO_ID
    ).then(p_chosenButton =&gt; {
        if (p_chosenButton === Constants.USER_MESSAGES.ENTER_LEO_ID) {
            void vscode.commands.executeCommand(Constants.COMMANDS.SET_LEO_ID);
        }
    });
}

</t>
<t tx="felix.20220201235548.1">/**
 * * Set all remaining local objects, set ready flag(s) and refresh all panels
 */
public finishStartup(): void {
    g.app.windowList[this.frameIndex].startupWindow = true;

    // * Create Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this.leoStates, this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._context.subscriptions.push(
        this._leoDocuments,
        this._leoDocuments.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._context.subscriptions.push(
        this._leoDocumentsExplorer,
        this._leoDocumentsExplorer.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoDocuments = this._leoDocumentsExplorer;

    // * Create '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this.leoStates, this.buttonIcons);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._context.subscriptions.push(
        this._leoButtons,
        this._leoButtons.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._context.subscriptions.push(
        this._leoButtonsExplorer,
        this._leoButtonsExplorer.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoButtons = this._leoButtonsExplorer;

    // * Create goto Treeview Providers and tree views
    this._leoGotoProvider = new LeoGotoProvider(this);
    this._leoGoto = vscode.window.createTreeView(Constants.GOTO_ID, { showCollapseAll: false, treeDataProvider: this._leoGotoProvider });
    this._context.subscriptions.push(
        this._leoGoto,
        this._leoGoto.onDidChangeVisibility((p_event) =&gt;
            this._onGotoTreeViewVisibilityChanged(p_event, false)
        )
    );
    this._leoGotoExplorer = vscode.window.createTreeView(Constants.GOTO_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoGotoProvider });
    this._context.subscriptions.push(
        this._leoGotoExplorer,
        this._leoGotoExplorer.onDidChangeVisibility((p_event) =&gt;
            this._onGotoTreeViewVisibilityChanged(p_event, true)
        )
    );

    // * Create Undos Treeview Providers and tree views
    this._leoUndosProvider = new LeoUndosProvider(this.leoStates, this, this.undoIcons);
    this._leoUndos = vscode.window.createTreeView(Constants.UNDOS_ID, { showCollapseAll: false, treeDataProvider: this._leoUndosProvider });
    this._context.subscriptions.push(
        this._leoUndos,
        this._leoUndos.onDidChangeVisibility((p_event =&gt; this._onUndosTreeViewVisibilityChanged(p_event, false)))
    );
    this._leoUndosExplorer = vscode.window.createTreeView(Constants.UNDOS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoUndosProvider });
    this._context.subscriptions.push(
        this._leoUndosExplorer,
        this._leoUndosExplorer.onDidChangeVisibility((p_event =&gt; this._onUndosTreeViewVisibilityChanged(p_event, true)))
    );
    this._lastLeoUndos = this._leoUndosExplorer;

    // * Create Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);

    this._bodyMainSelectionColumn = 1;

    // * Create Status bar Entry
    // this._leoStatusBar = new LeoStatusBar(_context, this);

    // * Leo Find Panel
    this._leoFindPanelProvider = new LeoFindPanelProvider(
        this._context.extensionUri,
        this._context,
        this
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        ),
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_EXPLORER_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );

    // * 'onDid' event detections all pushed as disposables in context.subscription
    this._context.subscriptions.push(
        // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
        vscode.window.onDidChangeActiveTextEditor((p_editor) =&gt;
            this._onActiveEditorChanged(p_editor)
        ),

        // * React to change in selection, cursor position and scroll position
        vscode.window.onDidChangeTextEditorSelection((p_event) =&gt;
            this._onChangeEditorSelection(p_event)
        ),
        vscode.window.onDidChangeTextEditorVisibleRanges((p_event) =&gt;
            this._onChangeEditorScroll(p_event)
        ),

        // * Triggers when a different text editor/vscode window changed focus or visibility, or dragged
        // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
        vscode.window.onDidChangeTextEditorViewColumn((p_columnChangeEvent) =&gt;
            this._changedTextEditorViewColumn(p_columnChangeEvent)
        ), // Also triggers after drag and drop
        vscode.window.onDidChangeVisibleTextEditors((p_editors) =&gt;
            this._changedVisibleTextEditors(p_editors)
        ), // Window.visibleTextEditors changed
        vscode.window.onDidChangeWindowState((p_windowState) =&gt;
            this._changedWindowState(p_windowState)
        ), // Focus state of the current window changes

        // * React when typing and changing body pane
        vscode.workspace.onDidChangeTextDocument((p_textDocumentChange) =&gt;
            this._onDocumentChanged(p_textDocumentChange)
        ),

        // * React to configuration settings events
        vscode.workspace.onDidChangeConfiguration((p_configChange) =&gt;
            this._onChangeConfiguration(p_configChange)
        ),

        // * React to opening of any file in vscode
        vscode.workspace.onDidOpenTextDocument((p_document) =&gt;
            this._onDidOpenTextDocument(p_document)
        )
    );

    this._setupOpenedLeoDocument(); // this sets this.leoStates.fileOpenedReady

    this.leoStates.leoReady = true;
    this.leoStates.leojsStartupDone = true;

}

</t>
<t tx="felix.20220417151556.1">export function getIdFromDialog(): Thenable&lt;string&gt; {
    return vscode.window.showInputBox({
        title: Constants.USER_MESSAGES.ENTER_LEO_ID,
        prompt: Constants.USER_MESSAGES.GET_LEO_ID_PROMPT

    }).then((p_id) =&gt; {
        if (p_id) {
            return p_id;
        }
        return '';
    });
}

</t>
<t tx="felix.20220417155704.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { Position } from "./core/leoNodes";
import { LeoButtonNode } from "./leoButtons";
import { LeoGotoNode } from "./leoGoto";
import { LeoOutlineNode } from "./leoOutline";
import { LeoUI } from "./leoUI";
import { LeoUndoNode } from "./leoUndos";
import { ReqRefresh, Focus, LeoGotoNavKey } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20220417155732.1">/**
 * * Make all command/key bindings 
 */
export function makeAllBindings(p_leoUI: LeoUI, p_context: vscode.ExtensionContext): void {
    // Shortcut pointers for readability
    const U = undefined;
    const CMD = Constants.COMMANDS;
    const LEOCMD = Constants.LEO_COMMANDS;

    const NO_REFRESH: ReqRefresh = {};
    const REFRESH_NODE_BODY: ReqRefresh = {
        node: true, // Reveal the returned 'selected position' without changes to the tree
        body: true, // Goto/select another node needs the body pane refreshed
        states: true
    };
    const REFRESH_TREE: ReqRefresh = {
        tree: true,
        states: true
    };
    const REFRESH_TREE_BODY: ReqRefresh = {
        tree: true,
        body: true,
        states: true
    };
    const REFRESH_ALL: ReqRefresh = {
        tree: true,
        body: true,
        states: true,
        documents: true,
        buttons: true
    };

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        &lt;&lt; Define entries for all commands &gt;&gt;
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });
}

</t>
<t tx="felix.20220417215549.1">/**
 * Make all key and commands bindings
 */
public makeAllBindings(): void {
    commandBindings.makeAllBindings(this, this._context);
}

</t>
<t tx="felix.20220505215916.1"></t>
<t tx="felix.20220505215916.2">/**
 * Opens the Nav tab and focus on nav text input
 */
public findQuick(p_string?: string): Thenable&lt;unknown&gt; {
    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    return vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        const w_message: { [key: string]: string } = { type: 'selectNav' };
        if (p_string &amp;&amp; p_string?.trim()) {
            w_message["text"] = p_string.trim();
        }
        void w_panel?.webview.postMessage(w_message);
    });
}

</t>
<t tx="felix.20220505215916.3">/**
 * Opens the Nav tab with the selected text as the search string
 */
public findQuickSelected(): Thenable&lt;unknown&gt; {
    if (vscode.window.activeTextEditor) {
        const editor = vscode.window.activeTextEditor;
        const selection = editor.selection;
        if (!selection.isEmpty) {
            const text = editor.document.getText(selection);
            return this.findQuick(text);
        }
    }
    return this.findQuick();
}

</t>
<t tx="felix.20220505215916.4">/**
 * Lists all nodes in reversed gnx order, newest to oldest
 */
public findQuickTimeline(): Thenable&lt;unknown&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;
    scon.qsc_sort_by_gnx();
    this._leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane(); // Finish by opening and focussing nav pane
}

</t>
<t tx="felix.20220505215916.5">/**
 * Lists all nodes that are changed (aka "dirty") since last save.
 */
public findQuickChanged(): Thenable&lt;unknown&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;
    scon.qsc_find_changed();
    this._leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane(); // Finish by opening and focussing nav pane
}

</t>
<t tx="felix.20220505215916.6">/**
 * Lists nodes from c.nodeHistory.
 */
public findQuickHistory(): Thenable&lt;unknown&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;
    scon.qsc_get_history();
    this._leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane(); // Finish by opening and focussing nav pane
}

</t>
<t tx="felix.20220505215916.7">/**
 * List all marked nodes.
 */
public findQuickMarked(p_preserveFocus?: boolean): Thenable&lt;unknown&gt; {
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;
    scon.qsc_show_marked();
    this._leoGotoProvider.refreshTreeRoot();
    if (p_preserveFocus &amp;&amp; (this._leoGoto.visible || this._leoGotoExplorer.visible)) {
        return Promise.resolve();
    }
    return this.showGotoPane(); // Finish by opening and focussing nav pane
}

</t>
<t tx="felix.20220505215916.8">/**
 * Opens goto and focus in depending on passed options
 */
public showGotoPane(p_options?: { preserveFocus?: boolean }): Thenable&lt;unknown&gt; {
    let w_panel = "";

    if (this._lastTreeView === this._leoTreeExView) {
        w_panel = Constants.GOTO_EXPLORER_ID;
    } else {
        w_panel = Constants.GOTO_ID;
    }

    void vscode.commands.executeCommand(w_panel + '.focus', p_options);

    return Promise.resolve();
}

</t>
<t tx="felix.20220505215916.9">/**
 * * Handles a click (selection) of a nav panel node: Sends 'goto' command to server.
 */
public async gotoNavEntry(p_node: LeoGotoNode): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    this._leoGotoProvider.resetSelectedNode(p_node); // Inform controller of last index chosen
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;

    if (p_node.entryType === 'tag') {
        // * For when the nav input IS CLEARED : GOTO PANE LISTS ALL TAGS!
        // The node clicked was one of the tags, pre-fill the nac search with this tag and open find pane
        let w_string: string = p_node.label as string;

        let w_panelID = '';
        let w_panel: vscode.WebviewView | undefined;
        if (this._lastTreeView === this._leoTreeExView) {
            w_panelID = Constants.FIND_EXPLORER_ID;
            w_panel = this._findPanelWebviewExplorerView;
        } else {
            w_panelID = Constants.FIND_ID;
            w_panel = this._findPanelWebviewView;
        }
        await vscode.commands.executeCommand(w_panelID + '.focus');

        if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
            w_panel = this._findPanelWebviewView;
        } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
            w_panel = this._findPanelWebviewExplorerView;
        }

        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        const w_message: { [key: string]: string; } = { type: 'selectNav' };
        if (w_string &amp;&amp; w_string.trim()) {
            w_message["text"] = w_string.trim();
        }
        await w_panel!.webview.postMessage(w_message);
        // Do search

        setTimeout(() =&gt; {
            const inp = scon.navText;
            if (scon.isTag) {
                scon.qsc_find_tags(inp);
            } else {
                scon.qsc_search(inp);
            }
            this._leoGotoProvider.refreshTreeRoot();
            void this.showGotoPane({ preserveFocus: true }); // show but dont change focus
        }, 10);

    } else if (p_node.entryType !== 'generic' &amp;&amp; p_node.entryType !== 'parent') {
        // Other and not a tag so just locate the entry in either body or outline
        // const p_navEntryResult = await this.sendAction(
        //     Constants.LEOBRIDGE.GOTO_NAV_ENTRY,
        //     { key: p_node.key }
        // );

        const it = p_node.key;
        scon.onSelectItem(it);

        let w_focus = this._get_focus();

        if (!w_focus) {
            return vscode.window.showInformationMessage('Not found');
        } else {
            let w_revealTarget = Focus.Body;
            w_focus = w_focus.toLowerCase();

            if (w_focus.includes('tree') || w_focus.includes('head')) {
                // tree
                w_revealTarget = Focus.Outline;
                this.showOutlineIfClosed = true;
            } else {
                this.showBodyIfClosed = true;
            }

            this.setupRefresh(
                // ! KEEP FOCUS ON GOTO PANE !
                Focus.Goto,
                {
                    tree: true,
                    body: true,
                    scroll: w_revealTarget === Focus.Body,
                    // documents: false,
                    // buttons: false,
                    states: true,
                }
            );
            return this.launchRefresh();
        }
    }

}
</t>
<t tx="felix.20220505215924.1"></t>
<t tx="felix.20220505215924.12">/**
 * * Set search setting in the search webview
 * @param p_id string id of the setting name
 */
public setSearchSetting(p_id: string): void {
    if (this._findPanelWebviewExplorerView) {
        void this._findPanelWebviewExplorerView!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
    }
    if (this._findPanelWebviewView) {
        void this._findPanelWebviewView!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
    }
}

</t>
<t tx="felix.20220505215924.13">/**
 * * Gets the search settings from Leo, and applies them to the find panel webviews
 */
public loadSearchSettings(): void {

    if (!g.app.windowList.length || !g.app.windowList[this.frameIndex]) {
        return;
    }
    const c = g.app.windowList[this.frameIndex].c;
    const scon = c.quicksearchController;
    const leoISettings = c.findCommands.ftm.get_settings();
    const w_settings: LeoSearchSettings = {
        // Nav options
        navText: scon.navText,
        showParents: scon.showParents,
        isTag: scon.isTag,
        searchOptions: scon.searchOptions,
        //Find/change strings...
        findText: leoISettings.find_text,
        replaceText: leoISettings.change_text,
        // Find options...
        ignoreCase: leoISettings.ignore_case,
        markChanges: leoISettings.mark_changes,
        markFinds: leoISettings.mark_finds,
        wholeWord: leoISettings.whole_word,
        regExp: leoISettings.pattern_match,
        searchHeadline: leoISettings.search_headline,
        searchBody: leoISettings.search_body,
        // 0, 1 or 2 for outline, sub-outline, or node.
        searchScope:
            0 +
            (leoISettings.suboutline_only ? 1 : 0) +
            (leoISettings.node_only ? 2 : 0) +
            (leoISettings.file_only ? 3 : 0),
    };
    if (w_settings.searchScope &gt; 2) {
        console.error('searchScope SHOULD BE 0, 1, 2 only: ', w_settings.searchScope);
    }
    this._lastSettingsUsed = w_settings;
    if (this._findPanelWebviewExplorerView) {
        void this._findPanelWebviewExplorerView.webview.postMessage({
            type: 'setSettings',
            value: w_settings,
        });
    }
    if (this._findPanelWebviewView) {
        void this._findPanelWebviewView.webview.postMessage({
            type: 'setSettings',
            value: w_settings,
        });
    }

}

</t>
<t tx="felix.20220505215924.14">/**
 * * Send the settings to Leo implementation
 * @param p_settings the search settings to be set in Leo implementation to affect next results
 * @returns
 */
public saveSearchSettings(p_settings: LeoSearchSettings): Thenable&lt;unknown&gt; {

    if (!g.app.windowList.length || !g.app.windowList[this.frameIndex]) {
        return Promise.resolve();
    }

    this._lastSettingsUsed = p_settings;
    // convert to LeoGuiFindTabManagerSettings
    const searchSettings: LeoGuiFindTabManagerSettings = {
        // Nav settings
        is_tag: p_settings.isTag,
        nav_text: p_settings.navText,
        show_parents: p_settings.showParents,
        search_options: p_settings.searchOptions,
        // Find/change strings...
        find_text: p_settings.findText,
        change_text: p_settings.replaceText,
        // Find options...
        ignore_case: p_settings.ignoreCase,
        mark_changes: p_settings.markChanges,
        mark_finds: p_settings.markFinds,
        node_only: !!(p_settings.searchScope === 2),
        file_only: !!(p_settings.searchScope === 3),
        pattern_match: p_settings.regExp,
        search_body: p_settings.searchBody,
        search_headline: p_settings.searchHeadline,
        suboutline_only: !!(p_settings.searchScope === 1),
        whole_word: p_settings.wholeWord,
    };

    // Sets search options. Init widgets and ivars from param.searchSettings
    const c = g.app.windowList[this.frameIndex].c;
    const scon = c.quicksearchController;
    const find = c.findCommands;
    const ftm = c.findCommands.ftm;

    // * Try to set the search settings
    // nav settings
    scon.navText = searchSettings.nav_text;
    scon.showParents = searchSettings.show_parents;
    scon.isTag = searchSettings.is_tag;
    scon.searchOptions = searchSettings.search_options;

    // Find/change text boxes.
    const table: [string, string, string][] = [
        ['find_findbox', 'find_text', ''],
        ['find_replacebox', 'change_text', ''],
    ];
    for (let [widget_ivar, setting_name, w_default] of table) {
        const w = ftm[widget_ivar as keyof StringFindTabManager]; // getattr(ftm, widget_ivar)
        const s = searchSettings[setting_name as keyof LeoGuiFindTabManagerSettings] || w_default;
        w.clear();
        w.insert(s);
    }

    // Check boxes.
    const table2: [string, string][] = [
        ['ignore_case', 'check_box_ignore_case'],
        ['mark_changes', 'check_box_mark_changes'],
        ['mark_finds', 'check_box_mark_finds'],
        ['pattern_match', 'check_box_regexp'],
        ['search_body', 'check_box_search_body'],
        ['search_headline', 'check_box_search_headline'],
        ['whole_word', 'check_box_whole_word'],
    ];
    for (let [setting_name, widget_ivar] of table2) {
        const w = ftm[widget_ivar as keyof StringFindTabManager]; // getattr(ftm, widget_ivar)
        const val = searchSettings[setting_name as keyof LeoGuiFindTabManagerSettings];
        (find as any)[setting_name as keyof LeoFind] = val;
        if (val !== w.isChecked()) {
            w.toggle();
        }
    }

    // Radio buttons
    const table3: [string, string, string][] = [
        ['node_only', 'node_only', 'radio_button_node_only'],
        ['file_only', 'file_only', 'radio_button_file_only'],
        ['entire_outline', "", 'radio_button_entire_outline'],
        ['suboutline_only', 'suboutline_only', 'radio_button_suboutline_only'],
    ];
    for (let [setting_name, ivar, widget_ivar] of table3) {
        const w = ftm[widget_ivar as keyof StringFindTabManager]; // getattr(ftm, widget_ivar)
        const val = searchSettings[setting_name as keyof LeoGuiFindTabManagerSettings] || false;

        if (ivar) {
            // assert hasattr(find, setting_name), setting_name

            // setattr(find, setting_name, val)
            (find as any)[setting_name as keyof LeoFind] = val;

            if (val !== w.isChecked()) {
                w.toggle();
            }
        }
    }

    // Ensure one radio button is set.
    const w = ftm.radio_button_entire_outline;
    const nodeOnly = searchSettings.node_only || false;
    const fileOnly = searchSettings.file_only || false;
    const suboutlineOnly = searchSettings.suboutline_only || false;

    if (!nodeOnly &amp;&amp; !suboutlineOnly &amp;&amp; !fileOnly) {
        find.entire_outline = true;
        if (!w.isChecked()) {
            w.toggle();
        }
    } else {
        find.entire_outline = false;
        if (w.isChecked()) {
            w.toggle();
        }
    }

    return Promise.resolve();
}

</t>
<t tx="felix.20220505215924.2">/**
 * * Handles an enter press in the 'nav pattern' input
 */
public async navEnter(): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;

    const inp = scon.navText;
    if (scon.isTag) {
        scon.qsc_find_tags(inp);
    } else {
        scon.qsc_search(inp);
    }

    this._leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane({ preserveFocus: true }); // show but dont change focus

}

</t>
<t tx="felix.20220505215924.3">/**
 * * Handles a debounced text change in the nav pattern input box
 */
public async navTextChange(): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;

    const inp = scon.navText;
    if (scon.isTag) {
        scon.qsc_find_tags(inp);
    } else {
        const exp = inp.replace(/ /g, '*');
        scon.qsc_background_search(exp);
    }
    this._leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane({ preserveFocus: true }); // show but dont change focus
}

</t>
<t tx="felix.20220505215924.4">/**
 * * Opens the find panel and selects all &amp; focuses on the find field.
 */
public startSearch(): void {

    // already instantiated &amp; shown ?
    let w_panel: vscode.WebviewView | undefined;

    if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
        w_panel = this._findPanelWebviewView;
    } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
        w_panel = this._findPanelWebviewExplorerView;
    }

    if (w_panel) {
        // ALREADY VISIBLE FIND PANEL
        this._findNeedsFocus = false;
        void w_panel.webview.postMessage({ type: 'selectFind' });
        return;
    }

    this._findNeedsFocus = true;
    let w_panelID = '';
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
    } else {
        w_panelID = Constants.FIND_ID;
    }
    void vscode.commands.executeCommand(w_panelID + '.focus');

}

</t>
<t tx="felix.20220505215924.6">/**
 * * Get a find pattern string input from the user
 * @param p_replace flag for doing a 'replace' instead of a 'find'
 * @returns Promise of string or undefined if cancelled
 */
private _inputFindPattern(p_replace?: boolean, p_value?: string): Thenable&lt;string | undefined&gt; {
    let w_title, w_prompt, w_placeHolder;
    w_title = p_replace ? Constants.USER_MESSAGES.REPLACE_TITLE : Constants.USER_MESSAGES.SEARCH_TITLE;
    w_prompt = p_replace ? Constants.USER_MESSAGES.REPLACE_PROMPT : Constants.USER_MESSAGES.SEARCH_PROMPT;
    w_placeHolder = p_replace ? Constants.USER_MESSAGES.REPLACE_PLACEHOLDER : Constants.USER_MESSAGES.SEARCH_PLACEHOLDER;
    return vscode.window.showInputBox({
        title: w_title,
        prompt: w_prompt,
        value: p_value,
        placeHolder: w_placeHolder,
    });
}

</t>
<t tx="felix.20220505215924.7">/**
 * * Find next / previous commands
 * @param p_fromOutline
 * @param p_reverse
 * @returns Promise that resolves when the "launch refresh" is started
 */
public async find(p_fromOutline: boolean, p_reverse: boolean): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    let found;
    let focus;

    const c = g.app.windowList[this.frameIndex].c;
    const fc = c.findCommands;
    let p: Position | undefined = c.p;

    const fromOutline = p_fromOutline;
    const fromBody = !fromOutline;

    let w = this.get_focus(c);
    focus = this.widget_name(w);

    const inOutline = (focus.includes("tree")) || (focus.includes("head"));
    const inBody = !inOutline;

    if (fromOutline &amp;&amp; inBody) {
        fc.in_headline = true;
    } else if (fromBody &amp;&amp; inOutline) {
        fc.in_headline = false;
        c.bodyWantsFocus();
        c.bodyWantsFocusNow();
    }

    let pos, newpos, settings;
    settings = fc.ftm.get_settings();
    if (p_reverse) {
        [p, pos, newpos] = fc.do_find_prev(settings);
    } else {
        [p, pos, newpos] = fc.do_find_next(settings);
    }

    w = this.get_focus(c); // get focus again after the operation
    focus = this.widget_name(w);
    found = p &amp;&amp; p.__bool__();

    this.findFocusTree = false; // Reset flag for headline range

    if (!found || !focus) {
        return vscode.window.showInformationMessage('Not found');
    } else {
        let w_finalFocus = Focus.Body;
        const w_focus = focus.toLowerCase();
        if (w_focus.includes('tree') || w_focus.includes('head')) {
            // tree
            w_finalFocus = Focus.Outline;
            this.showOutlineIfClosed = true;
            // * SETUP HEADLINE RANGE
            this.findFocusTree = true;
            this.findHeadlineRange = [w.sel[0], w.sel[1]];
            this.findHeadlinePosition = c.p;
        } else {
            this.showBodyIfClosed = true;
        }
        const w_scroll = (found &amp;&amp; w_finalFocus === Focus.Body) || undefined;

        this.setupRefresh(
            w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
            {
                tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
                body: true,
                scroll: w_scroll,
                // documents: false,
                // buttons: false,
                states: true,
            },
            this.findFocusTree
        );
        return this.launchRefresh();
    }
}

</t>
<t tx="felix.20220505215924.8">/**
 * * find-var or find-def commands
 * @param p_def find-def instead of find-var
 * @returns Promise that resolves when the "launch refresh" is started
 */
public async findSymbol(p_def: boolean): Promise&lt;unknown&gt; {

    // This sets the selection on a word in the body pane. (needs selection on a symbol word in vscode word)
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;
    const fc = c.findCommands;

    if (p_def) {
        fc.find_def();
    } else {
        fc.find_var();
    }

    let found = true;

    const focus = this._get_focus();

    if (!found || !focus) {
        return vscode.window.showInformationMessage('Not found');
    } else {
        let w_finalFocus = Focus.Body;
        const w_focus = focus.toLowerCase();
        if (w_focus.includes('tree') || w_focus.includes('head')) {
            // tree
            w_finalFocus = Focus.Outline;
        }
        this.loadSearchSettings();
        this.setupRefresh(
            w_finalFocus,
            {
                tree: true,
                body: true,
                scroll: found &amp;&amp; w_finalFocus === Focus.Body,
                // documents: false,
                // buttons: false,
                states: true,
            });
        return this.launchRefresh();
    }

}

</t>
<t tx="felix.20220505215924.9">/**
 * * Replace / Replace-Then-Find commands
 * @param p_fromOutline
 * @param p_thenFind
 * @returns Promise that resolves when the "launch refresh" is started
 */
public async replace(p_fromOutline?: boolean, p_thenFind?: boolean): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    let found;
    let focus;

    const c = g.app.windowList[this.frameIndex].c;
    const fc = c.findCommands;

    const fromOutline = p_fromOutline;
    const fromBody = !fromOutline;

    let w = this.get_focus(c);
    focus = this.widget_name(w);

    const inOutline = (focus.includes("tree")) || (focus.includes("head"));
    const inBody = !inOutline;

    if (fromOutline &amp;&amp; inBody) {
        fc.in_headline = true;
    } else if (fromBody &amp;&amp; inOutline) {
        fc.in_headline = false;
        c.bodyWantsFocus();
        c.bodyWantsFocusNow();
    }

    found = false;

    const settings = fc.ftm.get_settings();
    fc.init_ivars_from_settings(settings); // ? Needed for fc.change_selection

    fc.check_args('replace');
    if (p_thenFind) {
        found = fc.do_change_then_find(settings);
    } else {
        fc.change_selection(c.p);
        found = true;
    }

    w = this.get_focus(c); // get focus again after the operation
    focus = this.widget_name(w);

    this.findFocusTree = false; // Reset flag for headline range

    if (!found || !focus) {
        void vscode.window.showInformationMessage('Not found'); // Flag not found/replaced!
    }
    if (focus) {
        let w_finalFocus = Focus.Body;
        const w_focus = focus.toLowerCase();
        if (w_focus.includes('tree') || w_focus.includes('head')) {
            // tree
            w_finalFocus = Focus.Outline;
            this.showOutlineIfClosed = true;
            // * SETUP HEADLINE RANGE
            this.findFocusTree = true;
            this.findHeadlineRange = [w.sel[0], w.sel[1]];
            this.findHeadlinePosition = c.p;
        } else {
            this.showBodyIfClosed = true;
        }
        const w_scroll = (found &amp;&amp; w_finalFocus === Focus.Body) || undefined;

        this.setupRefresh(
            w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
            {
                tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
                body: true,
                scroll: w_scroll,
                // documents: false,
                // buttons: false,
                states: true,
            },
            this.findFocusTree
        );
        return this.launchRefresh();
    }

}

</t>
<t tx="felix.20220505220527.1">export type TGotoTypes = "tag" | "headline" | "body" | "parent" | "generic";

</t>
<t tx="felix.20220505220532.1">export interface LeoGoto {
    key: number; // id from python
    h: string;
    t: TGotoTypes;
}

</t>
<t tx="felix.20220505220537.1">/**
 * * Enum type for the search scope radio buttons of the find panel.
 */
export const enum LeoSearchScope {
    entireOutline = 0,
    subOutlineOnly,
    nodeOnly,
    fileOnly
}

</t>
<t tx="felix.20220505220544.1">/**
 * * Search settings structure for use with the 'find' webview
 */
export interface LeoSearchSettings {
    // Nav options
    navText: string;
    isTag: boolean;
    showParents: boolean;
    searchOptions: number;
    // Find/change strings...
    findText: string;  // find_text
    replaceText: string; // change_text
    // Find options...
    wholeWord: boolean;
    ignoreCase: boolean;
    regExp: boolean;
    markFinds: boolean;
    markChanges: boolean;
    searchHeadline: boolean;
    searchBody: boolean;
    searchScope: LeoSearchScope; // 0, 1 or 2 for outline, sub-outline, or node.
}

</t>
<t tx="felix.20220505220550.1">/**
 * * Leo's GUI search settings internal structure
 */
export interface LeoGuiFindTabManagerSettings {
    // Nav options
    nav_text: string;
    is_tag: boolean;
    show_parents: boolean;
    search_options: number;
    //Find/change strings...
    find_text: string,
    change_text: string,
    // Find options...
    ignore_case: boolean,
    mark_changes: boolean,
    mark_finds: boolean,
    node_only: boolean,
    file_only: boolean,
    pattern_match: boolean,
    search_body: boolean,
    search_headline: boolean,
    suboutline_only: boolean,
    whole_word: boolean
}

</t>
<t tx="felix.20220505220619.1">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20220505220626.1">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20220505220630.1">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    // ! TEST scroll as single number only (for Leo vertical scroll value)
    scroll: number;
    // scroll: {
    //     start: BodyPosition;
    //     end: BodyPosition;
    // }
    insert: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20220505220706.1">/**
 * * Used to select a button's rclick by index
 */
export interface ChooseRClickItem extends vscode.QuickPickItem {
    index: number;
    rclick?: RClick;
}

</t>
<t tx="felix.20220505221929.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as g from './core/leoGlobals';
import { QuickSearchController } from "./core/quicksearch";
import { LeoUI } from "./leoUI";
import { LeoGoto, LeoGotoNavKey, TGotoTypes } from "./types";
import * as utils from "./utils";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20220505222045.1">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoGotoProvider implements vscode.TreeDataProvider&lt;LeoGotoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoGotoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoGotoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoGotoNode | undefined&gt; = this._onDidChangeTreeData.event;

    private _lastGotoView: vscode.TreeView&lt;LeoGotoNode&gt; | undefined;

    private _nodeList: LeoGotoNode[] = []; // Node list kept here.

    private _selectedNodeIndex: number = 0;

    constructor(private _leoUI: LeoUI) { }

    public setLastGotoView(p_view: vscode.TreeView&lt;LeoGotoNode&gt;): void {
        this._lastGotoView = p_view;
    }

    public resetSelectedNode(p_node?: LeoGotoNode): void {
        this._selectedNodeIndex = 0;
        if (p_node) {
            const w_found = this._nodeList.indexOf(p_node);
            if (w_found &gt;= 0) {
                this._selectedNodeIndex = w_found;
            }
        }
    }

    public async navigateNavEntry(p_nav: LeoGotoNavKey): Promise&lt;void&gt; {
        if (!this._nodeList.length) {
            return;
        }
        switch (p_nav.valueOf()) {
            case LeoGotoNavKey.first:
                this._selectedNodeIndex = 0;
                break;

            case LeoGotoNavKey.last:
                this._selectedNodeIndex = this._nodeList.length - 1;
                break;

            case LeoGotoNavKey.next:
                if (this._selectedNodeIndex &lt; this._nodeList.length - 1) {
                    this._selectedNodeIndex += 1;
                }
                break;

            case LeoGotoNavKey.prev:
                if (this._selectedNodeIndex &gt; 0) {
                    this._selectedNodeIndex -= 1;
                }
                break;

        }
        await this._leoUI.gotoNavEntry(this._nodeList[this._selectedNodeIndex]);
        await this._lastGotoView?.reveal(this._nodeList[this._selectedNodeIndex], {
            select: true,
            focus: true
        });
    }

    /**
     * * Refresh the whole outline
     */
    public refreshTreeRoot(): void {
        this._nodeList = [];
        this._selectedNodeIndex = 0;
        this._onDidChangeTreeData.fire(undefined);
    }

    public getTreeItem(element: LeoGotoNode): Thenable&lt;LeoGotoNode&gt; | LeoGotoNode {
        return element;
    }

    public getChildren(element?: LeoGotoNode): Thenable&lt;LeoGotoNode[]&gt; {

        // if called with element, or not ready, give back empty array as there won't be any children
        if (this._leoUI.leoStates.fileOpenedReady &amp;&amp; !element) {

            const c = g.app.windowList[this._leoUI.frameIndex].c;
            const scon: QuickSearchController = c.quicksearchController;

            const result: { [key: string]: any } = {};

            const navlist: LeoGoto[] = [];
            for (let k = 0; k &lt; scon.its.length; k++) {
                navlist.push(
                    {
                        "key": k,
                        "h": scon.its[k][0]["label"],
                        "t": scon.its[k][0]["type"] as TGotoTypes
                    }
                );
            }

            result["navList"] = navlist;
            result["messages"] = scon.lw;
            result["navText"] = scon.navText;
            result["navOptions"] = { "isTag": scon.isTag, "showParents": scon.showParents };

            this._nodeList = [];
            if (result &amp;&amp; result.navList) {

                const w_navList: LeoGoto[] = result.navList;
                if (w_navList &amp;&amp; w_navList.length) {
                    w_navList.forEach((p_goto: LeoGoto) =&gt; {
                        const w_newNode = new LeoGotoNode(this._leoUI, p_goto, result.navOptions!);
                        this._nodeList.push(w_newNode);
                    });
                }
                return Promise.resolve(this._nodeList);
            } else {
                return Promise.resolve([]);
            }

        } else {
            return Promise.resolve([]); // Defaults to an empty list of children
        }
    }

    public getParent(element: LeoGotoNode): vscode.ProviderResult&lt;LeoGotoNode&gt; | null {
        // Leo documents are just a list, as such, entries are always child of root, so return null
        return null;
    }

}
</t>
<t tx="felix.20220505222101.1">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoGotoNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public entryType: TGotoTypes;
    private _id: string;
    private _description: string | boolean;
    private _headline: string;
    private _iconIndex: number; // default to tag
    private _leoUI: LeoUI;
    public key: number; // id from python

    constructor(
        p_leoUI: LeoUI,
        p_gotoEntry: LeoGoto,
        p_navOptions: { isTag: boolean, showParents: boolean },

    ) {
        let w_spacing = "";
        if (p_navOptions.showParents &amp;&amp; !p_navOptions.isTag) {
            w_spacing = "    ";
        }
        let w_label = "";
        if (["tag", "headline"].includes(p_gotoEntry.t)) {
            w_label = w_spacing + p_gotoEntry.h;
        }
        super(w_label);

        // Setup this instance
        this._leoUI = p_leoUI;
        this._id = utils.getUniqueId();
        this.entryType = p_gotoEntry.t;
        this.key = p_gotoEntry.key;
        this._headline = p_gotoEntry.h.trim();

        this._description = false;
        if (this.entryType === 'body') {
            this._iconIndex = 2;
            if (p_navOptions.showParents) {
                this._description = "    " + this._headline;
            } else {
                this._description = "  " + this._headline;
            }
        } else if (this.entryType === 'parent') {
            this._iconIndex = 0;
            this._description = this._headline.trim();
        } else if (this.entryType === 'generic') {
            this._iconIndex = 4;
            this._description = this._headline;
        } else if (this.entryType === 'headline') {
            this._iconIndex = 1;
        } else {
            this._iconIndex = 3; // tag
        }

        this.command = {
            command: Constants.COMMANDS.GOTO_NAV_ENTRY,
            title: '',
            arguments: [this]
        };

    }

    // @ts-ignore
    public get tooltip(): string {
        if (this.entryType !== "generic") {
            return this.entryType.charAt(0).toUpperCase() + this.entryType.slice(1);
        }
        return this._headline;
    }

    // @ts-ignore
    public get description(): string | boolean {
        return this._description;
    }

    // @ts-ignore
    public get iconPath(): Icon | vscode.ThemeIcon | string {
        if (this._iconIndex &lt; 4) {
            return this._leoUI.gotoIcons[this._iconIndex];
        }
        // else return undefined for generic text without icon
        return undefined;
    }

    // @ts-ignore
    public get id(): string {
        // Add prefix and suffix salt to numeric index to prevent accidental duplicates
        // Should be unique when refreshed
        return "g" + this._id + "o";
    }

}
</t>
<t tx="felix.20220505225023.1">/**
 * * Get new uniqueID
 */
export function getUniqueId(): string {
    const id = uniqueId++;
    return id.toString();
}

</t>
<t tx="felix.20220505225030.1">/**
 * * Unique numeric Id
 */
var uniqueId: number = 0;

</t>
<t tx="felix.20220505225236.1">/**
 * * Build all possible strings for the goto panel
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the goto anywhere tree view
 */
export function buildGotoIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_PARENT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_PARENT)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_NODE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_NODE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BODY),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BODY)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_TAG),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_TAG)
        }
    ];
}

</t>
<t tx="felix.20220508201944.1">/**
 * Redo operation available state
 */
private _leoCanGoBack: boolean = false;
get leoCanGoBack(): boolean {
    return this._leoCanGoBack;
}
set leoCanGoBack(p_value: boolean) {
    this._leoCanGoBack = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_BACK, p_value);
}

</t>
<t tx="felix.20220508201944.2">/**
 * Redo operation available state
 */
private _leoCanGoNext: boolean = false;
get leoCanGoNext(): boolean {
    return this._leoCanGoNext;
}
set leoCanGoNext(p_value: boolean) {
    this._leoCanGoNext = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_NEXT, p_value);
}

</t>
<t tx="felix.20220516005841.1">public runAskYesNoCancelDialog(
    c: Commands | undefined,
    title: string,
    message: string,
    yesMessage = Constants.USER_MESSAGES.YES,
    noMessage = Constants.USER_MESSAGES.NO,
    yesToAllMessage = "",
    defaultButton = Constants.USER_MESSAGES.YES,
    cancelMessage = ""
): Thenable&lt;string&gt; {
    const w_choices = [
        yesMessage,
        noMessage,
        // Note: Already shows a 'cancel' !
    ];
    if (yesToAllMessage) {
        w_choices.push(yesToAllMessage);
    }
    if (cancelMessage) {
        w_choices.push(cancelMessage);
    }

    return vscode.window
        .showInformationMessage(
            title,
            {
                modal: true,
                detail: message
            },
            ...w_choices
            // Note: Already shows a 'cancel' !
        )
        .then((answer) =&gt; {
            if (answer === yesMessage) {
                return 'yes';
            } else if (answer === noMessage) {
                return 'no';
            } else if (answer === yesToAllMessage) {
                return 'yes-to-all';
            } else if (answer === cancelMessage) {
                return 'cancel';
            } else {
                return 'cancel'; // undefined will yield this 'cancel'.
            }
        });
}

</t>
<t tx="felix.20220517002104.1">/**
* * Creates a new Leo file
* @returns the promise started after it's done creating the frame and commander
*/
public async newLeoFile(): Promise&lt;unknown&gt; {

    this.showBodyIfClosed = true;
    this.showOutlineIfClosed = true;

    this.setupRefresh(Focus.NoChange, {
        tree: true,
        body: true,
        documents: true,
        buttons: true,
        states: true
    });

    if (!this.leoStates.fileOpenedReady) {
        if (g.app.loadManager) {
            await g.app.loadManager.openEmptyLeoFile(this);
        }
    } else {
        await this.triggerBodySave(true);
        const c = g.app.windowList[this.frameIndex].c;
        await c.new(this);
    }
    this.loadSearchSettings();
    return this.launchRefresh();
}

</t>
<t tx="felix.20220517202245.1">{
  "command": "leojs.saveLeoFileFromOutline",
  "when": "viewItem =~ /^leojsDocumentSelectedTitled/",
  "group": "inline@1"
},
{
  "command": "leojs.saveAsLeoFile",
  "when": "viewItem =~ /^leojsDocumentSelected/",
  "group": "inline@1"
},
{
  "command": "leojs.saveAsLeoJsFile",
  "when": "viewItem =~ /^leojsDocumentSelectedUntitled/",
  "group": "inline@1"
},
{
  "command": "leojs.closeLeoFile",
  "when": "viewItem =~ /^leojsDocumentSelected/",
  "group": "inline@2"
},
</t>
<t tx="felix.20220517203332.1">{
  "command": "leojs.removeButton",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsButtonNode/",
  "group": "leojsButtonContext1@1"
},
{
  "command": "leojs.gotoScript",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsButtonNode/",
  "group": "leojsButtonContext1@2"
},
</t>
<t tx="felix.20220517212706.1">/**
 * * Show input window to select
 */
private async _handleRClicks(p_rclicks: RClick[], topLevelName?: string): Promise&lt;ChooseRClickItem | undefined&gt; {
    const w_choices: ChooseRClickItem[] = [];
    let w_index = 0;
    if (topLevelName) {
        w_choices.push(
            { label: topLevelName, picked: true, alwaysShow: true, index: w_index++ }
        );
    }
    w_choices.push(
        ...p_rclicks.map((p_rclick): ChooseRClickItem =&gt; { return { label: p_rclick.position.h, index: w_index++, rclick: p_rclick }; })
    );
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.CHOOSE_BUTTON
    };
    const w_picked = await vscode.window.showQuickPick(w_choices, w_options);
    if (w_picked) {
        this._rclickSelected.push(w_picked.index);
        if (topLevelName &amp;&amp; w_picked.index === 0) {
            return Promise.resolve(w_picked);
        }
        if (w_picked.rclick &amp;&amp; w_picked.rclick.children &amp;&amp; w_picked.rclick.children.length) {
            return this._handleRClicks(w_picked.rclick.children);
        } else {
            return Promise.resolve(w_picked);
        }
    }
    return Promise.resolve(undefined);
}

</t>
<t tx="felix.20220517212718.1">/**
 * * Finds and goes to the script of an at-button. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was right-clicked
 * @returns the launchRefresh promise started after it's done finding the node
 */
public async gotoScript(p_node: LeoButtonNode): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);
    const tag = 'goto_script';
    const index = p_node.button.index;
    const c = g.app.windowList[g.app.gui.frameIndex].c;
    const d = c.theScriptingController.buttonsArray;
    const butWidget = d[index];

    if (butWidget) {

        try {
            const gnx: string = butWidget.command.gnx;

            let p: Position | undefined; // Replace YourPType with actual type

            for (const pos of c.all_positions()) {
                if (pos.gnx === gnx) {
                    p = pos;
                    break;
                }
            }

            if (p) {
                c.selectPosition(p);
                this.setupRefresh(
                    Focus.Outline,
                    {
                        tree: true,
                        body: true,
                        documents: true,
                        states: true,
                        buttons: true,
                    }
                );
                return this.launchRefresh();
            } else {
                throw new Error(`${tag}: not found ${gnx}`);
            }

        } catch (e) {
            g.es_exception(e);
        }

    }
    return Promise.resolve(false);

}

</t>
<t tx="felix.20220519232002.1">public resolveTreeItem(item: LeoOutlineNode, element: Position, token: vscode.CancellationToken): vscode.ProviderResult&lt;LeoOutlineNode&gt; {
    if (element.v.u) {
        const w_u = element.v.u;
        const w_uaLength = Object.keys(w_u).length;
        if (w_uaLength) {

            if (w_uaLength === 1 &amp;&amp; w_u.__node_tags &amp;&amp; w_u.__node_tags.length) {
                // list tags instead
                item.tooltip = item.label.label + "\n\u{1F3F7} " + w_u.__node_tags.join('\n\u{1F3F7} ');

            } else {
                item.tooltip = item.label.label + "\n" +
                    JSON.stringify(w_u, undefined, 2);
            }

            return item;
        }

    }
    item.tooltip = item.label.label; // * Fallsback to whole headline as tooltip
    return item;
}

</t>
<t tx="felix.20220520011951.1">public resolveTreeItem(item: LeoUndoNode, element: LeoUndoNode, token: vscode.CancellationToken): vscode.ProviderResult&lt;LeoUndoNode&gt; {
    if (item.contextValue === Constants.CONTEXT_FLAGS.UNDO_BEAD) {
        item.tooltip = "Undo Bead #" + item.beadIndex;
    }
    return item;
}
</t>
<t tx="felix.20220523140004.1">async function runLeo(p_context: vscode.ExtensionContext) {
    const w_start = process.hrtime(); // For calculating total startup time duration
    g.app.loadManager = new LoadManager(p_context);
    await g.app.loadManager.load();
    console.log(`leojs startup launched in ${utils.getDurationMs(w_start)} ms`);
}

</t>
<t tx="felix.20220523151725.1">function setScheme(p_event: vscode.WorkspaceFoldersChangeEvent, p_context: vscode.ExtensionContext) {
    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders.length) {
        console.log('WORKSPACE CHANGE DETECTED! length ' + vscode.workspace.workspaceFolders.length);

        g.app.vscodeWorkspaceUri = vscode.workspace.workspaceFolders[0].uri;
        g.app.vscodeUriScheme = vscode.workspace.workspaceFolders[0].uri.scheme;
        g.app.vscodeUriAuthority = vscode.workspace.workspaceFolders[0].uri.authority;
        g.app.vscodeUriPath = vscode.workspace.workspaceFolders[0].uri.path;
        console.log('is Writable Filesystem: ', vscode.workspace.fs.isWritableFileSystem(g.app.vscodeUriScheme));

        console.log('WORKSPACE CHANGE DETECTED! workspace JSON: ' + JSON.stringify(g.app.vscodeWorkspaceUri.toJSON()));
        console.log('WORKSPACE CHANGE DETECTED! workspace toString: ' + g.app.vscodeWorkspaceUri.toString());

        // * Set new and unsaved document's c.openDirectory.
        //  g.app.windowList[this.frameIndex].c;
        // for (const w_frame of g.app.windowList) {
        //     if (!w_frame.c.openDirectory) {
        //         // ! LEOJS : SET c.openDirectory to the g.app.vscodeWorkspaceUri !
        //         w_frame.c.openDirectory = g.app.vscodeWorkspaceUri?.fsPath;
        //         if (w_frame.c.openDirectory) {
        //             w_frame.c.frame.openDirectory = w_frame.c.openDirectory;
        //         }
        //     }
        // }

        // not started yet? 
        if (!g.app.loadManager &amp;&amp; g.isBrowser) {
            // Check if not file scheme : only virtual workspaces are suported if g.isBrowser is true.
            if (g.app.vscodeUriScheme !== 'file') {
                if (activateDebug) {
                    console.log('STARTUP:           g.app.vscodeWorkspaceUri: ', g.app.vscodeWorkspaceUri);
                }

                void runLeo(p_context);
            } else {
                // Is local filesystem
                void vscode.window.showInformationMessage("LeoJS in browser supports remote virtual filesystems: Local Filesystem requires desktop VSCode application: ", "More Info").then(selection =&gt; {
                    if (selection === "More Info") {
                        vscode.env.openExternal(
                            vscode.Uri.parse('https://code.visualstudio.com/docs/editor/vscode-web#_opening-a-project')
                        ).then(() =&gt; { }, (e) =&gt; {
                            console.error('LEOJS: Could not open external vscode help URL in browser.', e);
                        });
                    }
                });
                console.log('NOT started because no remote workspace yet');
                void setStartupDoneContext(true);
                return;
            }
        }
    } else {
        console.log('TODO : HANDLE WORKSPACE CHANGE DETECTED! but no workspace');
        void setStartupDoneContext(true);
    }

}

</t>
<t tx="felix.20220613164517.1">public runAboutLeoDialog(
    c: Commands | undefined,
    version: string,
    theCopyright: string,
    url: string,
    email: string
): Thenable&lt;unknown&gt; {
    return vscode.window.showInformationMessage(
        version,
        {
            modal: true,
            detail: theCopyright
        });
}

</t>
<t tx="felix.20220725004247.1">/**
 * * Sets the outline pane top bar string message or refreshes with existing title if no title passed
 * @param p_title new string to replace the current title
 */
private _setTreeViewTitle(p_title?: string): void {
    const w_changed = this.leoStates.fileOpenedReady &amp;&amp; this.leoStates.leoOpenedFileName &amp;&amp; this.leoStates.leoChanged ? "*" : "";
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    let w_title = this._currentOutlineTitle + w_changed;
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    if (this._leoTreeView &amp;&amp; w_title !== this._leoTreeView.title) {
        this._leoTreeView.title = w_title;
    }
    w_title = Constants.GUI.EXPLORER_TREEVIEW_PREFIX + w_title;
    if (this._leoTreeExView &amp;&amp; w_title !== this._leoTreeExView.title) {
        this._leoTreeExView.title = w_title;
    }
    this.refreshDesc();
}

</t>
<t tx="felix.20220917013425.1">[CMD.SET_ENABLE_PREVIEW, () =&gt; p_leoUI.config.setEnablePreview()],
[CMD.CLEAR_CLOSE_EMPTY_GROUPS, () =&gt; p_leoUI.config.clearCloseEmptyGroups()],

</t>
<t tx="felix.20220918234128.1">"languages": [
  {
    "id": "leojsbody.plain",
    "aliases": [
      "Leo Body Plain",
      "leojsbody"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.plain.language-configuration.json"
  },
  {
    "id": "leojsbody.python",
    "aliases": [
      "Leo Body Python",
      "leojsbody.python"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.python.language-configuration.json"
  },
  {
    "id": "leojsbody.typescript",
    "aliases": [
      "Leo Body Typescript",
      "leojsbody.typescript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.typescript.language-configuration.json"
  },
  {
    "id": "leojsbody.javascript",
    "aliases": [
      "Leo Body Javascript",
      "leojsbody.javascript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.javascript.language-configuration.json"
  },
  {
    "id": "leojsbody.c",
    "aliases": [
      "Leo Body c",
      "leojsbody.c"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.c.language-configuration.json"
  },
  {
    "id": "leojsbody.cpp",
    "aliases": [
      "Leo Body C++",
      "leojsbody.cpp"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.cpp.language-configuration.json"
  },
  {
    "id": "leojsbody.css",
    "aliases": [
      "Leo Body CSS",
      "leojsbody.css"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.css.language-configuration.json"
  },
  {
    "id": "leojsbody.fortran",
    "aliases": [
      "Leo Body Fortran",
      "leojsbody.fortran"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.fortran.language-configuration.json"
  },
  {
    "id": "leojsbody.fortran90",
    "aliases": [
      "Leo Body Fortran90",
      "leojsbody.fortran90"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.fortran.language-configuration.json"
  },
  {
    "id": "leojsbody.html",
    "aliases": [
      "Leo Body HTML",
      "leojsbody.html"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.html.language-configuration.json"
  },
  {
    "id": "leojsbody.java",
    "aliases": [
      "Leo Body Java",
      "leojsbody.java"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.java.language-configuration.json"
  },
  {
    "id": "leojsbody.json",
    "aliases": [
      "Leo Body Json",
      "leojsbody.json"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.json.language-configuration.json"
  },
  {
    "id": "leojsbody.markdown",
    "aliases": [
      "Leo Body Markdown",
      "leojsbody.markdown"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.markdown.language-configuration.json"
  },
  {
    "id": "leojsbody.php",
    "aliases": [
      "Leo Body PHP",
      "leojsbody.php"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.php.language-configuration.json"
  },
  {
    "id": "leojsbody.restructuredtext",
    "aliases": [
      "Leo Body reStructuredText",
      "leojsbody.restructuredtext"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.rst.language-configuration.json"
  },
  {
    "id": "leojsbody.rust",
    "aliases": [
      "Leo Body Rust",
      "leojsbody.rust"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leojsbody.rust.language-configuration.json"
  }
],
</t>
<t tx="felix.20220918234147.1">"grammars": [
  {
    "language": "leojsbody.plain",
    "scopeName": "source.leojsbody.plain",
    "path": "./syntaxes/leojsbody.plain.tmLanguage.json"
  },
  {
    "language": "leojsbody.python",
    "scopeName": "source.leojsbody.python",
    "path": "./syntaxes/leojsbody.python.tmLanguage.json"
  },
  {
    "language": "leojsbody.typescript",
    "scopeName": "source.leojsbody.typescript",
    "path": "./syntaxes/leojsbody.typescript.tmLanguage.json"
  },
  {
    "language": "leojsbody.javascript",
    "scopeName": "source.leojsbody.javascript",
    "path": "./syntaxes/leojsbody.javascript.tmLanguage.json"
  },
  {
    "language": "leojsbody.c",
    "scopeName": "source.leojsbody.c",
    "path": "./syntaxes/leojsbody.c.tmLanguage.json"
  },
  {
    "language": "leojsbody.cpp",
    "scopeName": "source.leojsbody.cpp",
    "path": "./syntaxes/leojsbody.cpp.tmLanguage.json"
  },
  {
    "language": "leojsbody.css",
    "scopeName": "source.leojsbody.css",
    "path": "./syntaxes/leojsbody.css.tmLanguage.json"
  },
  {
    "language": "leojsbody.fortran",
    "scopeName": "source.leojsbody.fortran",
    "path": "./syntaxes/leojsbody.fortran.tmLanguage.json"
  },
  {
    "language": "leojsbody.fortran90",
    "scopeName": "source.leojsbody.fortran90",
    "path": "./syntaxes/leojsbody.fortran90.tmLanguage.json"
  },
  {
    "language": "leojsbody.html",
    "scopeName": "source.leojsbody.html",
    "path": "./syntaxes/leojsbody.html.tmLanguage.json"
  },
  {
    "language": "leojsbody.java",
    "scopeName": "source.leojsbody.java",
    "path": "./syntaxes/leojsbody.java.tmLanguage.json"
  },
  {
    "language": "leojsbody.json",
    "scopeName": "source.leojsbody.json",
    "path": "./syntaxes/leojsbody.json.tmLanguage.json"
  },
  {
    "language": "leojsbody.markdown",
    "scopeName": "source.leojsbody.markdown",
    "path": "./syntaxes/leojsbody.markdown.tmLanguage.json"
  },
  {
    "language": "leojsbody.php",
    "scopeName": "source.leojsbody.php",
    "path": "./syntaxes/leojsbody.php.tmLanguage.json"
  },
  {
    "language": "leojsbody.restructuredtext",
    "scopeName": "source.leojsbody.restructuredtext",
    "path": "./syntaxes/leojsbody.rst.tmLanguage.json"
  },
  {
    "language": "leojsbody.rust",
    "scopeName": "source.leojsbody.rust",
    "path": "./syntaxes/leojsbody.rust.tmLanguage.json"
  },
  {
    "injectTo": [
      "source.leojsbody.c",
      "source.leojsbody.cpp",
      "source.leojsbody.css",
      "source.leojsbody.fortran",
      "source.leojsbody.fortran90",
      "source.leojsbody.html",
      "source.leojsbody.java",
      "source.leojsbody.javascript",
      "source.leojsbody.json",
      "source.leojsbody.markdown",
      "source.leojsbody.php",
      "source.leojsbody.plain",
      "source.leojsbody.python",
      "source.leojsbody.restructuredtext",
      "source.leojsbody.rust",
      "source.leojsbody.typescript"
    ],
    "path": "./syntaxes/leojsbody.tmLanguage.json",
    "scopeName": "leojs.injection"
  }
],
</t>
<t tx="felix.20220918234152.1">"snippets": [
  {
    "language": "leojsbody.c",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leojsbody.cpp",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leojsbody.fortran90",
    "path": "./snippets/fortran90.code-snippets"
  },
  {
    "language": "leojsbody.javascript",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leojsbody.typescript",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leojsbody.java",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leojsbody.php",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leojsbody.markdown",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leojsbody.restructuredtext",
    "path": "./snippets/restructuredtext.code-snippets"
  },
  {
    "language": "leojsbody.rust",
    "path": "./snippets/rust.code-snippets"
  }
],
</t>
<t tx="felix.20220920001018.1"></t>
<t tx="felix.20220920001018.2">/**
 * * Adds a message string to LeoJS log pane. Used when leoBridge receives an async 'log' command.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    this._leoLogPane.appendLine(p_message);
}

</t>
<t tx="felix.20220920001018.3">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(p_focus?: boolean): Thenable&lt;unknown&gt; {
    if (this._leoLogPane) {
        this._leoLogPane.show(!p_focus); // use flag to preserve focus
        return Promise.resolve(true);
    } else {
        return Promise.resolve(undefined); // if cancelled
    }
}

</t>
<t tx="felix.20220920001202.1">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    if (this._leoLogPane) {
        this._leoLogPane.hide();
    }
}

</t>
<t tx="felix.20220922000450.1"></t>
<t tx="felix.20220922000450.10">
/**
 * * Closes any body pane opened in this vscode window instance
 * @returns a promise that resolves when the file is closed and removed from recently opened list
 */
public closeBody(): Thenable&lt;any&gt; {

    const w_foundTabs: vscode.Tab[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        w_foundTabs.forEach((p_tab) =&gt; {
            if (p_tab.input) {

                void vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                void vscode.workspace.applyEdit(w_edit);
            }
        });
    } else {
        q_closedTabs = Promise.resolve(true);

    }

    let q_closedBody;
    if (this.bodyUri) {
        q_closedBody = vscode.commands.executeCommand(
            'vscode.removeFromRecentlyOpened',
            this.bodyUri
        );
    } else {
        q_closedBody = Promise.resolve(true);
    }

    return Promise.all([q_closedTabs, q_closedBody]);
}

</t>
<t tx="felix.20220922000450.11">/**
 * * cleanupBody closes all remaining body pane to shut down this vscode window
 * @returns a promise that resolves when done saving and closing
 */
public cleanupBody(): Thenable&lt;any&gt; {
    let q_save: Thenable&lt;any&gt;;
    //
    if (this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        utils.leoUriToStr(this.bodyUri) === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
    ) {
        q_save = this._bodySaveDeactivate(this._bodyLastChangedDocument);
    } else {
        q_save = Promise.resolve(true);
    }

    // Adding log in the chain of events
    let q_edit: Thenable&lt;boolean&gt;;
    if (this.bodyUri) {
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(this.bodyUri, { ignoreIfNotExists: true });
        q_edit = vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            return true;
        }, () =&gt; {
            return false;
        });
    } else {
        q_edit = Promise.resolve(true);
    }
    Promise.all([q_save, q_edit])
        .then(() =&gt; {
            return this.closeBody();
        }, () =&gt; {
            return true;
        });

    return q_save;
}

</t>
<t tx="felix.20220922000450.12">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preventTakingFocus flag that when true will stop the editor from taking focus once opened
 * @returns a promise of an editor, or void if body had been changed again in the meantime.
 */
public async showBody(p_aside: boolean, p_preventTakingFocus?: boolean, p_preventReveal?: boolean): Promise&lt;vscode.TextEditor | void&gt; {
    const w_openedDocumentTS = utils.performanceNow();
    const w_openedDocumentGnx = utils.leoUriToStr(this.bodyUri);
    let q_saved: Thenable&lt;unknown&gt; | undefined;

    // First setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._refreshType.body) {
        this._refreshType.body = false;

        if (this._bodyLastChangedDocument &amp;&amp;
            !this._bodyLastChangedDocument.isClosed &amp;&amp;
            (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
            w_openedDocumentGnx === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
        ) {
            // ! FAKE SAVE to make sure body is not dirty !
            this._leoFileSystem.preventSaveToLeo = true;
            this._editorTouched = false;
            q_saved = this._bodyLastChangedDocument.save();
        }

        if (q_saved) {
            await q_saved;
            this._leoFileSystem.fireRefreshFile(w_openedDocumentGnx);
        }

    }

    // Handle 'Config was changed -&gt; refresh without showing body' and return
    // (because _tryApplyNodeToBody will always call showBody if outline refreshes with )
    if (this._preventShowBody) {
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }

    // let w_preFoundDocOpened = false;
    // let w_preFoundTabOpened = false;
    // vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
    //     p_tabGroup.tabs.forEach((p_tab) =&gt; {

    //         if (p_tab.input &amp;&amp;
    //             (p_tab.input as vscode.TabInputText).uri &amp;&amp;
    //             (p_tab.input as vscode.TabInputText).uri.fsPath === this.bodyUri.fsPath) {
    //             w_preFoundTabOpened = true;
    //             vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
    //                 if (p_textDocument.uri.fsPath === (p_tab.input as vscode.TabInputText).uri.fsPath) {
    //                     w_preFoundDocOpened = true;
    //                 }
    //             });
    //         }
    //     });
    // });


    // * Step 1 : Open the document
    const w_openedDocument = await vscode.workspace.openTextDocument(this.bodyUri);

    this._bodyTextDocument = w_openedDocument;
    let w_bodySel: BodySelectionInfo | undefined;
    // * Set document language along with the proper cursor position, selection range and scrolling position
    if (!this._needLastSelectedRefresh) {

        // * Get the language.
        const c = g.app.windowList[this.frameIndex].c;
        const p = c.p;
        let w_language = this._getBodyLanguage();

        // # Get the body wrap state
        const w_wrap = !!g.scanAllAtWrapDirectives(c, p);
        const tempTabWidth = g.scanAllAtTabWidthDirectives(c, p);
        const w_tabWidth: number | boolean = tempTabWidth || !!tempTabWidth;

        const insert = p.v.insertSpot;
        const start = p.v.selectionStart;
        const end = p.v.selectionStart + p.v.selectionLength;
        const scroll = p.v.scrollBarSpot;

        w_bodySel = {
            "gnx": p.v.gnx,
            "scroll": scroll,
            "insert": this._row_col_pv_dict(insert, p.v.b),
            "start": this._row_col_pv_dict(start, p.v.b),
            "end": this._row_col_pv_dict(end, p.v.b)
        };
        // console.log('From p:', ` insert:${w_bodySel.insert.line}, ${w_bodySel.insert.col} start:${w_bodySel.start.line},${w_bodySel.start.col} end:${w_bodySel.end.line}, ${w_bodySel.end.col}`);

        // ! -------------------------------
        // ! TEST SELECTION GETTER OVERRIDE!
        // ! -------------------------------
        const wrapper = c.frame.body.wrapper;
        const test_insert = wrapper.getInsertPoint();
        let test_start, test_end;
        [test_start, test_end] = wrapper.getSelectionRange(true);
        // ! OVERRIDE !
        //const w_bodySel_w = {
        w_bodySel = {
            "gnx": p.v.gnx,
            "scroll": scroll,
            "insert": this._row_col_wrapper_dict(test_insert, wrapper),
            "start": this._row_col_wrapper_dict(test_start, wrapper),
            "end": this._row_col_wrapper_dict(test_end, wrapper)
        };
        // console.log('From w:', ` insert:${w_bodySel_w.insert.line}, ${w_bodySel_w.insert.col} start:${w_bodySel_w.start.line},${w_bodySel_w.start.col} end:${w_bodySel_w.end.line}, ${w_bodySel_w.end.col}`);
        // console.log('From w:', ` insert:${w_bodySel.insert.line}, ${w_bodySel.insert.col} start:${w_bodySel.start.line},${w_bodySel.start.col} end:${w_bodySel.end.line}, ${w_bodySel.end.col}`);

        // TODO : Apply tabwidth
        // console.log('TABWIDTH: ', w_tabWidth);
        // TODO : Apply Wrap. see https://github.com/microsoft/vscode/issues/136927
        // console.log('WRAP: ', w_wrap);

        // Replace language string if in 'exceptions' array
        w_language = Constants.LEO_LANGUAGE_PREFIX + (Constants.LANGUAGE_CODES[w_language] || w_language);

        let w_debugMessage = "";
        let w_needRefreshFlag = false;

        // Apply language if the selected node is still the same after all those events
        if (!w_openedDocument.isClosed) {
            // w_openedDocument still OPEN
            if (this.isTsStillValid(w_openedDocumentTS)) { // No need to check gnx of command stack){
                // command stack last node is still valid
                if (this.lastSelectedNode &amp;&amp; w_openedDocumentGnx === this.lastSelectedNode.gnx) {
                    // still same gnx as this.bodyUri
                    void this._setBodyLanguage(w_openedDocument, w_language);
                } else {
                    // NOT SAME GNX!
                    w_debugMessage = "all good but not same GNX!?!";
                    w_needRefreshFlag = true;
                }

            } else {
                // NOT VALID : NEW NODE SELECTED SINCE THIS STARTED!
                w_debugMessage = "New node selected since this started!";
                w_needRefreshFlag = false;
            }

        } else {
            w_debugMessage = "w_openedDocument is CLOSED " + w_openedDocument.uri.fsPath;
            w_needRefreshFlag = false;
        }

        // * Debug Info
        // if (w_debugMessage) {
        //     console.log(w_debugMessage);
        //     console.log("w_openedDocumentGnx", w_openedDocumentGnx);
        //     console.log("this.lastSelectedNode.gnx", this.lastSelectedNode!.gnx);
        //     console.log("w_gnx", w_gnx);
        // }

        if (w_needRefreshFlag) {
            if (this._showBodySwitchBodyTimer) {
                clearTimeout(this._showBodySwitchBodyTimer);
            }
            // redo apply to body!
            this._showBodySwitchBodyTimer = setTimeout(() =&gt; {
                if (this.lastSelectedNode) {
                    void this._switchBody(false, p_preventTakingFocus);
                }
            }, 0);
            return;

        }
    }

    // Find body pane's position if already opened with same gnx 
    // Note: language still needs to be set per position
    let w_foundDocOpened = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {

            if (
                p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.fsPath === w_openedDocument.uri.fsPath
            ) {
                vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
                    if (
                        p_textDocument.uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                        p_textDocument.uri.fsPath === (p_tab.input as vscode.TabInputText).uri.fsPath
                    ) {
                        this._bodyTextDocument = p_textDocument; // vscode.workspace.openTextDocument
                        this._bodyMainSelectionColumn = p_tab.group.viewColumn;
                        if (p_preventReveal) {
                            if (p_tab.isActive) {
                                w_foundDocOpened = true;
                            }
                        } else {
                            w_foundDocOpened = true;
                        }
                    }
                });
            }
        });
    });


    if (!w_foundDocOpened &amp;&amp; p_preventReveal) {
        return; // ! HAD PREVENT REVEAL !
    }

    if (w_foundDocOpened &amp;&amp; !q_saved) {
        // Was the same and was asked to show body (and did not already had to fake-save and refresh)
        this._leoFileSystem.fireRefreshFile(w_openedDocumentGnx);
    }
    // Setup options for the preview state of the opened editor, and to choose which column it should appear
    const w_showOptions: vscode.TextDocumentShowOptions = p_aside
        ? {
            viewColumn: vscode.ViewColumn.Beside,
            preserveFocus: p_preventTakingFocus,
            preview: true, // should text document be in preview only? set false for fully opened
        }
        : {
            viewColumn: this._bodyMainSelectionColumn
                ? this._bodyMainSelectionColumn
                : 1,
            preserveFocus: p_preventTakingFocus,
            preview: true, // should text document be in preview only? set false for fully opened
        };

    // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER "await vscode.workspace.openTextDocument"
    if (
        w_openedDocument.isClosed ||
        !this.isTsStillValid(w_openedDocumentTS) // No need to check gnx

        // Should the gnx be relevant? -&gt; !this.isGnxStillValid(w_openedDocumentGnx, w_openedDocumentTS)

    ) {
        return;
    }

    // * Actually Show the body pane document in a text editor
    const q_showTextDocument = vscode.window.showTextDocument(
        this._bodyTextDocument,
        w_showOptions
    ).then(
        (p_result) =&gt; {
            this.showBodyIfClosed = false; // * BODY IS ACTUALLY SHOWN!
            return p_result;
        }
    );

    // else q_bodyStates will exist.
    if (!this._needLastSelectedRefresh) {
        void q_showTextDocument.then(
            (p_textEditor: vscode.TextEditor) =&gt; {

                // * Set text selection range
                const w_bodyTextEditor = p_textEditor;
                if (!w_bodySel) {
                    console.log("no selection in returned package from get_body_states");
                }

                const w_leoBodySel: BodySelectionInfo = w_bodySel!;

                // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER q_bodyStates &amp; q_showTextDocument
                if (
                    w_openedDocument.isClosed ||
                    !this.isTsStillValid(w_openedDocumentTS) ||
                    (this.lastSelectedNode &amp;&amp; w_leoBodySel.gnx !== this.lastSelectedNode.gnx)
                    // Should the gnx be relevant? -&gt; !this.isGnxStillValid(w_openedDocumentGnx, w_openedDocumentTS)
                ) {
                    return;
                }

                // Cursor position and selection range
                const w_activeRow: number = w_leoBodySel.insert.line;
                const w_activeCol: number = w_leoBodySel.insert.col;
                let w_anchorLine: number = w_leoBodySel.start.line;
                let w_anchorCharacter: number = w_leoBodySel.start.col;

                if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                    // Active insertion same as start selection, so use the other ones
                    w_anchorLine = w_leoBodySel.end.line;
                    w_anchorCharacter = w_leoBodySel.end.col;
                }

                const w_selection = new vscode.Selection(
                    w_anchorLine,
                    w_anchorCharacter,
                    w_activeRow,
                    w_activeCol
                );

                let w_scrollRange: vscode.Range | undefined;

                // Build scroll position from selection range.
                w_scrollRange = new vscode.Range(
                    w_activeRow,
                    w_activeCol,
                    w_activeRow,
                    w_activeCol
                );

                if (w_bodyTextEditor) {
                    // this._revealType = RevealType.NoReveal; // ! IN CASE THIS WAS STILL UP FROM SHOW_OUTLINE

                    // console.log(
                    //     'ShowBody is setting selection! anchor: ', w_selection.anchor.line, w_selection.anchor.character,
                    //     ' active: ', w_selection.active.line, w_selection.active.character
                    // );

                    w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                    if (!w_scrollRange) {
                        w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                    }

                    if (this._refreshType.scroll) {
                        this._refreshType.scroll = false;

                        // Set scroll approximation
                        w_bodyTextEditor.revealRange(w_scrollRange, vscode.TextEditorRevealType.InCenterIfOutsideViewport);
                        // ! Compensate for reveal that steals the focus.
                        if (this._refreshType.goto) {
                            this._refreshType.goto = false;
                            let w_viewName: string;
                            if (this._lastTreeView === this._leoTreeExView) {
                                w_viewName = Constants.GOTO_EXPLORER_ID;
                            } else {
                                w_viewName = Constants.GOTO_ID;
                            }
                            void vscode.commands.executeCommand(w_viewName + ".focus");
                        }
                    }

                } else {
                    console.log("no selection in returned package from showTextDocument");
                }

            }
        );
    }

    return q_showTextDocument;
}

</t>
<t tx="felix.20220922000450.13">/**
 * * Sets vscode's body-pane editor's language
 */
private _setBodyLanguage(p_document: vscode.TextDocument, p_language: string): Thenable&lt;vscode.TextDocument&gt; {
    return vscode.languages.setTextDocumentLanguage(p_document, p_language).then(
        (p_mewDocument) =&gt; { return p_mewDocument; }, // ok - language found
        (p_error) =&gt; {
            let w_langName: string = p_error.toString().split('\n')[0];
            if (w_langName.length &gt; 36 &amp;&amp; w_langName.includes(Constants.LEO_LANGUAGE_PREFIX)) {
                w_langName = w_langName.substring(36);
            } else {
                w_langName = "";
            }
            if (w_langName &amp;&amp; !this._languageFlagged.includes(w_langName)) {
                this._languageFlagged.push(w_langName);
                void vscode.window.showInformationMessage(
                    w_langName + Constants.USER_MESSAGES.LANGUAGE_NOT_SUPPORTED
                );
            } else if (!w_langName) {
                // Document was closed: refresh after a timeout cycle (should not happen!)
                setTimeout(() =&gt; {
                    this.setupRefresh(
                        this.finalFocus,
                        {
                            // tree: true,
                            body: true,
                            // documents: true,
                            // buttons: false,
                            states: true,
                        }
                    );
                    void this.launchRefresh();
                }, 0);
            }
            return p_document;
        }
    );
}

</t>
<t tx="felix.20220922000450.14">/**
 * * Refreshes body pane's statuses such as applied language file type, word-wrap state, etc.
 */
public refreshBodyStates(): void {
    if (!this._bodyTextDocument || !this.lastSelectedNode) {
        return;
    }

    // * Set document language along with the proper cursor position, selection range and scrolling position
    const c = g.app.windowList[this.frameIndex].c;
    const p = c.p;
    let w_language = this._getBodyLanguage();

    // # Get the body wrap state
    let w_wrap = !!g.scanAllAtWrapDirectives(c, p);

    // TODO : Apply Wrap. see https://github.com/microsoft/vscode/issues/136927
    // console.log('WRAP: ', w_wrap);

    // Replace language string if in 'exceptions' array
    w_language = Constants.LEO_LANGUAGE_PREFIX + (Constants.LANGUAGE_CODES[w_language] || w_language);
    // Apply language if the selected node is still the same after all those events
    if (this._bodyTextDocument &amp;&amp;
        !this._bodyTextDocument.isClosed &amp;&amp;
        this.lastSelectedNode &amp;&amp;
        w_language !== this._bodyTextDocument.languageId &amp;&amp;
        utils.leoUriToStr(this._bodyTextDocument.uri) === this.lastSelectedNode.gnx
    ) {
        void this._setBodyLanguage(this._bodyTextDocument, w_language);
    }

}

</t>
<t tx="felix.20220922000450.15">/**
 * * Refresh body states after a small debounced delay.
 */
public debouncedRefreshBodyStates(p_delay?: number) {

    if (!p_delay) {
        p_delay = 0;
    }

    if (this._bodyStatesTimer) {
        clearTimeout(this._bodyStatesTimer);
    }
    if (p_delay === 0) {
        if (this._bodyLastChangedDocument &amp;&amp; this.leoStates.fileOpenedReady) {
            void this._bodySaveDocument(this._bodyLastChangedDocument);
            this.refreshBodyStates();
        }
    } else {
        this._bodyStatesTimer = setTimeout(() =&gt; {
            if (this._bodyLastChangedDocument &amp;&amp; this.leoStates.fileOpenedReady) {
                void this._bodySaveDocument(this._bodyLastChangedDocument);
                this.refreshBodyStates();
            }
        }, p_delay);
    }
}

</t>
<t tx="felix.20220922000450.2">/**
 * * Makes sure the body now reflects the selected node.
 * This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_preventTakingFocus Flag used to keep focus where it was instead of forcing in body
 * @returns a text editor of the p_node parameter's gnx (As 'leo' file scheme). Or rejects if interrupted.
 */
private _tryApplyNodeToBody(
    p_node: Position,
    p_aside: boolean,
    p_preventTakingFocus: boolean,
): Thenable&lt;void | vscode.TextEditor&gt; {

    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context

    // if not first time and still opened - also not somewhat exactly opened somewhere.
    if (this._bodyTextDocument &amp;&amp;
        !this._bodyTextDocument.isClosed &amp;&amp;
        !this._locateOpenedBody(p_node.gnx) // COULD NOT LOCATE NEW GNX
    ) {
        // if needs switching by actually having different gnx
        if (utils.leoUriToStr(this.bodyUri) !== p_node.gnx) {
            // * LOCATE OLD GNX FOR PROPER COLUMN
            this._locateOpenedBody(utils.leoUriToStr(this.bodyUri));
            // Make sure any pending changes in old body are applied before switching
            return this._bodyTextDocument.save().then(() =&gt; {
                return this._switchBody(p_aside, p_preventTakingFocus);
            });
        }
    }

    // first time or no body opened
    this.bodyUri = utils.strToLeoUri(p_node.gnx);
    if (this._isBodyVisible() === 0 &amp;&amp; !this.showBodyIfClosed) {
        return Promise.resolve();
    }
    return this.showBody(p_aside, p_preventTakingFocus);
}

</t>
<t tx="felix.20220922000450.3">/**
 * * Close body pane document and change the bodyUri to this.lastSelectedNode's gnx
 * This blocks 'undos' from crossing over
 * @param p_aside From 'Open Aside'.
 * @param p_preventTakingFocus prevents forcing focus on text body.
 */
private _switchBody(
    p_aside: boolean,
    p_preventTakingFocus?: boolean
): Thenable&lt;void | vscode.TextEditor&gt; {
    const w_oldUri: vscode.Uri = this.bodyUri;
    const w_newUri: vscode.Uri = utils.strToLeoUri(this.lastSelectedNode!.gnx);
    const w_newTS = utils.performanceNow();
    const w_visibleCount = this._isBodyVisible();

    this.bodyUri = w_newUri; // New GLOBAL BODY URI

    if (w_visibleCount === 0 &amp;&amp; !this.showBodyIfClosed) {
        return Promise.resolve();
    }

    if (w_visibleCount === 1) {
        this._bodyPreviewMode = this._isBodyPreview(); // recheck in case user double clicked on title
    }

    if (this.lastSelectedNode &amp;&amp; this._bodyPreviewMode &amp;&amp; this._bodyEnablePreview &amp;&amp; w_visibleCount &lt; 2) {

        // just show in same column and delete after
        const q_showBody = this.showBody(p_aside, p_preventTakingFocus);

        if (w_oldUri.fsPath !== this.bodyUri.fsPath) {
            void q_showBody.then(() =&gt; {
                const w_tabsToCloseFound: vscode.Tab[] = [];
                let q_lastSecondSaveFound: Thenable&lt;boolean&gt; = Promise.resolve(true);
                vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
                    p_tabGroup.tabs.forEach((p_tab) =&gt; {
                        if (p_tab.input &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri.fsPath === w_oldUri.fsPath
                        ) {
                            // Make sure it's saved AGAIN!!
                            if (
                                p_tab.isDirty &amp;&amp;
                                this._bodyLastChangedDocument &amp;&amp;
                                (p_tab.input as vscode.TabInputText).uri.fsPath === this._bodyLastChangedDocument.uri.fsPath
                            ) {
                                this._leoFileSystem.preventSaveToLeo = true;
                                this._editorTouched = false;
                                q_lastSecondSaveFound = this._bodyLastChangedDocument.save();
                            }
                            w_tabsToCloseFound.push(p_tab);
                        }
                    });
                });
                if (w_tabsToCloseFound.length) {
                    void q_lastSecondSaveFound.then(() =&gt; {
                        void vscode.window.tabGroups.close(w_tabsToCloseFound, true);
                    });
                }
                // Remove from potential 'recently opened'
                void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri);

            });
        }
        return q_showBody;
    } else {
        // Close ALL LEO EDITORS first !
        const w_tabsToCloseAll: vscode.Tab[] = [];
        let q_lastSecondSaveAll: Thenable&lt;boolean&gt; = Promise.resolve(true);

        vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
            p_tabGroup.tabs.forEach((p_tab) =&gt; {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                    w_newUri.fsPath !== (p_tab.input as vscode.TabInputText).uri.fsPath // Maybe useless to check if different!
                ) {

                    if (
                        p_tab.isDirty &amp;&amp;
                        this._bodyLastChangedDocument &amp;&amp;
                        (p_tab.input as vscode.TabInputText).uri.fsPath === this._bodyLastChangedDocument.uri.fsPath
                    ) {
                        this._leoFileSystem.preventSaveToLeo = true;
                        this._editorTouched = false;
                        q_lastSecondSaveAll = this._bodyLastChangedDocument.save();
                    }

                    w_tabsToCloseAll.push(p_tab);
                }
            });
        });

        let q_closeAll: Thenable&lt;unknown&gt;;
        if (w_tabsToCloseAll.length) {
            q_closeAll = q_lastSecondSaveAll.then(() =&gt; {
                return vscode.window.tabGroups.close(w_tabsToCloseAll, true);
            });

        } else {
            q_closeAll = Promise.resolve();
        }

        // async, so don't wait for this to finish
        if (w_oldUri.fsPath !== w_newUri.fsPath) {
            void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri);
        }

        return q_closeAll.then(() =&gt; {
            this._bodyPreviewMode = true;
            // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER q_bodyStates &amp; q_showTextDocument
            if (
                // Should the gnx be relevant?  !this.isGnxStillValid(w_newGnx, w_newTS)
                !this.isTsStillValid(w_newTS)
            ) {
                return;
            }
            return this.showBody(p_aside, p_preventTakingFocus);
        });
    }
}

</t>
<t tx="felix.20220922000450.4">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 * @returns true if located and found, false otherwise
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri) === p_gnx
            ) {
                vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
                    if (
                        utils.leoUriToStr(p_textDocument.uri) === p_gnx
                    ) {
                        w_found = true;
                        this._bodyTextDocument = p_textDocument; // vscode.workspace.openTextDocument
                        this._bodyMainSelectionColumn = p_tab.group.viewColumn;
                    }
                });
            }
        });
    });
    return w_found;
}

</t>
<t tx="felix.20220922000450.5">/**
 * * Checks for all tabs if any are 'leoBody' scheme
 * @returns total found
 */
private _isBodyVisible(): number {
    let w_total = 0;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME
            ) {
                w_total++;
            }
        });
    });
    return w_total;
}

</t>
<t tx="felix.20220922000450.6">/**
 * * Checks for all tabs if any are 'leoBody' scheme
 * @returns total found
 */
private _isBodyPreview(): boolean {
    let w_isPreview: boolean = true;
    let w_found: boolean = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME
            ) {
                w_found = true;
                if (!p_tab.isPreview) {
                    w_isPreview = false;
                }
            }
        });
    });
    if (w_found) {
        return w_isPreview;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20220922000450.7">/**
 * * Checks if outline is visible
 * @returns true if either outline is visible
 */
public isOutlineVisible(): boolean {
    return this._leoTreeExView.visible || this._leoTreeView.visible;
}

</t>
<t tx="felix.20220922000450.8">/**
 * * Closes non-existing text-editor body if it doesn't match bodyUri
 * @param p_textEditor the editor to close
 * @returns promise that resolves to true if it closed tabs, false if none were found
 */
private _hideDeleteBody(p_textEditor: vscode.TextEditor): Thenable&lt;unknown&gt; {
    const w_foundTabs: vscode.Tab[] = [];
    const w_editorFsPath = p_textEditor.document.uri.fsPath;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.fsPath === w_editorFsPath &amp;&amp;
                this.bodyUri.fsPath !== w_editorFsPath // if BODY is now the same, dont hide!
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    // * Make sure the closed/deleted body is not remembered as vscode's recent files!
    void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', p_textEditor.document.uri);

    if (w_foundTabs.length) {
        return vscode.window.tabGroups.close(w_foundTabs, true);
    }

    return Promise.resolve();
}

</t>
<t tx="felix.20220922000450.9">/**
 * * Clears the global 'Preview Mode' flag if the given editor is not in the main body column
 * @param p_editor is the editor to check for is in the same column as the main one
 */
private _checkPreviewMode(p_editor: vscode.TextEditor): void {
    // if selected gnx but in another column
    if (
        p_editor.document.uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
        p_editor.document.uri.fsPath === this.bodyUri.fsPath &amp;&amp;
        p_editor.viewColumn !== this._bodyMainSelectionColumn
    ) {
        this._bodyPreviewMode = false;
        this._bodyMainSelectionColumn = p_editor.viewColumn;
    }
}

</t>
<t tx="felix.20220922215553.1">/**
 * * Location of focus to be set when current/last command is resolved
 */
export const enum Focus {
    NoChange = 0, // Stays on goto pane, or other current panel.
    Body, // Forces body to appear, refresh leaves focus on body.
    Outline, // Forces outline to appear, refresh leaves focus on Outline.
    Goto
}

</t>
<t tx="felix.20220922235942.1">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 * @returns Thenable from the reveal tree node action, resolves directly if no tree visible
 */
private _revealNode(
    p_leoNode: Position,
    p_options?: { select?: boolean; focus?: boolean; expand?: boolean | number }
): Thenable&lt;void&gt; {
    let w_treeview: vscode.TreeView&lt;Position&gt; | undefined;
    if (this._leoTreeView.visible) {
        w_treeview = this._leoTreeView;
    }
    if (this._leoTreeExView.visible &amp;&amp; this.config.treeInExplorer) {
        w_treeview = this._leoTreeExView;
    }
    if (!w_treeview &amp;&amp; (this.showOutlineIfClosed || (p_options &amp;&amp; p_options.focus))) {
        this.showOutlineIfClosed = false;
        w_treeview = this._lastTreeView;
        if (p_options) {
            p_options.focus = true;
        } else {
            p_options = {
                focus: true,
                select: true
            };
        }
    }
    try {
        if (w_treeview) {
            return w_treeview.reveal(p_leoNode, p_options).then(
                () =&gt; {
                    // ok
                    this._revealNodeRetriedRefreshOutline = false;
                },
                (p_reason) =&gt; {
                    console.log('_revealNode could not reveal. Reason: ', p_reason);

                    if (!this._revealNodeRetriedRefreshOutline) {
                        this._revealNodeRetriedRefreshOutline = true;
                        // Reveal failed. Retry refreshOutline once
                        this._refreshOutline(true, RevealType.RevealSelect);
                    }
                }
            );
        }

    } catch (p_error) {
        console.error("_revealNode error: ", p_error);
        // Retry refreshOutline once
        if (!this._revealNodeRetriedRefreshOutline) {
            this._revealNodeRetriedRefreshOutline = true;
            // Reveal failed. Retry refreshOutline once
            this._refreshOutline(true, RevealType.RevealSelect);
        }
    }
    return Promise.resolve(); // Defaults to resolving even if both are hidden
}

</t>
<t tx="felix.20220923001235.1">/**
 * * Checks timestamp only, if is still the latest lastReceivedNode
  * @param ts timestamp of last time
 */
public isTsStillValid(ts: number): boolean {

    // also test other sources, and check if command also not started to go back to original gnx
    // by checking if the test above only failed for gnx being the same
    if (
        this._refreshNode &amp;&amp;
        this._lastRefreshNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new _refreshNode is different and newer
        return false;
    }
    if (
        this.lastSelectedNode &amp;&amp;
        this._lastSelectedNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new lastSelectedNode is different and newer
        return false;
    }
    return true;
}

</t>
<t tx="felix.20220923001725.1">/**
 * * Refreshes all parts.
 * @returns Promise back from command's execution, if added on stack, undefined otherwise.
 */
public fullRefresh(p_keepFocus?: boolean): void {
    this.setupRefresh(
        p_keepFocus ? Focus.NoChange : this.finalFocus,
        {
            tree: true,
            body: true,
            states: true,
            buttons: true,
            documents: true,
            goto: true,
        }
    );
    void this.launchRefresh();
}

</t>
<t tx="felix.20220923003944.1">/**
 * * Table for converting Leo languages names for the currently opened body pane
 * Used in showBody method of leoUI.ts
 */
public static LANGUAGE_CODES: { [key: string]: string | undefined } = {
    cplusplus: 'cpp',
    md: 'markdown',
    rest: 'restructuredtext',
    rst: 'restructuredtext'
};

</t>
<t tx="felix.20220929001102.1">/**
 * * window.performace.now browser/node crossover utility
 */
export function performanceNow(): number {
    const w_now = process.hrtime();
    const [w_secs, w_nanosecs] = w_now;
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20220930212953.1">/**
 * * Handles the opening of a file in vscode, and check if it's a Leo file to suggest opening options
 * @param p_event The opened document event passed by vscode
 */
private _onDidOpenTextDocument(p_document: vscode.TextDocument): void {
    if (
        this.leoStates.leoReady &amp;&amp;
        (
            p_document.uri.fsPath.toLowerCase().endsWith('.leo') ||
            p_document.uri.fsPath.toLowerCase().endsWith('.leojs')
        )
    ) {
        if (!this._hasShownContextOpenMessage) {
            void vscode.window.showInformationMessage(Constants.USER_MESSAGES.RIGHT_CLICK_TO_OPEN);
            this._hasShownContextOpenMessage = true;
        }
    }
}

</t>
<t tx="felix.20220930214434.1">/**
 * * Handle the change of visibility of either goto treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onGotoTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_event.visible) {
        this._leoGotoProvider.setLastGotoView(p_explorerView ? this._leoGotoExplorer : this._leoGoto);
    }
}

</t>
<t tx="felix.20220930214530.1">/**
 * * Handle the change of visibility of either find panel
 * @param p_event The visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onFindViewVisibilityChanged(p_explorerView: boolean): void {
    if (p_explorerView) {
        if (this._findPanelWebviewExplorerView?.visible) {
            this._lastFindView = this._findPanelWebviewExplorerView;
            this.checkForceFindFocus(false);
        }
    } else {
        if (this._findPanelWebviewView?.visible) {
            this._lastFindView = this._findPanelWebviewView;
            this.checkForceFindFocus(false);
        }
    }
}

</t>
<t tx="felix.20220930214929.1">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * @param p_editor The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by LeoJS itself
 */
private _onActiveEditorChanged(
    p_editor: vscode.TextEditor | undefined,
    p_internalCall?: boolean
): void {

    if (p_editor &amp;&amp; p_editor.document.uri.scheme === Constants.URI_LEOJS_SCHEME) {
        if (this.bodyUri.fsPath !== p_editor.document.uri.fsPath) {
            void this._hideDeleteBody(p_editor);
        }
        this._checkPreviewMode(p_editor);
    }
    if (!p_internalCall) {
        void this.triggerBodySave(true, true); // Save in case edits were pending
    }

}

</t>
<t tx="felix.20220930214943.1">/**
 * * Moved a document to another column
 * @param p_columnChangeEvent  event describing the change of a text editor's view column
 */
public _changedTextEditorViewColumn(
    p_columnChangeEvent: vscode.TextEditorViewColumnChangeEvent
): void {
    if (p_columnChangeEvent &amp;&amp; p_columnChangeEvent.textEditor.document.uri.scheme === Constants.URI_LEOJS_SCHEME) {
        this._checkPreviewMode(p_columnChangeEvent.textEditor);
    }
    void this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20220930214948.1">/**
 * * Tabbed on another editor
 * @param p_editors text editor array (to be checked for changes in this method)
 */
public _changedVisibleTextEditors(p_editors: readonly vscode.TextEditor[]): void {
    if (p_editors &amp;&amp; p_editors.length) {
        // May be no changes - so check length
        p_editors.forEach((p_textEditor) =&gt; {
            if (p_textEditor &amp;&amp; p_textEditor.document.uri.scheme === Constants.URI_LEOJS_SCHEME) {
                if (this.bodyUri.fsPath !== p_textEditor.document.uri.fsPath) {
                    void this._hideDeleteBody(p_textEditor);
                }
                this._checkPreviewMode(p_textEditor);
            }
        });
    }
    void this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20220930214953.1">/**
 * * Whole window has been minimized/restored
 * @param p_windowState the state of the window that changed
 */
public _changedWindowState(p_windowState: vscode.WindowState): void {
    // no other action
    void this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20220930214959.1">/**
 * * Handles detection of the active editor's selection change or cursor position
 * @param p_event a change event containing the active editor's selection, if any.
 */
private _onChangeEditorSelection(p_event: vscode.TextEditorSelectionChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEOJS_SCHEME) {
        if (p_event.selections.length) {
            this._selectionDirty = true;
            this._selection = p_event.selections[0];
            this._selectionGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20220930215005.1">/**
 * * Handles detection of the active editor's scroll position changes
 * @param p_event a change event containing the active editor's visible range, if any.
 */
private _onChangeEditorScroll(p_event: vscode.TextEditorVisibleRangesChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEOJS_SCHEME) {
        if (p_event.visibleRanges.length) {
            this._scrollDirty = true;
            this._scroll = p_event.visibleRanges[0];
            this._scrollGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20220930215012.1">/**
 * * Handle typing, undos and read-from-file refreshes that was detected as a document change
 * @param p_textDocumentChange Text changed event passed by vscode
 */
private _onDocumentChanged(p_textDocumentChange: vscode.TextDocumentChangeEvent): void {

    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (
        this.lastSelectedNode &amp;&amp;
        p_textDocumentChange.contentChanges.length &amp;&amp;
        p_textDocumentChange.document.uri.scheme === Constants.URI_LEOJS_SCHEME
    ) {

        // * There was a on a Leo Body by the user OR FROM LEO REFRESH FROM FILE
        this._bodyLastChangedDocument = p_textDocumentChange.document;
        this._bodyLastChangedDocumentSaved = false;
        this._editorTouched = true; // To make sure to transfer content to Leo even if all undone
        this._bodyPreviewMode = false;

        // * If icon should change then do it now (if there's no document edit pending)
        if (
            utils.leoUriToStr(p_textDocumentChange.document.uri) === this.lastSelectedNode.gnx
        ) {
            const w_hasBody = !!p_textDocumentChange.document.getText().length;
            const w_iconChanged = utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody) || this.findFocusTree;

            const c = g.app.windowList[this.frameIndex].c;

            if (c.p &amp;&amp; c.p.__bool__() &amp;&amp; p_textDocumentChange.document.getText() === c.p.b) {
                // WAS NOT A USER MODIFICATION? (external file change, replace, replace-then-find)
                // Set proper cursor insertion point and selection range.
                void this.showBody(false, true, true);
                return;
            }

            if (!this.leoStates.leoChanged || w_iconChanged) {
                // Document pane icon needs refresh (changed) and/or outline icon changed
                void this._bodySaveDocument(p_textDocumentChange.document).then(() =&gt; {
                    // todo : Really saved to node, no need to set dirty or hasbody -&gt; Check &amp; test to see if icon changes!
                    // if (this.lastSelectedNode) {
                    //     this.lastSelectedNode.dirty = true;
                    //     this.lastSelectedNode.hasBody = w_hasBody;
                    // }
                    if (w_iconChanged) {
                        this.findFocusTree = false;
                        // NOT incrementing this.treeID to keep ids intact
                        // NoReveal since we're keeping the same id.
                        this._refreshOutline(false, RevealType.NoReveal);
                    }
                });

                if (!this.leoStates.leoChanged) {
                    // also refresh document panel (icon may be dirty now)
                    this.refreshDocumentsPane();
                }
            }
        }

        // * If body changed a line with and '@' directive refresh body states
        let w_needsRefresh = false;
        p_textDocumentChange.contentChanges.forEach(p_contentChange =&gt; {
            if (p_contentChange.text.includes('@')) {
                // There may have been an @
                w_needsRefresh = true;
            }
        });

        const w_textEditor = vscode.window.activeTextEditor;

        if (w_textEditor &amp;&amp; p_textDocumentChange.document.uri.fsPath === w_textEditor.document.uri.fsPath) {
            w_textEditor.selections.forEach(p_selection =&gt; {
                // TRY TO DETECT IF LANGUAGE RESET NEEDED!
                let w_line = w_textEditor.document.lineAt(p_selection.active.line).text;
                if (w_line.trim().startsWith('@') || w_line.includes('language') || w_line.includes('killcolor') || w_line.includes('nocolor-node')) {
                    w_needsRefresh = true;
                }
            });
        }
        if (w_needsRefresh) {
            this.debouncedRefreshBodyStates(1);
        }

    }
}

</t>
<t tx="felix.20220930215020.1">/**
 * * Capture instance for further calls on find panel webview
 * @param p_panel The panel (usually that got the latest onDidReceiveMessage)
 */
public setFindPanel(p_panel: vscode.WebviewView): void {
    if (p_panel.viewType === Constants.FIND_EXPLORER_ID) {
        // Explorer find panel
        this._lastFindView = this._findPanelWebviewExplorerView;
        this._findPanelWebviewExplorerView = p_panel;
        this._context.subscriptions.push(
            p_panel.onDidChangeVisibility(() =&gt;
                this._onFindViewVisibilityChanged(true)
            ));
    } else {
        // Leo Pane find panel
        this._findPanelWebviewView = p_panel;
        this._lastFindView = this._findPanelWebviewView;
        this._context.subscriptions.push(
            p_panel.onDidChangeVisibility(() =&gt;
                this._onFindViewVisibilityChanged(false)
            ));
    }
    this.checkForceFindFocus(true);
}

</t>
<t tx="felix.20220930215434.1">/**
 * * Places selection on the required node with a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_frame Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_frame: LeoFrame): void {
    if (this._leoDocumentsRevealTimer) {
        clearTimeout(this._leoDocumentsRevealTimer);
    }
    this._leoDocumentsRevealTimer = setTimeout(() =&gt; {
        if (!this._leoDocuments.visible &amp;&amp; !this._leoDocumentsExplorer.visible) {
            return;
        }
        let w_trigger = false;
        let w_docView: undefined | vscode.TreeView&lt;LeoFrame&gt;;
        if (this._leoDocuments.visible &amp;&amp; this._lastLeoDocuments === this._leoDocuments) {
            w_docView = this._leoDocuments;
        } else if (this._leoDocumentsExplorer === this._lastLeoDocuments) {
            w_docView = this._leoDocumentsExplorer;
        }
        if (!w_docView) {
            return;
        }
        if (w_docView.selection.length &amp;&amp; w_docView.selection[0] === p_frame) {
            // console.log('already selected!');
        } else {
            w_trigger = true;
        }
        if (w_trigger) {
            w_docView.reveal(p_frame, { select: true, focus: false })
                .then(
                    (p_result) =&gt; {
                        // Shown document node
                    },
                    (p_reason) =&gt; {
                        console.log('shown doc error on reveal: ', p_reason);
                    }
                );
        }
    }, 0);
}

</t>
<t tx="felix.20220930215533.1"></t>
<t tx="felix.20220930215540.1">/**
 * * highlights the current undo state without disturbing focus
 * @param p_undoNode Node instance in the Leo History view to be the 'selected' one.
 */
private _setUndoSelection(p_undoNode: LeoUndoNode): void {
    if (this._lastLeoUndos &amp;&amp; this._lastLeoUndos.visible) {
        this._lastLeoUndos.reveal(p_undoNode, { select: true, focus: false }).then(
            () =&gt; { }, // Ok - do nothing
            (p_error) =&gt; {
                console.log('setUndoSelection could not reveal');
            }
        );
    }
}

</t>
<t tx="felix.20220930215747.1">/**
 * * Reverts to a particular undo bead state
 */
public revertToUndo(p_undo: LeoUndoNode): Promise&lt;any&gt; {

    if (p_undo.contextValue !== Constants.CONTEXT_FLAGS.UNDO_BEAD) {
        return Promise.resolve();
    }
    let action = "redo"; // Constants.LEOBRIDGE.REDO;
    let repeat = p_undo.beadIndex;
    if (p_undo.beadIndex &lt;= 0) {
        action = "undo"; // Constants.LEOBRIDGE.UNDO;
        repeat = (-p_undo.beadIndex) + 1;
    }
    const c = g.app.windowList[this.frameIndex].c;
    const u = c.undoer;
    for (let x = 0; x &lt; repeat; x++) {
        if (action === "redo") {
            if (u.canRedo()) {
                u.redo();
            }
        } else if (action === "undo") {
            if (u.canUndo()) {
                u.undo();
            }
        }
    }
    this.setupRefresh(
        Focus.Outline,
        {
            tree: true,
            body: true,
            documents: true,
            states: true,
            buttons: true,
        }
    );
    return Promise.resolve(this.launchRefresh());
}

</t>
<t tx="felix.20220930222931.1">/**
 * Check if search input should be forced-focused again
 */
public checkForceFindFocus(p_fromInit: boolean): void {
    if (this._findNeedsFocus) {
        this._findNeedsFocus = false; // Set false before timeout.
        setTimeout(() =&gt; {
            let w_panel: vscode.WebviewView | undefined;
            if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
                w_panel = this._findPanelWebviewView;
            } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
                w_panel = this._findPanelWebviewExplorerView;
            }
            if (w_panel) {
                this._findNeedsFocus = false; // Set false ALSO AFTER !
                void w_panel.webview.postMessage({ type: 'selectFind' });
            }
        }, 60);
    }
}

</t>
<t tx="felix.20221001002338.1">/**
 * * Public method exposed as 'refreshButtonsPane' setter/getter to refresh the buttons pane
 * Buttons Panel May be refreshed by other services (states service, ...)
 */
private _refreshButtonsPane(): void {
    this._leoButtonsProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20221002011858.1">/**
 * * Closes all visible text editors that have Leo filesystem scheme (that are not dirty)
 */
async function closeLeoTextEditors(): Promise&lt;unknown&gt; {
    const w_foundTabs: vscode.Tab[] = [];

    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {

            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEOJS_SCHEME &amp;&amp;
                !p_tab.isDirty

            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        for (const p_tab of w_foundTabs) {
            if (p_tab.input) {
                await vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                await vscode.workspace.applyEdit(w_edit);
            }
        }
    } else {
        q_closedTabs = Promise.resolve(true);
    }
    return q_closedTabs;
}

</t>
<t tx="felix.20221002011903.1">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns A promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Thenable&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leojs first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            void vscode.window.showInformationMessage(`leojs upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}

</t>
<t tx="felix.20221002124249.1">/**
 * * Opens quickPick minibuffer pallette to choose from all commands in this file's commander
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
private async _showMinibufferHistory(p_choices: vscode.QuickPickItem[]): Promise&lt;unknown&gt; {

    // Wait for _isBusyTriggerSave resolve because the full body save may change available commands
    await this.triggerBodySave(true);

    const c = g.app.windowList[this.frameIndex].c;

    if (!c.commandHistory.length) {
        return;
    }
    // Build from list of strings (labels).
    let w_commandList: vscode.QuickPickItem[] = [];
    for (const w_command of c.commandHistory) {
        let w_found = false;
        for (const w_pick of p_choices) {
            if (w_pick.label === w_command) {
                w_commandList.push(w_pick);
                w_found = true;
                break;
            }
        }
        if (!w_found) {
            w_commandList.push({
                label: w_command,
                description: Constants.USER_MESSAGES.MINIBUFFER_BAD_COMMAND,
                detail: `No command function for ${w_command}`
            });
        }
    }
    if (!w_commandList.length) {
        return;
    }
    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
        matchOnDetail: true,
    };
    const w_picked = await vscode.window.showQuickPick(w_commandList, w_options);
    return this._doMinibufferCommand(w_picked);
}

</t>
<t tx="felix.20221002124535.1">/**
 * * Perform chosen minibuffer command
 */
private _doMinibufferCommand(p_picked?: vscode.QuickPickItem): Promise&lt;unknown&gt; {
    if (p_picked &amp;&amp; p_picked.label) {
        // Setup refresh
        this.setupRefresh(Focus.NoChange,
            {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true
            }
        );

        this._addToMinibufferHistory(p_picked);
        const c = g.app.windowList[this.frameIndex].c;

        let w_command = p_picked.label; // May be overriden with async commands

        // * LEOJS : OVERRIDE with custom async commands where applicable
        if (Constants.MINIBUFFER_OVERRIDDEN_NAMES[p_picked.label]) {
            w_command = Constants.MINIBUFFER_OVERRIDDEN_NAMES[p_picked.label];
        }

        const w_commandResult = c.executeMinibufferCommand(w_command);

        if (w_commandResult &amp;&amp; w_commandResult.then) {
            // IS A PROMISE so tack-on the launchRefresh to its '.then' chain. 
            void (w_commandResult as Thenable&lt;unknown&gt;).then((p_result) =&gt; {
                void this.launchRefresh();
            });
        } else {
            void this.launchRefresh();
        }
        // In both cases, return the result, or if a promise: the promise itself, not the result.
        return Promise.resolve(w_commandResult);

    } else {
        // Canceled
        return Promise.resolve(undefined);
    }
}

</t>
<t tx="felix.20221004234249.1">/**
 * Used mostly for leojsOutline ViewsWelcome content
 */
private _leojsStartupDone: boolean = false;
get leojsStartupDone(): boolean {
    return this._leojsStartupDone;
}
set leojsStartupDone(p_value: boolean) {
    this._leojsStartupDone = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_STARTUP_DONE, p_value);
}

</t>
<t tx="felix.20221005002719.1">function setStartupDoneContext(p_value: boolean): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, Constants.CONTEXT_FLAGS.LEO_STARTUP_DONE, p_value);
}

</t>
<t tx="felix.20221009011653.1">export interface CommandOptions {
    node?: Position, // facultative, precise node onto which the command is run (also see p_keepSelection)
    refreshType: ReqRefresh, // Object containing flags for sections needing to refresh after command ran
    finalFocus: Focus, // final focus placement
    keepSelection?: boolean, // flag to bring back selection on the original node
    isNavigation?: boolean // Navigation commands force-show the body and outline
}

</t>
<t tx="felix.20221009233703.1">/**
 * List of command names for both categories of possible offsets when keeping selection.
 */
public static OLD_POS_OFFSETS = {
    DELETE: ["cut-node", "delete-node"],
    ADD: ["clone-node", "async-paste-node", "async-paste-retaining-clones"]
};

</t>
<t tx="felix.20221026222034.1">public set_focus(commander: Commands, widget: any): void {
    this.focusWidget = widget;
    const w_widgetName = this.widget_name(widget);
    // * LeoJS custom finalFocus replacement.
    if (widget &amp;&amp; this.finalFocus === Focus.NoChange) {
        // * Check which panel to focus
        let w_target = Focus.NoChange;
        if (w_widgetName === 'body') {
            w_target = Focus.Body;
        } else if (w_widgetName === 'tree') {
            w_target = Focus.Outline;
        }
        this.setupRefresh(w_target);
    } else {
        // pass
    }
}

</t>
<t tx="felix.20221026222040.1">public get_focus(c?: Commands): StringTextWrapper {
    return this.focusWidget!;
}

</t>
<t tx="felix.20221027153815.1">public widget_name(w: any): string {
    let name: string;
    if (!w) {
        name = '&lt;no widget&gt;';
    } else if (w['getName']) {
        name = w.getName();
    } else if (w['objectName']) {
        name = w.objectName();
    } else if (w['_name']) {
        name = w._name;
    } else if (w['name']) {
        name = w.name;
    } else {
        name = w.toString();
    }
    return name;
}

</t>
<t tx="felix.20221027155442.1">export const enum LeoGotoNavKey {
    prev = 0,
    next,
    first,
    last
}

</t>
<t tx="felix.20221027155905.1">/**
 * * Goto the next, previous, first or last nav entry via arrow keys in
 */
public navigateNavEntry(p_nav: LeoGotoNavKey): void {
    void this._leoGotoProvider.navigateNavEntry(p_nav);
}

</t>
<t tx="felix.20221027230322.1">/**
 * * Build all possible strings for undo icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the undo tree view
 */
export function buildUndoIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_UNDO_ACTIVE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_UNDO_ACTIVE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_UNDO),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_UNDO)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_REDO_ACTIVE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_REDO_ACTIVE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_REDO),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_REDO)
        }
    ];
}

</t>
<t tx="felix.20221101220727.1">/**
 * Set filename as description
 */
public refreshDesc(): void {
    let titleDesc = "";

    if (this.leoStates.fileOpenedReady) {

        const s = this.leoStates.leoOpenedFileName;
        const w_filename = s ? utils.getFileFromPath(s) : Constants.UNTITLED_FILE_NAME;
        let w_path = "";
        const n = s ? s.lastIndexOf(w_filename) : -1;
        if (n &gt;= 0 &amp;&amp; n + w_filename.length &gt;= s.length) {
            w_path = s.substring(0, n);
        }
        titleDesc = w_filename + (w_path ? " in " + w_path : '');

        // const c = g.app.windowList[this.frameIndex].c;
        // titleDesc = c.frame.title;

        if (this._leoTreeView) {
            this._leoTreeView.description = titleDesc;
        }
        if (this._leoTreeExView) {
            this._leoTreeExView.description = titleDesc;
        }
    }
    if (this._leoTreeView.description === titleDesc) {
        return;
    }
    if (this._leoTreeView) {
        this._leoTreeView.description = titleDesc;
    }
    if (this._leoTreeExView) {
        this._leoTreeExView.description = titleDesc;
    }

    // * FROM LEO SERVER this is used to make _titleDesc
    // fileName = c.fileName()
    // branch, commit = g.gitInfoForFile(fileName)


    // * FROM LEOINTEG:

    // if (this.leoStates.fileOpenedReady) {

    //     if (this.config.showBranchInOutlineTitle) {
    //         this.sendAction(
    //             Constants.LEOBRIDGE.GET_BRANCH
    //         ).then(
    //             (p_result: LeoBridgePackage) =&gt; {
    //                 let w_branch = "";
    //                 if (p_result &amp;&amp; p_result.branch) {
    //                     w_branch = p_result.branch + ": ";
    //                 }

    //                 if (this._leoTreeView) {
    //                     this._leoTreeView.description = w_branch + this._titleDesc;
    //                 }
    //                 if (this._leoTreeExView) {
    //                     this._leoTreeExView.description = w_branch + this._titleDesc;
    //                 }
    //             }
    //         );
    //     } else {
    //         if (this._leoTreeView) {
    //             this._leoTreeView.description = this._titleDesc;
    //         }
    //         if (this._leoTreeExView) {
    //             this._leoTreeExView.description = this._titleDesc;
    //         }
    //     }

    // } else {
    //     if (this._leoTreeView) {
    //         this._leoTreeView.description = "";
    //     }
    //     if (this._leoTreeExView) {
    //         this._leoTreeExView.description = "";
    //     }
    // }

}

</t>
<t tx="felix.20221106230554.1">/**
 * Handle a successful find match.
 */
public show_find_success(c: Commands, in_headline: boolean, insert: number, p: Position): void {
    // TODO : see focus_to_body !
    // TODO : USE ONLY 'WRAPPER' OR 'WIDGET' like in show_find_success!
    if (in_headline) {
        // edit_widget(p)
        // c.frame.edit_widget(p);
        // console.log('try to set');
        try {
            g.app.gui.set_focus(c, c.frame.tree.edit_widget(p));
        }
        catch (e) {
            console.log('oops!', e);

        }
        // g.app.gui.set_focus(c, { _name: 'tree' });
    } else {
        try {
            g.app.gui.set_focus(c, c.frame.body.widget);
        }
        catch (e) {
            console.log('oops!', e);
        }
    }

    // edit_widget
    // ? needed ?

    // trace = False and not g.unitTesting
    // if in_headline:
    //     if trace:
    //         g.trace('HEADLINE', p.h)
    //     c.frame.tree.widget.select_leo_node(p)
    //     self.focus_to_head(c, p)  # Does not return.
    // else:
    //     w = c.frame.body.widget
    //     row, col = g.convertPythonIndexToRowCol(p.b, insert)
    //     if trace:
    //         g.trace('BODY ROW', row, p.h)
    //     w.cursor_line = row
    //     self.focus_to_body(c)  # Does not return.
}

</t>
<t tx="felix.20221108222157.1">{
  "command": "leojs.hoistNode",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leojs.hoistSelection",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanHoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leojs.hoistSelectionFromOutline",
  "category": "Leojs",
  "title": "Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanHoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leojs.deHoist",
  "category": "Leojs",
  "title": "De-Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanDehoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leojs.deHoistFromOutline",
  "category": "Leojs",
  "title": "De-Hoist",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCanDehoist &amp;&amp; !leojsTopHoistChapter",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leojs.chapterNext",
  "category": "Leojs",
  "title": "Chapter Next",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/chapter-next.svg",
    "dark": "resources/dark/chapter-next.svg"
  }
},
{
  "command": "leojs.chapterBack",
  "category": "Leojs",
  "title": "Chapter Back",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/chapter-back.svg",
    "dark": "resources/dark/chapter-back.svg"
  }
},
{
  "command": "leojs.chapterMain",
  "category": "Leojs",
  "title": "Chapter Main",
  "enablement": "leojsTreeOpened &amp;&amp; leojsTopHoistChapter",
  "icon": {
    "light": "resources/light/chapter-main.svg",
    "dark": "resources/dark/chapter-main.svg"
  }
},
{
  "command": "leojs.chapterSelect",
  "category": "Leojs",
  "title": "Chapter Select",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/chapter-select.svg",
    "dark": "resources/dark/chapter-select.svg"
  }
},
</t>
<t tx="felix.20221112230919.1">"editor/title": [
  {
    "command": "leojs.prev",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.next",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leojs.executeScript",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leojs.extract",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leojs.extractNames",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leojs.importAnyFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leojs.chapterSelect",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@7"
  },
  {
    "command": "leojs.writeDirtyAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leojs.refreshFromDiskSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leojs.showSettingsPage",
    "when": "resourceScheme == leojs",
    "group": "1_leojs@1"
  },
  {
    "command": "leojs.showLogPane",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs@2"
  },
  {
    "command": "leojs.newLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs1@1"
  },
  {
    "command": "leojs.openLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsReady",
    "group": "1_leojs1@2"
  },
  {
    "command": "leojs.saveLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs1@3"
  },
  {
    "command": "leojs.saveAsLeoFile",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs1@4"
  },
  {
    "command": "leojs.sortChildrenSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@1"
  },
  {
    "command": "leojs.sortSiblingsSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@2"
  },
  {
    "command": "leojs.promoteSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@3"
  },
  {
    "command": "leojs.demoteSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs2@4"
  },
  {
    "command": "leojs.cloneNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@1"
  },
  {
    "command": "leojs.cutNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@2"
  },
  {
    "command": "leojs.copyNodeSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@3"
  },
  {
    "command": "leojs.pasteNodeAtSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@4"
  },
  {
    "command": "leojs.pasteNodeAsCloneAtSelection",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs3@5"
  },
  {
    "command": "leojs.readFileIntoNode",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@2"
  },
  {
    "command": "leojs.writeFileFromNode",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@3"
  },
  {
    "command": "leojs.writeAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@4"
  },
  {
    "command": "leojs.writeDirtyAtFileNodes",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs4@5"
  },
  {
    "command": "leojs.cloneFindAll",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@1"
  },
  {
    "command": "leojs.cloneFindAllFlattened",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@2"
  },
  {
    "command": "leojs.cloneFindMarked",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@3"
  },
  {
    "command": "leojs.cloneFindFlattenedMarked",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@4"
  },
  {
    "command": "leojs.cloneFindParents",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@5"
  },
  {
    "command": "leojs.cloneFindTag",
    "when": "resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "1_leojs5@6"
  }
],
</t>
<t tx="felix.20221113002623.1">public showSettings(): void {
    void this.leoSettingsWebview.openWebview();
}
</t>
<t tx="felix.20221113165005.1">"editor/context": [
  {
    "command": "leojs.findVar",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.findDef",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.extract",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leojs.extractNames",
    "when": "editorHasSelection &amp;&amp; !editorHasMultipleSelections &amp;&amp; resourceScheme == leojs &amp;&amp; leojsTreeOpened",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20221113221607.1">/**
 * * Public method exposed as 'refreshGotoPane' setter/getter to refresh the Goto pane
 * Goto Panel May be refreshed by other services (states service, ...)
 */
private _refreshGotoPane(): void {
    this._leoGotoProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20221113232048.1">{
  "command": "leojs.startSearch",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Start Search"
},
{
  "command": "leojs.searchBackward",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Search Backward"
},
{
  "command": "leojs.reSearch",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Regexp Search"
},
{
  "command": "leojs.reSearchBackward",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Regexp Search Backward"
},
{
  "command": "leojs.wordSearch",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Word Search"
},
{
  "command": "leojs.wordSearchBackward",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Word Search Backward"
},
{
  "command": "leojs.findAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find All"
},
{
  "command": "leojs.findNext",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Next"
},
{
  "command": "leojs.findNextFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Next",
  "icon": {
    "light": "resources/light/find-next.svg",
    "dark": "resources/dark/find-next.svg"
  }
},
{
  "command": "leojs.findPrevious",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Previous"
},
{
  "command": "leojs.findPreviousFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find Previous",
  "icon": {
    "light": "resources/light/find-previous.svg",
    "dark": "resources/dark/find-previous.svg"
  }
},
{
  "command": "leojs.findVar",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Find the var under the cursor"
},
{
  "command": "leojs.findDef",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Definition",
  "title": "Find the def or class under the cursor"
},
{
  "command": "leojs.replace",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace"
},
{
  "command": "leojs.replaceFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace"
},
{
  "command": "leojs.replaceThenFind",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace Then Find"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace Then Find"
},
{
  "command": "leojs.replaceAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Replace All"
},
{
  "command": "leojs.gotoGlobalLine",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Goto Global Line"
},
{
  "command": "leojs.setFindEverywhereOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Everywhere",
  "title": "Set Find Everywhere Option"
},
{
  "command": "leojs.setFindNodeOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in Node",
  "title": "Set Find in Node Only Option"
},
{
  "command": "leojs.setFindFileOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in External Files",
  "title": "Set Find in External Files Only Option"
},
{
  "command": "leojs.setFindSuboutlineOnlyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find in SubOutline",
  "title": "Set Find in SubOutline Only Option"
},
{
  "command": "leojs.toggleFindIgnoreCaseOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Ignore Case",
  "title": "Toggle Find Ignore Case Option"
},
{
  "command": "leojs.toggleFindMarkChangesOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Mark Changes",
  "title": "Toggle Find Mark Changes Option"
},
{
  "command": "leojs.toggleFindMarkFindsOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Mark Finds",
  "title": "Toggle Find Mark Finds Option"
},
{
  "command": "leojs.toggleFindRegexpOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find RegExp",
  "title": "Toggle Find RegExp Option"
},
{
  "command": "leojs.toggleFindWordOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Whole Word",
  "title": "Toggle Find Whole Word Option"
},
{
  "command": "leojs.toggleFindSearchBodyOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Search Body",
  "title": "Toggle Find Search Body Option"
},
{
  "command": "leojs.toggleFindSearchHeadlineOption",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "Find Search Headline",
  "title": "Toggle Find Search Headline Option"
},
{
  "command": "leojs.cloneFindAll",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cfa",
  "title": "Clone Find All"
},
{
  "command": "leojs.cloneFindAllFlattened",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cff",
  "title": "Clone Find All Flattened"
},
{
  "command": "leojs.cloneFindMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cfam",
  "title": "cfam - Clone Find All Marked Nodes"
},
{
  "command": "leojs.cloneFindFlattenedMarked",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cffm",
  "title": "cffm - Clone Find Flattened Marked"
},
{
  "command": "leojs.cloneFindParents",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsCloned",
  "title": "Clone Find Parents"
},
{
  "command": "leojs.cloneFindTag",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "shortTitle": "cft",
  "title": "Clone Find Tag"
},
</t>
<t tx="felix.20221113232103.1">{
  "command": "leojs.findQuick",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Focus on Nav tab"
},
{
  "command": "leojs.goAnywhere",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Go Anywhere"
},
{
  "command": "leojs.gotoNavPrev",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Previous Goto Result"
},
{
  "command": "leojs.gotoNavNext",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Next Goto Result"
},
{
  "command": "leojs.gotoNavFirst",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select First Goto Result"
},
{
  "command": "leojs.gotoNavLast",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Select Last Goto Result"
},
{
  "command": "leojs.findQuickSelected",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Nav search with current selection",
  "icon": {
    "light": "resources/light/find-quick-selected.svg",
    "dark": "resources/dark/find-quick-selected.svg"
  }
},
{
  "command": "leojs.findQuickTimeline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List timeline of nodes in reverse gnx order",
  "icon": {
    "light": "resources/light/find-quick-timeline.svg",
    "dark": "resources/dark/find-quick-timeline.svg"
  }
},
{
  "command": "leojs.findQuickChanged",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List all changed/dirty nodes",
  "icon": {
    "light": "resources/light/find-quick-changed.svg",
    "dark": "resources/dark/find-quick-changed.svg"
  }
},
{
  "command": "leojs.history",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List visited nodes from history",
  "icon": {
    "light": "resources/light/find-quick-history.svg",
    "dark": "resources/dark/find-quick-history.svg"
  }
},
{
  "command": "leojs.markedList",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "List all marked nodes",
  "icon": {
    "light": "resources/light/find-quick-marked.svg",
    "dark": "resources/dark/find-quick-marked.svg"
  }
}
</t>
<t tx="felix.20221113232519.1">{
  "command": "leojs.tagChildren",
  "category": "Leojs",
  "enablement": "leojsTreeOpened &amp;&amp; leojsChild",
  "title": "Tag Children"
},
{
  "command": "leojs.tagNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Tag Node"
},
{
  "command": "leojs.removeTag",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Tag"
},
{
  "command": "leojs.removeTags",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove All Tags"
},
</t>
<t tx="felix.20221114213948.1">{
  "command": "leojs.importAnyFile",
  "title": "Import File",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "icon": {
    "light": "resources/light/import.svg",
    "dark": "resources/dark/import.svg"
  }
},
{
  "command": "leojs.readFileIntoNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Read File Into Node..."
},
{
  "command": "leojs.exportHeadlines",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Export Outline..."
},
{
  "command": "leojs.flattenOutline",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Flatten Selected Outline..."
},
{
  "command": "leojs.outlineToCweb",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Outline to CWEB..."
},
{
  "command": "leojs.outlineToNoweb",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Outline to Noweb..."
},
{
  "command": "leojs.removeSentinels",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Remove Sentinels..."
},
{
  "command": "leojs.weave",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Weave..."
},
{
  "command": "leojs.writeFileFromNode",
  "category": "Leojs",
  "enablement": "leojsTreeOpened",
  "title": "Write File From Node..."
},
</t>
<t tx="felix.20221114220040.1">[CMD.IMPORT_ANY_FILE, () =&gt; p_leoUI.command(LEOCMD.IMPORT_ANY_FILE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.READ_FILE_INTO_NODE, () =&gt; p_leoUI.command(LEOCMD.READ_FILE_INTO_NODE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.EXPORT_HEADLINES, () =&gt; p_leoUI.command(LEOCMD.EXPORT_HEADLINES, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.FLATTEN_OUTLINE, () =&gt; p_leoUI.command(LEOCMD.FLATTEN_OUTLINE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.OUTLINE_TO_CWEB, () =&gt; p_leoUI.command(LEOCMD.OUTLINE_TO_CWEB, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.OUTLINE_TO_NOWEB, () =&gt; p_leoUI.command(LEOCMD.OUTLINE_TO_NOWEB, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.REMOVE_SENTINELS, () =&gt; p_leoUI.command(LEOCMD.REMOVE_SENTINELS, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.WEAVE, () =&gt; p_leoUI.command(LEOCMD.WEAVE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.WRITE_FILE_FROM_NODE, () =&gt; p_leoUI.command(LEOCMD.WRITE_FILE_FROM_NODE, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

</t>
<t tx="felix.20221115214948.1">{
  "command": "leojs.goAnywhere",
  "key": "ctrl+p",
  "mac": "cmd+p",
  "when": "config.leojs.goAnywhereShortcut &amp;&amp; leojsEditHeadline || config.leojs.goAnywhereShortcut &amp;&amp; leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/ || config.leojs.goAnywhereShortcut &amp;&amp; leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leojsEditHeadline || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.findNextFromOutline",
  "key": "f3",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.findNext",
  "key": "f3",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.findPreviousFromOutline",
  "key": "f2",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.findPrevious",
  "key": "f2",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replace",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replaceFromOutline",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.replaceThenFind",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/"
},
{
  "command": "leojs.gotoGlobalLine",
  "key": "alt+g",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindFileOnlyOption",
  "key": "ctrl+alt+l",
  "mac": "cmd+alt+l",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
{
  "command": "leojs.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leojsEditHeadline || leojsFindFocus || leojsTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leojs/ || leojsTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leojs"
},
</t>
<t tx="felix.20221115220743.1">{
  "command": "leojs.findNextFromOutline",
  "when": "false"
},
{
  "command": "leojs.findPreviousFromOutline",
  "when": "false"
},
{
  "command": "leojs.replaceFromOutline",
  "when": "false"
},
{
  "command": "leojs.replaceThenFindFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20221115230034.1">/**
 * * VSCode Wrapper for showInputBox, or, for showQuickPick if tabList is given.
 */
public get1Arg(
    options?: vscode.InputBoxOptions | vscode.QuickPickOptions,
    token?: vscode.CancellationToken,
    tabList?: string[]
): Thenable&lt;string | undefined&gt; {
    if (tabList) {
        const itemList: vscode.QuickPickItem[] = tabList.map(
            (entry) =&gt; { return { label: entry }; }
        );
        return vscode.window.showQuickPick(itemList, options).then(
            (p_picked) =&gt; {
                if (p_picked &amp;&amp; p_picked.label) {
                    return p_picked.label;
                }
                return undefined;
            }
        );
    } else {
        return vscode.window.showInputBox(options, token);
    }
}

</t>
<t tx="felix.20221119204248.1"></t>
<t tx="felix.20221130233817.1">/**
 * * Adds entries in _openedBodiesGnx and _openedBodiesInfo if needed
 * * and sets the modified time of an opened body.
 */
private _setOpenedBodyTime(p_gnx: string): void {
    const w_now = new Date().getTime();
    let w_created = w_now;
    if (!this._openedBodiesGnx.includes(p_gnx)) {
        this._openedBodiesGnx.push(p_gnx);
    } else {
        w_created = this._openedBodiesInfo[p_gnx].ctime; // Already created?
    }
    this._openedBodiesInfo[p_gnx] = {
        ctime: w_created, // w_now, // maybe kept.
        mtime: w_now // new 'modified' time for sure.
    };
}

</t>
<t tx="felix.20221206201231.1">/**
 * Mimic vscode's CTRL+P to find any position by it's headline
 */
public async goAnywhere(): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    const allPositions: { label: string; description?: string; position?: Position; }[] = [];
    // Options for date to look like : Saturday, September 17, 2016
    const w_dateOptions: Intl.DateTimeFormatOptions = { weekday: "long", year: 'numeric', month: "long", day: 'numeric' };
    const c = g.app.windowList[this.frameIndex].c;

    // 'true' parameter because each position is kept individually for the time the QuickPick control is opened
    for (const p_position of c.all_unique_positions(true)) {

        let w_description = p_position.gnx; // Defaults as gnx.
        const w_gnxParts = w_description.split('.');
        if (w_gnxParts.length === 3 &amp;&amp; w_gnxParts[1].length === 14) {
            // legit 3 part gnx
            const dateString = w_gnxParts[1];
            const w_year = +dateString.substring(0, 4); // unary + operator to convert the strings to numbers.
            const w_month = +dateString.substring(4, 6);
            const w_day = +dateString.substring(6, 8);
            const w_date = new Date(w_year, w_month - 1, w_day);
            w_description = `by ${w_gnxParts[0]} on ${w_date.toLocaleDateString("en-US", w_dateOptions)}`;
        }
        allPositions.push({
            label: p_position.h,
            position: p_position,
            description: w_description
        });

    }
    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.SEARCH_POSITION_BY_HEADLINE
    };

    const p_picked = await vscode.window.showQuickPick(allPositions, w_options);

    if (p_picked &amp;&amp; p_picked.label &amp;&amp; p_picked.position) {
        if (c.positionExists(p_picked.position)) {
            c.selectPosition(p_picked.position);  // set this node as selection
        }
        this.setupRefresh(
            Focus.Body, // Finish in body pane given explicitly because last focus was in input box.
            {
                tree: true,
                body: true,
                // documents: false,
                // buttons: false,
                states: true,
            }
        );
        void this.launchRefresh();
    }

    return Promise.resolve(undefined); // Canceled

}

</t>
<t tx="felix.20221207231723.1">{
  "command": "workbench.files.action.collapseExplorerFolders",
  "key": "alt+-",
  "when": "config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == untitled || config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == file || config.leojs.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; explorerViewletFocus"
},
{
  "command": "workbench.view.extension.leojsView",
  "key": "ctrl+shift+l",
  "when": "config.leojs.activityViewShortcut &amp;&amp; !editorHasSelection &amp;&amp; !inSearchEditor &amp;&amp; focusedView != workbench.view.search"
}
</t>
<t tx="felix.20221213210705.1">{
  "command": "leojs.revertToUndo",
  "when": "leojsTreeOpened &amp;&amp; viewItem =~ /^leojsUndoNode/",
  "group": "leojsUndosContext1@1"
}
</t>
<t tx="felix.20221214003903.1">/**
 * * Looks for c.p coloring language, taking account of '@killcolor', etc.
 */
private _getBodyLanguage(): string {
    const c = g.app.windowList[this.frameIndex].c;
    const p = c.p;
    let w_language = "plain";

    if (g.useSyntaxColoring(p)) {
        const aList = g.get_directives_dict_list(p);
        const d = g.scanAtCommentAndAtLanguageDirectives(aList);
        w_language =
            (d &amp;&amp; d['language'])
            || g.getLanguageFromAncestorAtFileNode(p)
            || c.config.getLanguage('target-language')
            || 'plain';

        w_language = w_language.toLowerCase();
    }
    return w_language;
}

</t>
<t tx="felix.20221222003636.1">/**
 * * Clears the nav search results of the goto pane
 */
public navTextClear(): void {

    const c = g.app.windowList[this.frameIndex].c;
    const scon: QuickSearchController = c.quicksearchController;

    scon.clear();

    this._leoGotoProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20221227223718.1">private _get_focus(): string {
    const c = g.app.windowList[this.frameIndex].c;
    const w = g.app.gui.get_focus(c);
    const focus = g.app.gui.widget_name(w);
    return focus;
}

</t>
<t tx="felix.20230109233134.1">/**
 * Put focus in body widget.
 */
public focus_to_body(c: Commands, p: Position): void {
    // TODO : see show_find_success !
    // TODO : USE ONLY 'WRAPPER' OR 'WIDGET' like in show_find_success!
    this.set_focus(c, c.frame.body.wrapper);
}
</t>
<t tx="felix.20230109233154.1">/**
 * Put focus in tree widget.
 */
public focus_to_head(c: Commands, p: Position): void {
    this.set_focus(c, c.frame.tree.treeWidget);
}
</t>
<t tx="felix.20230112203533.1">/**
 * Utility to convert a string index into a line, col dict
 */
private _row_col_pv_dict(i: number, s: string): { line: number, col: number, index: number } {
    if (!i) {
        i = 0; // prevent none type
    }
    // BUG: this uses current selection wrapper only, use
    // g.convertPythonIndexToRowCol instead !
    let line: number;
    let col: number;
    [line, col] = g.convertPythonIndexToRowCol(s, i);
    return { "line": line, "col": col, "index": i };
};

</t>
<t tx="felix.20230112220003.1">/**
 * Converts from wrapper text index to line /col
 */
private _row_col_wrapper_dict(i: number, wrapper: StringTextWrapper): { "line": number, "col": number, "index": number } {
    if (!i) {
        i = 0; // prevent none type
    }
    let line, col;
    [line, col] = wrapper.toPythonIndexRowCol(i);
    return { "line": line, "col": col, "index": i };
}

</t>
<t tx="felix.20230121211548.1">/**
 * Interactive Search to implement search-backward, re-search, word-search. etc.
 */
public async interactiveSearch(p_backward: boolean, p_regex: boolean, p_word: boolean): Promise&lt;unknown&gt; {

    await this.triggerBodySave(true);

    if (p_regex &amp;&amp; p_word) {
        console.error('interactiveSearch called with both "WORD" and "REGEX"');
        return;
    }

    let w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_TITLE;
    let w_searchPrompt = Constants.USER_MESSAGES.INT_SEARCH_PROMPT;
    let w_searchPlaceholder = Constants.USER_MESSAGES.SEARCH_PLACEHOLDER;

    const c = g.app.windowList[this.frameIndex].c;
    const fc = c.findCommands;
    const ftm = fc.ftm;

    if (p_backward) {
        w_searchTitle += Constants.USER_MESSAGES.INT_SEARCH_BACKWARD;
        // Set flag for show_find_options.
        fc.reverse = true;
        // Set flag for do_find_next().
        fc.request_reverse = true;
    }
    if (p_regex) {
        w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_REGEXP + w_searchTitle;
        // Set flag for show_find_options.
        fc.pattern_match = true;
        // Set flag for do_find_next().
        fc.request_pattern_match = true;
    }
    if (p_word) {
        w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_WORD + w_searchTitle;
        // Set flag for show_find_options.
        fc.whole_word = true;
        // Set flag for do_find_next().
        fc.request_whole_word = true;
    }

    fc.show_find_options(); // ! PRINT THEM BUT DONT CHANGE IN FTM/FIND PANEL

    const disposables: vscode.Disposable[] = [];

    // Get value from find panel input
    const w_startValue = this._lastSettingsUsed!.findText === Constants.USER_MESSAGES.FIND_PATTERN_HERE ? '' : this._lastSettingsUsed!.findText;

    try {
        return await new Promise&lt;unknown&gt;((resolve, reject) =&gt; {
            const input = vscode.window.createInputBox();
            input.title = w_searchTitle;
            input.value = w_startValue;
            input.prompt = w_searchPrompt;
            input.placeholder = w_searchPlaceholder;

            this._interactiveSearchOptions = {
                search: "",
                replace: "",
                word: p_word,
                regex: p_regex,
                backward: p_backward
            };

            disposables.push(
                input.onDidAccept(() =&gt; {
                    // utils.setContext(Constants.CONTEXT_FLAGS.INTERACTIVE_SEARCH, false);
                    if (!input.value) {
                        input.hide();
                        return resolve(true); // Cancelled with escape or empty string.
                    }
                    const value = input.value; // maybe this was replace.
                    this._interactiveSearchOptions.search = value;

                    const find_pattern = this._interactiveSearchOptions.search;
                    const change_pattern = this._interactiveSearchOptions.replace;

                    ftm.set_find_text(find_pattern);
                    fc.update_find_list(find_pattern);

                    this.loadSearchSettings(); // * Set vscode's find panel from the Leo find settings
                    fc.init_vim_search(find_pattern);
                    fc.init_in_headline();  // Required.
                    const settings = fc.ftm.get_settings();

                    let p, pos, newpos;
                    [p, pos, newpos] = fc.do_find_next(settings);
                    let w, focus;
                    let found;
                    w = this.get_focus(c); // get focus again after the operation
                    focus = this.widget_name(w);
                    found = p &amp;&amp; p.__bool__();

                    this.findFocusTree = false; // Reset flag for headline range

                    if (!found || !focus) {
                        void vscode.window.showInformationMessage('Not found');
                        return resolve(true);
                    } else {
                        let w_finalFocus = Focus.Body;
                        const w_focus = focus.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_finalFocus = Focus.Outline;
                            this.showOutlineIfClosed = true;
                            // * SETUP HEADLINE RANGE
                            this.findFocusTree = true;
                            this.findHeadlineRange = [w.sel[0], w.sel[1]];
                            this.findHeadlinePosition = c.p;
                        } else {
                            this.showBodyIfClosed = true;
                        }
                        const w_scroll = (found &amp;&amp; w_finalFocus === Focus.Body) || undefined;

                        this.setupRefresh(
                            w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
                            {
                                tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
                                body: true,
                                scroll: w_scroll,
                                // documents: false,
                                // buttons: false,
                                states: true,
                            },
                            this.findFocusTree
                        );
                        void this.launchRefresh();
                        return resolve(true);
                    }

                }),
                input.onDidHide(() =&gt; {
                    // utils.setContext(Constants.CONTEXT_FLAGS.INTERACTIVE_SEARCH, false);
                    return resolve(true);
                })
            );
            if (this._interactiveSearchInputBox) {
                this._interactiveSearchInputBox.dispose(); // just in case.
            }
            this._interactiveSearchInputBox = input;
            this._interactiveSearchInputBox.show();
        });
    } finally {
        disposables.forEach(d =&gt; d.dispose());
        this._interactiveSearchInputBox?.hide();
    }

}

</t>
<t tx="felix.20230121212426.1">[CMD.PREV_NODE, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.PREV_NODE_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_PREV_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],

[CMD.NEXT_NODE, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],
[CMD.NEXT_NODE_FO, () =&gt; p_leoUI.command(LEOCMD.GOTO_NEXT_HISTORY, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Outline })],
</t>
<t tx="felix.20230121212438.1">[CMD.FIND_QUICK, () =&gt; p_leoUI.findQuick()],
[CMD.FIND_QUICK_SELECTED, () =&gt; p_leoUI.findQuickSelected()],
[CMD.FIND_QUICK_TIMELINE, () =&gt; p_leoUI.findQuickTimeline()],
[CMD.FIND_QUICK_CHANGED, () =&gt; p_leoUI.findQuickChanged()],
[CMD.FIND_QUICK_HISTORY, () =&gt; p_leoUI.findQuickHistory()],
[CMD.FIND_QUICK_MARKED, () =&gt; p_leoUI.findQuickMarked()],
[CMD.FIND_QUICK_GO_ANYWHERE, () =&gt; p_leoUI.goAnywhere()],

[CMD.GOTO_NAV_PREV, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.prev)],
[CMD.GOTO_NAV_NEXT, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.next)],
[CMD.GOTO_NAV_FIRST, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.first)],
[CMD.GOTO_NAV_LAST, () =&gt; p_leoUI.navigateNavEntry(LeoGotoNavKey.last)],

[CMD.GOTO_NAV_ENTRY, (p_node: LeoGotoNode) =&gt; p_leoUI.gotoNavEntry(p_node)],

[CMD.START_SEARCH, () =&gt; p_leoUI.command(LEOCMD.START_SEARCH, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.SEARCH_BACKWARD, () =&gt; p_leoUI.command(LEOCMD.SEARCH_BACKWARD, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.RE_SEARCH, () =&gt; p_leoUI.command(LEOCMD.RE_SEARCH, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.RE_SEARCH_BACKWARD, () =&gt; p_leoUI.command(LEOCMD.RE_SEARCH_BACKWARD, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.WORD_SEARCH, () =&gt; p_leoUI.command(LEOCMD.WORD_SEARCH, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.WORD_SEARCH_BACKWARD, () =&gt; p_leoUI.command(LEOCMD.WORD_SEARCH_BACKWARD, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

[CMD.FIND_ALL, () =&gt; p_leoUI.command(LEOCMD.FIND_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],
[CMD.REPLACE_ALL, () =&gt; p_leoUI.command(LEOCMD.REPLACE_ALL, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.NoChange })],

[CMD.FIND_NEXT, () =&gt; p_leoUI.find(false, false)],
[CMD.FIND_NEXT_FO, () =&gt; p_leoUI.find(true, false)],
[CMD.FIND_PREVIOUS, () =&gt; p_leoUI.find(false, true)],
[CMD.FIND_PREVIOUS_FO, () =&gt; p_leoUI.find(true, true)],

[CMD.FIND_VAR, () =&gt; p_leoUI.command(LEOCMD.FIND_VAR, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],
[CMD.FIND_DEF, () =&gt; p_leoUI.command(LEOCMD.FIND_DEF, { refreshType: NO_REFRESH, finalFocus: Focus.NoChange })],

[CMD.REPLACE, () =&gt; p_leoUI.replace(false, false)],
[CMD.REPLACE_FO, () =&gt; p_leoUI.replace(true, false)],
[CMD.REPLACE_THEN_FIND, () =&gt; p_leoUI.replace(false, true)],
[CMD.REPLACE_THEN_FIND_FO, () =&gt; p_leoUI.replace(true, true)],

[CMD.GOTO_GLOBAL_LINE, () =&gt; p_leoUI.command(LEOCMD.GOTO_GLOBAL_LINE, { refreshType: REFRESH_TREE_BODY, finalFocus: Focus.Body })],

[CMD.TAG_CHILDREN, (p_node?: Position) =&gt; p_leoUI.command(LEOCMD.TAG_CHILDREN, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.NoChange, keepSelection: true })],
[CMD.TAG_NODE, (p_node?: Position) =&gt; p_leoUI.command(LEOCMD.TAG_NODE, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.NoChange, keepSelection: true })],
[CMD.REMOVE_TAG, (p_node?: Position) =&gt; p_leoUI.command(LEOCMD.REMOVE_TAG, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.NoChange, keepSelection: true })],
[CMD.REMOVE_TAGS, (p_node?: Position) =&gt; p_leoUI.command(LEOCMD.REMOVE_ALL_TAGS, { node: p_node, refreshType: REFRESH_TREE, finalFocus: Focus.NoChange, keepSelection: true })],

</t>
<t tx="felix.20230222212520.1">/**
 * Add to the minibuffer history (without duplicating entries)
 */
private _addToMinibufferHistory(p_command: vscode.QuickPickItem): void {
    const c = g.app.windowList[this.frameIndex].c;
    const w_found = c.commandHistory.indexOf(p_command.label);
    // If found, will be removed (and placed on top)
    if (w_found &gt;= 0) {
        c.commandHistory.splice(w_found, 1);
    }
    // Add to top of minibuffer history
    c.commandHistory.unshift(p_command.label);
}

</t>
<t tx="felix.20230305205014.1">{
  "command": "leojs.tagNode",
  "when": "viewItem =~ /leojsNode/",
  "group": "leojsNodeContext2@2"
},
{
  "command": "leojs.removeTag",
  "when": "viewItem =~ /leojsNodeTags/",
  "group": "leojsNodeContext2@3"
},
{
  "command": "leojs.removeTags",
  "when": "viewItem =~ /leojsNodeTags/",
  "group": "leojsNodeContext2@4"
},
</t>
<t tx="felix.20230315215040.1">export function getNonce(): string {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i &lt; 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

</t>
<t tx="felix.20230330224010.1">@language md
@tabwidth -4
# Sponsors and Backers 🏅

[Support Me via GitHub Sponsors](https://github.com/sponsors/boltex)

## Many thanks to these awesome sponsors and backers

&lt;table&gt;
    &lt;tr&gt;
        &lt;td align="center"&gt;
            &lt;a href="https://github.com/edreamleo"&gt;
                &lt;img src="https://avatars.githubusercontent.com/u/592928?v=4"
                     alt="Edward K. Ream"
                     width="48"
                     height="48"
                &gt;
            &lt;/a&gt;
            &lt;br&gt;
            Edward K. Ream
        &lt;/td&gt;
        &lt;td align="center"&gt;
            &lt;a href="https://github.com/kghenderson"&gt;
                &lt;img src="https://avatars.githubusercontent.com/u/3522168?v=4"
                     alt="Kevin Henderson"
                     width="48"
                     height="48"
                &gt;
            &lt;/a&gt;
            &lt;br&gt;
            Kevin Henderson
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</t>
<t tx="felix.20230403223923.1">/**
 * Currently selected can de-hoist state
 */
private _leoTopHoistChapter: boolean = false;
get leoTopHoistChapter(): boolean {
    return this._leoTopHoistChapter;
}
set leoTopHoistChapter(p_value: boolean) {
    this._leoTopHoistChapter = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_TOP_HOIST_CHAPTER, p_value);
}

</t>
<t tx="felix.20230416212643.1">/**
 * Milliseconds converted into seconds, limiting to two decimals. 
 */
export function getDurationSeconds(p_start: [number, number], p_end?: [number, number]): number {
    return parseFloat((getDurationMs(p_start, p_end) / 1000).toFixed(2));
}
</t>
<t tx="felix.20230505220205.1">// Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

// These plugins now contain the importer code for all kinds of @auto nodes.
// Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language typescript
</t>
<t tx="felix.20230715185802.1"></t>
<t tx="felix.20230715185809.1"></t>
<t tx="felix.20230820145332.1">/**
 * * Cycle opened documents
 */
public async tabCycle(): Promise&lt;unknown&gt; {
    await this.triggerBodySave(true);

    let w_chosenIndex;
    const w_files = g.app.windowList;

    if (w_files &amp;&amp; w_files.length &amp;&amp; w_files.length &gt; 1) {
        if (this.frameIndex === w_files.length - 1) {
            w_chosenIndex = 0;
        } else {
            w_chosenIndex = this.frameIndex + 1;
        }
    } else {
        // "Only one, or no opened documents"
        return undefined;
    }

    this.finalFocus = Focus.Outline;
    return this.selectOpenedLeoDocument(w_chosenIndex);
}

</t>
<t tx="felix.20230905212324.1">public static MINIBUFFER_QUICK_PICK: vscode.QuickPickItem = {
    label: Constants.USER_MESSAGES.MINIBUFFER_HISTORY_LABEL,
    description: Constants.USER_MESSAGES.MINIBUFFER_HISTORY_DESC,
    iconPath: new vscode.ThemeIcon("history")
};
</t>
<t tx="felix.20230914004301.1">// Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

// These plugins contain the write code for all kinds of special @auto nodes.
// Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language typescript
</t>
<t tx="felix.20231029213146.1">/**
 * Show a headline input box that resolves to undefined only with escape.
 * Other Leo commands interrupt by accepting the value entered so far.
 */
private _showHeadlineInputBox(p_options: vscode.InputBoxOptions): Promise&lt;string | undefined&gt; {

    const hib = vscode.window.createInputBox();
    this._hibLastValue = undefined; // Prepare for 'cancel' as default.
    const q_headlineInputBox = new Promise&lt;string | undefined&gt;((p_resolve, p_reject) =&gt; {

        hib.ignoreFocusOut = !!p_options.ignoreFocusOut;
        hib.value = p_options.value!;
        hib.valueSelection = p_options.valueSelection;
        hib.prompt = p_options.prompt;
        this._hibDisposables.push(hib.onDidAccept(() =&gt; {
            if (this._hib) {
                this._hib.enabled = false;
                this._hibLastValue = this._hib.value;
                this._hib.hide();
            }
        }, this));
        if (this._hibResolve) {
            console.error('IN _showHeadlineInputBox AND THE _hibResolve PROMISE ALREADY EXISTS!');
        }
        this._hibResolve = p_resolve;
        // onDidHide handles CANCEL AND ACCEPT AND INTERCEPT !
        this._hibDisposables.push(hib.onDidHide(() =&gt; {
            if (this._hib) {
                this._hibLastValue = this._hib.value; // * FORCE VALUE EVEN WHEN CANCELLING LIKE IN ORIGINAL LEO !
            }
            this.leoStates.leoEditHeadline = false;
            if (this._hibResolve) {
                // RESOLVE whatever value was set otherwise undefined will mean 'canceled'.
                this._hibResolve(this._hibLastValue);
                // Dispose of everything disposable with the edit headline process.
                for (const disp of this._hibDisposables) {
                    disp.dispose();
                }
                // Empty related global variables.
                this._hibDisposables = [];
                this._hibResolve = undefined;
                this._hib = undefined;
            } else {
                console.log('ERROR ON onDidHide NO _hibResolve !');
            }
        }, this));
        this._hibDisposables.push(hib);
        // setup finished, set command context and show it! 
        this._hib = hib;
        this.leoStates.leoEditHeadline = true;
        this._hib.show();
    });
    return q_headlineInputBox;
}

</t>
<t tx="felix.20231030200350.1">private _leoEditHeadline: boolean = false;
get leoEditHeadline(): boolean {
    return this._leoEditHeadline;
}
set leoEditHeadline(p_value: boolean) {
    this._leoEditHeadline = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_EDIT_HEADLINE, p_value);
}

</t>
<t tx="felix.20231120232158.1">public destroySelf(): void {
    // pass // Nothing more needs to be done once all windows have been destroyed.
}

</t>
<t tx="felix.20231127195758.1">public setConfirmBeforeClose(p_state: boolean): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("window")
        .update("confirmBeforeClose", p_state ? "always" : "never", true);
}

</t>
<t tx="felix.20231127210614.1">public checkConfirmBeforeClose(): void {

    let hasDirty = false;
    for (const frame of g.app.windowList) {
        if (frame.c.changed) {
            hasDirty = true;
        }
    }
    if (hasDirty !== this.lastRefreshHadDirty) {
        // don't wait for this promise!
        void this.config.setConfirmBeforeClose(hasDirty);
    }
    this.lastRefreshHadDirty = hasDirty;

}

</t>
</tnodes>
</leo_file>
