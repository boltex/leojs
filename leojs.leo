<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="felix.20201208214250.2"><vh>Documentation</vh>
<v t="felix.20201208214319.1"><vh>@clean README.md</vh></v>
<v t="felix.20201208214506.1"><vh>@clean CHANGELOG.md</vh></v>
<v t="felix.20201208224703.1"><vh>@clean CONTRIBUTING.md</vh></v>
</v>
<v t="felix.20201208214322.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20201208215613.1"><vh>activate</vh></v>
<v t="felix.20201208215619.1"><vh>deactivate</vh></v>
</v>
<v t="felix.20201208223531.1"><vh>@clean src/leojs.ts</vh></v>
<v t="felix.20201208223553.1"><vh>@clean src/leoOutline.ts</vh></v>
<v t="felix.20201208223554.1"><vh>@clean src/leoNode.ts</vh></v>
<v t="felix.20201208215536.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20201208215536.2"><vh>class Constants</vh>
<v t="felix.20201208215536.3"><vh>general constants</vh></v>
<v t="felix.20201208215536.4"><vh>workbench interface panels</vh></v>
<v t="felix.20201208215536.5"><vh>user messages</vh></v>
<v t="felix.20201208215536.6"><vh>ask/save buttons</vh></v>
<v t="felix.20201208215536.10"><vh>context flags</vh></v>
<v t="felix.20201208235204.1"><vh>vscode commands</vh></v>
<v t="felix.20201208215536.16"><vh>commands strings</vh></v>
</v>
</v>
<v t="felix.20201208224407.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20201208224407.2"><vh>padNumber2</vh></v>
<v t="felix.20201208224407.4"><vh>addFileToGlobal</vh></v>
<v t="felix.20201208224407.5"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20201208224407.6"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20201208224407.7"><vh>buildDocumentIconPaths</vh></v>
<v t="felix.20201208224407.8"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20201208224407.10"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20201208224407.11"><vh>getFileFromPath</vh></v>
<v t="felix.20201208224407.12"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20201208224407.14"><vh>strToLeoUri</vh></v>
<v t="felix.20201208224407.15"><vh>leoUriToStr</vh></v>
<v t="felix.20201208224407.16"><vh>setContext</vh></v>
</v>
<v t="felix.20201208224420.1"><vh>@clean src/types.d.ts</vh>
<v t="felix.20201208224420.2"><vh>ConfigMembers</vh></v>
<v t="felix.20201208224420.3"><vh>ConfigSetting</vh></v>
<v t="felix.20201208224420.4"><vh>RevealType</vh></v>
<v t="felix.20201208224420.5"><vh>RefreshType</vh></v>
<v t="felix.20201208224420.6"><vh>UserCommand</vh></v>
<v t="felix.20201208224420.7"><vh>ShowBodyParam</vh></v>
<v t="felix.20201208224420.8"><vh>LeoAction</vh></v>
<v t="felix.20201208224420.9"><vh>LeoLogEntry</vh></v>
<v t="felix.20201208224420.10"><vh>ArchivedPosition</vh></v>
<v t="felix.20201208224420.11"><vh>LeoPackageStates</vh></v>
<v t="felix.20201208224420.12"><vh>LeoBridgePackageOpenedInfo</vh></v>
<v t="felix.20201208224420.13"><vh>LeoBridgePackage</vh></v>
<v t="felix.20201208224420.14"><vh>LeoDocument</vh></v>
<v t="felix.20201208224420.15"><vh>LeoButton</vh></v>
<v t="felix.20201208224420.16"><vh>Icon</vh></v>
<v t="felix.20201208224420.17"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201208224420.18"><vh>BodyPosition</vh></v>
<v t="felix.20201208224420.19"><vh>BodySelectionInfo</vh></v>
<v t="felix.20201208224420.20"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20201208224420.21"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20201208224420.22"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20201208224420.23"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20201208224420.24"><vh>AskMessageItem</vh></v>
<v t="felix.20201208224420.25"><vh>ChooseDocumentItem</vh></v>
<v t="felix.20201208224420.26"><vh>MinibufferCommand</vh></v>
</v>
<v t="felix.20201208224441.1"><vh>@clean src/leoFileBrowser.ts</vh>
<v t="felix.20201208224441.2"><vh>class LeoFilesBrowser</vh>
<v t="felix.20201208224441.3"><vh>_getBestOpenFolderUri</vh></v>
<v t="felix.20201208224441.4"><vh>getLeoFileUrl</vh></v>
</v>
</v>
<v t="felix.20201208214449.1"><vh>@clean package.json</vh>
<v t="felix.20201208222541.1"><vh>views</vh></v>
<v t="felix.20201208221211.1"><vh>viewsWelcome</vh></v>
<v t="felix.20201208220441.1"><vh>commands</vh></v>
<v t="felix.20201208221448.1"><vh>menus</vh>
<v t="felix.20201208221652.1"><vh>commandPalette</vh></v>
<v t="felix.20201208221716.1"><vh>explorer/context</vh></v>
<v t="felix.20201208221809.1"><vh>view/title</vh></v>
<v t="felix.20201208221847.1"><vh>view/item/context</vh></v>
</v>
<v t="felix.20201208221945.1"><vh>keybindings</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="felix.20201208214250.2"></t>
<t tx="felix.20201208214319.1"># leojs

Literate Editor with Outline _in Typescript_ version 0.1.00

**Enjoy!**
</t>
<t tx="felix.20201208214322.1">import * as vscode from 'vscode';

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20201208214449.1">@language json
@tabwidth -2
{
  "name": "leojs",
  "displayName": "leojs",
  "description": "Leo Literate Editor with Outline in Typescript",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.51.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "*"
  ],
  "main": "./dist/extension.js",
  "contributes": {
    @others
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "webpack --devtool nosources-source-map --config ./build/node-extension.webpack.config.js",
    "watch": "webpack --watch --devtool nosources-source-map --info-verbosity verbose --config ./build/node-extension.webpack.config.js",
    "package": "webpack --mode production --config ./build/node-extension.webpack.config.js",
    "test-compile": "tsc -p ./",
    "test-watch": "tsc -watch -p ./",
    "pretest": "npm run test-compile &amp;&amp; npm run lint",
    "lint": "tslint -p ./",
    "OldLint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js"
  },
  "devDependencies": {
    "@types/vscode": "^1.51.0",
    "@types/glob": "^7.1.3",
    "@types/mocha": "^8.0.0",
    "@types/node": "^12.11.7",
    "eslint": "^7.9.0",
    "@typescript-eslint/eslint-plugin": "^4.1.1",
    "@typescript-eslint/parser": "^4.1.1",
    "glob": "^7.1.6",
    "mocha": "^8.1.3",
    "typescript": "^4.0.2",
    "vscode-test": "^1.4.0",
    "ts-loader": "^8.0.3",
    "tslint": "^6.1.3",
    "webpack": "^4.44.1",
    "webpack-cli": "^3.3.12"
  }
}
</t>
<t tx="felix.20201208214506.1"># Change Log

## 0.1.00

- Initial state</t>
<t tx="felix.20201208215536.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208215536.10">/**
 * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    LEO_READY: "leoReady", // Extension activated and classes created and ready
    TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
    SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leoChanged",
    LEO_CAN_UNDO: "leoCanUndo",
    LEO_CAN_REDO: "leoCanRedo",
    LEO_CAN_DEMOTE: "leoCanDemote",
    LEO_CAN_PROMOTE: "leoCanPromote",
    LEO_CAN_DEHOIST: "leoCanDehoist",
    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
    SELECTED_CLONE: "leoCloned",
    SELECTED_DIRTY: "leoDirty",
    SELECTED_EMPTY: "leoEmpty",
    SELECTED_CHILD: "leoChild", // Has children
    SELECTED_ATFILE: "LeoAtFile", // Can be refreshed
    SELECTED_ROOT: "leoRoot", // ! Computed by hand
    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leoObjectSelected", // keybindings "On": Outline or body has focus
    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leoNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leoNodeCloned",
    NODE_ROOT: "leoNodeRoot",
    NODE_NOT_ROOT: "leoNodeNotRoot"
};

</t>
<t tx="felix.20201208215536.16">/**
 * All commands this expansion exposes (in package.json, contributes &gt; commands)
 */
public static COMMANDS = {
    // Leo Documents
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile",
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline",
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    // Outline Node User Interaction
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside", // selects and opens body splitting the workspace
    // Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection",
    SORT_CHILDREN_FO: Constants.NAME + ".sortChildrenSelectionFromOutline",
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    // Commands from tree panel buttons or context: focus on OUTLINE
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // Commands from keyboard, while focus on OUTLINE (no need for COPY_SELECTION)
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",
    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
};

</t>
<t tx="felix.20201208215536.2">/**
 * Text and numeric constants used throughout leojs
 */
export class Constants {

    @others
}
</t>
<t tx="felix.20201208215536.3">public static NAME: string = "leojs";

public static TREEVIEW_EXPLORER_ID: string = "leojsExplorer";

public static FILE_EXTENSION: string = "leo";

public static URI_LEO_SCHEME: string = "leo";

public static URI_FILE_SCHEME: string = "file";

public static URI_SCHEME_HEADER: string = "leo:/";

public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";

public static UNTITLED_FILE_NAME: string = "untitled";

public static RECENT_FILES_KEY: string = "leoRecentFiles";

public static LAST_FILES_KEY: string = "leoLastFiles";

public static STATES_DEBOUNCE_DELAY: number = 100;

</t>
<t tx="felix.20201208215536.4">/**
 * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",
    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",
    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    STATUSBAR_INDICATOR: "$(keyboard) ",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
    EXPLORER_TREEVIEW_PREFIX: "LEO ",
    TREEVIEW_TITLE: "OUTLINE",
    BODY_TITLE: "LEO BODY",
    LOG_PANE_TITLE: "Leo Log Window"
};

</t>
<t tx="felix.20201208215536.5">/**
 * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SAVE_CHANGES: "Save changes to",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOJS: "Open this Leo file with leojs?",
    OPEN_RECENT_FILE: "Open Recent Leo File",
    RIGHT_CLICK_TO_OPEN: "Right-click Leo files to open with leojs",
    FILE_ALREADY_OPENED: "Leo file already opened",
    CHOOSE_OPENED_FILE: "Select an opened Leo File",
    FILE_NOT_OPENED: "No files opened.",
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    DEFAULT_HEADLINE: "New Headline",
    CLOSE_ERROR: "Cannot close: No files opened.",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "Leo is busy! " // with voluntary trailing space
};

</t>
<t tx="felix.20201208215536.6">/**
 * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20201208215613.1">// - `src/extension.ts` - this is the main file where you will provide the implementation of your command.
//   - The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command).
//     Inside the `activate` function we call `registerCommand`.
//   - We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

// this method is called when your extension is activated
// your extension is activated the very first time the command is executed
export function activate(context: vscode.ExtensionContext) {

	// Use the console to output diagnostic information (console.log) and errors (console.error)
	// This line of code will only be executed once when your extension is activated
	console.log('Congratulations, your extension "leojs" is now active!');

	// The command has been defined in the package.json file
	// Now provide the implementation of the command with registerCommand
	// The commandId parameter must match the command field in package.json
	let disposable = vscode.commands.registerCommand('leojs.helloWorld', () =&gt; {
		// The code you place here will be executed every time your command is executed

		// Display a message box to the user
		vscode.window.showInformationMessage('Hello World from leojs!');
	});

	context.subscriptions.push(disposable);
}

</t>
<t tx="felix.20201208215619.1">// this method is called when your extension is deactivated
export function deactivate() { }

</t>
<t tx="felix.20201208220441.1">"commands": [
  {
    "command": "leointeg.test",
    "category": "Leo",
    "title": "Test leojs"
  },
  {
    "command": "leointeg.executeScript",
    "category": "Leo",
    "title": "Execute Script"
  },
  {
    "command": "leointeg.minibuffer",
    "category": "Leo",
    "title": "Minibuffer"
  },
  {
    "command": "leointeg.removeButton",
    "category": "Leo",
    "title": "Remove Button"
  },
  {
    "command": "leointeg.showBody",
    "category": "Leo",
    "title": "Focus to Body"
  },
  {
    "command": "leointeg.showOutline",
    "category": "Leo",
    "title": "Focus to Tree"
  },
  {
    "command": "leointeg.showLogPane",
    "category": "Leo",
    "title": "Show Log Pane"
  },
  {
    "command": "leointeg.openLeoFile",
    "title": "Open Leo File",
    "category": "Leo",
    "icon": {
      "light": "resources/light/folder.svg",
      "dark": "resources/dark/folder.svg"
    }
  },
  {
    "command": "leointeg.recentLeoFiles",
    "category": "Leo",
    "title": "Recent Files"
  },
  {
    "command": "leointeg.switchLeoFile",
    "title": "Switch Leo File",
    "category": "Leo",
    "icon": {
      "light": "resources/light/switch.svg",
      "dark": "resources/dark/switch.svg"
    }
  },
  {
    "command": "leointeg.newLeoFile",
    "title": "New Leo File",
    "category": "Leo",
    "icon": {
      "light": "resources/light/new-file.svg",
      "dark": "resources/dark/new-file.svg"
    }
  },
  {
    "command": "leointeg.closeLeoFile",
    "title": "Close Leo File",
    "category": "Leo",
    "icon": {
      "light": "resources/light/close.svg",
      "dark": "resources/dark/close.svg"
    }
  },
  {
    "command": "leointeg.saveLeoFile",
    "category": "Leo",
    "title": "Save Leo File",
    "icon": {
      "light": "resources/light/save.svg",
      "dark": "resources/dark/save.svg"
    }
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "category": "Leo",
    "title": "Save Leo File",
    "icon": {
      "light": "resources/light/save.svg",
      "dark": "resources/dark/save.svg"
    }
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "category": "Leo",
    "title": "Save Leo File as...",
    "icon": {
      "light": "resources/light/save-as.svg",
      "dark": "resources/dark/save-as.svg"
    }
  },
  {
    "command": "leointeg.refreshFromDisk",
    "category": "Leo",
    "title": "Refresh from Disk"
  },
  {
    "command": "leointeg.refreshFromDiskSelection",
    "category": "Leo",
    "title": "Refresh from Disk"
  },
  {
    "command": "leointeg.refreshFromDiskSelectionFromOutline",
    "category": "Leo",
    "title": "Refresh from Disk"
  },
  {
    "command": "leointeg.gitDiff",
    "category": "Leo",
    "title": "Git Diff"
  },
  {
    "command": "leointeg.selectTreeNode",
    "category": "Leo",
    "title": "Select Node"
  },
  {
    "command": "leointeg.openAside",
    "category": "Leo",
    "title": "Open to the Side"
  },
  {
    "command": "leointeg.contractAll",
    "category": "Leo",
    "title": "Contract All",
    "icon": {
      "light": "resources/light/collapse.svg",
      "dark": "resources/dark/collapse.svg"
    }
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "category": "Leo",
    "title": "Contract All",
    "icon": {
      "light": "resources/light/collapse.svg",
      "dark": "resources/dark/collapse.svg"
    }
  },
  {
    "command": "leointeg.editHeadline",
    "category": "Leo",
    "title": "Edit Headline",
    "icon": {
      "light": "resources/light/edit.svg",
      "dark": "resources/dark/edit.svg"
    }
  },
  {
    "command": "leointeg.editSelectedHeadline",
    "category": "Leo",
    "title": "Edit Headline"
  },
  {
    "command": "leointeg.editSelectedHeadlineFromOutline",
    "category": "Leo",
    "title": "Edit Headline"
  },
  {
    "command": "leointeg.mark",
    "category": "Leo",
    "title": "Mark",
    "icon": {
      "light": "resources/light/mark.svg",
      "dark": "resources/dark/mark.svg"
    }
  },
  {
    "command": "leointeg.markSelection",
    "category": "Leo",
    "title": "Mark"
  },
  {
    "command": "leointeg.markSelectionFromOutline",
    "category": "Leo",
    "title": "Mark"
  },
  {
    "command": "leointeg.unmark",
    "category": "Leo",
    "title": "Unmark",
    "icon": {
      "light": "resources/light/unmark.svg",
      "dark": "resources/dark/unmark.svg"
    }
  },
  {
    "command": "leointeg.unmarkSelection",
    "category": "Leo",
    "title": "Unmark"
  },
  {
    "command": "leointeg.unmarkSelectionFromOutline",
    "category": "Leo",
    "title": "Unmark"
  },
  {
    "command": "leointeg.copyNode",
    "category": "Leo",
    "title": "Copy Node",
    "icon": {
      "light": "resources/light/clipboard.svg",
      "dark": "resources/dark/clipboard.svg"
    }
  },
  {
    "command": "leointeg.copyNodeSelection",
    "category": "Leo",
    "title": "Copy Node"
  },
  {
    "command": "leointeg.cutNode",
    "category": "Leo",
    "title": "Cut Node"
  },
  {
    "command": "leointeg.cutNodeSelection",
    "category": "Leo",
    "title": "Cut Node"
  },
  {
    "command": "leointeg.cutNodeSelectionFromOutline",
    "category": "Leo",
    "title": "Cut Node"
  },
  {
    "command": "leointeg.pasteNode",
    "category": "Leo",
    "title": "Paste Node"
  },
  {
    "command": "leointeg.pasteNodeAtSelection",
    "category": "Leo",
    "title": "Paste Node"
  },
  {
    "command": "leointeg.pasteNodeAtSelectionFromOutline",
    "category": "Leo",
    "title": "Paste Node"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "category": "Leo",
    "title": "Paste Node as Clone"
  },
  {
    "command": "leointeg.pasteNodeAsCloneAtSelection",
    "category": "Leo",
    "title": "Paste Node as Clone"
  },
  {
    "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
    "category": "Leo",
    "title": "Paste Node as Clone"
  },
  {
    "command": "leointeg.delete",
    "category": "Leo",
    "title": "Delete",
    "icon": {
      "light": "resources/light/close.svg",
      "dark": "resources/dark/close.svg"
    }
  },
  {
    "command": "leointeg.deleteSelection",
    "category": "Leo",
    "title": "Delete Node"
  },
  {
    "command": "leointeg.deleteSelectionFromOutline",
    "category": "Leo",
    "title": "Delete Node"
  },
  {
    "command": "leointeg.extract",
    "category": "Leo",
    "title": "Extract"
  },
  {
    "command": "leointeg.extractNames",
    "category": "Leo",
    "title": "Extract Names"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "category": "Leo",
    "title": "Move Outline Down",
    "icon": {
      "light": "resources/light/arrow-down.svg",
      "dark": "resources/dark/arrow-down.svg"
    }
  },
  {
    "command": "leointeg.moveOutlineDownSelection",
    "category": "Leo",
    "title": "Move Outline Down"
  },
  {
    "command": "leointeg.moveOutlineDownSelectionFromOutline",
    "category": "Leo",
    "title": "Move Outline Down"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "category": "Leo",
    "title": "Move Outline Left",
    "icon": {
      "light": "resources/light/arrow-left.svg",
      "dark": "resources/dark/arrow-left.svg"
    }
  },
  {
    "command": "leointeg.moveOutlineLeftSelection",
    "category": "Leo",
    "title": "Move Outline Left"
  },
  {
    "command": "leointeg.moveOutlineLeftSelectionFromOutline",
    "category": "Leo",
    "title": "Move Outline Left"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "category": "Leo",
    "title": "Move Outline Right",
    "icon": {
      "light": "resources/light/arrow-right.svg",
      "dark": "resources/dark/arrow-right.svg"
    }
  },
  {
    "command": "leointeg.moveOutlineRightSelection",
    "category": "Leo",
    "title": "Move Outline Right"
  },
  {
    "command": "leointeg.moveOutlineRightSelectionFromOutline",
    "category": "Leo",
    "title": "Move Outline Right"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "category": "Leo",
    "title": "Move Outline Up",
    "icon": {
      "light": "resources/light/arrow-up.svg",
      "dark": "resources/dark/arrow-up.svg"
    }
  },
  {
    "command": "leointeg.moveOutlineUpSelection",
    "category": "Leo",
    "title": "Move Outline Up"
  },
  {
    "command": "leointeg.moveOutlineUpSelectionFromOutline",
    "category": "Leo",
    "title": "Move Outline Up"
  },
  {
    "command": "leointeg.insertNode",
    "category": "Leo",
    "title": "Insert Node",
    "icon": {
      "light": "resources/light/plus.svg",
      "dark": "resources/dark/plus.svg"
    }
  },
  {
    "command": "leointeg.insertNodeSelection",
    "category": "Leo",
    "title": "Insert Node",
    "icon": {
      "light": "resources/light/plus.svg",
      "dark": "resources/dark/plus.svg"
    }
  },
  {
    "command": "leointeg.insertNodeSelectionFromOutline",
    "category": "Leo",
    "title": "Insert Node",
    "icon": {
      "light": "resources/light/plus.svg",
      "dark": "resources/dark/plus.svg"
    }
  },
  {
    "command": "leointeg.insertNodeSelectionInterrupt",
    "category": "Leo",
    "title": "Insert Node",
    "icon": {
      "light": "resources/light/plus.svg",
      "dark": "resources/dark/plus.svg"
    }
  },
  {
    "command": "leointeg.cloneNode",
    "category": "Leo",
    "title": "Clone Node",
    "icon": {
      "light": "resources/light/link.svg",
      "dark": "resources/dark/link.svg"
    }
  },
  {
    "command": "leointeg.cloneNodeSelection",
    "category": "Leo",
    "title": "Clone Node"
  },
  {
    "command": "leointeg.cloneNodeSelectionFromOutline",
    "category": "Leo",
    "title": "Clone Node"
  },
  {
    "command": "leointeg.promote",
    "category": "Leo",
    "title": "Promote Children"
  },
  {
    "command": "leointeg.promoteSelection",
    "category": "Leo",
    "title": "Promote Children"
  },
  {
    "command": "leointeg.promoteSelectionFromOutline",
    "category": "Leo",
    "title": "Promote Children"
  },
  {
    "command": "leointeg.demote",
    "category": "Leo",
    "title": "Demote Siblings"
  },
  {
    "command": "leointeg.demoteSelection",
    "category": "Leo",
    "title": "Demote Siblings"
  },
  {
    "command": "leointeg.demoteSelectionFromOutline",
    "category": "Leo",
    "title": "Demote Siblings"
  },
  {
    "command": "leointeg.sortChildrenSelection",
    "category": "Leo",
    "title": "Sort Children"
  },
  {
    "command": "leointeg.sortSiblingsSelection",
    "category": "Leo",
    "title": "Sort Siblings"
  },
  {
    "command": "leointeg.sortSiblingsSelectionFromOutline",
    "category": "Leo",
    "title": "Sort Siblings"
  },
  {
    "command": "leointeg.gotoFirstVisible",
    "category": "Leo",
    "title": "Goto First Visible"
  },
  {
    "command": "leointeg.gotoLastVisible",
    "category": "Leo",
    "title": "Goto Last Visible"
  },
  {
    "command": "leointeg.pageUp",
    "category": "Leo",
    "title": "Page Up"
  },
  {
    "command": "leointeg.pageDown",
    "category": "Leo",
    "title": "Page Down"
  },
  {
    "command": "leointeg.gotoLastSibling",
    "category": "Leo",
    "title": "Goto Last Sibling"
  },
  {
    "command": "leointeg.gotoNextVisible",
    "category": "Leo",
    "title": "Goto Next Visible"
  },
  {
    "command": "leointeg.gotoPrevVisible",
    "category": "Leo",
    "title": "Goto Prev Visible"
  },
  {
    "command": "leointeg.contractOrGoLeft",
    "category": "Leo",
    "title": "Contract Or Go Left"
  },
  {
    "command": "leointeg.expandAndGoRight",
    "category": "Leo",
    "title": "Expand And Go Right"
  },
  {
    "command": "leointeg.hoistNode",
    "category": "Leo",
    "title": "Hoist"
  },
  {
    "command": "leointeg.hoistSelection",
    "category": "Leo",
    "title": "Hoist"
  },
  {
    "command": "leointeg.hoistSelectionFromOutline",
    "category": "Leo",
    "title": "Hoist"
  },
  {
    "command": "leointeg.deHoist",
    "category": "Leo",
    "title": "De-Hoist",
    "icon": {
      "light": "resources/light/dehoist.svg",
      "dark": "resources/dark/dehoist.svg"
    }
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "category": "Leo",
    "title": "De-Hoist",
    "icon": {
      "light": "resources/light/dehoist.svg",
      "dark": "resources/dark/dehoist.svg"
    }
  },
  {
    "command": "leointeg.undo",
    "category": "Leo",
    "title": "Undo",
    "icon": {
      "light": "resources/light/undo.svg",
      "dark": "resources/dark/undo.svg"
    }
  },
  {
    "command": "leointeg.undoFromOutline",
    "category": "Leo",
    "title": "Undo",
    "icon": {
      "light": "resources/light/undo.svg",
      "dark": "resources/dark/undo.svg"
    }
  },
  {
    "command": "leointeg.redo",
    "category": "Leo",
    "title": "Redo",
    "icon": {
      "light": "resources/light/redo.svg",
      "dark": "resources/dark/redo.svg"
    }
  },
  {
    "command": "leointeg.redoFromOutline",
    "category": "Leo",
    "title": "Redo",
    "icon": {
      "light": "resources/light/redo.svg",
      "dark": "resources/dark/redo.svg"
    }
  },
  {
    "command": "leointeg.cloneFindAll",
    "category": "Leo",
    "title": "Clone Find All"
  },
  {
    "command": "leointeg.cloneFindAllFlattened",
    "category": "Leo",
    "title": "Clone Find All Flattened"
  },
  {
    "command": "leointeg.cloneFindMarked",
    "category": "Leo",
    "title": "Clone Find Marked"
  },
  {
    "command": "leointeg.cloneFindFlattenedMarked",
    "category": "Leo",
    "title": "cffm - Clone Find Flattened Marked"
  },
  {
    "command": "leointeg.copyMarked",
    "category": "Leo",
    "title": "Copy Marked"
  },
  {
    "command": "leointeg.diffMarkedNodes",
    "category": "Leo",
    "title": "Diff Marked Nodes"
  },
  {
    "command": "leointeg.gotoNextMarked",
    "category": "Leo",
    "title": "Goto Next Marked"
  },
  {
    "command": "leointeg.gotoNextClone",
    "category": "Leo",
    "title": "Goto Next Clone"
  },
  {
    "command": "leointeg.gotoNextCloneSelection",
    "category": "Leo",
    "title": "Goto Next Clone"
  },
  {
    "command": "leointeg.gotoNextCloneSelectionFromOutline",
    "category": "Leo",
    "title": "Goto Next Clone"
  },
  {
    "command": "leointeg.markChangedItems",
    "category": "Leo",
    "title": "Mark Changed Items"
  },
  {
    "command": "leointeg.markSubheads",
    "category": "Leo",
    "title": "Mark Subheads"
  },
  {
    "command": "leointeg.unmarkAll",
    "category": "Leo",
    "title": "Unmark All"
  },
  {
    "command": "leointeg.cloneMarkedNodes",
    "category": "Leo",
    "title": "Clone Marked Nodes"
  },
  {
    "command": "leointeg.deleteMarkedNodes",
    "category": "Leo",
    "title": "Delete Marked Nodes"
  },
  {
    "command": "leointeg.moveMarkedNodes",
    "category": "Leo",
    "title": "Move Marked Nodes"
  }
],
</t>
<t tx="felix.20201208221211.1">"viewsWelcome": [
  {
    "view": "leoIntegrationExplorer",
    "contents": "[Open Leo File](command:leojs.openLeoFile)\n[Create Leo File](command:leojs.openLeoFile)",
    "when": "!leoTreeOpened"
  }
],
</t>
<t tx="felix.20201208221448.1">"menus": {
  @others
},
</t>
<t tx="felix.20201208221652.1">"commandPalette": [
  {
    "command": "leointeg.startServer",
    "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened"
  },
  {
    "command": "leointeg.executeScript",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.minibuffer",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.showLogPane",
    "when": "leoBridgeReady"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "leoBridgeReady"
  },
  {
    "command": "leointeg.recentLeoFiles",
    "when": "leoBridgeReady"
  },
  {
    "command": "leointeg.switchLeoFile",
    "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "leoBridgeReady"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.saveLeoFile",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.refreshFromDiskSelection",
    "when": "leoTreeOpened &amp;&amp; leoAtFile"
  },
  {
    "command": "leointeg.gitDiff",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.contractAll",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.editSelectedHeadline",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.markSelection",
    "when": "leoTreeOpened &amp;&amp; !leoMarked"
  },
  {
    "command": "leointeg.unmarkSelection",
    "when": "leoTreeOpened &amp;&amp; leoMarked"
  },
  {
    "command": "leointeg.copyNodeSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.cutNodeSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.pasteNodeAtSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.pasteNodeAsCloneAtSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.deleteSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.moveOutlineDownSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.moveOutlineLeftSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.moveOutlineRightSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.moveOutlineUpSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.insertNodeSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.cloneNodeSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.promoteSelection",
    "when": "leoTreeOpened &amp;&amp; leoCanPromote"
  },
  {
    "command": "leointeg.demoteSelection",
    "when": "leoTreeOpened &amp;&amp; leoCanDemote"
  },
  {
    "command": "leointeg.sortChildrenSelection",
    "when": "leoTreeOpened &amp;&amp; leoChild"
  },
  {
    "command": "leointeg.sortSiblingsSelection",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.gotoNextMarked",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.gotoNextCloneSelection",
    "when": "leoTreeOpened &amp;&amp; leoCloned"
  },
  {
    "command": "leointeg.hoistSelection",
    "when": "leoTreeOpened &amp;&amp; !leoRoot"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoTreeOpened &amp;&amp; leoCanDehoist"
  },
  {
    "command": "leointeg.undo",
    "when": "leoTreeOpened &amp;&amp; leoCanUndo"
  },
  {
    "command": "leointeg.redo",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.cloneFindAll",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.cloneFindAllFlattened",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.cloneFindMarked",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.cloneFindFlattenedMarked",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.extract",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.extractNames",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.copyMarked",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.diffMarkedNodes",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.markChangedItems",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.markSubheads",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.unmarkAll",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.cloneMarkedNodes",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.deleteMarkedNodes",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.moveMarkedNodes",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.test",
    "when": "false"
  },
  {
    "command": "leointeg.removeButton",
    "when": "false"
  },
  {
    "command": "leointeg.showBody",
    "when": "false"
  },
  {
    "command": "leointeg.showOutline",
    "when": "false"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "false"
  },
  {
    "command": "leointeg.refreshFromDiskSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.selectTreeNode",
    "when": "false"
  },
  {
    "command": "leointeg.openAside",
    "when": "false"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "false"
  },
  {
    "command": "leointeg.editSelectedHeadlineFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.mark",
    "when": "false"
  },
  {
    "command": "leointeg.markSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.unmark",
    "when": "false"
  },
  {
    "command": "leointeg.unmarkSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.copyNode",
    "when": "false"
  },
  {
    "command": "leointeg.cutNode",
    "when": "false"
  },
  {
    "command": "leointeg.cutNodeSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "false"
  },
  {
    "command": "leointeg.pasteNodeAtSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "false"
  },
  {
    "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.delete",
    "when": "false"
  },
  {
    "command": "leointeg.deleteSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "when": "false"
  },
  {
    "command": "leointeg.moveOutlineDownSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "when": "false"
  },
  {
    "command": "leointeg.moveOutlineLeftSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "when": "false"
  },
  {
    "command": "leointeg.moveOutlineRightSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "when": "false"
  },
  {
    "command": "leointeg.moveOutlineUpSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.insertNode",
    "when": "false"
  },
  {
    "command": "leointeg.insertNodeSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.insertNodeSelectionInterrupt",
    "when": "false"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "false"
  },
  {
    "command": "leointeg.cloneNodeSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.promote",
    "when": "false"
  },
  {
    "command": "leointeg.promoteSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.demote",
    "when": "false"
  },
  {
    "command": "leointeg.demoteSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.sortSiblingsSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "false"
  },
  {
    "command": "leointeg.gotoNextCloneSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.gotoFirstVisible",
    "when": "false"
  },
  {
    "command": "leointeg.gotoLastVisible",
    "when": "false"
  },
  {
    "command": "leointeg.gotoLastSibling",
    "when": "false"
  },
  {
    "command": "leointeg.gotoNextVisible",
    "when": "false"
  },
  {
    "command": "leointeg.gotoPrevVisible",
    "when": "false"
  },
  {
    "command": "leointeg.contractOrGoLeft",
    "when": "false"
  },
  {
    "command": "leointeg.expandAndGoRight",
    "when": "false"
  },
  {
    "command": "leointeg.pageUp",
    "when": "false"
  },
  {
    "command": "leointeg.pageDown",
    "when": "false"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "false"
  },
  {
    "command": "leointeg.hoistSelectionFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "false"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "false"
  }
],
</t>
<t tx="felix.20201208221716.1">"explorer/context": [
  {
    "command": "leointeg.openLeoFile",
    "when": "resourceScheme == file &amp;&amp; resourceExtname == .leo",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20201208221809.1">"view/title": [
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoTreeTitled &amp;&amp; leoChanged",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanDehoist",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  }
],
</t>
<t tx="felix.20201208221847.1">"view/item/context": [
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "viewItem =~ /leoDocumentSelectedTitled/ &amp;&amp; leoChanged",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "viewItem =~ /leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "viewItem =~ /leoDocumentSelected/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "showEditOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.insertNode",
    "when": "showAddOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.copyNode",
    "when": "showCopyOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "showCloneOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.mark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeUnmarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.unmark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeMarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.openAside",
    "when": "showOpenAside &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext1@1"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "viewItem =~ /leoNodeNotRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoCanDehoist &amp;&amp; viewItem =~ /leoNodeRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "viewItem =~ /leoNodeAtFile/",
    "group": "leoNodeContext1@3"
  },
  {
    "command": "leointeg.mark",
    "when": "viewItem =~ /leoNodeUnmarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.unmark",
    "when": "viewItem =~ /leoNodeMarked/",
    "group": "leoNodeContext2@2"
  },
  {
    "command": "leointeg.copyNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@3"
  },
  {
    "command": "leointeg.cutNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@4"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@5"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@6"
  },
  {
    "command": "leointeg.delete",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@7"
  },
  {
    "command": "leointeg.insertNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@1"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@2"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNodeCloned/",
    "group": "leoNodeContext3@3"
  },
  {
    "command": "leointeg.removeButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoButtonNode/",
    "group": "leoButtonContext1@1"
  }
]
</t>
<t tx="felix.20201208221945.1">"keybindings": [
  {
    "command": "leointeg.executeScript",
    "key": "ctrl+b",
    "mac": "cmd+b",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.executeScript",
    "key": "ctrl+b",
    "mac": "cmd+b",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.minibuffer",
    "key": "alt+x",
    "when": "leoTreeOpened"
  },
  {
    "command": "leointeg.showOutline",
    "key": "alt+t",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.showOutline",
    "key": "ctrl+t",
    "mac": "cmd+t",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.showBody",
    "key": "ctrl+t",
    "mac": "cmd+t",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
  },
  {
    "command": "leointeg.showBody",
    "key": "alt+d",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
  },
  {
    "command": "leointeg.showBody",
    "key": "tab",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
  },
  {
    "command": "leointeg.showBody",
    "key": "enter",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "key": "ctrl+s",
    "mac": "cmd+s",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments/"
  },
  {
    "command": "leointeg.saveLeoFile",
    "key": "ctrl+s",
    "mac": "cmd+s",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.contractAll",
    "key": "alt+-",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "key": "alt+-",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
  },
  {
    "command": "leointeg.editSelectedHeadline",
    "key": "ctrl+h",
    "mac": "cmd+h",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.editSelectedHeadlineFromOutline",
    "key": "ctrl+h",
    "mac": "cmd+h",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.markSelection",
    "key": "ctrl+m",
    "mac": "cmd+m",
    "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.markSelectionFromOutline",
    "key": "ctrl+m",
    "mac": "cmd+m",
    "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.unmarkSelection",
    "key": "ctrl+m",
    "mac": "cmd+m",
    "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.unmarkSelectionFromOutline",
    "key": "ctrl+m",
    "mac": "cmd+m",
    "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.extract",
    "key": "ctrl+shift+d",
    "mac": "cmd+shift+d",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.extract",
    "key": "ctrl+shift+d",
    "mac": "cmd+shift+d",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.extractNames",
    "key": "ctrl+shift+n",
    "mac": "cmd++shift+n",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.extractNames",
    "key": "ctrl+shift+n",
    "mac": "cmd+shift+n",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineDownSelection",
    "key": "ctrl+d",
    "mac": "cmd+d",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.moveOutlineDownSelection",
    "key": "shift+alt+down",
    "mac": "shift+alt+down",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.moveOutlineDownSelectionFromOutline",
    "key": "ctrl+d",
    "mac": "cmd+d",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineDownSelectionFromOutline",
    "key": "shift+down",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineDownSelectionFromOutline",
    "key": "shift+alt+down",
    "mac": "shift+alt+down",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineLeftSelection",
    "key": "ctrl+l",
    "mac": "cmd+l",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.moveOutlineLeftSelection",
    "key": "shift+alt+left",
    "mac": "shift+alt+left",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.moveOutlineLeftSelectionFromOutline",
    "key": "ctrl+l",
    "mac": "cmd+l",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineLeftSelectionFromOutline",
    "key": "shift+left",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineLeftSelectionFromOutline",
    "key": "shift+alt+left",
    "mac": "shift+alt+left",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineRightSelection",
    "key": "ctrl+r",
    "mac": "cmd+r",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.moveOutlineRightSelection",
    "key": "shift+alt+right",
    "mac": "shift+alt+right",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.moveOutlineRightSelectionFromOutline",
    "key": "ctrl+r",
    "mac": "cmd+r",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineRightSelectionFromOutline",
    "key": "shift+right",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineRightSelectionFromOutline",
    "key": "shift+alt+right",
    "mac": "shift+alt+right",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineUpSelection",
    "key": "ctrl+u",
    "mac": "cmd+u",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.moveOutlineUpSelection",
    "key": "shift+alt+up",
    "mac": "shift+alt+up",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.moveOutlineUpSelectionFromOutline",
    "key": "ctrl+u",
    "mac": "cmd+u",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineUpSelectionFromOutline",
    "key": "shift+up",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.moveOutlineUpSelectionFromOutline",
    "key": "shift+alt+up",
    "mac": "shift+alt+up",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.sortSiblingsSelection",
    "key": "alt+a",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.sortSiblingsSelectionFromOutline",
    "key": "alt+a",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.promoteSelection",
    "key": "ctrl+[BracketLeft]",
    "win": "ctrl+oem_4",
    "linux": "ctrl+[",
    "mac": "cmd+[BracketLeft]",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.promoteSelectionFromOutline",
    "key": "ctrl+[BracketLeft]",
    "win": "ctrl+oem_4",
    "linux": "ctrl+[",
    "mac": "cmd+[BracketLeft]",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.demoteSelection",
    "key": "ctrl+[BracketRight]",
    "win": "ctrl+oem_6",
    "linux": "ctrl+]",
    "mac": "cmd+[BracketRight]",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.demoteSelectionFromOutline",
    "key": "ctrl+[BracketRight]",
    "win": "ctrl+oem_6",
    "linux": "ctrl+]",
    "mac": "cmd+[BracketRight]",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.insertNodeSelection",
    "key": "ctrl+i",
    "mac": "cmd+i",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.insertNodeSelectionFromOutline",
    "key": "ctrl+i",
    "mac": "cmd+i",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.insertNodeSelectionInterrupt",
    "key": "ctrl+i",
    "mac": "cmd+i",
    "when": "leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
  },
  {
    "command": "leointeg.cloneNodeSelection",
    "key": "ctrl+[Backquote]",
    "win": "ctrl+oem_7",
    "linux": "ctrl+'",
    "mac": "cmd+[Backquote]",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.cloneNodeSelectionFromOutline",
    "key": "ctrl+[Backquote]",
    "win": "ctrl+oem_7",
    "linux": "ctrl+'",
    "mac": "cmd+[Backquote]",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.cutNodeSelection",
    "key": "ctrl+shift+x",
    "mac": "cmd+shift+x",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.cutNodeSelectionFromOutline",
    "key": "ctrl+shift+x",
    "mac": "cmd+shift+x",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.copyNodeSelection",
    "key": "ctrl+shift+c",
    "mac": "cmd+shift+c",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.copyNodeSelection",
    "key": "ctrl+shift+c",
    "mac": "cmd+shift+c",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.pasteNodeAtSelection",
    "key": "ctrl+shift+v",
    "mac": "cmd+shift+v",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.pasteNodeAtSelectionFromOutline",
    "key": "ctrl+shift+v",
    "mac": "cmd+shift+v",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.deleteSelection",
    "key": "ctrl+shift+backspace",
    "mac": "cmd+shift+backspace",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.deleteSelectionFromOutline",
    "key": "ctrl+shift+backspace",
    "mac": "cmd+shift+backspace",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.gotoFirstVisible",
    "key": "alt+home",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.gotoLastSibling",
    "key": "alt+end",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.gotoFirstVisible",
    "key": "home",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.gotoLastVisible",
    "key": "end",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.pageUp",
    "key": "pageup",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.pageDown",
    "key": "pagedown",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.gotoNextCloneSelectionFromOutline",
    "key": "alt+n",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.gotoNextCloneSelection",
    "key": "alt+n",
    "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.gotoNextVisible",
    "key": "down",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.gotoNextVisible",
    "key": "alt+down",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
  },
  {
    "command": "leointeg.gotoNextVisible",
    "key": "alt+down",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.gotoPrevVisible",
    "key": "up",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.gotoPrevVisible",
    "key": "alt+up",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
  },
  {
    "command": "leointeg.gotoPrevVisible",
    "key": "alt+up",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.contractOrGoLeft",
    "key": "left",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.contractOrGoLeft",
    "key": "alt+left",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
  },
  {
    "command": "leointeg.contractOrGoLeft",
    "key": "alt+left",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  },
  {
    "command": "leointeg.expandAndGoRight",
    "key": "right",
    "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
  },
  {
    "command": "leointeg.expandAndGoRight",
    "key": "alt+right",
    "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
  },
  {
    "command": "leointeg.expandAndGoRight",
    "key": "alt+right",
    "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
  }
]
</t>
<t tx="felix.20201208222541.1">"views": {
  "explorer": [
    {
      "id": "leoJsExplorer",
      "name": "Leo",
      "contextualTitle": "Leo"
    }
  ]
},
</t>
<t tx="felix.20201208223531.1"></t>
<t tx="felix.20201208223553.1"></t>
<t tx="felix.20201208223554.1"></t>
<t tx="felix.20201208224407.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { Icon, UserCommand, ArchivedPosition } from "./types";
import { LeoNode } from "./leoNode";

// String and other types/structures helper functions, along with common vscode API calls

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208224407.10">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number]): number {
    const [w_secs, w_nanosecs] = process.hrtime(p_start);
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201208224407.11">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20201208224407.12">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: LeoNode, p_newHasBody: boolean): boolean {
    if (!p_node.dirty || (p_node.hasBody === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20201208224407.14"> /**
 * Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
 * @param p_str leo node gnx strings are used to build Uri
 * @returns A vscode 'Uri' object
 */
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20201208224407.15">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substr(1);
}

</t>
<t tx="felix.20201208224407.16">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'bridgeReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20201208224407.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20201208224407.4">/**
 * * Performs the actual addition into globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
 */
export function addFileToGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.globalState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.globalState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.globalState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.globalState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201208224407.5">/**
 * * Removes file entry from globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
  */
export function removeFileFromGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.globalState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.globalState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.globalState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201208224407.6">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT)
        };
    });
}

</t>
<t tx="felix.20201208224407.7">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20201208224407.8">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="felix.20201208224420.1">import * as vscode from "vscode";
import { LeoNode } from "./leoNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208224420.10">/**
 * * ArchivedPosition format package from Leo's leoflexx.py
 */
export interface ArchivedPosition {
    hasBody: boolean;       // bool(p.b),
    hasChildren: boolean;   // p.hasChildren()
    childIndex: number;     // p._childIndex
    cloned: boolean;        // p.isCloned()
    dirty: boolean;         // p.isDirty()
    expanded: boolean;      // p.isExpanded()
    gnx: string;            // p.v.gnx
    level: number;          // p.level()
    headline: string;       // p.h
    marked: boolean;        // p.isMarked()
    atFile: boolean         // p.isAnyAtFileNode():
    selected: boolean;      // p == commander.p
    u?: any;               // User Attributes
    stack: {
        gnx: string;        // stack_v.gnx
        childIndex: number; // stack_childIndex
        headline: string;   // stack_v.h
    }[];                    // for (stack_v, stack_childIndex) in p.stack]
}

</t>
<t tx="felix.20201208224420.11">/**
 * * Object sent back from leoInteg's 'getStates' command
 */
export interface LeoPackageStates {
    changed: boolean; // Leo document has changed (is dirty)
    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'
    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted
    canDehoist: boolean; // Leo Document is currently hoisted and can be de-hoisted
}

</t>
<t tx="felix.20201208224420.12">/**
 * * Returned info about currently opened and editing document
 * Used after opening, switching or setting the opened document
 */
export interface LeoBridgePackageOpenedInfo {
    total: number;
    filename: string;
    node: ArchivedPosition;
}

</t>
<t tx="felix.20201208224420.13">/**
 * * Main interface for JSON sent from Leo back to leoInteg
 */
export interface LeoBridgePackage {
    id: number; // TODO : Could be used for error checking
    // * Each of those top level member is an answer from a "Constants.LEOBRIDGE" command
    allGnx?: string[];
    bodyLength?: number;
    bodyData?: string;
    bodyStates?: {
        language: string;
        selection: BodySelectionInfo;
    }
    node?: ArchivedPosition;
    nodes?: ArchivedPosition[];
    states?: LeoPackageStates;
    closed?: {
        total: number;
        filename?: string;
        node?: ArchivedPosition;
    },
    opened?: LeoBridgePackageOpenedInfo,
    setOpened?: LeoBridgePackageOpenedInfo,
    openedFiles?: {
        index: number;
        files: LeoDocument[];
    }
    buttons?: LeoButton[];
    commands?: MinibufferCommand[];
}

</t>
<t tx="felix.20201208224420.14">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider sent back by the server
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20201208224420.15">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider sent back by the server
 */
export interface LeoButton {
    name: string;
    index: string; // STRING KEY
}

</t>
<t tx="felix.20201208224420.16">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string;
    dark: string;
}

</t>
<t tx="felix.20201208224420.17">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    gnx: string;
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20201208224420.18">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20201208224420.19">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    scroll: {
        start: BodyPosition;
        end: BodyPosition;
    }
    active: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20201208224420.2">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;
    statusBarString: string;
    statusBarColor: string;
    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;
    invertNodeContrast: boolean;
    leoPythonCommand: string;
    startServerAutomatically: boolean;
    connectToServerAutomatically: boolean;
    connectionAddress: string;
    connectionPort: number;
}

</t>
<t tx="felix.20201208224420.20">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    // See TODO in leoAsync.ts
    "initialFile": string;
    "title": string;
    "message": string;
    "filetypes": string[];
    "defaultExtension": string;
}

</t>
<t tx="felix.20201208224420.21">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    "ask": string;
    "message": string;
    "yes_all": boolean;
    "no_all": boolean;
}

</t>
<t tx="felix.20201208224420.22">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    "warn": string;
    "message": string;
}

</t>
<t tx="felix.20201208224420.23">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    "message": string;
}

</t>
<t tx="felix.20201208224420.24">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20201208224420.25">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20201208224420.26">/**
 * * Used by the minibuffer command pallette
 * Acquired from the getCommands method in leobridgeserver.py
 */
export interface MinibufferCommand extends vscode.QuickPickItem {
    func: string;
}
</t>
<t tx="felix.20201208224420.3">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20201208224420.4">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // In apToLeoNode conversion, If if the global revealType is "NoReveal" and its the selected node, re-use the old id
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20201208224420.5">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    states?: boolean; // States needs refresh (changed, canUndo, canRedo, canDemote, canPromote, canDehoist)
    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
}

</t>
<t tx="felix.20201208224420.6">/**
 * * Stackable front end commands
 */
export interface UserCommand {
    action: string; // String from Constants.LEOBRIDGE, which are commands for leobridgeserver
    node?: LeoNode | undefined;  // We can START a stack with a targeted command
    text?: string | undefined; // If a string is required, for headline, etc.
    refreshType: ReqRefresh; // Minimal refresh level required by this command
    fromOutline: boolean; // Focus back on outline instead of body
    keepSelection?: boolean; // Should bring back selection on node prior to command
    resolveFn?: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn?: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20201208224420.7">/**
 * * Object container for parameters of leoIntegration's "apply-selected-node-to-body" method
 */
export interface ShowBodyParam {
    node: LeoNode,
    aside: boolean,
    showBodyKeepFocus: boolean,
    force_open?: boolean
}
</t>
<t tx="felix.20201208224420.8">
/**
 * * Stackable leoBridge actions to be performed by Leo
 */
export interface LeoAction {
    parameter: string; // to pass along with action to python's side
    deferredPayload?: any | undefined; // Used when the action already has a return value ready but is also waiting for python's side
    resolveFn: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20201208224420.9">/**
 * * Simple 'string log entry' package format
 */
export interface LeoLogEntry {
    log: string;
}

</t>
<t tx="felix.20201208224441.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20201208224441.2">/**
 * * Handles opening of file browser when choosing which Leo file to open
 */
export class LeoFilesBrowser {

    private _fileBrowserActive: boolean = false;

    constructor(private _context: vscode.ExtensionContext) { }

    @others
}
</t>
<t tx="felix.20201208224441.3">/**
 * * Finds a folder to propose when opening the browse-for-leo-file chooser
 * @returns An Uri for path to a folder for initial opening
 */
private _getBestOpenFolderUri(): vscode.Uri {
    let w_openedFileEnvUri: vscode.Uri | boolean = false;
    let w_activeUri: vscode.Uri | undefined = undefined;

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders[0]) {
        w_activeUri = vscode.workspace.workspaceFolders[0].uri;
    }

    if (w_activeUri) {
        const w_defaultFolder = vscode.workspace.getWorkspaceFolder(w_activeUri);
        if (w_defaultFolder) {
            w_openedFileEnvUri = w_defaultFolder.uri; // Set as current opened document-path's folder
        }
    }
    if (!w_openedFileEnvUri) {
        w_openedFileEnvUri = vscode.Uri.file("~"); // TODO : set as home folder properly, this doesn't work
        // ! EXAMPLE WITH os : const homedir = require('os').homedir();
    }
    return w_openedFileEnvUri;
}

</t>
<t tx="felix.20201208224441.4">/**
 * * Open a file browser and let the user choose a Leo file or cancel the operation
 * @param p_saveAsFlag Optional flag that will ask for a 'save' path+filename
 * @returns A promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoFileUrl(p_saveAsFlag?: boolean): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_filters: { [name: string]: string[] } = {};
        w_filters[Constants.FILE_OPEN_FILTER_MESSAGE] = [Constants.FILE_EXTENSION];

        if (p_saveAsFlag) {
            // Choose file
            vscode.window.showSaveDialog({
                saveLabel: "Save Leo File",
                defaultUri: this._getBestOpenFolderUri(),
                filters: { 'Leo File': ['leo'] }
            })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // single string
                        p_resolve(p_chosenLeoFile.fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve(""); // not rejection - resolve empty string
                    }
                });
        } else {
            vscode.window
                .showOpenDialog({
                    canSelectMany: false,
                    defaultUri: this._getBestOpenFolderUri(),
                    filters: w_filters
                })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // array instead of single string
                        p_resolve(p_chosenLeoFile[0].fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve("");
                    }
                });
        }
    });
}

</t>
<t tx="felix.20201208224703.1"># How to install and run the development version

Thanks for trying out the development version of LeoInteg! :sunglasses: Contributions and pull requests are more than welcome!

## Introduction

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

</t>
<t tx="felix.20201208235204.1">/**
 * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
</tnodes>
</leo_file>
