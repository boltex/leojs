#@+leo-ver=5-thin
#@+node:ekr.20201210035538.1: * @file scripts.txt
#@@language python
"""
This file contains @button nodes and other scripts for use in leojs.leo.

This file reduces git diffs agains leojs.leo itself.

This file has a .txt extension to avoid warnings from pyflakes.
"""
#@+others
#@+node:ekr.20201209145256.2: ** @button backup
"""
Back up files to ~/Backup/leojs, preserving os.curdir.

Note: os.environ['LEO_BACKUP'] resolves to ~/Backup/
"""
g.cls()
import os
import time
#@+<< define backup_file >>
#@+node:ekr.20201211112621.1: *3* << define backup_file >>
def backup_file(filename):
    """Back up the file to ~/Backup/leojs"""
    # Find the git branch.
    c_path = os.path.dirname(c.fileName())
    git_path = os.path.abspath(os.path.join(c_path, '.git', 'HEAD'))
    git_branch, junk = g.gitInfo(git_path)
    if not git_branch:
        return g.trace(f"No git branch at {git_path!r}")
    # Compute the Backup/leojs directory.
    backup_dir = os.path.join(os.environ['LEO_BACKUP'], 'leojs')
    if not os.path.exists(backup_dir):
        return g.trace(f"No directory: {backup_dir!r}")
    read_path = os.path.join(c_path, filename)
    write_path = os.path.normpath(os.path.join(backup_dir, f"{git_branch}-{stamp}-{filename}"))
    with open(read_path, 'r') as f:
        contents = f.read()
    with open(write_path, 'w') as f:
        f.write(contents)
    g.es_print(f"wrote: {write_path!r}")
#@-<< define backup_file >>
if g.app.leoID == 'ekr':
    stamp = time.strftime("%Y%m%d-%H%M%S")
    old_cwd = os.getcwd()
    try:
        backup_file('myLeojs.leo')
        backup_file('scripts.txt') 
    finally:
        os.chdir(old_cwd)
else:
    print('This script is for EKR only')
#@+node:ekr.20201209145330.1: ** @button write-leojs
"""
Update leojs.leo from the given list of nodes.

This must be run from myLeojs.leo.
"""
g.cls()
import os
#@+others
#@+node:ekr.20201209145330.2: *3* check_file_names
def check_file_names():
    """
    Return the path to leojs.leo.
    
    Return None and give an error if:
    - We are not running from myLeojs.leo or
    - Leojs.leo does not exist.
    """
    if c.shortFileName() == 'leojs.leo':
        oops("Don't run this script from leojs.leo")
        return None
    base_dir = os.path.dirname(c.fileName())
    path = os.path.join(base_dir, 'leojs.leo')
    if not os.path.exists(path):
        oops(f"Not found: {path}")
        return None
    return os.path.normpath(path)
#@+node:ekr.20201209145330.3: *3* check_nodes
def check_nodes(node_list):
    """Return True if all nodes are found."""
    result = []
    for node in node_list:
        p = g.findTopLevelNode(c, node, exact=True)
        if p:
            result.append(p.copy())
        else:
            oops(f"Top-level node {node} not found")
            return []
    return result
#@+node:ekr.20201209145330.4: *3* get_content
def get_content(positions_list):
    """
    Return the desired contents of leoPyRef.leo.
    
    Based on code by Виталије Милошевић.
    """
    # Make only one copy for all calls.
    fc = c.fileCommands
    fc.currentPosition = c.p
    fc.rootPosition = c.rootPosition()
    fc.vnodesDict = {}
    # Put the file
    fc.outputFile = g.FileLikeObject()
    fc.putProlog()
    fc.putHeader()
    fc.putGlobals()
    fc.putPrefs()
    fc.putFindSettings()
    fc.put("<vnodes>\n")
    for p in positions_list:
        # An optimization: Write the next top-level node.
        fc.putVnode(p, isIgnore=p.isAtIgnoreNode())
    fc.put("</vnodes>\n")
    fc.putTnodes()
    fc.putPostlog()
    return fc.outputFile.getvalue()
#@+node:ekr.20201209145330.5: *3* main
def main(node_list):
    """The main line."""
    c.endEditing()
    path = check_file_names()
    if not path:
        return
    positions_list = check_nodes(node_list)
    if not positions_list:
        return
    content = get_content(positions_list)
    with open(path, 'w', encoding="utf-8", newline='\n') as f:
        f.write(content)
    print('')
    g.es_print(f"Updated {path}")
#@+node:ekr.20201209145330.6: *3* oops
def oops(message):
    """Print an error message"""
    print('')
    g.es_print(message)
    print('')
#@-others
main(node_list = ['Startup', 'Documentation', 'Code'])
#@+node:ekr.20201210092221.1: ** @button diff-pr
import leo.commands.editFileCommands as efc
import os

x = efc.GitDiffController(c)
x.diff_pull_request(directory=os.curdir)
#@+node:ekr.20201209152713.1: ** script: split contributes/commands (works)
"""
Split the "commands" node of the "contributes" section into separate nodes.

Inner entries have the form:

  {
    "command": "leojs.test",
    "category": "Leo",
    "title": "Test leojs"
  },
"""
g.cls()
outer_parent_h = '@clean package.json'
outer_parent = g.findNodeAnywhere(c, outer_parent_h)
assert outer_parent, f"Not found: {outer_parent_h}"
root_h = 'commands'
root = g.findNodeInTree(c, outer_parent, root_h)
assert root, f"Not found: {root_h}"
last = c.lastTopLevel()
parent = last.insertAfter()
parent.h = 'command tree'
command_lines, level = [], 0
for i, line in enumerate(g.splitLines(root.b)):
    line_s = line.strip()
    if command_lines:  # Accumulating a new node.
        command_lines.append(line)
        if line_s.endswith(('}', '},')):
            level -= 1
            if level == 0:
                # End of command.
                p = parent.insertAsLastChild()
                h = command_lines[1].strip()
                head = '"command": "leojs.'
                assert h.startswith(head), (i, repr(h))
                if h.endswith(','): h = h[:-1]
                if h.endswith('"'): h = h[:-1]
                p.h = h[len(head):]
                p.b = ''.join(command_lines)
                # g.printObj(command_lines)
                command_lines = []
        elif line_s.endswith('{'):
            level += 1
        else:
            pass
    elif line_s.endswith('{'):
        level = 1
        command_lines = [line]
    elif line_s:
        assert line_s.endswith('[') or line_s.startswith('],'), (i, repr(line))
        # print('OUTSIDE', repr(line))
c.redraw()
#@+node:ekr.20201210041738.1: ** script: split contributes/menus (partially works)
"""
Split the "menus" node of the "contributes" section into separate nodes.

Inner entries have the form:
    
  {
    "command": "leojs.executeScript",
    "when": "leoTreeOpened"
  },
"""
g.cls()
outer_parent_h = '@clean package.json'
outer_parent = g.findNodeAnywhere(c, outer_parent_h)
assert outer_parent, f"Not found: {outer_parent_h}"
menus_h = 'menus'
menus_p = g.findNodeInTree(c, outer_parent, menus_h)
assert menus_p, f"Not found: {menus_h}"
last = c.lastTopLevel()
menu_parent = last.insertAfter()
menu_parent.h = 'menu tree'
# The 'menus' node contains @others.
# Create an organizer node for each child.
for child in menus_p.children():
    parent = menu_parent.insertAsLastChild()
    parent.h = child.h
    command_lines, level = [], 0
    for i, line in enumerate(g.splitLines(child.b)):
        line_s = line.strip()
        # print(line_s)
        if command_lines:  # Accumulating a new node.
            command_lines.append(line)
            if line_s.endswith(('}', '},')):
                level -= 1
                if level == 0:
                    # End of command.
                    p = parent.insertAsLastChild()
                    h = command_lines[1].strip()
                    head = '"command": "leojs.'
                    assert h.startswith(head), (i, repr(h))
                    if h.endswith(','): h = h[:-1]
                    if h.endswith('"'): h = h[:-1]
                    p.h = h[len(head):]
                    p.b = ''.join(command_lines)
                    # g.printObj(command_lines)
                    command_lines = []
            elif line_s.endswith('{'):
                level += 1
            else:
                pass
        elif line_s.endswith('{'):
            level = 1
            command_lines = [line]
        elif line_s:
            assert line_s.endswith(('[', ']')) or line_s.startswith('],'), (i, repr(line))
            # print('OUTSIDE', repr(line))
    c.redraw()
#@+node:ekr.20201210041817.1: ** script: split contributes/keybindings (new)
g.es_print('not ready', p.h)  # Changed.
#@+node:ekr.20201210035719.1: ** script: diff-pr
import leo.commands.editFileCommands as efc
x = efc.GitDiffController(c)
x.diff_pull_request(branch_name = 'package.json')
#@-others
#@-leo
